{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment CB Documentation  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}CB Documentation}
{\comment Generated by doxygen1.9.2.}
{\creatim \yr2021\mo10\dy12\hr9\min42\sec14}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt CB Documentation}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Tue Oct 12 2021 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
CrazyBreakout{\tc \v CrazyBreakout}\par \pard\plain 
{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
First Proyect For The Algoritms and Data Structures Curse \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Deprecated List{\tc \v Deprecated List}\par \pard\plain 
{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::iterator_wrapper}  (reference ref) noexcept\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
This stream operator is deprecated and will be removed in future 4.0.0 of the library. Please use {\b items()} instead; that is, replace {\f2 json::iterator_wrapper(j)}  with {\f2 j.items()} .  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator<<}  ({\b basic_json} &j, std::istream &i)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use {\b operator>>(std::istream&, basic_json&)} instead; that is, replace calls like {\f2 j << i;}  with {\f2 i >> j;} .  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Member {\b nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator>>}  (const {\b basic_json} &j, std::ostream &o)\par
}
{\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
This stream operator is deprecated and will be removed in future 4.0.0 of the library. Please use {\b operator<<(std::ostream&, const basic_json&)} instead; that is, replace calls like {\f2 j >> o;}  with {\f2 o << j;} . \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b nlohmann} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Namespace for Niels Lohmann })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Detail namespace with internal helper functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::container_input_adapter_factory_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::dtoa_impl} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implements the Grisu2 algorithm for binary to decimal floating-point conversion })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::utility_internal} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Ui} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::adl_serializer< ValueType, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
B1
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::conjunction< B1 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::binary_writer< BasicJsonType, CharType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
BinaryType
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::byte_container_with_subtype< BinaryType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::dtoa_impl::boundaries\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::dtoa_impl::cached_power\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Client\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, Enable >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::detector< Default, AlwaysVoid, Op, Args >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::detector< Default, void_t< Op< Args... > >, Op, Args... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::dtoa_impl::diyfp\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::exception
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::exception\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIF \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::invalid_iterator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::other_error\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::out_of_range\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::parse_error\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::type_error\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
nlohmann::detail::utility_internal::Extend< Seq, SeqSize, Rem >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 0 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 1 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::external_constructor< value_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::external_constructor< value_t::array >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::external_constructor< value_t::binary >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::external_constructor< value_t::boolean >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::external_constructor< value_t::number_float >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::external_constructor< value_t::number_integer >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::external_constructor< value_t::number_unsigned >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::external_constructor< value_t::object >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::external_constructor< value_t::string >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::false_type
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, ConstructibleStringType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLT \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_compatible_string_type< BasicJsonType, ConstructibleStringType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::has_from_json< BasicJsonType, T, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::has_non_default_from_json< BasicJsonType, T, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::has_to_json< BasicJsonType, T, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_basic_json< typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_compatible_array_type< BasicJsonType, CompatibleArrayType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_compatible_integer_type< RealIntegerType, CompatibleNumberIntegerType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLO \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_compatible_object_type< BasicJsonType, CompatibleObjectType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLX \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_compatible_type< BasicJsonType, CompatibleType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::is_complete_type< T, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_constructible_array_type< BasicJsonType, ConstructibleArrayType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMN \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_constructible_object_type< BasicJsonType, ConstructibleObjectType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMS \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_constructible_string_type< BasicJsonType, ConstructibleStringType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::is_constructible_tuple< T1, T2 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_iterator_traits< T, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_json_ref< typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::file_input_adapter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::from_json_fn\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::utility_internal::Gen< T, N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::utility_internal::Gen< T, 0 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::hash< nlohmann::json >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::identity_tag< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::input_stream_adapter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::integer_sequence< T, Ints >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::integral_constant
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::negation< B >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::tuple_size<::nlohmann::detail::iteration_proxy_value< IteratorType > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::internal_iterator< BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, enable_if_t< is_detected< value_type_t, CompatibleArrayType >::value &&is_detected< iterator_t, CompatibleArrayType >::value &&!is_iterator_traits< iterator_traits< CompatibleArrayType > >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, CompatibleStringType >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, enable_if_t< is_complete_type< CompatibleType >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::is_constructible
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_constructible< T, Args >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< !std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value &&is_default_constructible< ConstructibleArrayType >::value &&(std::is_move_assignable< ConstructibleArrayType >::value||std::is_copy_assignable< ConstructibleArrayType >::value)&&is_detected< value_type_t, ConstructibleArrayType >::value &&is_detected< iterator_t, ConstructibleArrayType >::value &&is_complete_type< detected_t< value_type_t, ConstructibleArrayType > >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, ConstructibleStringType >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::is_default_constructible
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_default_constructible< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
is_detected
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_detected_lazy< Op, Args >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::is_getable< BasicJsonType, T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABND \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_iterator_of_multibyte< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_iterator_traits< iterator_traits< T > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_ordered_map< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_sax< SAX, BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_sax_static_asserts< SAX, BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::iter_impl< BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::iteration_proxy< IteratorType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::iteration_proxy_value< IteratorType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::iterator_input_adapter< IteratorType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::iterator_traits< T, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::iterator_types< It, typename >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::iterator_types< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRD \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::iterator_traits< T, enable_if_t< !std::is_pointer< T >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::json_pointer< BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::json_ref< BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::json_sax< BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::json_sax_acceptor< BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::json_sax_dom_parser< BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::less<::nlohmann::detail::value_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::lexer_base< BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWC \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::make_void< Ts >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::nonesuch\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::output_adapter< CharType, StringType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::output_adapter_protocol< CharType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXP \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::output_stream_adapter< CharType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::output_string_adapter< CharType, StringType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::output_vector_adapter< CharType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::parser< BasicJsonType, InputAdapterType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::position_t\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::primitive_iterator_t\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::priority_tag< N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::priority_tag< 0 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QGraphicsRectItem
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Ball\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CommonBlk\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DeepBlk\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DoubleBlk\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InternBlk\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Paddle\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
TripleBlk\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
surprise\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QGraphicsView
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Game\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QMainWindow
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
MainWindow\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QObject
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Ball\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QWidget
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
gameover\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
gamewindow\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
std::reverse_iterator
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::json_reverse_iterator< Base >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::serializer< BasicJsonType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::span_input_adapter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::static_const< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::to_json_fn\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::true_type
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::conjunction< is_constructible< T1, Args >... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHW \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_constructible_tuple< T1, std::tuple< Args... > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::conjunction< is_default_constructible< T1 >, is_default_constructible< T2 > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHW \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_default_constructible< const std::pair< T1, T2 > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMY \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_constructible< const std::pair< T1, T2 > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::is_default_constructible< std::pair< T1, T2 > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_constructible< std::pair< T1, T2 > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
nlohmann::detail::conjunction< is_default_constructible< Ts >... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHW \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_default_constructible< const std::tuple< Ts... > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_constructible< const std::tuple< Ts... > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABME \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::is_default_constructible< std::tuple< Ts... > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::is_constructible< std::tuple< Ts... > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
nlohmann::detail::conjunction<... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_basic_json< NLOHMANN_BASIC_JSON_TPL >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_complete_type< T, decltype(void(sizeof(T)))>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABML \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_json_ref< json_ref< T > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
std::tuple_element< N, ::nlohmann::detail::iteration_proxy_value< IteratorType > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::is_ordered_map< T >::two\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::conditional::type
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::detail::conjunction< B1, Bn... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
std::vector< std::pair< const Key, T >, std::allocator< std::pair< const Key, T > > >
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::wide_string_input_helper< BaseInputAdapter, T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 2 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 4 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b nlohmann::adl_serializer< ValueType, typename >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default JSONSerializer template argument })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Ball} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates objects of type {\b Ball} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Class to store JSON values })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deserialization of CBOR, MessagePack, and UBJSON values })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::binary_writer< BasicJsonType, CharType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serialization to CBOR and MessagePack values })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::dtoa_impl::boundaries} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::byte_container_with_subtype< BinaryType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Internal type for a backed binary type })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::dtoa_impl::cached_power} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Client} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CommonBlk} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates objects of type {\b CommonBlk} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::conjunction<... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::conjunction< B1 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::conjunction< B1, Bn... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, Enable >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DeepBlk} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates objects of type {\b DeepBlk} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::detector< Default, AlwaysVoid, Op, Args >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::detector< Default, void_t< Op< Args... > >, Op, Args... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::dtoa_impl::diyfp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DoubleBlk} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates objects of type {\b DoubleBlk} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::exception} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
General exception of the {\b basic_json} class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::utility_internal::Extend< Seq, SeqSize, Rem >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 0 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 1 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::external_constructor< value_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::external_constructor< value_t::array >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::external_constructor< value_t::binary >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::external_constructor< value_t::boolean >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::external_constructor< value_t::number_float >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::external_constructor< value_t::number_integer >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::external_constructor< value_t::number_unsigned >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::external_constructor< value_t::object >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::external_constructor< value_t::string >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::file_input_adapter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::from_json_fn} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Game} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Runs the game interface and manages all the game process })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b gameover} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b gamewindow} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::utility_internal::Gen< T, N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::utility_internal::Gen< T, 0 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::has_from_json< BasicJsonType, T, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::has_non_default_from_json< BasicJsonType, T, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::has_to_json< BasicJsonType, T, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::hash< nlohmann::json >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hash value for JSON objects })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::identity_tag< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::input_stream_adapter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::integer_sequence< T, Ints >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::internal_iterator< BasicJsonType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iterator value })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InternBlk} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates objects of type {\b InternBlk} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::invalid_iterator} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception indicating errors with iterators })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABKZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_basic_json< typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_basic_json< NLOHMANN_BASIC_JSON_TPL >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_array_type< BasicJsonType, CompatibleArrayType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, enable_if_t< is_detected< value_type_t, CompatibleArrayType >::value &&is_detected< iterator_t, CompatibleArrayType >::value &&!is_iterator_traits< iterator_traits< CompatibleArrayType > >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_integer_type< RealIntegerType, CompatibleNumberIntegerType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_object_type< BasicJsonType, CompatibleObjectType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_string_type< BasicJsonType, ConstructibleStringType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, CompatibleStringType >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_type< BasicJsonType, CompatibleType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, enable_if_t< is_complete_type< CompatibleType >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_complete_type< T, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_complete_type< T, decltype(void(sizeof(T)))>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible< T, Args >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible< const std::pair< T1, T2 > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible< const std::tuple< Ts... > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABME \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible< std::pair< T1, T2 > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible< std::tuple< Ts... > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_array_type< BasicJsonType, ConstructibleArrayType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< !std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value &&is_default_constructible< ConstructibleArrayType >::value &&(std::is_move_assignable< ConstructibleArrayType >::value||std::is_copy_assignable< ConstructibleArrayType >::value)&&is_detected< value_type_t, ConstructibleArrayType >::value &&is_detected< iterator_t, ConstructibleArrayType >::value &&is_complete_type< detected_t< value_type_t, ConstructibleArrayType > >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABML \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_object_type< BasicJsonType, ConstructibleObjectType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_string_type< BasicJsonType, ConstructibleStringType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, ConstructibleStringType >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_tuple< T1, T2 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_constructible_tuple< T1, std::tuple< Args... > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_default_constructible< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_default_constructible< const std::pair< T1, T2 > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_default_constructible< const std::tuple< Ts... > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_default_constructible< std::pair< T1, T2 > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_default_constructible< std::tuple< Ts... > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_detected_lazy< Op, Args >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_getable< BasicJsonType, T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABND \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_iterator_of_multibyte< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_iterator_traits< T, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_iterator_traits< iterator_traits< T > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_json_ref< typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_json_ref< json_ref< T > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_ordered_map< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_sax< SAX, BasicJsonType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_sax_static_asserts< SAX, BasicJsonType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::iter_impl< BasicJsonType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template for a bidirectional iterator for the {\b basic_json} class This class implements a both iterators (iterator and const_iterator) for the {\b basic_json} class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::iteration_proxy< IteratorType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Proxy class for the items() function })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::iteration_proxy_value< IteratorType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::iterator_input_adapter< IteratorType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::iterator_traits< T, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::iterator_traits< T, enable_if_t< !std::is_pointer< T >::value > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::iterator_types< It, typename >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::json_pointer< BasicJsonType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON Pointer })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::json_ref< BasicJsonType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::json_reverse_iterator< Base >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Template for a reverse iterator class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::json_sax< BasicJsonType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX interface })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::json_sax_acceptor< BasicJsonType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::json_sax_dom_parser< BasicJsonType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX implementation to create a JSON value from SAX events })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::less<::nlohmann::detail::value_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::lexer< BasicJsonType, InputAdapterType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lexical analysis })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::lexer_base< BasicJsonType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MainWindow} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Shows the first window of the game })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::make_void< Ts >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::negation< B >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::nonesuch} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::other_error} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception indicating other library errors })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::out_of_range} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception indicating access out of the defined range })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::output_adapter< CharType, StringType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::output_adapter_protocol< CharType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Abstract output adapter interface })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::output_stream_adapter< CharType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Output adapter for output streams })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::output_string_adapter< CharType, StringType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Output adapter for basic_string })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::output_vector_adapter< CharType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Output adapter for byte vectors })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Paddle} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates objects of type {\b Paddle} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::parse_error} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception indicating a parse error })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::parser< BasicJsonType, InputAdapterType >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Syntax analysis })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::position_t} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Struct to capture the start position of the current token })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::primitive_iterator_t} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::priority_tag< N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::priority_tag< 0 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::serializer< BasicJsonType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::span_input_adapter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::static_const< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b surprise} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates surprises })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::to_json_fn} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TripleBlk} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates objects of type {\b TripleBlk} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tuple_element< N, ::nlohmann::detail::iteration_proxy_value< IteratorType > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b std::tuple_size<::nlohmann::detail::iteration_proxy_value< IteratorType > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::is_ordered_map< T >::two} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::type_error} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exception indicating executing a member function with a wrong type })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::wide_string_input_helper< BaseInputAdapter, T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 2 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 4 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b Client/{\b Ball.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Ball.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b client.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b client.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Commonblk.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Commonblk.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Deepblk.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Deepblk.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Doubleblk.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Doubleblk.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Game.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Game.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b gameover.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b gameover.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b gamewindow.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Internblk.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Internblk.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b json.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b mainwindow.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b mainwindow.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Paddle.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Paddle.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b surprise.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b surprise.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Tripleblk.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Client/{\b Tripleblk.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann Namespace Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann}
{\xe \v nlohmann}
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
namespace for Niels Lohmann }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b detail}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
detail namespace with internal helper functions }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b adl_serializer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
default JSONSerializer template argument }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b basic_json}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a class to store JSON values }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b byte_container_with_subtype}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an internal type for a backed binary type }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b json_pointer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON Pointer. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b json_sax}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX interface. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ordered_map}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b json} = {\b basic_json}<>\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
default JSON class }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ordered_json} = {\b basic_json}< {\b nlohmann::ordered_map} >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ordered JSON class }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NLOHMANN_BASIC_JSON_TPL_DECLARATION} std::string {\b to_string} (const {\b NLOHMANN_BASIC_JSON_TPL} &j)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
user-defined to_string function for JSON values }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
namespace for Niels Lohmann \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://github.com/nlohmann} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0\par
}}namespace to hold default {\f2 to_json}  function to see why this is required: {\f2 http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4381.html} \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v json\:nlohmann}
{\xe \v nlohmann\:json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b nlohmann::json} = typedef {\b basic_json}<>}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
default JSON class }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This type is the default specialization of the {\b basic_json} class which uses the standard template types.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 3408} of file {\b json.hpp}.}\par
}
{\xe \v ordered_json\:nlohmann}
{\xe \v nlohmann\:ordered_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b nlohmann::ordered_json} = typedef {\b basic_json}<{\b nlohmann::ordered_map}>}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ordered JSON class }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This type preserves the insertion order of object keys.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.9.0 \par
}}}{
Definition at line {\b 3420} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v to_string\:nlohmann}
{\xe \v nlohmann\:to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b NLOHMANN_BASIC_JSON_TPL_DECLARATION} std::string nlohmann::to_string (const {\b NLOHMANN_BASIC_JSON_TPL} &  {\i j})}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
user-defined to_string function for JSON values }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function implements a user-defined to_string for JSON objects.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{a JSON object \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a std::string object \par
}}}{
Definition at line {\b 26358} of file {\b json.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail Namespace Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail}
{\xe \v nlohmann::detail}
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
detail namespace with internal helper functions }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b container_input_adapter_factory_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b dtoa_impl}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
implements the Grisu2 algorithm for binary to decimal floating-point conversion. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b utility_internal}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b binary_reader}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialization of CBOR, MessagePack, and UBJSON values }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b binary_writer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serialization to CBOR and MessagePack values }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b conjunction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b conjunction< B1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b conjunction< B1, Bn... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b detector}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b detector< Default, void_t< Op< Args... > >, Op, Args... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b exception}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
general exception of the {\b basic_json} class }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b external_constructor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b external_constructor< value_t::array >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b external_constructor< value_t::binary >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b external_constructor< value_t::boolean >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b external_constructor< value_t::number_float >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b external_constructor< value_t::number_integer >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b external_constructor< value_t::number_unsigned >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b external_constructor< value_t::object >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b external_constructor< value_t::string >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b file_input_adapter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b from_json_fn}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_from_json}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_non_default_from_json}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_to_json}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b identity_tag}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b input_stream_adapter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b integer_sequence}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b internal_iterator}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an iterator value }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b invalid_iterator}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating errors with iterators }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_basic_json}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_basic_json< NLOHMANN_BASIC_JSON_TPL >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_array_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_array_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, enable_if_t< is_detected< value_type_t, CompatibleArrayType >::value &&is_detected< iterator_t, CompatibleArrayType >::value &&!is_iterator_traits< iterator_traits< CompatibleArrayType > >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_integer_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_integer_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_object_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_object_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_string_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_string_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, CompatibleStringType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_compatible_type_impl< BasicJsonType, CompatibleType, enable_if_t< is_complete_type< CompatibleType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_complete_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_complete_type< T, decltype(void(sizeof(T)))>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible< const std::pair< T1, T2 > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible< const std::tuple< Ts... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible< std::pair< T1, T2 > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible< std::tuple< Ts... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_array_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_array_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< !std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value &&is_default_constructible< ConstructibleArrayType >::value &&(std::is_move_assignable< ConstructibleArrayType >::value||std::is_copy_assignable< ConstructibleArrayType >::value)&&is_detected< value_type_t, ConstructibleArrayType >::value &&is_detected< iterator_t, ConstructibleArrayType >::value &&is_complete_type< detected_t< value_type_t, ConstructibleArrayType > >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_object_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_object_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_string_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_string_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, ConstructibleStringType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_tuple}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_constructible_tuple< T1, std::tuple< Args... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_default_constructible}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_default_constructible< const std::pair< T1, T2 > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_default_constructible< const std::tuple< Ts... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_default_constructible< std::pair< T1, T2 > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_default_constructible< std::tuple< Ts... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_detected_lazy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_getable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_iterator_of_multibyte}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_iterator_traits}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_iterator_traits< iterator_traits< T > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_json_ref}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_json_ref< json_ref< T > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_ordered_map}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_sax}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_sax_static_asserts}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b iter_impl}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a template for a bidirectional iterator for the {\b basic_json} class This class implements a both iterators (iterator and const_iterator) for the {\b basic_json} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b iteration_proxy}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
proxy class for the items() function }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b iteration_proxy_value}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b iterator_input_adapter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b iterator_input_adapter_factory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b iterator_traits}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b iterator_traits< T *, enable_if_t< std::is_object< T >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b iterator_traits< T, enable_if_t< !std::is_pointer< T >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b iterator_types}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b json_ref}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b json_reverse_iterator}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a template for a reverse iterator class }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b json_sax_acceptor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b json_sax_dom_callback_parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b json_sax_dom_parser}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX implementation to create a JSON value from SAX events. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b lexer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
lexical analysis }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b lexer_base}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b make_void}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b negation}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nonesuch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b other_error}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating other library errors }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b out_of_range}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating access out of the defined range }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b output_adapter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b output_adapter_protocol}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
abstract output adapter interface }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b output_stream_adapter}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for output streams }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b output_string_adapter}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for basic_string }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b output_vector_adapter}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for byte vectors }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b parse_error}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating a parse error }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b parser}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
syntax analysis }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b position_t}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct to capture the start position of the current token }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b primitive_iterator_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b priority_tag}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b priority_tag< 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b serializer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b span_input_adapter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b static_const}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b to_json_fn}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b type_error}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating executing a member function with a wrong type }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b wide_string_input_adapter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b wide_string_input_helper}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b wide_string_input_helper< BaseInputAdapter, 2 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b wide_string_input_helper< BaseInputAdapter, 4 >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b uncvref_t} = typename std::remove_cv< typename std::remove_reference< T >::type >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<bool B, typename T  = void> using {\b enable_if_t} = typename std::enable_if< B, T >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<size_t... Ints> using {\b index_sequence} = {\b integer_sequence}< size_t, Ints... >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , T N> using {\b make_integer_sequence} = typename {\b utility_internal::Gen}< T, N >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<size_t N> using {\b make_index_sequence} = {\b make_integer_sequence}< size_t, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Ts> using {\b index_sequence_for} = {\b make_index_sequence}< sizeof...(Ts)>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> using {\b void_t} = typename {\b make_void}< Ts... >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<template< class... > class Op, class... Args> using {\b is_detected} = typename {\b detector}< {\b nonesuch}, void, Op, Args... >::{\b value_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<template< class... > class Op, class... Args> using {\b detected_t} = typename {\b detector}< {\b nonesuch}, void, Op, Args... >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Default , template< class... > class Op, class... Args> using {\b detected_or} = {\b detector}< Default, void, Op, Args... >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Default , template< class... > class Op, class... Args> using {\b detected_or_t} = typename {\b detected_or}< Default, Op, Args... >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Expected , template< class... > class Op, class... Args> using {\b is_detected_exact} = std::is_same< Expected, {\b detected_t}< Op, Args... > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class To , template< class... > class Op, class... Args> using {\b is_detected_convertible} = std::is_convertible< {\b detected_t}< Op, Args... >, To >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b mapped_type_t} = typename T::mapped_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b key_type_t} = typename T::key_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b value_type_t} = typename T::value_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b difference_type_t} = typename T::difference_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b pointer_t} = typename T::pointer\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b reference_t} = typename T::reference\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b iterator_category_t} = typename T::iterator_category\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b iterator_t} = typename T::iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename... Args> using {\b to_json_function} = decltype(T::to_json(std::declval< Args >()...))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename... Args> using {\b from_json_function} = decltype(T::from_json(std::declval< Args >()...))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > using {\b get_template_function} = decltype(std::declval< T >().template {\b get}< U >())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b contiguous_bytes_input_adapter} = decltype({\b input_adapter}(std::declval< const char * >(), std::declval< const char * >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b null_function_t} = decltype(std::declval< T & >().null())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b boolean_function_t} = decltype(std::declval< T & >().boolean(std::declval< bool >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Integer > using {\b number_integer_function_t} = decltype(std::declval< T & >().number_integer(std::declval< Integer >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Unsigned > using {\b number_unsigned_function_t} = decltype(std::declval< T & >().number_unsigned(std::declval< Unsigned >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Float , typename String > using {\b number_float_function_t} = decltype(std::declval< T & >().number_float(std::declval< Float >(), std::declval< const String & >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename String > using {\b string_function_t} = decltype(std::declval< T & >().string(std::declval< String & >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Binary > using {\b binary_function_t} = decltype(std::declval< T & >().binary(std::declval< Binary & >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b start_object_function_t} = decltype(std::declval< T & >().start_object(std::declval< std::size_t >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename String > using {\b key_function_t} = decltype(std::declval< T & >().key(std::declval< String & >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b end_object_function_t} = decltype(std::declval< T & >().end_object())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b start_array_function_t} = decltype(std::declval< T & >().start_array(std::declval< std::size_t >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b end_array_function_t} = decltype(std::declval< T & >().end_array())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Exception > using {\b parse_error_function_t} = decltype(std::declval< T & >().{\b parse_error}(std::declval< std::size_t >(), std::declval< const std::string & >(), std::declval< const Exception & >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > using {\b parser_callback_t} = std::function< bool(int, {\b parse_event_t}, BasicJsonType &)>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharType > using {\b output_adapter_t} = std::shared_ptr< {\b output_adapter_protocol}< CharType > >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type to simplify interfaces }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b value_t} : std::uint8_t \{ {\b null}
, {\b object}
, {\b array}
, {\b string}
, {\b boolean}
, {\b number_integer}
, {\b number_unsigned}
, {\b number_float}
, {\b binary}
, {\b discarded}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the JSON type enumeration }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b input_format_t} \{ {\b json}
, {\b cbor}
, {\b msgpack}
, {\b ubjson}
, {\b bson}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the supported input formats }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b cbor_tag_handler_t} \{ {\b error}
, {\b ignore}
, {\b store}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
how to treat CBOR tags }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b parse_event_t} : std::uint8_t \{ {\b object_start}
, {\b object_end}
, {\b array_start}
, {\b array_end}
, {\b key}
, {\b value}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b error_handler_t} \{ {\b strict}
, {\b replace}
, {\b ignore}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
how to treat decoding errors }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b value_t} lhs, const {\b value_t} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison operator for JSON types }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b replace_substring} (std::string &s, const std::string &f, const std::string &t)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
replace all occurrences of a substring by another string }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b escape} (std::string s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
string escaping as described in RFC 6901 (Sect. 4) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U , {\b enable_if_t}< !std::is_same< T, U >::value, int >  = 0> T {\b conditional_static_cast} (U value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b from_json} (const BasicJsonType &j, typename std::nullptr_t &n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ArithmeticType , {\b enable_if_t}< std::is_arithmetic< ArithmeticType >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::boolean_t >::value, int >  = 0> void {\b get_arithmetic_value} (const BasicJsonType &j, ArithmeticType &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b from_json} (const BasicJsonType &j, typename BasicJsonType::boolean_t &b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b from_json} (const BasicJsonType &j, typename BasicJsonType::string_t &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ConstructibleStringType , {\b enable_if_t}< {\b is_constructible_string_type}< BasicJsonType, ConstructibleStringType >::value &&!std::is_same< typename BasicJsonType::string_t, ConstructibleStringType >::value, int >  = 0> void {\b from_json} (const BasicJsonType &j, ConstructibleStringType &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b from_json} (const BasicJsonType &j, typename BasicJsonType::number_float_t &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b from_json} (const BasicJsonType &j, typename BasicJsonType::number_unsigned_t &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b from_json} (const BasicJsonType &j, typename BasicJsonType::number_integer_t &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename EnumType , {\b enable_if_t}< std::is_enum< EnumType >::value, int >  = 0> void {\b from_json} (const BasicJsonType &j, EnumType &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , typename Allocator , {\b enable_if_t}< {\b is_getable}< BasicJsonType, T >::value, int >  = 0> void {\b from_json} (const BasicJsonType &j, std::forward_list< T, Allocator > &l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , {\b enable_if_t}< {\b is_getable}< BasicJsonType, T >::value, int >  = 0> void {\b from_json} (const BasicJsonType &j, std::valarray< T > &l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , std::size_t N> auto {\b from_json} (const BasicJsonType &j, T(&arr)[N]) -> decltype(j.template {\b get}< T >(), void())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b from_json_array_impl} (const BasicJsonType &j, typename BasicJsonType::array_t &arr, {\b priority_tag}< 3 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , std::size_t N> auto {\b from_json_array_impl} (const BasicJsonType &j, std::array< T, N > &arr, {\b priority_tag}< 2 >) -> decltype(j.template {\b get}< T >(), void())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ConstructibleArrayType , {\b enable_if_t}< std::is_assignable< ConstructibleArrayType &, ConstructibleArrayType >::value, int >  = 0> auto {\b from_json_array_impl} (const BasicJsonType &j, ConstructibleArrayType &arr, {\b priority_tag}< 1 >) -> decltype(arr.reserve(std::declval< typename ConstructibleArrayType::size_type >()), j.template {\b get}< typename ConstructibleArrayType::value_type >(), void())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ConstructibleArrayType , {\b enable_if_t}< std::is_assignable< ConstructibleArrayType &, ConstructibleArrayType >::value, int >  = 0> void {\b from_json_array_impl} (const BasicJsonType &j, ConstructibleArrayType &arr, {\b priority_tag}< 0 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ConstructibleArrayType , {\b enable_if_t}< {\b is_constructible_array_type}< BasicJsonType, ConstructibleArrayType >::value &&!{\b is_constructible_object_type}< BasicJsonType, ConstructibleArrayType >::value &&!{\b is_constructible_string_type}< BasicJsonType, ConstructibleArrayType >::value &&!std::is_same< ConstructibleArrayType, typename BasicJsonType::binary_t >::value &&!{\b is_basic_json}< ConstructibleArrayType >::value, int >  = 0> auto {\b from_json} (const BasicJsonType &j, ConstructibleArrayType &arr) -> decltype({\b from_json_array_impl}(j, arr, {\b priority_tag}< 3 > \{\}), j.template {\b get}< typename ConstructibleArrayType::value_type >(), void())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , std::size_t... Idx> std::array< T, sizeof...(Idx)> {\b from_json_inplace_array_impl} (BasicJsonType &&j, {\b identity_tag}< std::array< T, sizeof...(Idx)> >, {\b index_sequence}< Idx... >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , std::size_t N> auto {\b from_json} (BasicJsonType &&j, {\b identity_tag}< std::array< T, N > > tag) -> decltype({\b from_json_inplace_array_impl}(std::forward< BasicJsonType >(j), tag, {\b make_index_sequence}< N > \{\}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b from_json} (const BasicJsonType &j, typename BasicJsonType::binary_t &bin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ConstructibleObjectType , {\b enable_if_t}< {\b is_constructible_object_type}< BasicJsonType, ConstructibleObjectType >::value, int >  = 0> void {\b from_json} (const BasicJsonType &j, ConstructibleObjectType &obj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ArithmeticType , {\b enable_if_t}< std::is_arithmetic< ArithmeticType >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::number_unsigned_t >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::number_integer_t >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::number_float_t >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::boolean_t >::value, int >  = 0> void {\b from_json} (const BasicJsonType &j, ArithmeticType &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename... Args, std::size_t... Idx> std::tuple< Args... > {\b from_json_tuple_impl_base} (BasicJsonType &&j, {\b index_sequence}< Idx... >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , class A1 , class A2 > std::pair< A1, A2 > {\b from_json_tuple_impl} (BasicJsonType &&j, {\b identity_tag}< std::pair< A1, A2 > >, {\b priority_tag}< 0 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename A1 , typename A2 > void {\b from_json_tuple_impl} (BasicJsonType &&j, std::pair< A1, A2 > &p, {\b priority_tag}< 1 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename... Args> std::tuple< Args... > {\b from_json_tuple_impl} (BasicJsonType &&j, {\b identity_tag}< std::tuple< Args... > >, {\b priority_tag}< 2 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename... Args> void {\b from_json_tuple_impl} (BasicJsonType &&j, std::tuple< Args... > &t, {\b priority_tag}< 3 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename TupleRelated > auto {\b from_json} (BasicJsonType &&j, TupleRelated &&t) -> decltype({\b from_json_tuple_impl}(std::forward< BasicJsonType >(j), std::forward< TupleRelated >(t), {\b priority_tag}< 3 > \{\}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename Key , typename Value , typename Compare , typename Allocator , typename  = enable_if_t < !std::is_constructible <                                        typename BasicJsonType::string_t, Key >::value >> void {\b from_json} (const BasicJsonType &j, std::map< Key, Value, Compare, Allocator > &m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename Key , typename Value , typename Hash , typename KeyEqual , typename Allocator , typename  = enable_if_t < !std::is_constructible <                                        typename BasicJsonType::string_t, Key >::value >> void {\b from_json} (const BasicJsonType &j, std::unordered_map< Key, Value, Hash, KeyEqual, Allocator > &m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename string_type > void {\b int_to_string} (string_type &target, std::size_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t N, typename IteratorType , {\b enable_if_t}< N==0, int >  = 0> auto {\b get} (const {\b nlohmann::detail::iteration_proxy_value}< IteratorType > &i) -> decltype(i.key())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , {\b enable_if_t}< std::is_same< T, typename BasicJsonType::boolean_t >::value, int >  = 0> void {\b to_json} (BasicJsonType &j, T b) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleString , {\b enable_if_t}< std::is_constructible< typename BasicJsonType::string_t, CompatibleString >::value, int >  = 0> void {\b to_json} (BasicJsonType &j, const CompatibleString &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b to_json} (BasicJsonType &j, typename BasicJsonType::string_t &&s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename FloatType , {\b enable_if_t}< std::is_floating_point< FloatType >::value, int >  = 0> void {\b to_json} (BasicJsonType &j, FloatType val) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleNumberUnsignedType , {\b enable_if_t}< {\b is_compatible_integer_type}< typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType >::value, int >  = 0> void {\b to_json} (BasicJsonType &j, CompatibleNumberUnsignedType val) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleNumberIntegerType , {\b enable_if_t}< {\b is_compatible_integer_type}< typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType >::value, int >  = 0> void {\b to_json} (BasicJsonType &j, CompatibleNumberIntegerType val) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename EnumType , {\b enable_if_t}< std::is_enum< EnumType >::value, int >  = 0> void {\b to_json} (BasicJsonType &j, EnumType e) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b to_json} (BasicJsonType &j, const std::vector< bool > &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleArrayType , {\b enable_if_t}< {\b is_compatible_array_type}< BasicJsonType, CompatibleArrayType >::value &&!{\b is_compatible_object_type}< BasicJsonType, CompatibleArrayType >::value &&!{\b is_compatible_string_type}< BasicJsonType, CompatibleArrayType >::value &&!std::is_same< typename BasicJsonType::binary_t, CompatibleArrayType >::value &&!{\b is_basic_json}< CompatibleArrayType >::value, int >  = 0> void {\b to_json} (BasicJsonType &j, const CompatibleArrayType &arr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b to_json} (BasicJsonType &j, const typename BasicJsonType::binary_t &bin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , {\b enable_if_t}< std::is_convertible< T, BasicJsonType >::value, int >  = 0> void {\b to_json} (BasicJsonType &j, const std::valarray< T > &arr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b to_json} (BasicJsonType &j, typename BasicJsonType::array_t &&arr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleObjectType , {\b enable_if_t}< {\b is_compatible_object_type}< BasicJsonType, CompatibleObjectType >::value &&!{\b is_basic_json}< CompatibleObjectType >::value, int >  = 0> void {\b to_json} (BasicJsonType &j, const CompatibleObjectType &obj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b to_json} (BasicJsonType &j, typename BasicJsonType::object_t &&obj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , std::size_t N, {\b enable_if_t}< !std::is_constructible< typename BasicJsonType::string_t, const T(&)[N]>::value, int >  = 0> void {\b to_json} (BasicJsonType &j, const T(&arr)[N])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T1 , typename T2 , {\b enable_if_t}< std::is_constructible< BasicJsonType, T1 >::value &&std::is_constructible< BasicJsonType, T2 >::value, int >  = 0> void {\b to_json} (BasicJsonType &j, const std::pair< T1, T2 > &p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , {\b enable_if_t}< std::is_same< T, {\b iteration_proxy_value}< typename BasicJsonType::iterator > >::value, int >  = 0> void {\b to_json} (BasicJsonType &j, const T &b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename Tuple , std::size_t... Idx> void {\b to_json_tuple_impl} (BasicJsonType &j, const Tuple &t, {\b index_sequence}< Idx... >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b combine} (std::size_t seed, std::size_t h) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > std::size_t {\b hash} (const BasicJsonType &j)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
hash a JSON value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename IteratorType > {\b iterator_input_adapter_factory}< IteratorType >::adapter_type {\b input_adapter} (IteratorType first, IteratorType last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ContainerType > {\b container_input_adapter_factory_impl::container_input_adapter_factory}< ContainerType >::adapter_type {\b input_adapter} (const ContainerType &container)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_input_adapter} {\b input_adapter} (std::FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b input_stream_adapter} {\b input_adapter} (std::istream &stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b input_stream_adapter} {\b input_adapter} (std::istream &&stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharT , typename std::enable_if< std::is_pointer< CharT >::value &&!std::is_array< CharT >::value &&std::is_integral< typename std::remove_pointer< CharT >::type >::value &&sizeof(typename std::remove_pointer< CharT >::type)==1, int >::type  = 0> {\b contiguous_bytes_input_adapter} {\b input_adapter} (CharT b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , std::size_t N> auto {\b input_adapter} (T(&array)[N]) -> decltype(input_adapter(array, array+N))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename FloatType > {\b JSON_HEDLEY_RETURNS_NON_NULL} char * {\b to_chars} (char *first, const char *last, FloatType value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
generates a decimal representation of the floating-point number value in [first, last). }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
detail namespace with internal helper functions \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This namespace collects functions that should not be exposed, implementations of some {\b basic_json} methods, and meta-programming helpers.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.1.0 \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v binary_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:binary_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename Binary > using {\b nlohmann::detail::binary_function_t} = typedef decltype(std::declval<T&>().binary(std::declval<Binary&>()))}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8201} of file {\b json.hpp}.}\par
}
{\xe \v boolean_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:boolean_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::boolean_function_t} = typedef decltype(std::declval<T&>().boolean(std::declval<bool>()))}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8181} of file {\b json.hpp}.}\par
}
{\xe \v contiguous_bytes_input_adapter\:nlohmann::detail}
{\xe \v nlohmann::detail\:contiguous_bytes_input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b nlohmann::detail::contiguous_bytes_input_adapter} = typedef decltype({\b input_adapter}(std::declval<const char*>(), std::declval<const char*>()))}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5760} of file {\b json.hpp}.}\par
}
{\xe \v detected_or\:nlohmann::detail}
{\xe \v nlohmann::detail\:detected_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Default , template< class... > class Op, class... Args> using {\b nlohmann::detail::detected_or} = typedef {\b detector}<Default, void, Op, Args...>}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3332} of file {\b json.hpp}.}\par
}
{\xe \v detected_or_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:detected_or_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Default , template< class... > class Op, class... Args> using {\b nlohmann::detail::detected_or_t} = typedef typename {\b detected_or}<Default, Op, Args...>::type}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3335} of file {\b json.hpp}.}\par
}
{\xe \v detected_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:detected_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< class... > class Op, class... Args> using {\b nlohmann::detail::detected_t} = typedef typename {\b detector}<{\b nonesuch}, void, Op, Args...>::type}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3329} of file {\b json.hpp}.}\par
}
{\xe \v difference_type_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:difference_type_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::difference_type_t} = typedef typename T::difference_type}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3484} of file {\b json.hpp}.}\par
}
{\xe \v enable_if_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:enable_if_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<bool B, typename T  = void> using {\b nlohmann::detail::enable_if_t} = typedef typename std::enable_if<B, T>::type}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3063} of file {\b json.hpp}.}\par
}
{\xe \v end_array_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:end_array_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::end_array_function_t} = typedef decltype(std::declval<T&>().end_array())}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8220} of file {\b json.hpp}.}\par
}
{\xe \v end_object_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:end_object_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::end_object_function_t} = typedef decltype(std::declval<T&>().end_object())}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8213} of file {\b json.hpp}.}\par
}
{\xe \v from_json_function\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json_function}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename... Args> using {\b nlohmann::detail::from_json_function} = typedef decltype(T::from_json(std::declval<Args>()...))}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3502} of file {\b json.hpp}.}\par
}
{\xe \v get_template_function\:nlohmann::detail}
{\xe \v nlohmann::detail\:get_template_function}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U > using {\b nlohmann::detail::get_template_function} = typedef decltype(std::declval<T>().template {\b get}<U>())}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3505} of file {\b json.hpp}.}\par
}
{\xe \v index_sequence\:nlohmann::detail}
{\xe \v nlohmann::detail\:index_sequence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t... Ints> using {\b nlohmann::detail::index_sequence} = typedef {\b integer_sequence}<size_t, Ints...>}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3105} of file {\b json.hpp}.}\par
}
{\xe \v index_sequence_for\:nlohmann::detail}
{\xe \v nlohmann::detail\:index_sequence_for}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> using {\b nlohmann::detail::index_sequence_for} = typedef {\b make_index_sequence}<sizeof...(Ts)>}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3167} of file {\b json.hpp}.}\par
}
{\xe \v is_detected\:nlohmann::detail}
{\xe \v nlohmann::detail\:is_detected}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< class... > class Op, class... Args> using {\b nlohmann::detail::is_detected} = typedef typename {\b detector}<{\b nonesuch}, void, Op, Args...>::{\b value_t}}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3323} of file {\b json.hpp}.}\par
}
{\xe \v is_detected_convertible\:nlohmann::detail}
{\xe \v nlohmann::detail\:is_detected_convertible}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class To , template< class... > class Op, class... Args> using {\b nlohmann::detail::is_detected_convertible} = typedef std::is_convertible<{\b detected_t}<Op, Args...>, To>}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3341} of file {\b json.hpp}.}\par
}
{\xe \v is_detected_exact\:nlohmann::detail}
{\xe \v nlohmann::detail\:is_detected_exact}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Expected , template< class... > class Op, class... Args> using {\b nlohmann::detail::is_detected_exact} = typedef std::is_same<Expected, {\b detected_t}<Op, Args...> >}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3338} of file {\b json.hpp}.}\par
}
{\xe \v iterator_category_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:iterator_category_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::iterator_category_t} = typedef typename T::iterator_category}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3493} of file {\b json.hpp}.}\par
}
{\xe \v iterator_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:iterator_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::iterator_t} = typedef typename T::iterator}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3496} of file {\b json.hpp}.}\par
}
{\xe \v key_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:key_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename String > using {\b nlohmann::detail::key_function_t} = typedef decltype(std::declval<T&>().key(std::declval<String&>()))}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8209} of file {\b json.hpp}.}\par
}
{\xe \v key_type_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:key_type_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::key_type_t} = typedef typename T::key_type}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3478} of file {\b json.hpp}.}\par
}
{\xe \v make_index_sequence\:nlohmann::detail}
{\xe \v nlohmann::detail\:make_index_sequence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t N> using {\b nlohmann::detail::make_index_sequence} = typedef {\b make_integer_sequence}<size_t, N>}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3159} of file {\b json.hpp}.}\par
}
{\xe \v make_integer_sequence\:nlohmann::detail}
{\xe \v nlohmann::detail\:make_integer_sequence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , T N> using {\b nlohmann::detail::make_integer_sequence} = typedef typename {\b utility_internal::Gen}<T, N>::type}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3151} of file {\b json.hpp}.}\par
}
{\xe \v mapped_type_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:mapped_type_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::mapped_type_t} = typedef typename T::mapped_type}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3475} of file {\b json.hpp}.}\par
}
{\xe \v null_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:null_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::null_function_t} = typedef decltype(std::declval<T&>().null())}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8178} of file {\b json.hpp}.}\par
}
{\xe \v number_float_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:number_float_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename Float , typename String > using {\b nlohmann::detail::number_float_function_t} = typedef decltype(std::declval<T&>().number_float( std::declval<Float>(), std::declval<const String&>()))}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8193} of file {\b json.hpp}.}\par
}
{\xe \v number_integer_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:number_integer_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename Integer > using {\b nlohmann::detail::number_integer_function_t} = typedef decltype(std::declval<T&>().number_integer(std::declval<Integer>()))}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8185} of file {\b json.hpp}.}\par
}
{\xe \v number_unsigned_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:number_unsigned_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename Unsigned > using {\b nlohmann::detail::number_unsigned_function_t} = typedef decltype(std::declval<T&>().number_unsigned(std::declval<Unsigned>()))}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8189} of file {\b json.hpp}.}\par
}
{\xe \v output_adapter_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:output_adapter_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > using {\b nlohmann::detail::output_adapter_t} = typedef std::shared_ptr<{\b output_adapter_protocol}<CharType> >}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type to simplify interfaces }}\par
{
Definition at line {\b 13485} of file {\b json.hpp}.}\par
}
{\xe \v parse_error_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:parse_error_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename Exception > using {\b nlohmann::detail::parse_error_function_t} = typedef decltype(std::declval<T&>().{\b parse_error}( std::declval<std::size_t>(), std::declval<const std::string&>(), std::declval<const Exception&>()))}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8223} of file {\b json.hpp}.}\par
}
{\xe \v parser_callback_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:parser_callback_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::parser_callback_t} = typedef std::function<bool(int , {\b parse_event_t} , BasicJsonType& )>}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10874} of file {\b json.hpp}.}\par
}
{\xe \v pointer_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:pointer_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::pointer_t} = typedef typename T::pointer}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3487} of file {\b json.hpp}.}\par
}
{\xe \v reference_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:reference_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::reference_t} = typedef typename T::reference}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3490} of file {\b json.hpp}.}\par
}
{\xe \v start_array_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:start_array_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::start_array_function_t} = typedef decltype(std::declval<T&>().start_array(std::declval<std::size_t>()))}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8216} of file {\b json.hpp}.}\par
}
{\xe \v start_object_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:start_object_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::start_object_function_t} = typedef decltype(std::declval<T&>().start_object(std::declval<std::size_t>()))}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8205} of file {\b json.hpp}.}\par
}
{\xe \v string_function_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:string_function_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename String > using {\b nlohmann::detail::string_function_t} = typedef decltype(std::declval<T&>().string(std::declval<String&>()))}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8197} of file {\b json.hpp}.}\par
}
{\xe \v to_json_function\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json_function}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename... Args> using {\b nlohmann::detail::to_json_function} = typedef decltype(T::to_json(std::declval<Args>()...))}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3499} of file {\b json.hpp}.}\par
}
{\xe \v uncvref_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:uncvref_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::uncvref_t} = typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3049} of file {\b json.hpp}.}\par
}
{\xe \v value_type_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:value_type_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::value_type_t} = typedef typename T::value_type}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3481} of file {\b json.hpp}.}\par
}
{\xe \v void_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:void_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ... Ts> using {\b nlohmann::detail::void_t} = typedef typename {\b make_void}<Ts...>::type}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3226} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v cbor_tag_handler_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:cbor_tag_handler_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b nlohmann::detail::cbor_tag_handler_t}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
how to treat CBOR tags }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v error\:nlohmann::detail}
{\xe \v nlohmann::detail\:error}
{\qr error{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
throw a {\b parse_error} exception in case of a tag \par
}\cell }{\row }
{\xe \v ignore\:nlohmann::detail}
{\xe \v nlohmann::detail\:ignore}
{\qr ignore{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ignore tags \par
}\cell }{\row }
{\xe \v store\:nlohmann::detail}
{\xe \v nlohmann::detail\:store}
{\qr store{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
store tags as binary type \par
}\cell }{\row }
}
{
Definition at line {\b 8325} of file {\b json.hpp}.}\par
}
{\xe \v error_handler_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:error_handler_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b nlohmann::detail::error_handler_t}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
how to treat decoding errors }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v strict\:nlohmann::detail}
{\xe \v nlohmann::detail\:strict}
{\qr strict{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
throw a {\b type_error} exception in case of invalid UTF-8 \par
}\cell }{\row }
{\xe \v replace\:nlohmann::detail}
{\xe \v nlohmann::detail\:replace}
{\qr replace{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
replace invalid UTF-8 sequences with U+FFFD \par
}\cell }{\row }
{\xe \v ignore\:nlohmann::detail}
{\xe \v nlohmann::detail\:ignore}
{\qr ignore{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ignore invalid UTF-8 sequences \par
}\cell }{\row }
}
{
Definition at line {\b 16361} of file {\b json.hpp}.}\par
}
{\xe \v input_format_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:input_format_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b nlohmann::detail::input_format_t}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the supported input formats }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v json\:nlohmann::detail}
{\xe \v nlohmann::detail\:json}
{\qr json{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
\cell }{\cell }{\row }
{\xe \v cbor\:nlohmann::detail}
{\xe \v nlohmann::detail\:cbor}
{\qr cbor{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
\cell }{\cell }{\row }
{\xe \v msgpack\:nlohmann::detail}
{\xe \v nlohmann::detail\:msgpack}
{\qr msgpack{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
\cell }{\cell }{\row }
{\xe \v ubjson\:nlohmann::detail}
{\xe \v nlohmann::detail\:ubjson}
{\qr ubjson{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
\cell }{\cell }{\row }
{\xe \v bson\:nlohmann::detail}
{\xe \v nlohmann::detail\:bson}
{\qr bson{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 5357} of file {\b json.hpp}.}\par
}
{\xe \v parse_event_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:parse_event_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b nlohmann::detail::parse_event_t} : std::uint8_t{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v object_start\:nlohmann::detail}
{\xe \v nlohmann::detail\:object_start}
{\qr object_start{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the parser read {\f2 \{}  and started to process a JSON object \par
}\cell }{\row }
{\xe \v object_end\:nlohmann::detail}
{\xe \v nlohmann::detail\:object_end}
{\qr object_end{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the parser read {\f2 \}}  and finished processing a JSON object \par
}\cell }{\row }
{\xe \v array_start\:nlohmann::detail}
{\xe \v nlohmann::detail\:array_start}
{\qr array_start{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the parser read {\f2 [}  and started to process a JSON array \par
}\cell }{\row }
{\xe \v array_end\:nlohmann::detail}
{\xe \v nlohmann::detail\:array_end}
{\qr array_end{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the parser read {\f2 ]}  and finished processing a JSON array \par
}\cell }{\row }
{\xe \v key\:nlohmann::detail}
{\xe \v nlohmann::detail\:key}
{\qr key{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the parser read a key of a value in an object \par
}\cell }{\row }
{\xe \v value\:nlohmann::detail}
{\xe \v nlohmann::detail\:value}
{\qr value{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the parser finished reading a JSON value \par
}\cell }{\row }
}
{
Definition at line {\b 10857} of file {\b json.hpp}.}\par
}
{\xe \v value_t\:nlohmann::detail}
{\xe \v nlohmann::detail\:value_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b nlohmann::detail::value_t} : std::uint8_t{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the JSON type enumeration }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This enumeration collects the different JSON types. It is internally used to distinguish the stored values, and the functions {\b basic_json::is_null()}, {\b basic_json::is_object()}, {\b basic_json::is_array()}, {\b basic_json::is_string()}, {\b basic_json::is_boolean()}, {\b basic_json::is_number()} (with {\b basic_json::is_number_integer()}, {\b basic_json::is_number_unsigned()}, and {\b basic_json::is_number_float()}), {\b basic_json::is_discarded()}, {\b basic_json::is_primitive()}, and {\b basic_json::is_structured()} rely on it.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
There are three enumeration entries (number_integer, number_unsigned, and number_float), because the library distinguishes these three types for numbers: {\b basic_json::number_unsigned_t} is used for unsigned integers, {\b basic_json::number_integer_t} is used for signed integers, and {\b basic_json::number_float_t} is used for floating-point numbers or to approximate integers which do not fit in the limits of their respective type.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b basic_json::basic_json(const value_t value_type)} \'96 create a JSON value with the default value for a given type\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v null\:nlohmann::detail}
{\xe \v nlohmann::detail\:null}
{\qr null{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
null value \par
}\cell }{\row }
{\xe \v object\:nlohmann::detail}
{\xe \v nlohmann::detail\:object}
{\qr object{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
object (unordered set of name/value pairs) \par
}\cell }{\row }
{\xe \v array\:nlohmann::detail}
{\xe \v nlohmann::detail\:array}
{\qr array{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
array (ordered collection of values) \par
}\cell }{\row }
{\xe \v string\:nlohmann::detail}
{\xe \v nlohmann::detail\:string}
{\qr string{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
string value \par
}\cell }{\row }
{\xe \v boolean\:nlohmann::detail}
{\xe \v nlohmann::detail\:boolean}
{\qr boolean{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
boolean value \par
}\cell }{\row }
{\xe \v number_integer\:nlohmann::detail}
{\xe \v nlohmann::detail\:number_integer}
{\qr number_integer{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
number value (signed integer) \par
}\cell }{\row }
{\xe \v number_unsigned\:nlohmann::detail}
{\xe \v nlohmann::detail\:number_unsigned}
{\qr number_unsigned{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
number value (unsigned integer) \par
}\cell }{\row }
{\xe \v number_float\:nlohmann::detail}
{\xe \v nlohmann::detail\:number_float}
{\qr number_float{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
number value (floating-point) \par
}\cell }{\row }
{\xe \v binary\:nlohmann::detail}
{\xe \v nlohmann::detail\:binary}
{\qr binary{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
binary array (ordered collection of bytes) \par
}\cell }{\row }
{\xe \v discarded\:nlohmann::detail}
{\xe \v nlohmann::detail\:discarded}
{\qr discarded{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
discarded by the parser callback function \par
}\cell }{\row }
}
{
Definition at line {\b 120} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v combine\:nlohmann::detail}
{\xe \v nlohmann::detail\:combine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t nlohmann::detail::combine (std::size_t  {\i seed}, std::size_t  {\i h}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5203} of file {\b json.hpp}.}\par
}
{\xe \v conditional_static_cast\:nlohmann::detail}
{\xe \v nlohmann::detail\:conditional_static_cast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename U , {\b enable_if_t}< !std::is_same< T, U >::value, int >  = 0> T nlohmann::detail::conditional_static_cast (U  {\i value})}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3872} of file {\b json.hpp}.}\par
}
{\xe \v escape\:nlohmann::detail}
{\xe \v nlohmann::detail\:escape}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string nlohmann::detail::escape (std::string  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
string escaping as described in RFC 6901 (Sect. 4) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i s} \cell }{string to escape \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
escaped string\par
}}Note the order of escaping "~" to "~0" and "/" to "~1" is important. \par
}{
Definition at line {\b 2558} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T , std::size_t N> auto nlohmann::detail::from_json (BasicJsonType &&  {\i j}, {\b identity_tag}< std::array< T, N > >  {\i tag}) -> decltype({\b from_json_inplace_array_impl}(std::forward<BasicJsonType>(j), tag, {\b make_index_sequence}<N> \{\}))
}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4139} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename TupleRelated > auto nlohmann::detail::from_json (BasicJsonType &&  {\i j}, TupleRelated &&  {\i t}) -> decltype({\b from_json_tuple_impl}(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), {\b priority_tag}<3> \{\}))
}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4263} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename ArithmeticType , {\b enable_if_t}< std::is_arithmetic< ArithmeticType >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::number_unsigned_t >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::number_integer_t >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::number_float_t >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::boolean_t >::value, int >  = 0> void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, ArithmeticType &  {\i val})}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4195} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename ConstructibleArrayType , {\b enable_if_t}< {\b is_constructible_array_type}< BasicJsonType, ConstructibleArrayType >::value &&!{\b is_constructible_object_type}< BasicJsonType, ConstructibleArrayType >::value &&!{\b is_constructible_string_type}< BasicJsonType, ConstructibleArrayType >::value &&!std::is_same< ConstructibleArrayType, typename BasicJsonType::binary_t >::value &&!{\b is_basic_json}< ConstructibleArrayType >::value, int >  = 0> auto nlohmann::detail::from_json (const BasicJsonType &  {\i j}, ConstructibleArrayType &  {\i arr}) -> decltype({\b from_json_array_impl}(j, arr, {\b priority_tag}<3> \{\}),
j.template {\b get}<typename ConstructibleArrayType::value_type>(),
void())
}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4118} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename ConstructibleObjectType , {\b enable_if_t}< {\b is_constructible_object_type}< BasicJsonType, ConstructibleObjectType >::value, int >  = 0> void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, ConstructibleObjectType &  {\i obj})}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4163} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename ConstructibleStringType , {\b enable_if_t}< {\b is_constructible_string_type}< BasicJsonType, ConstructibleStringType >::value &&!std::is_same< typename BasicJsonType::string_t, ConstructibleStringType >::value, int >  = 0> void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, ConstructibleStringType &  {\i s})}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3967} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename EnumType , {\b enable_if_t}< std::is_enum< EnumType >::value, int >  = 0> void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, EnumType &  {\i e})}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3997} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T , typename Allocator , {\b enable_if_t}< {\b is_getable}< BasicJsonType, T >::value, int >  = 0> void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, std::forward_list< T, Allocator > &  {\i l})}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4007} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename Key , typename Value , typename Compare , typename Allocator , typename  = enable_if_t < !std::is_constructible <                                        typename BasicJsonType::string_t, Key >::value >> void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, std::map< Key, Value, Compare, Allocator > &  {\i m})}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4277} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename Key , typename Value , typename Hash , typename KeyEqual , typename Allocator , typename  = enable_if_t < !std::is_constructible <                                        typename BasicJsonType::string_t, Key >::value >> void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, std::unordered_map< Key, Value, Hash, KeyEqual, Allocator > &  {\i m})}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4297} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T , {\b enable_if_t}< {\b is_getable}< BasicJsonType, T >::value, int >  = 0> void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, std::valarray< T > &  {\i l})}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4024} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T , std::size_t N> auto nlohmann::detail::from_json (const BasicJsonType &  {\i j}, T(&)  {\i arr}[N]) -> decltype(j.template {\b get}<T>(), void())
}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4039} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, typename BasicJsonType::binary_t &  {\i bin})}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4151} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, typename BasicJsonType::boolean_t &  {\i b})}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3941} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, typename BasicJsonType::number_float_t &  {\i val})}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3978} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, typename BasicJsonType::number_integer_t &  {\i val})}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3990} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, typename BasicJsonType::number_unsigned_t &  {\i val})}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3984} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, typename BasicJsonType::string_t &  {\i s})}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3951} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::from_json (const BasicJsonType &  {\i j}, typename std::nullptr_t &  {\i n})}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3894} of file {\b json.hpp}.}\par
}
{\xe \v from_json_array_impl\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json_array_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename ConstructibleArrayType , {\b enable_if_t}< std::is_assignable< ConstructibleArrayType &, ConstructibleArrayType >::value, int >  = 0> void nlohmann::detail::from_json_array_impl (const BasicJsonType &  {\i j}, ConstructibleArrayType &  {\i arr}, {\b priority_tag}< 0 > )}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4093} of file {\b json.hpp}.}\par
}
{\xe \v from_json_array_impl\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json_array_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename ConstructibleArrayType , {\b enable_if_t}< std::is_assignable< ConstructibleArrayType &, ConstructibleArrayType >::value, int >  = 0> auto nlohmann::detail::from_json_array_impl (const BasicJsonType &  {\i j}, ConstructibleArrayType &  {\i arr}, {\b priority_tag}< 1 > ) -> decltype(
    arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),
    j.template {\b get}<typename ConstructibleArrayType::value_type>(),
    void())
}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4069} of file {\b json.hpp}.}\par
}
{\xe \v from_json_array_impl\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json_array_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T , std::size_t N> auto nlohmann::detail::from_json_array_impl (const BasicJsonType &  {\i j}, std::array< T, N > &  {\i arr}, {\b priority_tag}< 2 > ) -> decltype(j.template {\b get}<T>(), void())
}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4055} of file {\b json.hpp}.}\par
}
{\xe \v from_json_array_impl\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json_array_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::from_json_array_impl (const BasicJsonType &  {\i j}, typename BasicJsonType::array_t &  {\i arr}, {\b priority_tag}< 3 > )}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4049} of file {\b json.hpp}.}\par
}
{\xe \v from_json_inplace_array_impl\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json_inplace_array_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T , std::size_t... Idx> std::array< T, sizeof...(Idx)> nlohmann::detail::from_json_inplace_array_impl (BasicJsonType &&  {\i j}, {\b identity_tag}< std::array< T, sizeof...(Idx)> > , {\b index_sequence}< Idx... > )}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4132} of file {\b json.hpp}.}\par
}
{\xe \v from_json_tuple_impl\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json_tuple_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , class A1 , class A2 > std::pair< A1, A2 > nlohmann::detail::from_json_tuple_impl (BasicJsonType &&  {\i j}, {\b identity_tag}< std::pair< A1, A2 > > , {\b priority_tag}< 0 > )}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4238} of file {\b json.hpp}.}\par
}
{\xe \v from_json_tuple_impl\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json_tuple_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename... Args> std::tuple< Args... > nlohmann::detail::from_json_tuple_impl (BasicJsonType &&  {\i j}, {\b identity_tag}< std::tuple< Args... > > , {\b priority_tag}< 2 > )}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4251} of file {\b json.hpp}.}\par
}
{\xe \v from_json_tuple_impl\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json_tuple_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename A1 , typename A2 > void nlohmann::detail::from_json_tuple_impl (BasicJsonType &&  {\i j}, std::pair< A1, A2 > &  {\i p}, {\b priority_tag}< 1 > )}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4245} of file {\b json.hpp}.}\par
}
{\xe \v from_json_tuple_impl\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json_tuple_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename... Args> void nlohmann::detail::from_json_tuple_impl (BasicJsonType &&  {\i j}, std::tuple< Args... > &  {\i t}, {\b priority_tag}< 3 > )}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4257} of file {\b json.hpp}.}\par
}
{\xe \v from_json_tuple_impl_base\:nlohmann::detail}
{\xe \v nlohmann::detail\:from_json_tuple_impl_base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename... Args, std::size_t... Idx> std::tuple< Args... > nlohmann::detail::from_json_tuple_impl_base (BasicJsonType &&  {\i j}, {\b index_sequence}< Idx... > )}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4232} of file {\b json.hpp}.}\par
}
{\xe \v get\:nlohmann::detail}
{\xe \v nlohmann::detail\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::size_t N, typename IteratorType , {\b enable_if_t}< N==0, int >  = 0> auto nlohmann::detail::get (const {\b nlohmann::detail::iteration_proxy_value}< IteratorType > &  {\i i}) -> decltype(i.key())
}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4497} of file {\b json.hpp}.}\par
}
{\xe \v get_arithmetic_value\:nlohmann::detail}
{\xe \v nlohmann::detail\:get_arithmetic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename ArithmeticType , {\b enable_if_t}< std::is_arithmetic< ArithmeticType >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::boolean_t >::value, int >  = 0> void nlohmann::detail::get_arithmetic_value (const BasicJsonType &  {\i j}, ArithmeticType &  {\i val})}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3908} of file {\b json.hpp}.}\par
}
{\xe \v hash\:nlohmann::detail}
{\xe \v nlohmann::detail\:hash}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > std::size_t nlohmann::detail::hash (const BasicJsonType &  {\i j})}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
hash a JSON value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The hash function tries to rely on std::hash where possible. Furthermore, the type of the JSON value is taken into account to have different hash values for null, 0, 0U, and false, etc.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i BasicJsonType} \cell }{{\b basic_json} specialization \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i j} \cell }{JSON value to hash \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
hash value of j \par
}}}{
Definition at line {\b 5221} of file {\b json.hpp}.}\par
}
{\xe \v input_adapter\:nlohmann::detail}
{\xe \v nlohmann::detail\:input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharT , typename std::enable_if< std::is_pointer< CharT >::value &&!std::is_array< CharT >::value &&std::is_integral< typename std::remove_pointer< CharT >::type >::value &&sizeof(typename std::remove_pointer< CharT >::type)==1, int >::type  = 0> {\b contiguous_bytes_input_adapter} nlohmann::detail::input_adapter (CharT  {\i b})}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5770} of file {\b json.hpp}.}\par
}
{\xe \v input_adapter\:nlohmann::detail}
{\xe \v nlohmann::detail\:input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ContainerType > {\b container_input_adapter_factory_impl::container_input_adapter_factory}< ContainerType >::adapter_type nlohmann::detail::input_adapter (const ContainerType &  {\i container})}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5737} of file {\b json.hpp}.}\par
}
{\xe \v input_adapter\:nlohmann::detail}
{\xe \v nlohmann::detail\:input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > {\b iterator_input_adapter_factory}< IteratorType >::adapter_type nlohmann::detail::input_adapter (IteratorType  {\i first}, IteratorType  {\i last})}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5703} of file {\b json.hpp}.}\par
}
{\xe \v input_adapter\:nlohmann::detail}
{\xe \v nlohmann::detail\:input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b file_input_adapter} nlohmann::detail::input_adapter (std::FILE *  {\i file}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5744} of file {\b json.hpp}.}\par
}
{\xe \v input_adapter\:nlohmann::detail}
{\xe \v nlohmann::detail\:input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b input_stream_adapter} nlohmann::detail::input_adapter (std::istream &&  {\i stream}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5754} of file {\b json.hpp}.}\par
}
{\xe \v input_adapter\:nlohmann::detail}
{\xe \v nlohmann::detail\:input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b input_stream_adapter} nlohmann::detail::input_adapter (std::istream &  {\i stream}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5749} of file {\b json.hpp}.}\par
}
{\xe \v input_adapter\:nlohmann::detail}
{\xe \v nlohmann::detail\:input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , std::size_t N> auto nlohmann::detail::input_adapter (T(&)  {\i array}[N]) -> decltype(input_adapter(array, array + N)) 
}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5778} of file {\b json.hpp}.}\par
}
{\xe \v int_to_string\:nlohmann::detail}
{\xe \v nlohmann::detail\:int_to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename string_type > void nlohmann::detail::int_to_string (string_type &  {\i target}, std::size_t  {\i value})}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4366} of file {\b json.hpp}.}\par
}
{\xe \v operator<\:nlohmann::detail}
{\xe \v nlohmann::detail\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool nlohmann::detail::operator< (const {\b value_t}  {\i lhs}, const {\b value_t}  {\i rhs}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison operator for JSON types }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an ordering that is similar to Python:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
order: null < boolean < number < object < array < string < binary\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
furthermore, each type is not smaller than itself\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
discarded values are not comparable\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
binary is represented as a b"" string in python and directly comparable to a string; however, making a binary array directly comparable with a string would be surprising behavior in a JSON file.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 147} of file {\b json.hpp}.}\par
}
{\xe \v replace_substring\:nlohmann::detail}
{\xe \v nlohmann::detail\:replace_substring}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nlohmann::detail::replace_substring (std::string &  {\i s}, const std::string &  {\i f}, const std::string &  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
replace all occurrences of a substring by another string }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i s} \cell }{the string to manipulate; changed so that all occurrences of {\i f}  are replaced with {\i t}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i f} \cell }{the substring to replace with {\i t}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i t} \cell }{the string to replace {\i f}  \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The search string {\i f}  must not be empty. {\b This precondition is enforced with an assertion.} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 2540} of file {\b json.hpp}.}\par
}
{\xe \v to_chars\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_chars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename FloatType > {\b JSON_HEDLEY_RETURNS_NON_NULL} char * nlohmann::detail::to_chars (char *  {\i first}, const char *  {\i last}, FloatType  {\i value})}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
generates a decimal representation of the floating-point number value in [first, last). }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The format of the resulting decimal representation is similar to printf's g format. Returns an iterator pointing past-the-end of the decimal representation.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The input number must be finite, i.e. NaN's and Inf's are not supported. \par
The buffer must be large enough. \par
The result is NOT null-terminated. \par
}}}{
Definition at line {\b 16284} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleNumberIntegerType , {\b enable_if_t}< {\b is_compatible_integer_type}< typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, CompatibleNumberIntegerType  {\i val}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4819} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleNumberUnsignedType , {\b enable_if_t}< {\b is_compatible_integer_type}< typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, CompatibleNumberUnsignedType  {\i val}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4812} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleArrayType , {\b enable_if_t}< {\b is_compatible_array_type}< BasicJsonType, CompatibleArrayType >::value &&!{\b is_compatible_object_type}< BasicJsonType, CompatibleArrayType >::value &&!{\b is_compatible_string_type}< BasicJsonType, CompatibleArrayType >::value &&!std::is_same< typename BasicJsonType::binary_t, CompatibleArrayType >::value &&!{\b is_basic_json}< CompatibleArrayType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, const CompatibleArrayType &  {\i arr})}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4846} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleObjectType , {\b enable_if_t}< {\b is_compatible_object_type}< BasicJsonType, CompatibleObjectType >::value &&!{\b is_basic_json}< CompatibleObjectType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, const CompatibleObjectType &  {\i obj})}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4872} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleString , {\b enable_if_t}< std::is_constructible< typename BasicJsonType::string_t, CompatibleString >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, const CompatibleString &  {\i s})}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4792} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T1 , typename T2 , {\b enable_if_t}< std::is_constructible< BasicJsonType, T1 >::value &&std::is_constructible< BasicJsonType, T2 >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, const std::pair< T1, T2 > &  {\i p})}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4894} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T , {\b enable_if_t}< std::is_convertible< T, BasicJsonType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, const std::valarray< T > &  {\i arr})}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4859} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::to_json (BasicJsonType &  {\i j}, const std::vector< bool > &  {\i e})}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4833} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T , {\b enable_if_t}< std::is_same< T, {\b iteration_proxy_value}< typename BasicJsonType::iterator > >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, const T &  {\i b})}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4902} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T , std::size_t N, {\b enable_if_t}< !std::is_constructible< typename BasicJsonType::string_t, const T(&)[N]>::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, const T(&)  {\i arr}[N])}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4888} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::to_json (BasicJsonType &  {\i j}, const typename BasicJsonType::binary_t &  {\i bin})}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4852} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename EnumType , {\b enable_if_t}< std::is_enum< EnumType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, EnumType  {\i e}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4826} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename FloatType , {\b enable_if_t}< std::is_floating_point< FloatType >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, FloatType  {\i val}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4805} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T , {\b enable_if_t}< std::is_same< T, typename BasicJsonType::boolean_t >::value, int >  = 0> void nlohmann::detail::to_json (BasicJsonType &  {\i j}, T  {\i b}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4785} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::to_json (BasicJsonType &  {\i j}, typename BasicJsonType::array_t &&  {\i arr})}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4865} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::to_json (BasicJsonType &  {\i j}, typename BasicJsonType::object_t &&  {\i obj})}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4878} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void nlohmann::detail::to_json (BasicJsonType &  {\i j}, typename BasicJsonType::string_t &&  {\i s})}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4798} of file {\b json.hpp}.}\par
}
{\xe \v to_json_tuple_impl\:nlohmann::detail}
{\xe \v nlohmann::detail\:to_json_tuple_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename Tuple , std::size_t... Idx> void nlohmann::detail::to_json_tuple_impl (BasicJsonType &  {\i j}, const Tuple &  {\i t}, {\b index_sequence}< Idx... > )}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4908} of file {\b json.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::container_input_adapter_factory_impl Namespace Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::container_input_adapter_factory_impl}
{\xe \v nlohmann::detail::container_input_adapter_factory_impl}
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b container_input_adapter_factory}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::dtoa_impl Namespace Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl}
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
implements the Grisu2 algorithm for binary to decimal floating-point conversion. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b boundaries}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b cached_power}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b diyfp}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Target , typename Source > Target {\b reinterpret_bits} (const Source source)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename FloatType > {\b boundaries} {\b compute_boundaries} (FloatType value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b cached_power} {\b get_cached_power_for_binary_exponent} (int e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b find_largest_pow10} (const std::uint32_t n, std::uint32_t &pow10)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b grisu2_round} (char *buf, int len, std::uint64_t dist, std::uint64_t delta, std::uint64_t rest, std::uint64_t ten_k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b grisu2_digit_gen} (char *buffer, int &length, int &decimal_exponent, {\b diyfp} M_minus, {\b diyfp} w, {\b diyfp} M_plus)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b grisu2} (char *buf, int &len, int &decimal_exponent, {\b diyfp} m_minus, {\b diyfp} v, {\b diyfp} m_plus)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename FloatType > void {\b grisu2} (char *buf, int &len, int &decimal_exponent, FloatType value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JSON_HEDLEY_RETURNS_NON_NULL} char * {\b append_exponent} (char *buf, int e)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
appends a decimal representation of e to buf }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JSON_HEDLEY_RETURNS_NON_NULL} char * {\b format_buffer} (char *buf, int len, int decimal_exponent, int min_exp, int max_exp)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
prettify v = buf * 10^decimal_exponent }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr int {\b kAlpha} = -60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr int {\b kGamma} = -32\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
implements the Grisu2 algorithm for binary to decimal floating-point conversion. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This implementation is a slightly modified version of the reference implementation which may be obtained from {\f2 http://florian.loitsch.com/publications} (bench.tar.gz).\par
The code is distributed under the MIT license, Copyright (c) 2009 Florian Loitsch.\par
For a detailed description of the algorithm see:\par
[1] Loitsch, "Printing Floating-Point Numbers Quickly and Accurately with
    Integers", Proceedings of the ACM SIGPLAN 2010 Conference on Programming Language Design and Implementation, PLDI 2010 [2] Burger, Dybvig, "Printing Floating-Point Numbers Quickly and Accurately", Proceedings of the ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation, PLDI 1996 \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v append_exponent\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:append_exponent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JSON_HEDLEY_RETURNS_NON_NULL} char * nlohmann::detail::dtoa_impl::append_exponent (char *  {\i buf}, int  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
appends a decimal representation of e to buf }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a pointer to the element following the exponent. \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
-1000 < e < 1000 \par
}}}{
Definition at line {\b 16147} of file {\b json.hpp}.}\par
}
{\xe \v compute_boundaries\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:compute_boundaries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename FloatType > {\b boundaries} nlohmann::detail::dtoa_impl::compute_boundaries (FloatType  {\i value})}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute the (normalized) diyfp representing the input number 'value' and its boundaries.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
value must be finite and positive \par
}}}{
Definition at line {\b 15408} of file {\b json.hpp}.}\par
}
{\xe \v find_largest_pow10\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:find_largest_pow10}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nlohmann::detail::dtoa_impl::find_largest_pow10 (const std::uint32_t  {\i n}, std::uint32_t &  {\i pow10}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For n != 0, returns k, such that pow10 := 10^(k-1) <= n < 10^k. For n == 0, returns 1 and sets pow10 := 1. \par
}{
Definition at line {\b 15711} of file {\b json.hpp}.}\par
}
{\xe \v format_buffer\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:format_buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JSON_HEDLEY_RETURNS_NON_NULL} char * nlohmann::detail::dtoa_impl::format_buffer (char *  {\i buf}, int  {\i len}, int  {\i decimal_exponent}, int  {\i min_exp}, int  {\i max_exp}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
prettify v = buf * 10^decimal_exponent }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If v is in the range [10^min_exp, 10^max_exp) it will be printed in fixed-point notation. Otherwise it will be printed in exponential notation.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
min_exp < 0 \par
max_exp > 0 \par
}}}{
Definition at line {\b 16199} of file {\b json.hpp}.}\par
}
{\xe \v get_cached_power_for_binary_exponent\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:get_cached_power_for_binary_exponent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b cached_power} nlohmann::detail::dtoa_impl::get_cached_power_for_binary_exponent (int  {\i e}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For a normalized diyfp w = f * 2^e, this function returns a (normalized) cached power-of-ten c = f_c * 2^e_c, such that the exponent of the product w * c satisfies (Definition 3.2 from [1]) {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  alpha <= e_c + e + q <= gamma.\par
}
 \par
}{
Definition at line {\b 15547} of file {\b json.hpp}.}\par
}
{\xe \v grisu2\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:grisu2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nlohmann::detail::dtoa_impl::grisu2 (char *  {\i buf}, int &  {\i len}, int &  {\i decimal_exponent}, {\b diyfp}  {\i m_minus}, {\b diyfp}  {\i v}, {\b diyfp}  {\i m_plus}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
v = buf * 10^decimal_exponent len is the length of the buffer (number of decimal digits) The buffer must be large enough, i.e. >= max_digits10. \par
}{
Definition at line {\b 16047} of file {\b json.hpp}.}\par
}
{\xe \v grisu2\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:grisu2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename FloatType > void nlohmann::detail::dtoa_impl::grisu2 (char *  {\i buf}, int &  {\i len}, int &  {\i decimal_exponent}, FloatType  {\i value})}}
\par
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
v = buf * 10^decimal_exponent len is the length of the buffer (number of decimal digits) The buffer must be large enough, i.e. >= max_digits10. \par
}{
Definition at line {\b 16107} of file {\b json.hpp}.}\par
}
{\xe \v grisu2_digit_gen\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:grisu2_digit_gen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nlohmann::detail::dtoa_impl::grisu2_digit_gen (char *  {\i buffer}, int &  {\i length}, int &  {\i decimal_exponent}, {\b diyfp}  {\i M_minus}, {\b diyfp}  {\i w}, {\b diyfp}  {\i M_plus}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates V = buffer * 10^decimal_exponent, such that M- <= V <= M+. M- and M+ must be normalized and share the same exponent -60 <= e <= -32. \par
}{
Definition at line {\b 15806} of file {\b json.hpp}.}\par
}
{\xe \v grisu2_round\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:grisu2_round}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nlohmann::detail::dtoa_impl::grisu2_round (char *  {\i buf}, int  {\i len}, std::uint64_t  {\i dist}, std::uint64_t  {\i delta}, std::uint64_t  {\i rest}, std::uint64_t  {\i ten_k}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15765} of file {\b json.hpp}.}\par
}
{\xe \v reinterpret_bits\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:reinterpret_bits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Target , typename Source > Target nlohmann::detail::dtoa_impl::reinterpret_bits (const Source  {\i source})}}
\par
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15267} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v kAlpha\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:kAlpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr int nlohmann::detail::dtoa_impl::kAlpha = -60{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15530} of file {\b json.hpp}.}\par
}
{\xe \v kGamma\:nlohmann::detail::dtoa_impl}
{\xe \v nlohmann::detail::dtoa_impl\:kGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr int nlohmann::detail::dtoa_impl::kGamma = -32{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15531} of file {\b json.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::utility_internal Namespace Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::utility_internal}
{\xe \v nlohmann::detail::utility_internal}
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Extend}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Extend< integer_sequence< T, Ints... >, SeqSize, 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Extend< integer_sequence< T, Ints... >, SeqSize, 1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Gen}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Gen< T, 0 >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std Namespace Reference\par \pard\plain 
{\tc\tcl2 \v std}
{\xe \v std}
{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b hash< nlohmann::json >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
hash value for JSON objects }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b less<::nlohmann::detail::value_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b tuple_element< N, ::nlohmann::detail::iteration_proxy_value< IteratorType > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b tuple_size<::nlohmann::detail::iteration_proxy_value< IteratorType > >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<> void {\b swap< nlohmann::json >} ({\b nlohmann::json} &j1, {\b nlohmann::json} &j2) noexcept(//NOLINT(readability-inconsistent-declaration-parameter-name) is_nothrow_move_constructible< {\b nlohmann::json} >::value &&//NOLINT(misc-redundant-expression) is_nothrow_move_assignable< {\b nlohmann::json} >::value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values of two JSON objects }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v swap< nlohmann::json >\:std}
{\xe \v std\:swap< nlohmann::json >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<> void std::swap< {\b nlohmann::json} > ({\b nlohmann::json} &  {\i j1}, {\b nlohmann::json} &  {\i j2}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values of two JSON objects }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 26413} of file {\b json.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ui Namespace Reference\par \pard\plain 
{\tc\tcl2 \v Ui}
{\xe \v Ui}
{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::adl_serializer< ValueType, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::adl_serializer< ValueType, typename >}
{\xe \v nlohmann::adl_serializer< ValueType, typename >}
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
default JSONSerializer template argument }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename TargetType  = ValueType> static auto {\b from_json} (BasicJsonType &&j, TargetType &val) noexcept(noexcept(::nlohmann::from_json(std::forward< BasicJsonType >(j), val))) -> decltype(::nlohmann::from_json(std::forward< BasicJsonType >(j), val), void())\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
convert a JSON value to any value type }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename TargetType  = ValueType> static auto {\b from_json} (BasicJsonType &&j) noexcept(noexcept(::nlohmann::from_json(std::forward< BasicJsonType >(j), {\b detail::identity_tag}< TargetType > \{\}))) -> decltype(::nlohmann::from_json(std::forward< BasicJsonType >(j), {\b detail::identity_tag}< TargetType > \{\}))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
convert a JSON value to any value type }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename TargetType  = ValueType> static auto {\b to_json} (BasicJsonType &j, TargetType &&val) noexcept(noexcept(::nlohmann::to_json(j, std::forward< TargetType >(val)))) -> decltype(::nlohmann::to_json(j, std::forward< TargetType >(val)), void())\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
convert any value type to a JSON value }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename ValueType, typename>\par
struct nlohmann::adl_serializer< ValueType, typename >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
default JSONSerializer template argument \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This serializer ignores the template arguments and uses ADL ({\f2 argument-dependent lookup}) for serialization. \par
}{
Definition at line {\b 4948} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v from_json\:nlohmann::adl_serializer< ValueType, typename >}
{\xe \v nlohmann::adl_serializer< ValueType, typename >\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ValueType , typename > template<typename BasicJsonType , typename TargetType  = ValueType> static auto {\b nlohmann::adl_serializer}< ValueType, typename >::from_json (BasicJsonType &&  {\i j}) -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), {\b detail::identity_tag}<TargetType> \{\}))
    {\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
convert a JSON value to any value type }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is usually called by the {\f2 {\b get()}}  function of the {\b basic_json} class (either explicit or via conversion operators).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This function is chosen for value types which are not default-constructible.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON value to read from\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
copy of the JSON value, converted to {\i ValueType}  \par
}}}{
Definition at line {\b 4982} of file {\b json.hpp}.}\par
}
{\xe \v from_json\:nlohmann::adl_serializer< ValueType, typename >}
{\xe \v nlohmann::adl_serializer< ValueType, typename >\:from_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ValueType , typename > template<typename BasicJsonType , typename TargetType  = ValueType> static auto {\b nlohmann::adl_serializer}< ValueType, typename >::from_json (BasicJsonType &&  {\i j}, TargetType &  {\i val}) -> decltype(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())
    {\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
convert a JSON value to any value type }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is usually called by the {\f2 {\b get()}}  function of the {\b basic_json} class (either explicit or via conversion operators).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This function is chosen for default-constructible value types.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON value to read from \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i val} \cell }{value to write to \cell }
{\row }
}
}{
Definition at line {\b 4962} of file {\b json.hpp}.}\par
}
{\xe \v to_json\:nlohmann::adl_serializer< ValueType, typename >}
{\xe \v nlohmann::adl_serializer< ValueType, typename >\:to_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ValueType , typename > template<typename BasicJsonType , typename TargetType  = ValueType> static auto {\b nlohmann::adl_serializer}< ValueType, typename >::to_json (BasicJsonType &  {\i j}, TargetType &&  {\i val}) -> decltype(::nlohmann::to_json(j, std::forward<TargetType>(val)), void())
    {\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
convert any value type to a JSON value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is usually called by the constructors of the {\b basic_json} class.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i j} \cell }{JSON value to write to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{value to read from \cell }
{\row }
}
}{
Definition at line {\b 4999} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ball Class Reference\par \pard\plain 
{\tc\tcl2 \v Ball}
{\xe \v Ball}
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Ball} class creates objects of type {\b Ball}. }}\par
{
{\f2 #include <Ball.h>}}\par
Inheritance diagram for Ball:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_ball.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b moveBall} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::moveBall} moves the ball arond the playing area. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Ball} (QGraphicsItem *parent=NULL)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::Ball} constructor for {\b Ball} class creates a new ball with its required attributes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getCenterX} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::getCenterX} gets the center of the ball. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connecting} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MainWindow::connecting} method creates a new thread for constant communication with server. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addBall} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::addBall} add a new ball to the playing area. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b deleteBlk} (string type, string index)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::deleteBlk} deletes a block according to the server. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b deleteBall} (string index)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::deleteBall} deletes a block from the scene. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addDepthLevel} (QString lvl)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::addDepthLevel} adds a depth level to a specific ball. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b blkCreated} (string blkType)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::blkCreated} notyfies the server every time a block is created. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b notify} (QString str)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::notify} notify server about nickname. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Ball} class creates objects of type {\b Ball}. \par
}{
Definition at line {\b 12} of file {\b Ball.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Ball\:Ball}
{\xe \v Ball\:Ball}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Ball::Ball (QGraphicsItem *  {\i parent} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::Ball} constructor for {\b Ball} class creates a new ball with its required attributes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parent} \cell }{\cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
draw a rectangle for the ball\par
}{
Definition at line {\b 25} of file {\b Ball.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addBall\:Ball}
{\xe \v Ball\:addBall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ball::addBall ()}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::addBall} add a new ball to the playing area. }}\par
{
Definition at line {\b 458} of file {\b Ball.cpp}.}\par
}
{\xe \v addDepthLevel\:Ball}
{\xe \v Ball\:addDepthLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ball::addDepthLevel (QString  {\i lvl})}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::addDepthLevel} adds a depth level to a specific ball. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i lvl} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 534} of file {\b Ball.cpp}.}\par
}
{\xe \v blkCreated\:Ball}
{\xe \v Ball\:blkCreated}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ball::blkCreated (string  {\i blkType})}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::blkCreated} notyfies the server every time a block is created. }}\par
{
Definition at line {\b 542} of file {\b Ball.cpp}.}\par
}
{\xe \v connecting\:Ball}
{\xe \v Ball\:connecting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ball::connecting ()}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MainWindow::connecting} method creates a new thread for constant communication with server. }}\par
{
Definition at line {\b 69} of file {\b Ball.cpp}.}\par
}
{\xe \v deleteBall\:Ball}
{\xe \v Ball\:deleteBall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ball::deleteBall (string  {\i index})}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::deleteBall} deletes a block from the scene. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i index} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 518} of file {\b Ball.cpp}.}\par
}
{\xe \v deleteBlk\:Ball}
{\xe \v Ball\:deleteBlk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ball::deleteBlk (string  {\i type}, string  {\i index})}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::deleteBlk} deletes a block according to the server. }}\par
{
Definition at line {\b 465} of file {\b Ball.cpp}.}\par
}
{\xe \v getCenterX\:Ball}
{\xe \v Ball\:getCenterX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Ball::getCenterX ()}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::getCenterX} gets the center of the ball. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Double value \par
}}}{
Definition at line {\b 80} of file {\b Ball.cpp}.}\par
}
{\xe \v moveBall\:Ball}
{\xe \v Ball\:moveBall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ball::moveBall (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::moveBall} moves the ball arond the playing area. }}\par
{
Definition at line {\b 86} of file {\b Ball.cpp}.}\par
}
{\xe \v notify\:Ball}
{\xe \v Ball\:notify}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Ball::notify (QString  {\i nick})}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Ball::notify} notify server about nickname. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i nick} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 555} of file {\b Ball.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Ball.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Ball.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a class to store JSON values }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_t} = {\b detail::value_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b json_pointer} = ::{\b nlohmann::json_pointer}< {\b basic_json} >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON Pointer, see {\b nlohmann::json_pointer}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename SFINAE > using {\b json_serializer} = JSONSerializer< T, SFINAE >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b error_handler_t} = {\b detail::error_handler_t}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
how to treat decoding errors }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b cbor_tag_handler_t} = {\b detail::cbor_tag_handler_t}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
how to treat CBOR tags }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b initializer_list_t} = std::initializer_list< {\b detail::json_ref}< {\b basic_json} > >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
helper type for initializer lists of {\b basic_json} values }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b input_format_t} = {\b detail::input_format_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b json_sax_t} = {\b json_sax}< {\b basic_json} >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX interface type, see {\b nlohmann::json_sax}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b parse_event_t} = {\b detail::parse_event_t}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
parser event types }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b parser_callback_t} = {\b detail::parser_callback_t}< {\b basic_json} >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
per-element parser callback type }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JSON_HEDLEY_RETURNS_NON_NULL} const char * {\b type_name} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the type as string }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b allocator_type} {\b get_allocator} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the allocator associated with the container }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b meta} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns version information on the library }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JSON_PRIVATE_UNLESS_TESTED} {\b __pad3__}: {\b value_t} m_type = {\b value_t::null}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
json_value {\b m_value} = \{\}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the value of the current element }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b detail::value_t} > struct {\b detail::external_constructor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename InputType > class {\b ::nlohmann::detail::parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > class {\b ::nlohmann::detail::iter_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CharType > class {\b ::nlohmann::detail::binary_writer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename InputType , typename SAX > class {\b ::nlohmann::detail::binary_reader}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > class {\b ::nlohmann::detail::json_sax_dom_parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > class {\b ::nlohmann::detail::json_sax_dom_callback_parser}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ::nlohmann::detail::exception}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
exceptions\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
Classes to implement user-defined exceptions. \par
}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b exception} = {\b detail::exception}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
general exception of the {\b basic_json} class }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b parse_error} = {\b detail::parse_error}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating a parse error }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b invalid_iterator} = {\b detail::invalid_iterator}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating errors with iterators }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type_error} = {\b detail::type_error}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating executing a member function with a wrong type }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b out_of_range} = {\b detail::out_of_range}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating access out of the defined range }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b other_error} = {\b detail::other_error}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating other library errors }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
container types\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
The canonic container types to use {\b basic_json} like any other STL container. \par
}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = {\b basic_json}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of elements in a {\b basic_json} container }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reference} = {\b value_type} &\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of an element reference }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_reference} = const {\b value_type} &\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of an element const reference }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b difference_type} = std::ptrdiff_t\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type to represent differences between iterators }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b size_type} = std::size_t\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type to represent container sizes }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b allocator_type} = AllocatorType< {\b basic_json} >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the allocator type }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b pointer} = typename std::allocator_traits< {\b allocator_type} >::{\b pointer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of an element pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_pointer} = typename std::allocator_traits< {\b allocator_type} >::{\b const_pointer}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of an element const pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b iterator} = {\b iter_impl}< {\b basic_json} >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an iterator for a {\b basic_json} container }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_iterator} = {\b iter_impl}< const {\b basic_json} >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a const iterator for a {\b basic_json} container }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reverse_iterator} = {\b json_reverse_iterator}< typename {\b basic_json::iterator} >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a reverse iterator for a {\b basic_json} container }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_reverse_iterator} = {\b json_reverse_iterator}< typename {\b basic_json::const_iterator} >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a const reverse iterator for a {\b basic_json} container }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
JSON value data types\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
The data types to store a JSON value. These types are derived from the template arguments passed to class {\b basic_json}. \par
}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b object_comparator_t} = std::less< StringType >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b object_t} = ObjectType< StringType, {\b basic_json}, {\b object_comparator_t}, AllocatorType< std::pair< const StringType, {\b basic_json} > > >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for an object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b array_t} = ArrayType< {\b basic_json}, AllocatorType< {\b basic_json} > >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for an array }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b string_t} = StringType\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a string }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b boolean_t} = BooleanType\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a boolean }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_integer_t} = NumberIntegerType\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a number (integer) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_unsigned_t} = NumberUnsignedType\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a number (unsigned) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_float_t} = NumberFloatType\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a number (floating-point) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b binary_t} = {\b nlohmann::byte_container_with_subtype}< BinaryType >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a packed binary type }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
modifiers\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b reference} left, {\b reference} right) noexcept(std::is_nothrow_move_constructible< {\b value_t} >::{\b value} &&std::is_nothrow_move_assignable< {\b value_t} >::{\b value} &&std::is_nothrow_move_constructible< json_value >::{\b value} &&std::is_nothrow_move_assignable< json_value >::{\b value})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
clears the contents }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} ({\b basic_json} &&val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator+=} ({\b basic_json} &&val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} (const {\b basic_json} &val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator+=} (const {\b basic_json} &val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} (const typename object_t::value_type &val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator+=} (const typename object_t::value_type &val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} ({\b initializer_list_t} init)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator+=} ({\b initializer_list_t} init)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class... Args> {\b reference} {\b emplace_back} (Args &&... args)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class... Args> std::pair< {\b iterator}, bool > {\b emplace} (Args &&... args)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object if key does not exist }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Args> {\b iterator} {\b insert_iterator} ({\b const_iterator} pos, Args &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator} pos, const {\b basic_json} &val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator} pos, {\b basic_json} &&val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator} pos, {\b size_type} cnt, const {\b basic_json} &val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts elements }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator} pos, {\b const_iterator} first, {\b const_iterator} last)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts elements }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator} pos, {\b initializer_list_t} ilist)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts elements }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b insert} ({\b const_iterator} first, {\b const_iterator} last)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts elements }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} ({\b const_reference} j)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
updates a JSON object from another object, overwriting existing keys }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} ({\b const_iterator} first, {\b const_iterator} last)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
updates a JSON object from another object, overwriting existing keys }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b reference} other) noexcept(std::is_nothrow_move_constructible< {\b value_t} >::{\b value} &&std::is_nothrow_move_assignable< {\b value_t} >::{\b value} &&std::is_nothrow_move_constructible< json_value >::{\b value} &&std::is_nothrow_move_assignable< json_value >::{\b value})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b array_t} &other)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b object_t} &other)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b string_t} &other)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b binary_t} &other)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} (typename {\b binary_t::container_type} &other)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
lexicographical comparison operators\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b const_reference} lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator==} ({\b const_reference} lhs, ScalarType rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator==} (ScalarType lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} ({\b const_reference} lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: not equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator!=} ({\b const_reference} lhs, ScalarType rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: not equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator!=} (ScalarType lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: not equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} ({\b const_reference} lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator<} ({\b const_reference} lhs, ScalarType rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator<} (ScalarType lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} ({\b const_reference} lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than or equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator<=} ({\b const_reference} lhs, ScalarType rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than or equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator<=} (ScalarType lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than or equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} ({\b const_reference} lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator>} ({\b const_reference} lhs, ScalarType rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator>} (ScalarType lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} ({\b const_reference} lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than or equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator>=} ({\b const_reference} lhs, ScalarType rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than or equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool {\b operator>=} (ScalarType lhs, {\b const_reference} rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than or equal }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
serialization\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator<<} (std::ostream &o, const {\b basic_json} &j)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serialize to stream }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b operator>>} (const {\b basic_json} &j, std::ostream &o)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serialize to stream }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
deserialization\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::istream & {\b operator<<} ({\b basic_json} &j, std::istream &i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialize from stream }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::istream & {\b operator>>} (std::istream &i, {\b basic_json} &j)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialize from stream }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b parse} (InputType &&i, const {\b parser_callback_t} cb=nullptr, const bool allow_exceptions=true, const bool ignore_comments=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialize from a compatible input }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename IteratorType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b parse} (IteratorType first, IteratorType last, const {\b parser_callback_t} cb=nullptr, const bool allow_exceptions=true, const bool ignore_comments=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialize from a pair of character iterators }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b parse} ({\b detail::span_input_adapter} &&i, const {\b parser_callback_t} cb=nullptr, const bool allow_exceptions=true, const bool ignore_comments=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputType > static bool {\b accept} (InputType &&i, const bool ignore_comments=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
check if the input is valid JSON }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename IteratorType > static bool {\b accept} (IteratorType first, IteratorType last, const bool ignore_comments=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} bool {\b accept} ({\b detail::span_input_adapter} &&i, const bool ignore_comments=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputType , typename SAX > static bool {\b sax_parse} (InputType &&i, SAX *sax, {\b input_format_t} format={\b input_format_t::json}, const bool strict=true, const bool ignore_comments=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
generate SAX events }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class IteratorType , class SAX > static bool {\b sax_parse} (IteratorType first, IteratorType last, SAX *sax, {\b input_format_t} format={\b input_format_t::json}, const bool strict=true, const bool ignore_comments=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename SAX > static bool {\b sax_parse} ({\b detail::span_input_adapter} &&i, SAX *sax, {\b input_format_t} format={\b input_format_t::json}, const bool strict=true, const bool ignore_comments=false)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
value access\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
Direct access to the stored value of a JSON value. \par
}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename PointerType , typename std::enable_if< std::is_pointer< PointerType >::{\b value}, int >::{\b type}  = 0> auto {\b get_ptr} () noexcept -> decltype(std::declval< basic_json_t & >().get_impl_ptr(std::declval< PointerType >()))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a pointer value (implicit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename PointerType , typename std::enable_if< std::is_pointer< PointerType >::{\b value} &&std::is_const< typename std::remove_pointer< PointerType >::{\b type} >::{\b value}, int >::{\b type}  = 0> constexpr auto {\b get_ptr} () const noexcept -> decltype(std::declval< const basic_json_t & >().get_impl_ptr(std::declval< PointerType >()))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a pointer value (implicit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ValueTypeCV , typename ValueType  = detail::uncvref_t<ValueTypeCV>> auto {\b get} () const noexcept(noexcept(std::declval< const basic_json_t & >().template get_impl< ValueType >({\b detail::priority_tag}< 4 > \{\}))) -> decltype(std::declval< const basic_json_t & >().template get_impl< ValueType >({\b detail::priority_tag}< 4 > \{\}))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a (pointer) value (explicit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename PointerType , typename std::enable_if< std::is_pointer< PointerType >::{\b value}, int >::{\b type}  = 0> auto {\b get} () noexcept -> decltype(std::declval< basic_json_t & >().template {\b get_ptr}< PointerType >())\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a pointer value (explicit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ValueType , {\b detail::enable_if_t}< !{\b detail::is_basic_json}< ValueType >::{\b value} &&{\b detail::has_from_json}< basic_json_t, ValueType >::{\b value}, int >  = 0> ValueType & {\b get_to} (ValueType &v) const noexcept(noexcept(JSONSerializer< ValueType >::from_json(std::declval< const basic_json_t & >(), v)))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a value (explicit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ValueType , {\b detail::enable_if_t}< {\b detail::is_basic_json}< ValueType >::{\b value}, int >  = 0> ValueType & {\b get_to} (ValueType &v) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , std::size_t N, typename Array  = T (&)[N], {\b detail::enable_if_t}< {\b detail::has_from_json}< basic_json_t, Array >::{\b value}, int >  = 0> Array {\b get_to} (T(&v)[N]) const noexcept(noexcept(JSONSerializer< Array >::from_json(std::declval< const basic_json_t & >(), v)))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ReferenceType , typename std::enable_if< std::is_reference< ReferenceType >::{\b value}, int >::{\b type}  = 0> ReferenceType {\b get_ref} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a reference value (implicit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ReferenceType , typename std::enable_if< std::is_reference< ReferenceType >::{\b value} &&std::is_const< typename std::remove_reference< ReferenceType >::{\b type} >::{\b value}, int >::{\b type}  = 0> ReferenceType {\b get_ref} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a reference value (implicit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ValueType , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_pointer< ValueType > >, {\b detail::negation}< std::is_same< ValueType, {\b detail::json_ref}< {\b basic_json} > > >, {\b detail::negation}< std::is_same< ValueType, typename string_t::value_type > >, {\b detail::negation}< {\b detail::is_basic_json}< ValueType > >, {\b detail::negation}< std::is_same< ValueType, std::initializer_list< typename string_t::value_type > > >, {\b detail::is_detected_lazy}< {\b detail::get_template_function}, const basic_json_t &, ValueType > >::{\b value}, int >::{\b type}  = 0> {\b JSON_EXPLICIT} {\b operator ValueType} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a value (implicit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b binary_t} & {\b get_binary} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b binary_t} & {\b get_binary} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
constructors and destructors\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
Constructors of class {\b basic_json}, copy/move constructor, copy assignment, static functions creating objects, and the destructor. \par
}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b binary} (const typename {\b binary_t::container_type} &init)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create a binary array (without subtype) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b binary} (const typename {\b binary_t::container_type} &init, typename {\b binary_t::subtype_type} subtype)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create a binary array (with subtype) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b binary} (typename {\b binary_t::container_type} &&init)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create a binary array (without subtype) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b binary} (typename {\b binary_t::container_type} &&init, typename {\b binary_t::subtype_type} subtype)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create a binary array (with subtype) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b array} ({\b initializer_list_t} init=\{\})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create an array from an initializer list }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b object} ({\b initializer_list_t} init=\{\})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create an object from an initializer list }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_json} (const {\b value_t} v)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create an empty value with a given type }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_json} (std::nullptr_t=nullptr) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a null object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CompatibleType , typename U  = detail::uncvref_t<CompatibleType>, {\b detail::enable_if_t}< !{\b detail::is_basic_json}< U >::{\b value} &&{\b detail::is_compatible_type}< basic_json_t, U >::{\b value}, int >  = 0> {\b basic_json} (CompatibleType &&val) noexcept(noexcept(//NOLINT(bugprone-forwarding-{\b reference}-overload, bugprone-{\b exception}-escape) JSONSerializer< U >::to_json(std::declval< basic_json_t & >(), std::forward< CompatibleType >(val))))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , {\b detail::enable_if_t}< {\b detail::is_basic_json}< BasicJsonType >::{\b value} &&!std::is_same< {\b basic_json}, BasicJsonType >::{\b value}, int >  = 0> {\b basic_json} (const BasicJsonType &val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an existing one }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_json} ({\b initializer_list_t} init, bool type_deduction=true, {\b value_t} manual_type={\b value_t::array})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a container (array or object) from an initializer list }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_json} ({\b size_type} cnt, const {\b basic_json} &val)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
construct an array with count copies of given value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class InputIT , typename std::enable_if< std::is_same< InputIT, typename basic_json_t::iterator >::{\b value}||std::is_same< InputIT, typename basic_json_t::const_iterator >::{\b value}, int >::{\b type}  = 0> {\b basic_json} (InputIT first, InputIT last)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
construct a JSON container given an iterator range }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename JsonRef , {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::is_json_ref}< JsonRef >, std::is_same< typename JsonRef::value_type, {\b basic_json} > >::{\b value}, int >  = 0> {\b basic_json} (const JsonRef &ref)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_json} (const {\b basic_json} &other)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
copy constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_json} ({\b basic_json} &&other) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
move constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_json} & {\b operator=} ({\b basic_json} other) noexcept(std::is_nothrow_move_constructible< {\b value_t} >::{\b value} &&std::is_nothrow_move_assignable< {\b value_t} >::{\b value} &&std::is_nothrow_move_constructible< json_value >::{\b value} &&std::is_nothrow_move_assignable< json_value >::{\b value})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
copy assignment }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~basic_json} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
destructor }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
iterators\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b iteration_proxy}< {\b iterator} > {\b iterator_wrapper} ({\b reference} ref) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
wrapper to access iterator member functions in range-based for }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b iteration_proxy}< {\b const_iterator} > {\b iterator_wrapper} ({\b const_reference} ref) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
wrapper to access iterator member functions in range-based for }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b begin} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns an iterator to the first element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b begin} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const iterator to the first element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b cbegin} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const iterator to the first element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b end} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns an iterator to one past the last element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b end} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const iterator to one past the last element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b cend} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const iterator to one past the last element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reverse_iterator} {\b rbegin} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns an iterator to the reverse-beginning }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b rbegin} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const reverse iterator to the last element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reverse_iterator} {\b rend} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns an iterator to the reverse-end }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b rend} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const reverse iterator to one before the first }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b crbegin} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const reverse iterator to the last element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b crend} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const reverse iterator to one before the first }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iteration_proxy}< {\b iterator} > {\b items} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
helper to access iterator member functions in range-based for }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iteration_proxy}< {\b const_iterator} > {\b items} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
helper to access iterator member functions in range-based for }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
binary serialization/deserialization support\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::vector< std::uint8_t > {\b to_cbor} (const {\b basic_json} &j)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a CBOR serialization of a given JSON value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b to_cbor} (const {\b basic_json} &j, {\b detail::output_adapter}< std::uint8_t > o)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b to_cbor} (const {\b basic_json} &j, {\b detail::output_adapter}< char > o)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::vector< std::uint8_t > {\b to_msgpack} (const {\b basic_json} &j)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a MessagePack serialization of a given JSON value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b to_msgpack} (const {\b basic_json} &j, {\b detail::output_adapter}< std::uint8_t > o)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b to_msgpack} (const {\b basic_json} &j, {\b detail::output_adapter}< char > o)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::vector< std::uint8_t > {\b to_ubjson} (const {\b basic_json} &j, const bool use_size=false, const bool use_type=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a UBJSON serialization of a given JSON value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b to_ubjson} (const {\b basic_json} &j, {\b detail::output_adapter}< std::uint8_t > o, const bool use_size=false, const bool use_type=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b to_ubjson} (const {\b basic_json} &j, {\b detail::output_adapter}< char > o, const bool use_size=false, const bool use_type=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::vector< std::uint8_t > {\b to_bson} (const {\b basic_json} &j)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serializes the given JSON object {\f2 j}  to BSON and returns a vector containing the corresponding BSON-representation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b to_bson} (const {\b basic_json} &j, {\b detail::output_adapter}< std::uint8_t > o)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serializes the given JSON object {\f2 j}  to BSON and forwards the corresponding BSON-representation to the given output_adapter {\f2 o} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b to_bson} (const {\b basic_json} &j, {\b detail::output_adapter}< char > o)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serializes the given JSON object {\f2 j}  to BSON and forwards the corresponding BSON-representation to the given output_adapter {\f2 o} . }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_cbor} (InputType &&i, const bool strict=true, const bool allow_exceptions=true, const {\b cbor_tag_handler_t} tag_handler=cbor_tag_handler_t::error)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in CBOR format }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename IteratorType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_cbor} (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true, const {\b cbor_tag_handler_t} tag_handler=cbor_tag_handler_t::error)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in CBOR format }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_cbor} (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true, const {\b cbor_tag_handler_t} tag_handler=cbor_tag_handler_t::error)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_cbor} ({\b detail::span_input_adapter} &&i, const bool strict=true, const bool allow_exceptions=true, const {\b cbor_tag_handler_t} tag_handler=cbor_tag_handler_t::error)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_msgpack} (InputType &&i, const bool strict=true, const bool allow_exceptions=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in MessagePack format }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename IteratorType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_msgpack} (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in MessagePack format }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_msgpack} (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_msgpack} ({\b detail::span_input_adapter} &&i, const bool strict=true, const bool allow_exceptions=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_ubjson} (InputType &&i, const bool strict=true, const bool allow_exceptions=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in UBJSON format }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename IteratorType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_ubjson} (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in UBJSON format }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_ubjson} (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_ubjson} ({\b detail::span_input_adapter} &&i, const bool strict=true, const bool allow_exceptions=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_bson} (InputType &&i, const bool strict=true, const bool allow_exceptions=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a JSON value from an input in BSON format. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename IteratorType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_bson} (IteratorType first, IteratorType last, const bool strict=true, const bool allow_exceptions=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a JSON value from an input in BSON format. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_bson} (const T *ptr, std::size_t len, const bool strict=true, const bool allow_exceptions=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b from_bson} ({\b detail::span_input_adapter} &&i, const bool strict=true, const bool allow_exceptions=true)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
JSON Patch functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b diff} (const {\b basic_json} &source, const {\b basic_json} &target, const std::string &path="")\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
creates a diff as a JSON patch }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_json} {\b patch} (const {\b basic_json} &json_patch) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
applies a JSON patch }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
object inspection\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
Functions to inspect the type of a JSON value. \par
}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string_t} {\b dump} (const int indent=-1, const char indent_char=' ', const bool ensure_ascii=false, const {\b error_handler_t} error_handler=error_handler_t::strict) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serialization }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b value_t} {\b type} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the type of the JSON value (explicit) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_primitive} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether type is primitive }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_structured} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether type is structured }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_null} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is null }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_boolean} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is a boolean }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_number} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is a number }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_number_integer} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is an integer number }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_number_unsigned} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is an unsigned integer number }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_number_float} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is a floating-point number }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_object} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is an object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_array} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is an array }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_string} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is a string }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_binary} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is a binary array }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_discarded} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is discarded }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b operator value_t} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the type of the JSON value (implicit) }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
element access\par
\pard\plain 
{
\pard\plain \s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
Access to the JSON value. \par
}}

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b at} ({\b size_type} idx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified array element with bounds checking }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b at} ({\b size_type} idx) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified array element with bounds checking }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b at} (const typename object_t::key_type &key)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element with bounds checking }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b at} (const typename object_t::key_type &key) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element with bounds checking }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator[]} ({\b size_type} idx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified array element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b operator[]} ({\b size_type} idx) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified array element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator[]} (const typename object_t::key_type &key)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b operator[]} (const typename object_t::key_type &key) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
read-only access specified object element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b reference} {\b operator[]} (T *key)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b const_reference} {\b operator[]} (T *key) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
read-only access specified object element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ValueType , typename std::enable_if< {\b detail::is_getable}< basic_json_t, ValueType >::value &&!std::is_same< {\b value_t}, ValueType >::value, int >::{\b type}  = 0> ValueType {\b value} (const typename object_t::key_type &key, const ValueType &default_value) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element with default value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string_t} {\b value} (const typename object_t::key_type &key, const char *default_value) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
overload for a default value of type const char* }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class ValueType , typename std::enable_if< {\b detail::is_getable}< basic_json_t, ValueType >::value, int >::{\b type}  = 0> ValueType {\b value} (const {\b json_pointer} &ptr, const ValueType &default_value) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element via JSON Pointer with default value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string_t} {\b value} (const {\b json_pointer} &ptr, const char *default_value) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
overload for a default value of type const char* }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b front} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access the first element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b front} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access the first element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b back} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access the last element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b back} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access the last element }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class IteratorType , typename std::enable_if< std::is_same< IteratorType, typename basic_json_t::iterator >::{\b value}||std::is_same< IteratorType, typename basic_json_t::const_iterator >::{\b value}, int >::{\b type}  = 0> IteratorType {\b erase} (IteratorType pos)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove element given an iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class IteratorType , typename std::enable_if< std::is_same< IteratorType, typename basic_json_t::iterator >::{\b value}||std::is_same< IteratorType, typename basic_json_t::const_iterator >::{\b value}, int >::{\b type}  = 0> IteratorType {\b erase} (IteratorType first, IteratorType last)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove elements given an iterator range }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b size_type} {\b erase} (const typename object_t::key_type &key)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove element from a JSON object given a key }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b erase} (const {\b size_type} idx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove element from a JSON array given an index }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
lookup\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename KeyT > {\b iterator} {\b find} (KeyT &&key)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
find an element in a JSON object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename KeyT > {\b const_iterator} {\b find} (KeyT &&key) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
find an element in a JSON object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename KeyT > {\b size_type} {\b count} (KeyT &&key) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the number of occurrences of a key in a JSON object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename KeyT , typename std::enable_if< !std::is_same< typename std::decay< KeyT >::{\b type}, {\b json_pointer} >::{\b value}, int >::{\b type}  = 0> bool {\b contains} (KeyT &&key) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
check the existence of an element in a JSON object }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b contains} (const {\b json_pointer} &ptr) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
check the existence of an element in a JSON object given a JSON pointer }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
capacity\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b empty} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
checks whether the container is empty. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b size_type} {\b size} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the number of elements }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b size_type} {\b max_size} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the maximum possible number of elements }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
JSON Pointer functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator[]} (const {\b json_pointer} &ptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified element via JSON Pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b operator[]} (const {\b json_pointer} &ptr) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified element via JSON Pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b at} (const {\b json_pointer} &ptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified element via JSON Pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b at} (const {\b json_pointer} &ptr) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified element via JSON Pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_json} {\b flatten} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return flattened JSON value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_json} {\b unflatten} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
unflatten a previously flattened JSON value }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
JSON Merge Patch functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b merge_patch} (const {\b basic_json} &apply_patch)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
applies a JSON Merge Patch }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType = std::string, class BooleanType = bool, class NumberIntegerType = std::int64_t, class NumberUnsignedType = std::uint64_t, class NumberFloatType = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType = std::vector<std::uint8_t>>\par
class nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a class to store JSON values \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ObjectType} \cell }{type for JSON objects ({\f2 std::map}  by default; will be used in {\b object_t}) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ArrayType} \cell }{type for JSON arrays ({\f2 std::vector}  by default; will be used in {\b array_t}) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i StringType} \cell }{type for JSON strings and object keys ({\f2 std::string}  by default; will be used in {\b string_t}) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i BooleanType} \cell }{type for JSON booleans ({\f2 bool}  by default; will be used in {\b boolean_t}) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NumberIntegerType} \cell }{type for JSON integer numbers ({\f2 int64_t}  by default; will be used in {\b number_integer_t}) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NumberUnsignedType} \cell }{type for JSON unsigned integer numbers ({\f2 {\f2 uint64_t} }  by default; will be used in {\b number_unsigned_t}) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i NumberFloatType} \cell }{type for JSON floating-point numbers ({\f2 double}  by default; will be used in {\b number_float_t}) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i BinaryType} \cell }{type for packed binary data for compatibility with binary serialization formats ({\f2 std::vector<std::uint8_t>}  by default; will be used in {\b binary_t}) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i AllocatorType} \cell }{type of the allocator to use ({\f2 std::allocator}  by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i JSONSerializer} \cell }{the serializer to resolve internal calls to {\f2 {\b to_json()}}  and {\f2 {\b from_json()}}  ({\b adl_serializer} by default)\cell }
{\row }
}
@requirement The class satisfies the following concept requirements:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Basic{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 DefaultConstructible}: JSON values can be default constructed. The result will be a JSON null value.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 MoveConstructible}: A JSON value can be constructed from an rvalue argument.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 CopyConstructible}: A JSON value can be copy-constructed from an lvalue expression.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 MoveAssignable}: A JSON value van be assigned from an rvalue argument.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 CopyAssignable}: A JSON value can be copy-assigned from an lvalue expression.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 Destructible}: JSON values can be destructed.\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Layout{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 StandardLayoutType}: JSON values have {\f2 standard layout}: All non-static data members are private and standard layout types, the class has no virtual functions or (virtual) base classes.\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Library-wide{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 EqualityComparable}: JSON values can be compared with {\f2 ==} , see {\b operator==(const_reference,const_reference)}.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 LessThanComparable}: JSON values can be compared with {\f2 <} , see {\b operator<(const_reference,const_reference)}.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 Swappable}: Any JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of other compatible types, using unqualified function call {\b swap()}.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 NullablePointer}: JSON values can be compared against {\f2 std::nullptr_t}  objects which are used to model the {\f2 null}  value.\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Container{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 Container}: JSON values can be used like STL containers and provide iterator access.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 ReversibleContainer}; JSON values can be used like STL containers and provide reverse iterator access.\par}
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Invariant\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The member variables {\i m_value}  and {\i m_type}  have the following relationship:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If {\f2 m_type == {\b value_t::object}} , then {\f2 m_value.object != nullptr} .\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If {\f2 m_type == {\b value_t::array}} , then {\f2 m_value.array != nullptr} .\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If {\f2 m_type == {\b value_t::string}} , then {\f2 m_value.string != nullptr} . The invariants are checked by member function assert_invariant().\par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 RFC 8259: The JavaScript Object Notation (JSON) Data Interchange Format}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 17581} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v allocator_type\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:allocator_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b allocator_type} =  AllocatorType<{\b basic_json}>}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the allocator type }}\par
{
Definition at line {\b 17705} of file {\b json.hpp}.}\par
}
{\xe \v array_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:array_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b array_t} =  ArrayType<{\b basic_json}, AllocatorType<{\b basic_json}> >}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for an array }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 RFC 8259} describes JSON arrays as follows: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid An array is an ordered sequence of zero or more values. \par
}To store objects in C++, a type is defined by the template parameters explained below.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ArrayType} \cell }{container type to store arrays (e.g., {\f2 std::vector}  or {\f2 std::list} ) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i AllocatorType} \cell }{allocator to use for arrays (e.g., {\f2 std::allocator} )\cell }
{\row }
}
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Default type
\par}
{\tc\tcl4 \v Default type}
With the default values for {\i ArrayType}  ({\f2 std::vector} ) and {\i AllocatorType}  ({\f2 std::allocator} ), the default value for {\i array_t}  is:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid std::vector<\par
  basic_json, {\cf20 // value_type}\par
  std::allocator<basic_json> {\cf20 // allocator_type}\par
>\par
}
\par}
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Limits
\par}
{\tc\tcl4 \v Limits}
{\f2 RFC 8259} specifies: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid An implementation may set limits on the maximum depth of nesting. \par
}In this class, the array's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the {\b max_size} function of a JSON array.\par}
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Storage
\par}
{\tc\tcl4 \v Storage}
Arrays are stored as pointers in a {\b basic_json} type. That is, for any access to array values, a pointer of type {\f2 array_t*}  must be dereferenced.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b object_t} \'96 {\b type} for an {\b object} {\b value}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}\par}
}{
Definition at line {\b 17965} of file {\b json.hpp}.}\par
}
{\xe \v binary_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:binary_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b binary_t} =  {\b nlohmann::byte_container_with_subtype}<BinaryType>}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a packed binary type }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This type is a type designed to carry binary data that appears in various serialized formats, such as CBOR's Major Type 2, MessagePack's bin, and BSON's generic binary subtype. This type is NOT a part of standard JSON and exists solely for compatibility with these binary types. As such, it is simply defined as an ordered sequence of zero or more byte values.\par
Additionally, as an implementation detail, the subtype of the binary data is carried around as a {\f2 std::uint8_t} , which is compatible with both of the binary data formats that use binary subtyping, (though the specific numbering is incompatible with each other, and it is up to the user to translate between them).\par
{\f2 CBOR's RFC 7049} describes this type as: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Major type 2: a byte string. The string's length in bytes is represented following the rules for positive integers (major type 0). \par
}{\f2 MessagePack's documentation on the bin type family} describes this type as: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Bin format family stores an byte array in 2, 3, or 5 bytes of extra bytes in addition to the size of the byte array. \par
}{\f2 BSON's specifications} describe several binary types; however, this type is intended to represent the generic binary type which has the description: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Generic binary subtype - This is the most commonly used binary subtype and should be the 'default' for drivers and tools. \par
}None of these impose any limitations on the internal representation other than the basic unit of storage be some type of array whose parts are decomposable into bytes.\par
The default representation of this binary format is a {\f2 std::vector<std::uint8_t>} , which is a very common way to represent a byte array in modern C++.\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Default type
\par}
{\tc\tcl4 \v Default type}
The default values for {\i BinaryType}  is {\f2 std::vector<std::uint8_t>} \par}
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Storage
\par}
{\tc\tcl4 \v Storage}
Binary Arrays are stored as pointers in a {\b basic_json} type. That is, for any access to array values, a pointer of the type {\f2 binary_t*}  must be dereferenced.\par}
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Notes on subtypes
\par}
{\tc\tcl4 \v Notes on subtypes}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CBOR{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Binary values are represented as byte strings. Subtypes are serialized as tagged values.\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
MessagePack{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If a subtype is given and the binary array contains exactly 1, 2, 4, 8, or 16 elements, the fixext family (fixext1, fixext2, fixext4, fixext8) is used. For other sizes, the ext family (ext8, ext16, ext32) is used. The subtype is then added as singed 8-bit integer.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If no subtype is given, the bin family (bin8, bin16, bin32) is used.\par}
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
BSON{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If a subtype is given, it is used and added as unsigned 8-bit integer.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If no subtype is given, the generic binary subtype 0x00 is used.\par}
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see binary \'96 create a binary array\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}\par}
}{
Definition at line {\b 18326} of file {\b json.hpp}.}\par
}
{\xe \v boolean_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:boolean_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b boolean_t} =  BooleanType}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a boolean }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 RFC 8259} implicitly describes a boolean as a type which differentiates the two literals {\f2 true}  and {\f2 false} .\par
To store objects in C++, a type is defined by the template parameter {\i BooleanType}  which chooses the type to use.\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Default type
\par}
{\tc\tcl4 \v Default type}
With the default values for {\i BooleanType}  ({\f2 bool} ), the default value for {\i boolean_t}  is:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 bool}\par
}
\par}
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Storage
\par}
{\tc\tcl4 \v Storage}
Boolean values are stored directly inside a {\b basic_json} type.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}\par}
}{
Definition at line {\b 18044} of file {\b json.hpp}.}\par
}
{\xe \v cbor_tag_handler_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:cbor_tag_handler_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b cbor_tag_handler_t} =  {\b detail::cbor_tag_handler_t}}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
how to treat CBOR tags }}\par
{
Definition at line {\b 17650} of file {\b json.hpp}.}\par
}
{\xe \v const_iterator\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:const_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b const_iterator} =  {\b iter_impl}<const {\b basic_json}>}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a const iterator for a {\b basic_json} container }}\par
{
Definition at line {\b 17715} of file {\b json.hpp}.}\par
}
{\xe \v const_pointer\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:const_pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b const_pointer} =  typename std::allocator_traits<{\b allocator_type}>::{\b const_pointer}}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of an element const pointer }}\par
{
Definition at line {\b 17710} of file {\b json.hpp}.}\par
}
{\xe \v const_reference\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:const_reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b const_reference} =  const {\b value_type}&}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of an element const reference }}\par
{
Definition at line {\b 17697} of file {\b json.hpp}.}\par
}
{\xe \v const_reverse_iterator\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:const_reverse_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b const_reverse_iterator} =  {\b json_reverse_iterator}<typename {\b basic_json::const_iterator}>}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a const reverse iterator for a {\b basic_json} container }}\par
{
Definition at line {\b 17719} of file {\b json.hpp}.}\par
}
{\xe \v difference_type\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:difference_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b difference_type} =  std::ptrdiff_t}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type to represent differences between iterators }}\par
{
Definition at line {\b 17700} of file {\b json.hpp}.}\par
}
{\xe \v error_handler_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:error_handler_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b error_handler_t} =  {\b detail::error_handler_t}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
how to treat decoding errors }}\par
{
Definition at line {\b 17648} of file {\b json.hpp}.}\par
}
{\xe \v exception\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:exception}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b exception} =  {\b detail::exception}}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
general exception of the {\b basic_json} class }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is an extension of {\f2 std::exception}  objects with a member {\i id}  for exception ids. It is used as the base class for all exceptions thrown by the {\b basic_json} class. This class can hence be used as "wildcard" to catch exceptions.\par
Subclasses:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b parse_error} for exceptions indicating a parse error\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b invalid_iterator} for exceptions indicating errors with iterators\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b type_error} for exceptions indicating executing a member function with a wrong type\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b out_of_range} for exceptions indicating access out of the defined range\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b other_error} for exceptions indicating other library errors\par}
@liveexample\{The following code shows how arbitrary library exceptions can be caught.,exception\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 17667} of file {\b json.hpp}.}\par
}
{\xe \v initializer_list_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:initializer_list_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b initializer_list_t} =  std::initializer_list<{\b detail::json_ref}<{\b basic_json}> >}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
helper type for initializer lists of {\b basic_json} values }}\par
{
Definition at line {\b 17652} of file {\b json.hpp}.}\par
}
{\xe \v input_format_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:input_format_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b input_format_t} =  {\b detail::input_format_t}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17654} of file {\b json.hpp}.}\par
}
{\xe \v invalid_iterator\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:invalid_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b invalid_iterator} =  {\b detail::invalid_iterator}}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating errors with iterators }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exception is thrown if iterators passed to a library function do not match the expected semantics.\par
Exceptions have ids 2xx.\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{name / id   \cell }{example message   \cell }{description    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.201   \cell }{iterators are not compatible   \cell }{The iterators passed to constructor {\b basic_json(InputIT first, InputIT last)} are not compatible, meaning they do not belong to the same container. Therefore, the range ({\i first} , {\i last} ) is invalid.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.202   \cell }{iterator does not fit current value   \cell }{In an erase or insert function, the passed iterator {\i pos}  does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.203   \cell }{iterators do not fit current value   \cell }{Either iterator passed to function {\b erase(IteratorType first, IteratorType last)} does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.204   \cell }{iterators out of range   \cell }{When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly ({\b begin()}, {\b end()}), because this is the only way the single stored value is expressed. All other ranges are invalid.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.205   \cell }{iterator out of range   \cell }{When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the {\b begin()} iterator, because it is the only way to address the stored value. All other iterators are invalid.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.206   \cell }{cannot construct with iterators from null   \cell }{The iterators passed to constructor {\b basic_json(InputIT first, InputIT last)} belong to a JSON null value and hence to not define a valid range.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.207   \cell }{cannot use key() for non-object iterators   \cell }{The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.208   \cell }{cannot use operator[] for object iterators   \cell }{The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.209   \cell }{cannot use offsets with object iterators   \cell }{The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.210   \cell }{iterators do not fit   \cell }{The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range ({\i first} , {\i last} ) is invalid.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.211   \cell }{passed iterators may not belong to container   \cell }{The iterator range passed to the insert function must not be a subrange of the container to insert to.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.212   \cell }{cannot compare iterators of different containers   \cell }{When two iterators are compared, they must belong to the same container.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.213   \cell }{cannot compare order of object iterators   \cell }{The order of object iterators cannot be compared, because JSON objects are unordered.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.214   \cell }{cannot get value   \cell }{Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to {\b begin()}.   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
@liveexample\{The following code shows how an {\f2 invalid_iterator}  exception can be caught.,invalid_iterator\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
- {\b exception} for the base class of the library exceptions \par
- {\b parse_error} for exceptions indicating a {\b parse} error \par
- {\b type_error} for exceptions indicating executing a member function with a wrong {\b type} \par
- {\b out_of_range} for exceptions indicating access out of the defined range \par
- {\b other_error} for exceptions indicating other library errors\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 17671} of file {\b json.hpp}.}\par
}
{\xe \v iterator\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b iterator} =  {\b iter_impl}<{\b basic_json}>}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an iterator for a {\b basic_json} container }}\par
{
Definition at line {\b 17713} of file {\b json.hpp}.}\par
}
{\xe \v json_pointer\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:json_pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b json_pointer} =  ::{\b nlohmann::json_pointer}<{\b basic_json}>}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON Pointer, see {\b nlohmann::json_pointer}. }}\par
{
Definition at line {\b 17644} of file {\b json.hpp}.}\par
}
{\xe \v json_sax_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:json_sax_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b json_sax_t} =  {\b json_sax}<{\b basic_json}>}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX interface type, see {\b nlohmann::json_sax}. }}\par
{
Definition at line {\b 17656} of file {\b json.hpp}.}\par
}
{\xe \v json_serializer\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:json_serializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename T , typename SFINAE > using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b json_serializer} =  JSONSerializer<T, SFINAE>}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17646} of file {\b json.hpp}.}\par
}
{\xe \v number_float_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:number_float_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b number_float_t} =  NumberFloatType}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a number (floating-point) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 RFC 8259} describes numbers as follows: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. \par
}This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, {\b number_integer_t}, {\b number_unsigned_t} and {\b number_float_t} are used.\par
To store floating-point numbers in C++, a type is defined by the template parameter {\i NumberFloatType}  which chooses the type to use.\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Default type
\par}
{\tc\tcl4 \v Default type}
With the default values for {\i NumberFloatType}  ({\f2 double} ), the default value for {\i number_float_t}  is:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 double}\par
}
\par}
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Default behavior
\par}
{\tc\tcl4 \v Default behavior}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in floating-point literals will be ignored. Internally, the value will be stored as decimal number. For instance, the C++ floating-point literal {\f2 01.2}  will be serialized to {\f2 1.2} . During deserialization, leading zeros yield an error.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Not-a-number (NaN) values will be serialized to {\f2 null} .\par}
\par}
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Limits
\par}
{\tc\tcl4 \v Limits}
{\f2 RFC 8259} states: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754-2008 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision. \par
}This implementation does exactly follow this approach, as it uses double precision floating-point numbers. Note values smaller than {\f2 -1.79769313486232e+308}  and values greater than {\f2 1.79769313486232e+308}  will be stored as NaN internally and be serialized to {\f2 null} .\par}
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Storage
\par}
{\tc\tcl4 \v Storage}
Floating-point number values are stored directly inside a {\b basic_json} type.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b number_integer_t} \'96 {\b type} for number values (integer)\par
see {\b number_unsigned_t} \'96 {\b type} for number values (unsigned integer)\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}\par}
}{
Definition at line {\b 18255} of file {\b json.hpp}.}\par
}
{\xe \v number_integer_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:number_integer_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b number_integer_t} =  NumberIntegerType}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a number (integer) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 RFC 8259} describes numbers as follows: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. \par
}This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, {\b number_integer_t}, {\b number_unsigned_t} and {\b number_float_t} are used.\par
To store integer numbers in C++, a type is defined by the template parameter {\i NumberIntegerType}  which chooses the type to use.\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Default type
\par}
{\tc\tcl4 \v Default type}
With the default values for {\i NumberIntegerType}  ({\f2 int64_t} ), the default value for {\i number_integer_t}  is:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid int64_t\par
}
\par}
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Default behavior
\par}
{\tc\tcl4 \v Default behavior}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as octal number. Internally, the value will be stored as decimal number. For instance, the C++ integer literal {\f2 010}  will be serialized to {\f2 8} . During deserialization, leading zeros yield an error.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Not-a-number (NaN) values will be serialized to {\f2 null} .\par}
\par}
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Limits
\par}
{\tc\tcl4 \v Limits}
{\f2 RFC 8259} specifies: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid An implementation may set limits on the range and precision of numbers. \par
}When the default type is used, the maximal integer number that can be stored is {\f2 9223372036854775807}  (INT64_MAX) and the minimal integer number that can be stored is {\f2 -9223372036854775808}  (INT64_MIN). Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as {\b number_unsigned_t} or {\b number_float_t}.\par
{\f2 RFC 8259} further states: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Note that when such software is used, numbers that are integers and are in the range { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_0.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} are interoperable in the sense that implementations will agree exactly on their numeric values. \par
}As this range is a subrange of the exactly supported range [INT64_MIN, INT64_MAX], this class's integer type is interoperable.\par}
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Storage
\par}
{\tc\tcl4 \v Storage}
Integer number values are stored directly inside a {\b basic_json} type.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b number_float_t} \'96 {\b type} for number values (floating-point)\par
see {\b number_unsigned_t} \'96 {\b type} for number values (unsigned integer)\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}\par}
}{
Definition at line {\b 18116} of file {\b json.hpp}.}\par
}
{\xe \v number_unsigned_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:number_unsigned_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b number_unsigned_t} =  NumberUnsignedType}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a number (unsigned) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 RFC 8259} describes numbers as follows: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. \par
}This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, {\b number_integer_t}, {\b number_unsigned_t} and {\b number_float_t} are used.\par
To store unsigned integer numbers in C++, a type is defined by the template parameter {\i NumberUnsignedType}  which chooses the type to use.\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Default type
\par}
{\tc\tcl4 \v Default type}
With the default values for {\i NumberUnsignedType}  ({\f2 uint64_t} ), the default value for {\i number_unsigned_t}  is:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid uint64_t\par
}
\par}
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Default behavior
\par}
{\tc\tcl4 \v Default behavior}
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as octal number. Internally, the value will be stored as decimal number. For instance, the C++ integer literal {\f2 010}  will be serialized to {\f2 8} . During deserialization, leading zeros yield an error.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Not-a-number (NaN) values will be serialized to {\f2 null} .\par}
\par}
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Limits
\par}
{\tc\tcl4 \v Limits}
{\f2 RFC 8259} specifies: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid An implementation may set limits on the range and precision of numbers. \par
}When the default type is used, the maximal integer number that can be stored is {\f2 18446744073709551615}  (UINT64_MAX) and the minimal integer number that can be stored is {\f2 0} . Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as {\b number_integer_t} or {\b number_float_t}.\par
{\f2 RFC 8259} further states: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Note that when such software is used, numbers that are integers and are in the range { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_0.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} are interoperable in the sense that implementations will agree exactly on their numeric values. \par
}As this range is a subrange (when considered in conjunction with the number_integer_t type) of the exactly supported range [0, UINT64_MAX], this class's integer type is interoperable.\par}
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Storage
\par}
{\tc\tcl4 \v Storage}
Integer number values are stored directly inside a {\b basic_json} type.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b number_float_t} \'96 {\b type} for number values (floating-point) \par
see {\b number_integer_t} \'96 {\b type} for number values (integer)\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}\par}
}{
Definition at line {\b 18187} of file {\b json.hpp}.}\par
}
{\xe \v object_comparator_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:object_comparator_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b object_comparator_t} =  std::less<StringType>}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17829} of file {\b json.hpp}.}\par
}
{\xe \v object_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:object_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b object_t} =  ObjectType<StringType, {\b basic_json}, {\b object_comparator_t}, AllocatorType<std::pair<const StringType, {\b basic_json}> >>}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for an object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 RFC 8259} describes JSON objects as follows: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid An object is an unordered collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array. \par
}To store objects in C++, a type is defined by the template parameters described below.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ObjectType} \cell }{the container to store objects (e.g., {\f2 std::map}  or {\f2 std::unordered_map} ) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i StringType} \cell }{the type of the keys or names (e.g., {\f2 std::string} ). The comparison function {\f2 std::less<StringType>}  is used to order elements inside the container. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i AllocatorType} \cell }{the allocator to use for objects (e.g., {\f2 std::allocator} )\cell }
{\row }
}
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Default type
\par}
{\tc\tcl4 \v Default type}
With the default values for {\i ObjectType}  ({\f2 std::map} ), {\i StringType}  ({\f2 std::string} ), and {\i AllocatorType}  ({\f2 std::allocator} ), the default value for {\i object_t}  is:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid std::map<\par
  std::string, {\cf20 // key_type}\par
  basic_json, {\cf20 // value_type}\par
  std::less<std::string>, {\cf20 // key_compare}\par
  std::allocator<std::pair<const std::string, basic_json>> {\cf20 // allocator_type}\par
>\par
}
\par}
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Behavior
\par}
{\tc\tcl4 \v Behavior}
The choice of {\i object_t}  influences the behavior of the JSON class. With the default type, objects have the following behavior:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
When all names are unique, objects will be interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
When the names within an object are not unique, it is unspecified which one of the values for a given key will be chosen. For instance, {\f2 \{"key": 2, "key": 1\}}  could be equal to either {\f2 \{"key": 1\}}  or {\f2 \{"key": 2\}} .\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Internally, name/value pairs are stored in lexicographical order of the names. Objects will also be serialized (see {\b dump}) in this order. For instance, {\f2 \{"b": 1, "a": 2\}}  and {\f2 \{"a": 2, "b": 1\}}  will be stored and serialized as {\f2 \{"a": 2, "b": 1\}} .\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
When comparing objects, the order of the name/value pairs is irrelevant. This makes objects interoperable in the sense that they will not be affected by these differences. For instance, {\f2 \{"b": 1, "a": 2\}}  and {\f2 \{"a": 2, "b": 1\}}  will be treated as equal.\par}
\par}
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Limits
\par}
{\tc\tcl4 \v Limits}
{\f2 RFC 8259} specifies: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid An implementation may set limits on the maximum depth of nesting. \par
}In this class, the object's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the {\b max_size} function of a JSON object.\par}
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Storage
\par}
{\tc\tcl4 \v Storage}
Objects are stored as pointers in a {\b basic_json} type. That is, for any access to object values, a pointer of type {\f2 object_t*}  must be dereferenced.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b array_t} \'96 {\b type} for an array {\b value}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The order name/value pairs are added to the object is {\i not}  preserved by the library. Therefore, iterating an object may return name/value pairs in a different order than they were originally stored. In fact, keys will be traversed in alphabetical order as {\f2 std::map}  with {\f2 std::less}  is used by default. Please note this behavior conforms to {\f2 RFC 8259}, because any order implements the specified "unordered" nature of JSON objects. \par
}}\par}
}{
Definition at line {\b 17915} of file {\b json.hpp}.}\par
}
{\xe \v other_error\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:other_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b other_error} =  {\b detail::other_error}}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating other library errors }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exception is thrown in case of errors that cannot be classified with the other exception types.\par
Exceptions have ids 5xx.\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{name / id   \cell }{example message   \cell }{description    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.other_error.501   \cell }{unsuccessful: \{"op":"test","path":"/baz", "value":"bar"\}   \cell }{A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
- {\b exception} for the base class of the library exceptions \par
- {\b parse_error} for exceptions indicating a {\b parse} error \par
- {\b invalid_iterator} for exceptions indicating errors with iterators \par
- {\b type_error} for exceptions indicating executing a member function with a wrong {\b type} \par
- {\b out_of_range} for exceptions indicating access out of the defined range\par
}}@liveexample\{The following code shows how an {\f2 other_error}  exception can be caught.,other_error\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 17677} of file {\b json.hpp}.}\par
}
{\xe \v out_of_range\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:out_of_range}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b out_of_range} =  {\b detail::out_of_range}}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating access out of the defined range }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exception is thrown in case a library function is called on an input parameter that exceeds the expected range, for instance in case of array indices or nonexisting object keys.\par
Exceptions have ids 4xx.\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{name / id   \cell }{example message   \cell }{description    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.401   \cell }{array index 3 is out of range   \cell }{The provided array index {\i i}  is larger than {\i size-1} .    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.402   \cell }{array index '-' (3) is out of range   \cell }{The special array index {\f2 -}  in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.403   \cell }{key 'foo' not found   \cell }{The provided key was not found in the JSON object.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.404   \cell }{unresolved reference token 'foo'   \cell }{A reference token in a JSON Pointer could not be resolved.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.405   \cell }{JSON pointer has no parent   \cell }{The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.406   \cell }{number overflow parsing '10E1000'   \cell }{A parsed number could not be stored as without changing it to NaN or INF.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.407   \cell }{number overflow serializing '9223372036854775808'   \cell }{UBJSON and BSON only support integer numbers up to 9223372036854775807. (until version 3.8.0)    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.408   \cell }{excessive array size: 8658170730974374167   \cell }{The size (following {\f2 #} ) of an UBJSON array or object exceeds the maximal capacity.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.409   \cell }{BSON key cannot contain code point U+0000 (at byte 2)   \cell }{Key identifiers to be serialized to BSON cannot contain code point U+0000, since the key is stored as zero-terminated c-string   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
@liveexample\{The following code shows how an {\f2 out_of_range}  exception can be caught.,out_of_range\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
- {\b exception} for the base class of the library exceptions \par
- {\b parse_error} for exceptions indicating a {\b parse} error \par
- {\b invalid_iterator} for exceptions indicating errors with iterators \par
- {\b type_error} for exceptions indicating executing a member function with a wrong {\b type} \par
- {\b other_error} for exceptions indicating other library errors\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 17675} of file {\b json.hpp}.}\par
}
{\xe \v parse_error\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:parse_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b parse_error} =  {\b detail::parse_error}}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating a parse error }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exception is thrown by the library when a parse error occurs. Parse errors can occur during the deserialization of JSON text, CBOR, MessagePack, as well as when using JSON Patch.\par
Member {\i byte}  holds the byte index of the last read character in the input file.\par
Exceptions have ids 1xx.\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{name / id   \cell }{example message   \cell }{description    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.101   \cell }{parse error at 2: unexpected end of input; expected string literal   \cell }{This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member {\i byte}  indicates the error position.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.102   \cell }{parse error at 14: missing or wrong low surrogate   \cell }{JSON uses the {\f2 \\uxxxx}  format to describe Unicode characters. Code points above above 0xFFFF are split into two {\f2 \\uxxxx}  entries ("surrogate pairs"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.103   \cell }{parse error: code points above 0x10FFFF are invalid   \cell }{Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.104   \cell }{parse error: JSON patch must be an array of objects   \cell }{{\f2 RFC 6902} requires a JSON Patch document to be a JSON document that represents an array of objects.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.105   \cell }{parse error: operation must have string member 'op'   \cell }{An operation of a JSON Patch document must contain exactly one "op" member, whose value indicates the operation to perform. Its value must be one of "add", "remove", "replace", "move", "copy", or "test"; other values are errors.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.106   \cell }{parse error: array index '01' must not begin with '0'   \cell }{An array index in a JSON Pointer ({\f2 RFC 6901}) may be {\f2 0}  or any number without a leading {\f2 0} .    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.107   \cell }{parse error: JSON pointer must be empty or begin with '/' - was: 'foo'   \cell }{A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a {\f2 /}  character.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.108   \cell }{parse error: escape character '~' must be followed with '0' or '1'   \cell }{In a JSON Pointer, only {\f2 ~0}  and {\f2 ~1}  are valid escape sequences.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.109   \cell }{parse error: array index 'one' is not a number   \cell }{A JSON Pointer array index must be a number.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.110   \cell }{parse error at 1: cannot read 2 bytes from vector   \cell }{When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.112   \cell }{parse error at 1: error reading CBOR; last byte: 0xF8   \cell }{Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.113   \cell }{parse error at 2: expected a CBOR string; last byte: 0x98   \cell }{While parsing a map key, a value that is not a string has been read.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.114   \cell }{parse error: Unsupported BSON record type 0x0F   \cell }{The parsing of the corresponding BSON record type is not implemented (yet).    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.115   \cell }{parse error at byte 5: syntax error while parsing UBJSON high-precision number: invalid number text: 1A   \cell }{A UBJSON high-precision number could not be parsed.   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
For an input with n bytes, 1 is the index of the first character and n+1 is the index of the terminating null byte or the end of file. This also holds true when reading a byte vector (CBOR or MessagePack).\par
}}@liveexample\{The following code shows how a {\f2 parse_error}  exception can be caught.,parse_error\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
- {\b exception} for the base class of the library exceptions \par
- {\b invalid_iterator} for exceptions indicating errors with iterators \par
- {\b type_error} for exceptions indicating executing a member function with a wrong {\b type} \par
- {\b out_of_range} for exceptions indicating access out of the defined range \par
- {\b other_error} for exceptions indicating other library errors\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 17669} of file {\b json.hpp}.}\par
}
{\xe \v parse_event_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:parse_event_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b parse_event_t} =  {\b detail::parse_event_t}}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
parser event types }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parser callback distinguishes the following events:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 object_start} : the parser read {\f2 \{}  and started to process a JSON object\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 key} : the parser read a key of a value in an object\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 object_end} : the parser read {\f2 \}}  and finished processing a JSON object\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 array_start} : the parser read {\f2 [}  and started to process a JSON array\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 array_end} : the parser read {\f2 ]}  and finished processing a JSON array\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 value} : the parser finished reading a JSON value\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b parser_callback_t} for more information and examples \par
}}}{
Definition at line {\b 18787} of file {\b json.hpp}.}\par
}
{\xe \v parser_callback_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:parser_callback_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b parser_callback_t} =  {\b detail::parser_callback_t}<{\b basic_json}>}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
per-element parser callback type }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
With a parser callback function, the result of parsing a JSON text can be influenced. When passed to {\b parse}, it is called on certain events (passed as {\b parse_event_t} via parameter {\i event} ) with a set recursion depth {\i depth}  and context JSON value {\i parsed} . The return value of the callback function is a boolean indicating whether the element that emitted the callback shall be kept or not.\par
We distinguish six scenarios (determined by the event type) in which the callback function can be called. The following table describes the values of the parameters {\i depth} , {\i event} , and {\i parsed} .\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{parameter {\i event}    \cell }{description   \cell }{parameter {\i depth}    \cell }{parameter {\i parsed}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{parse_event_t::object_start   \cell }{the parser read {\f2 \{}  and started to process a JSON object   \cell }{depth of the parent of the JSON object   \cell }{a JSON value with type discarded    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b parse_event_t::key}   \cell }{the parser read a key of a value in an object   \cell }{depth of the currently parsed JSON object   \cell }{a JSON string containing the key    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{parse_event_t::object_end   \cell }{the parser read {\f2 \}}  and finished processing a JSON object   \cell }{depth of the parent of the JSON object   \cell }{the parsed JSON object    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{parse_event_t::array_start   \cell }{the parser read {\f2 [}  and started to process a JSON array   \cell }{depth of the parent of the JSON array   \cell }{a JSON value with type discarded    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{parse_event_t::array_end   \cell }{the parser read {\f2 ]}  and finished processing a JSON array   \cell }{depth of the parent of the JSON array   \cell }{the parsed JSON array    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\b parse_event_t::value}   \cell }{the parser finished reading a JSON value   \cell }{depth of the value   \cell }{the parsed JSON value   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
Discarding a value (i.e., returning {\f2 false} ) has different effects depending on the context in which function was called:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Discarded values in structured types are skipped. That is, the parser will behave as if the discarded value was never read.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In case a value outside a structured type is skipped, it is replaced with {\f2 null} . This case happens if the top-level element is skipped.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i depth} \cell }{the depth of the recursion during parsing\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i event} \cell }{an event of type parse_event_t indicating the context in the callback function has been called\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i parsed} \cell }{the current intermediate parse result; note that writing to this value has no effect for {\b parse_event_t::key} events\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether the JSON value which called the function during parsing should be kept ({\f2 true} ) or not ({\f2 false} ). In the latter case, it is either skipped completely or replaced by an empty discarded object.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b parse} for examples\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 18838} of file {\b json.hpp}.}\par
}
{\xe \v pointer\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b pointer} =  typename std::allocator_traits<{\b allocator_type}>::{\b pointer}}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of an element pointer }}\par
{
Definition at line {\b 17708} of file {\b json.hpp}.}\par
}
{\xe \v reference\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b reference} =  {\b value_type}&}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of an element reference }}\par
{
Definition at line {\b 17695} of file {\b json.hpp}.}\par
}
{\xe \v reverse_iterator\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:reverse_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b reverse_iterator} =  {\b json_reverse_iterator}<typename {\b basic_json::iterator}>}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a reverse iterator for a {\b basic_json} container }}\par
{
Definition at line {\b 17717} of file {\b json.hpp}.}\par
}
{\xe \v size_type\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:size_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b size_type} =  std::size_t}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type to represent container sizes }}\par
{
Definition at line {\b 17702} of file {\b json.hpp}.}\par
}
{\xe \v string_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:string_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b string_t} =  StringType}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type for a string }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 RFC 8259} describes JSON strings as follows: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid A string is a sequence of zero or more Unicode characters. \par
}To store objects in C++, a type is defined by the template parameter described below. Unicode values are split by the JSON class into byte-sized characters during deserialization.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i StringType} \cell }{the container to store strings (e.g., {\f2 std::string} ). Note this container is used for keys/names in objects, see {\b object_t}.\cell }
{\row }
}
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Default type
\par}
{\tc\tcl4 \v Default type}
With the default values for {\i StringType}  ({\f2 std::string} ), the default value for {\i string_t}  is:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid std::string\par
}
\par}
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Encoding
\par}
{\tc\tcl4 \v Encoding}
Strings are stored in UTF-8 encoding. Therefore, functions like {\f2 std::string::size()}  or {\f2 std::string::length()}  return the number of bytes in the string rather than the number of characters or glyphs.\par}
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
String comparison
\par}
{\tc\tcl4 \v String comparison}
{\f2 RFC 8259} states: \par
{\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid Software implementations are typically required to test names of object members for equality. Implementations that transform the textual representation into sequences of Unicode code units and then perform the comparison numerically, code unit by code unit, are interoperable in the sense that implementations will agree in all cases on equality or inequality of two strings. For example, implementations that compare strings with escaped characters unconverted may incorrectly find that {\f2 "a\\\\b"}  and {\f2 "a\\u005Cb"}  are not equal. \par
}This implementation is interoperable as it does compare strings code unit by code unit.\par}
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{{\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Storage
\par}
{\tc\tcl4 \v Storage}
String values are stored as pointers in a {\b basic_json} type. That is, for any access to string values, a pointer of type {\f2 string_t*}  must be dereferenced.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}\par}
}{
Definition at line {\b 18018} of file {\b json.hpp}.}\par
}
{\xe \v type_error\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:type_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b type_error} =  {\b detail::type_error}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating executing a member function with a wrong type }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exception is thrown in case of a type error; that is, a library function is executed on a JSON value whose type does not match the expected semantics.\par
Exceptions have ids 3xx.\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{name / id   \cell }{example message   \cell }{description    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.301   \cell }{cannot create object from initializer list   \cell }{To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.302   \cell }{type must be object, but is array   \cell }{During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.303   \cell }{incompatible ReferenceType for get_ref, actual type is object   \cell }{To retrieve a reference to a value stored in a {\b basic_json} object with {\b get_ref}, the type of the reference must match the value type. For instance, for a JSON array, the {\i ReferenceType}  must be {\b array_t} &.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.304   \cell }{cannot use {\b at()} with string   \cell }{The {\b at()} member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.305   \cell }{cannot use operator[] with string   \cell }{The {\b operator[]} member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.306   \cell }{cannot use {\b value()} with string   \cell }{The {\b value()} member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.307   \cell }{cannot use {\b erase()} with string   \cell }{The {\b erase()} member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.308   \cell }{cannot use {\b push_back()} with string   \cell }{The {\b push_back()} and {\b operator+=} member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.309   \cell }{cannot use {\b insert()} with   \cell }{The {\b insert()} member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.310   \cell }{cannot use {\b swap()} with number   \cell }{The {\b swap()} member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.311   \cell }{cannot use {\b emplace_back()} with string   \cell }{The {\b emplace_back()} member function can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.312   \cell }{cannot use {\b update()} with string   \cell }{The {\b update()} member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.313   \cell }{invalid value to unflatten   \cell }{The {\b unflatten} function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.314   \cell }{only objects can be unflattened   \cell }{The {\b unflatten} function only works for an object whose keys are JSON Pointers.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.315   \cell }{values in object must be primitive   \cell }{The {\b unflatten} function only works for an object whose keys are JSON Pointers and whose values are primitive.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.316   \cell }{invalid UTF-8 byte at index 10: 0x7E   \cell }{The {\b dump} function only works with UTF-8 encoded strings; that is, if you assign a {\f2 std::string}  to a JSON value, make sure it is UTF-8 encoded.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.317   \cell }{JSON value cannot be serialized to requested format   \cell }{The dynamic type of the object cannot be represented in the requested serialization format (e.g. a raw {\f2 true}  or {\f2 null}  JSON object cannot be serialized to BSON)   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
@liveexample\{The following code shows how a {\f2 type_error}  exception can be caught.,type_error\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
- {\b exception} for the base class of the library exceptions \par
- {\b parse_error} for exceptions indicating a {\b parse} error \par
- {\b invalid_iterator} for exceptions indicating errors with iterators \par
- {\b out_of_range} for exceptions indicating access out of the defined range \par
- {\b other_error} for exceptions indicating other library errors\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 17673} of file {\b json.hpp}.}\par
}
{\xe \v value_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:value_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b value_t} =  {\b detail::value_t}}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17642} of file {\b json.hpp}.}\par
}
{\xe \v value_type\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> using {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b value_type} =  {\b basic_json}}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of elements in a {\b basic_json} container }}\par
{
Definition at line {\b 17692} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v basic_json\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b basic_json} (const {\b value_t}  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create an empty value with a given type }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create an empty JSON value with a given type. The value will be default initialized with an empty value which depends on the type:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Value type   \cell }{initial value    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 null}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 false}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\f2 ""}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number   \cell }{{\f2 0}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\f2 \{\}}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\f2 []}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{empty array   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i v} \cell }{the type of the value to create\cell }
{\row }
}
@complexity Constant.\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
@liveexample\{The following code shows the constructor for different {\b value_t} values,basic_json__value_t\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b clear()} \'96 restores the postcondition of this constructor\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 18879} of file {\b json.hpp}.}\par
}
{\xe \v basic_json\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b basic_json} (std::nullptr_t  = {\f2 nullptr}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a null object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a {\f2 null}  JSON value. It either takes a null pointer as parameter (explicitly creating {\f2 null} ) or no parameter (implicitly creating {\f2 null} ). The passed null pointer itself is not read \'96 it is only used to choose the right constructor.\par
@complexity Constant.\par
@exceptionsafety No-throw guarantee: this constructor never throws exceptions.\par
@liveexample\{The following code shows the constructor with and without a null pointer parameter.,basic_json__nullptr_t\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 18903} of file {\b json.hpp}.}\par
}
{\xe \v basic_json\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename CompatibleType , typename U  = detail::uncvref_t<CompatibleType>, {\b detail::enable_if_t}< !{\b detail::is_basic_json}< U >::{\b value} &&{\b detail::is_compatible_type}< basic_json_t, U >::{\b value}, int >  = 0> {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b basic_json} (CompatibleType &&  {\i val}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a "catch all" constructor for all compatible JSON types; that is, types for which a {\f2 {\b to_json()}}  method exists. The constructor forwards the parameter {\i val}  to that method (to {\f2 json_serializer<U>::to_json}  method with {\f2 U = uncvref_t<CompatibleType>} , to be exact).\par
Template type {\i CompatibleType}  includes, but is not limited to, the following types:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b arrays} : {\b array_t} and all kinds of compatible containers such as {\f2 std::vector} , {\f2 std::deque} , {\f2 std::list} , {\f2 std::forward_list} , {\f2 std::array} , {\f2 std::valarray} , {\f2 std::set} , {\f2 std::unordered_set} , {\f2 std::multiset} , and {\f2 std::unordered_multiset}  with a {\f2 value_type}  from which a {\b basic_json} value can be constructed.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b objects} : {\b object_t} and all kinds of compatible associative containers such as {\f2 std::map} , {\f2 std::unordered_map} , {\f2 std::multimap} , and {\f2 std::unordered_multimap}  with a {\f2 key_type}  compatible to {\b string_t} and a {\f2 value_type}  from which a {\b basic_json} value can be constructed.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b strings} : {\b string_t}, string literals, and all compatible string containers can be used.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b numbers} : {\b number_integer_t}, {\b number_unsigned_t}, {\b number_float_t}, and all convertible number types such as {\f2 int} , {\f2 size_t} , {\f2 int64_t} , {\f2 float}  or {\f2 double}  can be used.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} : {\b boolean_t} / {\f2 bool}  can be used.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b binary} : {\b binary_t} / {\f2 std::vector<std::uint8_t>}  may be used, unfortunately because string literals cannot be distinguished from binary character arrays by the C++ type system, all types compatible with {\f2 const char*}  will be directed to the string constructor instead. This is both for backwards compatibility, and due to the fact that a binary type is not a standard JSON type.\par}
See the examples below.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CompatibleType} \cell }{a type such that:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i CompatibleType}  is not derived from {\f2 std::istream} ,\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i CompatibleType}  is not {\b basic_json} (to avoid hijacking copy/move constructors),\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i CompatibleType}  is not a different {\b basic_json} type (i.e. with different template arguments)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i CompatibleType}  is not a {\b basic_json} nested type (e.g., {\b json_pointer}, {\b iterator}, etc ...)\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 json_serializer<U>}  has a {\f2 to_json(basic_json_t&, CompatibleType&&)}  method\par}
\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i U} \cell }{= {\f2 uncvref_t<CompatibleType>} \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{the value to be forwarded to the respective constructor\cell }
{\row }
}
@complexity Usually linear in the size of the passed {\i val} , also depending on the implementation of the called {\f2 {\b to_json()}}  method.\par
@exceptionsafety Depends on the called constructor. For types directly supported by the library (i.e., all types for which no {\f2 {\b to_json()}}  function was provided), strong guarantee holds: if an exception is thrown, there are no changes to any JSON value.\par
@liveexample\{The following code shows the constructor with several compatible types.,basic_json__CompatibleType\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.1.0 \par
}}}{
Definition at line {\b 18975} of file {\b json.hpp}.}\par
}
{\xe \v basic_json\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename BasicJsonType , {\b detail::enable_if_t}< {\b detail::is_basic_json}< BasicJsonType >::{\b value} &&!std::is_same< {\b basic_json}, BasicJsonType >::{\b value}, int >  = 0> {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b basic_json} (const BasicJsonType &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an existing one }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is a constructor for existing {\b basic_json} types. It does not hijack copy/move constructors, since the parameter has different template arguments than the current ones.\par
The constructor tries to convert the internal {\b m_value} of the parameter.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i BasicJsonType} \cell }{a type such that:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i BasicJsonType}  is a {\b basic_json} type.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i BasicJsonType}  has different template arguments than basic_json_t.\par}
\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{the {\b basic_json} value to be converted.\cell }
{\row }
}
@complexity Usually linear in the size of the passed {\i val} , also depending on the implementation of the called {\f2 {\b to_json()}}  method.\par
@exceptionsafety Depends on the called constructor. For types directly supported by the library (i.e., all types for which no {\f2 {\b to_json()}}  function was provided), strong guarantee holds: if an exception is thrown, there are no changes to any JSON value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.2.0 \par
}}}{
Definition at line {\b 19013} of file {\b json.hpp}.}\par
}
{\xe \v basic_json\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b basic_json} ({\b initializer_list_t}  {\i init}, bool  {\i type_deduction} = {\f2 true}, {\b value_t}  {\i manual_type} = {\f2 {\b value_t::array}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a container (array or object) from an initializer list }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a JSON value of type array or object from the passed initializer list {\i init} . In case {\i type_deduction}  is {\f2 true}  (default), the type of the JSON value to be created is deducted from the initializer list {\i init}  according to the following rules:\par
{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab If the list is empty, an empty JSON object value {\f2 \{\}}  is created.\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab If the list consists of pairs whose first element is a string, a JSON object value is created where the first elements of the pairs are treated as keys and the second elements are as values.\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab In all other cases, an array is created.\par}
The rules aim to create the best fit between a C++ initializer list and JSON values. The rationale is as follows:\par
{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab The empty initializer list is written as {\f2 \{\}}  which is exactly an empty JSON object.\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab C++ has no way of describing mapped types other than to list a list of pairs. As JSON requires that keys must be of type string, rule 2 is the weakest constraint one can pose on initializer lists to interpret them as an object.\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab In all other cases, the initializer list could not be interpreted as JSON object type, so interpreting it as JSON array type is safe.\par}
With the rules described above, the following JSON values cannot be expressed by an initializer list:\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
the empty array ({\f2 []} ): use {\b array(initializer_list_t)} with an empty initializer list in this case\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
arrays whose elements satisfy rule 2: use {\b array(initializer_list_t)} with the same initializer list in this case\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
When used without parentheses around an empty initializer list, {\b basic_json()} is called instead of this function, yielding the JSON null value.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i init} \cell }{initializer list with JSON values\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i type_deduction} \cell }{internal parameter; when set to {\f2 true} , the type of the JSON value is deducted from the initializer list {\i init} ; when set to {\f2 false} , the type provided via {\i manual_type}  is forced. This mode is used by the functions {\b array(initializer_list_t)} and {\b object(initializer_list_t)}.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i manual_type} \cell }{internal parameter; when {\i type_deduction}  is set to {\f2 false} , the created JSON value will use the provided type (only {\b value_t::array} and {\b value_t::object} are valid); when {\i type_deduction}  is set to {\f2 true} , this parameter has no effect\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.301} \cell }{if {\i type_deduction}  is {\f2 false} , {\i manual_type}  is {\f2 {\b value_t::object}} , but {\i init}  contains an element which is not a pair whose first element is a string. In this case, the constructor could not create an object. If {\i type_deduction}  would have be {\f2 true} , an array would have been created. See {\b object(initializer_list_t)} for an example.\cell }
{\row }
}
@complexity Linear in the size of the initializer list {\i init} .\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
@liveexample\{The example below shows how JSON values are created from initializer lists.,basic_json__list_init_t\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b array(initializer_list_t)} \'96 create a JSON array {\b value} from an initializer list \par
see {\b object(initializer_list_t)} \'96 create a JSON {\b object} {\b value} from an initializer list\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19137} of file {\b json.hpp}.}\par
}
{\xe \v basic_json\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b basic_json} ({\b size_type}  {\i cnt}, const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
construct an array with count copies of given value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs a JSON array value by creating {\i cnt}  copies of a passed value. In case {\i cnt}  is {\f2 0} , an empty array is created.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cnt} \cell }{the number of JSON copies of {\i val}  to create \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{the JSON value to copy\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 std::distance({\b begin()},{\b end()}) == cnt}  holds.\par
}}@complexity Linear in {\i cnt} .\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
@liveexample\{The following code shows examples for the {\b basic_json}(size_type\\, const {\b basic_json}&) constructor.,basic_json__size_type_basic_json\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19392} of file {\b json.hpp}.}\par
}
{\xe \v basic_json\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<class InputIT , typename std::enable_if< std::is_same< InputIT, typename basic_json_t::iterator >::{\b value}||std::is_same< InputIT, typename basic_json_t::const_iterator >::{\b value}, int >::{\b type}  = 0> {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b basic_json} (InputIT  {\i first}, InputIT  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
construct a JSON container given an iterator range }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs the JSON value with the contents of the range {\f2 [first, last)} . The semantics depends on the different types a JSON value can have:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In case of a null type, invalid_iterator.206 is thrown.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In case of other primitive types (number, boolean, or string), {\i first}  must be {\f2 {\b begin()}}  and {\i last}  must be {\f2 {\b end()}} . In this case, the value is copied. Otherwise, invalid_iterator.204 is thrown.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In case of structured types (array, object), the constructor behaves as similar versions for {\f2 std::vector}  or {\f2 std::map} ; that is, a JSON array or object is constructed from the values in the range.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i InputIT} \cell }{an input iterator type ({\b iterator} or {\b const_iterator})\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i first} \cell }{begin of the range to copy from (included) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i last} \cell }{end of the range to copy from (excluded)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Iterators {\i first}  and {\i last}  must be initialized. {\b This precondition is enforced with an assertion (see warning).}  If assertions are switched off, a violation of this precondition yields undefined behavior.\par
Range {\f2 [first, last)}  is valid. Usually, this precondition cannot be checked efficiently. Only certain edge cases are detected; see the description of the exceptions below. A violation of this precondition yields undefined behavior.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A precondition is enforced with a runtime assertion that will result in calling {\f2 std::abort}  if this precondition is not met. Assertions can be disabled by defining {\f2 NDEBUG}  at compile time. See {\f2 https://en.cppreference.com/w/cpp/error/assert} for more information.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.201} \cell }{if iterators {\i first}  and {\i last}  are not compatible (i.e., do not belong to the same JSON value). In this case, the range {\f2 [first, last)}  is undefined. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.204} \cell }{if iterators {\i first}  and {\i last}  belong to a primitive type (number, boolean, or string), but {\i first}  does not point to the first element any more. In this case, the range {\f2 [first, last)}  is undefined. See example code below. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.206} \cell }{if iterators {\i first}  and {\i last}  belong to a null value. In this case, the range {\f2 [first, last)}  is undefined.\cell }
{\row }
}
@complexity Linear in distance between {\i first}  and {\i last} .\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
@liveexample\{The example below shows several ways to create JSON values by specifying a subrange with iterators.,basic_json__InputIt_InputIt\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19458} of file {\b json.hpp}.}\par
}
{\xe \v basic_json\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename JsonRef , {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::is_json_ref}< JsonRef >, std::is_same< typename JsonRef::value_type, {\b basic_json} > >::{\b value}, int >  = 0> {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b basic_json} (const JsonRef &  {\i ref}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19568} of file {\b json.hpp}.}\par
}
{\xe \v basic_json\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b basic_json} (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
copy constructor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a copy of a given JSON value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i other} \cell }{the JSON value to copy\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 *this == other} \par
}}@complexity Linear in the size of {\i other} .\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is linear.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
As postcondition, it holds: {\f2 other == basic_json(other)} .\par}
@liveexample\{The following code shows an example for the copy constructor.,basic_json__basic_json\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19595} of file {\b json.hpp}.}\par
}
{\xe \v basic_json\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::{\b basic_json} ({\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &&  {\i other}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
move constructor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Move constructor. Constructs a JSON value with the contents of the given value {\i other}  using move semantics. It "steals" the resources from {\i other}  and leaves it as JSON null value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i other} \cell }{value to move to this object\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 *this}  has the same value as {\i other}  before the call. \par
{\i other}  is a JSON null value.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this constructor never throws exceptions.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 MoveConstructible} requirements.\par
@liveexample\{The code below shows the move constructor explicitly called via std::move.,basic_json__moveconstructor\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19687} of file {\b json.hpp}.}\par
}
{\xe \v ~basic_json\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:~basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::~{\b basic_json} (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
destructor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Destroys the JSON value and frees all allocated memory.\par
@complexity Linear.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is linear.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
All stored elements are destroyed and all memory is freed.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19759} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v accept\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::accept ({\b detail::span_input_adapter} &&  {\i i}, const bool  {\i ignore_comments} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24393} of file {\b json.hpp}.}\par
}
{\xe \v accept\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename InputType > static bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::accept (InputType &&  {\i i}, const bool  {\i ignore_comments} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
check if the input is valid JSON }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Unlike the parse(InputType&&, const parser_callback_t,const bool) function, this function neither throws an exception in case of invalid JSON input (i.e., a parse error) nor creates diagnostic information.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i InputType} \cell }{A compatible input, for instance{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
an std::istream object\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
a FILE pointer\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
a C-style array of characters\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
a pointer to a null-terminated string of single byte characters\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
an object obj for which begin(obj) and end(obj) produces a valid pair of iterators.\par}
\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{input to read from \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ignore_comments} \cell }{whether comments should be ignored and treated like whitespace (true) or yield a parse error (true); (optional, false by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Whether the input read from {\i i}  is valid JSON.\par
}}@complexity Linear in the length of the input. The parser is a predictive LL(1) parser.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A UTF-8 byte order mark is silently ignored.\par
}}@liveexample\{The example below demonstrates the {\f2 {\b accept()}}  function reading from a string.,accept__string\} \par
}{
Definition at line {\b 24378} of file {\b json.hpp}.}\par
}
{\xe \v accept\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename IteratorType > static bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::accept (IteratorType  {\i first}, IteratorType  {\i last}, const bool  {\i ignore_comments} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24385} of file {\b json.hpp}.}\par
}
{\xe \v array\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::array ({\b initializer_list_t}  {\i init} = {\f2 \{\}}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create an array from an initializer list }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a JSON array value from a given initializer list. That is, given a list of values {\f2 a, b, c} , creates the JSON value {\f2 [a, b, c]} . If the initializer list is empty, the empty array {\f2 []}  is created.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This function is only needed to express two edge cases that cannot be realized with the initializer list constructor ({\b basic_json(initializer_list_t, bool, value_t)}). These cases are:{
\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab creating an array whose elements are all pairs whose first element is a string \'96 in this case, the initializer list constructor would create an object, taking the first elements as keys\par
\pard\plain \s142\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab creating an empty array \'96 passing the empty initializer list to the initializer list constructor yields an empty object\par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i init} \cell }{initializer list with JSON values to create an array from (optional)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
JSON array value\par
}}@complexity Linear in the size of {\i init} .\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
@liveexample\{The following code shows an example for the {\f2 array}  function.,array\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b basic_json(initializer_list_t, bool, value_t)} \'96 create a JSON {\b value} from an initializer list \par
see {\b object(initializer_list_t)} \'96 create a JSON {\b object} {\b value} from an initializer list\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19321} of file {\b json.hpp}.}\par
}
{\xe \v at\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::at (const {\b json_pointer} &  {\i ptr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified element via JSON Pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the element at with specified JSON pointer {\i ptr} , with bounds checking.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ptr} \cell }{JSON pointer to the desired element\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the element pointed to by {\i ptr}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.106} \cell }{if an array index in the passed JSON pointer {\i ptr}  begins with '0'. See example below.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.109} \cell }{if an array index in the passed JSON pointer {\i ptr}  is not a number. See example below.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.401} \cell }{if an array index in the passed JSON pointer {\i ptr}  is out of range. See example below.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.402} \cell }{if the array index '-' is used in the passed JSON pointer {\i ptr} . As {\f2 at}  provides checked access (and no elements are implicitly inserted), the index '-' is always invalid. See example below.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.403} \cell }{if the JSON pointer describes a key of an object which cannot be found. See example below.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.404} \cell }{if the JSON pointer {\i ptr}  can not be resolved. See example below.\cell }
{\row }
}
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes in the JSON value.\par
@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0\par
}}@liveexample\{The behavior is shown in the example.,at_json_pointer\} \par
}{
Definition at line {\b 25662} of file {\b json.hpp}.}\par
}
{\xe \v at\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::at (const {\b json_pointer} &  {\i ptr}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified element via JSON Pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const reference to the element at with specified JSON pointer {\i ptr} , with bounds checking.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ptr} \cell }{JSON pointer to the desired element\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the element pointed to by {\i ptr}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.106} \cell }{if an array index in the passed JSON pointer {\i ptr}  begins with '0'. See example below.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.109} \cell }{if an array index in the passed JSON pointer {\i ptr}  is not a number. See example below.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.401} \cell }{if an array index in the passed JSON pointer {\i ptr}  is out of range. See example below.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.402} \cell }{if the array index '-' is used in the passed JSON pointer {\i ptr} . As {\f2 at}  provides checked access (and no elements are implicitly inserted), the index '-' is always invalid. See example below.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.403} \cell }{if the JSON pointer describes a key of an object which cannot be found. See example below.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.404} \cell }{if the JSON pointer {\i ptr}  can not be resolved. See example below.\cell }
{\row }
}
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes in the JSON value.\par
@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0\par
}}@liveexample\{The behavior is shown in the example.,at_json_pointer_const\} \par
}{
Definition at line {\b 25705} of file {\b json.hpp}.}\par
}
{\xe \v at\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::at (const typename object_t::key_type &  {\i key}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element with bounds checking }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the element at with specified key {\i key} , with bounds checking.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key of the element to access\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the element at key {\i key}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.304} \cell }{if the JSON value is not an object; in this case, calling {\f2 at}  with a key makes no sense. See example below. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.403} \cell }{if the key {\i key}  is is not stored in the object; that is, {\f2 find(key) == {\b end()}} . See example below.\cell }
{\row }
}
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes in the JSON value.\par
@complexity Logarithmic in the size of the container.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b operator[](const typename object_t::key_type&)} for unchecked access by {\b reference} \par
see {\b value()} for access by {\b value} with a default {\b value}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0\par
}}@liveexample\{The example below shows how object elements can be read and written using {\f2 {\b at()}} . It also demonstrates the different exceptions that can be thrown.,at__object_t_key_type\} \par
}{
Definition at line {\b 20989} of file {\b json.hpp}.}\par
}
{\xe \v at\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::at (const typename object_t::key_type &  {\i key}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element with bounds checking }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const reference to the element at with specified key {\i key} , with bounds checking.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key of the element to access\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const reference to the element at key {\i key}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.304} \cell }{if the JSON value is not an object; in this case, calling {\f2 at}  with a key makes no sense. See example below. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.403} \cell }{if the key {\i key}  is is not stored in the object; that is, {\f2 find(key) == {\b end()}} . See example below.\cell }
{\row }
}
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes in the JSON value.\par
@complexity Logarithmic in the size of the container.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b operator[](const typename object_t::key_type&)} for unchecked access by {\b reference} \par
see {\b value()} for access by {\b value} with a default {\b value}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0\par
}}@liveexample\{The example below shows how object elements can be read using {\f2 {\b at()}} . It also demonstrates the different exceptions that can be thrown., at__object_t_key_type_const\} \par
}{
Definition at line {\b 21040} of file {\b json.hpp}.}\par
}
{\xe \v at\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::at ({\b size_type}  {\i idx}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified array element with bounds checking }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the element at specified location {\i idx} , with bounds checking.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i idx} \cell }{index of the element to access\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the element at index {\i idx}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.304} \cell }{if the JSON value is not an array; in this case, calling {\f2 at}  with an index makes no sense. See example below. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.401} \cell }{if the index {\i idx}  is out of range of the array; that is, {\f2 idx >= {\b size()}} . See example below.\cell }
{\row }
}
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes in the JSON value.\par
@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0\par
}}@liveexample\{The example below shows how array elements can be read and written using {\f2 {\b at()}} . It also demonstrates the different exceptions that can be thrown.,at__size_type\} \par
}{
Definition at line {\b 20891} of file {\b json.hpp}.}\par
}
{\xe \v at\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::at ({\b size_type}  {\i idx}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified array element with bounds checking }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const reference to the element at specified location {\i idx} , with bounds checking.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i idx} \cell }{index of the element to access\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const reference to the element at index {\i idx}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.304} \cell }{if the JSON value is not an array; in this case, calling {\f2 at}  with an index makes no sense. See example below. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.401} \cell }{if the index {\i idx}  is out of range of the array; that is, {\f2 idx >= {\b size()}} . See example below.\cell }
{\row }
}
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes in the JSON value.\par
@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0\par
}}@liveexample\{The example below shows how array elements can be read using {\f2 {\b at()}} . It also demonstrates the different exceptions that can be thrown., at__size_type_const\} \par
}{
Definition at line {\b 20938} of file {\b json.hpp}.}\par
}
{\xe \v back\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::back (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access the last element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the last element in the container. For a JSON container {\f2 c} , the expression {\f2 c.back()}  is equivalent to {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 auto} tmp = c.end();\par
--tmp;\par
{\cf19 return} *tmp;\par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
In case of a structured type (array or object), a reference to the last element is returned. In case of number, string, boolean, or binary values, a reference to the value is returned.\par
}}@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The JSON value must not be {\f2 null}  (would throw {\f2 std::out_of_range} ) or an empty array or object (undefined behavior, {\b guarded by assertions} ). \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The JSON value remains unchanged.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.214} \cell }{when called on a {\f2 null}  value. See example below.\cell }
{\row }
}
@liveexample\{The following code shows an example for {\f2 {\b back()}} .,back\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b front()} \'96 access the first element\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21554} of file {\b json.hpp}.}\par
}
{\xe \v back\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::back () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access the last element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the last element in the container. For a JSON container {\f2 c} , the expression {\f2 c.back()}  is equivalent to {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 auto} tmp = c.end();\par
--tmp;\par
{\cf19 return} *tmp;\par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
In case of a structured type (array or object), a reference to the last element is returned. In case of number, string, boolean, or binary values, a reference to the value is returned.\par
}}@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The JSON value must not be {\f2 null}  (would throw {\f2 std::out_of_range} ) or an empty array or object (undefined behavior, {\b guarded by assertions} ). \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The JSON value remains unchanged.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.214} \cell }{when called on a {\f2 null}  value. See example below.\cell }
{\row }
}
@liveexample\{The following code shows an example for {\f2 {\b back()}} .,back\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b front()} \'96 access the first element\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21564} of file {\b json.hpp}.}\par
}
{\xe \v begin\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::begin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const iterator to the first element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to the first element.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const iterator to the first element\par
}}@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 const_cast<const {\b basic_json}&>(*this).{\b begin()}} .\par}
@liveexample\{The following code shows an example for {\f2 {\b cbegin()}} .,cbegin\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b begin()} \'96 returns an {\b iterator} to the beginning \par
see {\b end()} \'96 returns an {\b iterator} to the {\b end} \par
see {\b cend()} \'96 returns a const {\b iterator} to the {\b end}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22085} of file {\b json.hpp}.}\par
}
{\xe \v begin\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::begin (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns an iterator to the first element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an iterator to the first element.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
iterator to the first element\par
}}@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par}
@liveexample\{The following code shows an example for {\f2 {\b begin()}} .,begin\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b cbegin()} \'96 returns a const {\b iterator} to the beginning \par
see {\b end()} \'96 returns an {\b iterator} to the {\b end} \par
see {\b cend()} \'96 returns a const {\b iterator} to the {\b end}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22075} of file {\b json.hpp}.}\par
}
{\xe \v binary\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::binary (const typename {\b binary_t::container_type} &  {\i init}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create a binary array (without subtype) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a {\f2 std::vector} . Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i init} \cell }{container containing bytes to use as binary type\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
JSON binary array value\par
}}@complexity Linear in the size of {\i init} .\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 19218} of file {\b json.hpp}.}\par
}
{\xe \v binary\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::binary (const typename {\b binary_t::container_type} &  {\i init}, typename {\b binary_t::subtype_type}  {\i subtype}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create a binary array (with subtype) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a {\f2 std::vector} . Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i init} \cell }{container containing bytes to use as binary type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i subtype} \cell }{subtype to use in MessagePack and BSON\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
JSON binary array value\par
}}@complexity Linear in the size of {\i init} .\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 19255} of file {\b json.hpp}.}\par
}
{\xe \v binary\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::binary (typename {\b binary_t::container_type} &&  {\i init}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create a binary array (without subtype) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a {\f2 std::vector} . Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i init} \cell }{container containing bytes to use as binary type\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
JSON binary array value\par
}}@complexity Linear in the size of {\i init} .\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 19265} of file {\b json.hpp}.}\par
}
{\xe \v binary\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::binary (typename {\b binary_t::container_type} &&  {\i init}, typename {\b binary_t::subtype_type}  {\i subtype}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create a binary array (with subtype) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a JSON binary array value from a given binary container. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a {\f2 std::vector} . Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i init} \cell }{container containing bytes to use as binary type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i subtype} \cell }{subtype to use in MessagePack and BSON\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
JSON binary array value\par
}}@complexity Linear in the size of {\i init} .\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 19275} of file {\b json.hpp}.}\par
}
{\xe \v cbegin\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:cbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::cbegin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const iterator to the first element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to the first element.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const iterator to the first element\par
}}@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 const_cast<const {\b basic_json}&>(*this).{\b begin()}} .\par}
@liveexample\{The following code shows an example for {\f2 {\b cbegin()}} .,cbegin\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b begin()} \'96 returns an {\b iterator} to the beginning \par
see {\b end()} \'96 returns an {\b iterator} to the {\b end} \par
see {\b cend()} \'96 returns a const {\b iterator} to the {\b end}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22115} of file {\b json.hpp}.}\par
}
{\xe \v cend\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:cend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::cend () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const iterator to one past the last element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to one past the last element.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const iterator one past the last element\par
}}@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 const_cast<const {\b basic_json}&>(*this).{\b end()}} .\par}
@liveexample\{The following code shows an example for {\f2 {\b cend()}} .,cend\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b end()} \'96 returns an {\b iterator} to the {\b end} \par
see {\b begin()} \'96 returns an {\b iterator} to the beginning \par
see {\b cbegin()} \'96 returns a const {\b iterator} to the beginning\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22186} of file {\b json.hpp}.}\par
}
{\xe \v clear\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::clear (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
clears the contents }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the content of a JSON value and resets it to the default value as if {\b basic_json(value_t)} would have been called with the current value type from {\b type()}:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Value type   \cell }{initial value    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 null}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 false}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\f2 ""}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number   \cell }{{\f2 0}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{An empty byte vector    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\f2 \{\}}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\f2 []}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Has the same effect as calling {
\par
\pard\plain \s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid *{\cf17 this} = basic_json(type());\par
}
\par
}}@liveexample\{The example below shows the effect of {\f2 {\b clear()}}  to different JSON types.,clear\}\par
@complexity Linear in the size of the JSON value.\par
@iterators All iterators, pointers and references related to this container are invalidated.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b basic_json(value_t)} \'96 constructor that creates an {\b object} with the same {\b value} than calling {\f2 {\b clear()}} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22767} of file {\b json.hpp}.}\par
}
{\xe \v contains\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::contains (const {\b json_pointer} &  {\i ptr}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
check the existence of an element in a JSON object given a JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check whether the given JSON pointer {\i ptr}  can be resolved in the current JSON value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This method can be executed on any JSON value type.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ptr} \cell }{JSON pointer to check its existence.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if the JSON pointer can be resolved to a stored value, false otherwise.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If {\f2 j.contains(ptr)}  returns true, it is safe to call {\f2 j[ptr]} .\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.106} \cell }{if an array index begins with '0' \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.109} \cell }{if an array index was not a number\cell }
{\row }
}
@complexity Logarithmic in the size of the JSON object.\par
@liveexample\{The following code shows an example for {\f2 {\b contains()}} .,contains_json_pointer\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b contains(KeyT &&) const} \'96 checks the existence of a key\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.7.0 \par
}}}{
Definition at line {\b 22036} of file {\b json.hpp}.}\par
}
{\xe \v contains\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename KeyT , typename std::enable_if< !std::is_same< typename std::decay< KeyT >::{\b type}, {\b json_pointer} >::{\b value}, int >::{\b type}  = 0> bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::contains (KeyT &&  {\i key}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
check the existence of an element in a JSON object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Check whether an element exists in a JSON object with key equivalent to {\i key} . If the element is not found or the JSON value is not an object, false is returned.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This method always returns false when executed on a JSON type that is not an object.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key value to check its existence.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true if an element with specified {\i key}  exists. If no such element with such key is found or the JSON value is not an object, false is returned.\par
}}@complexity Logarithmic in the size of the JSON object.\par
@liveexample\{The following code shows an example for {\f2 {\b contains()}} .,contains\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b find(KeyT&&)} \'96 returns an {\b iterator} to an {\b object} element \par
see {\b contains(const json_pointer&) const} \'96 checks the existence for a JSON {\b pointer}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 22005} of file {\b json.hpp}.}\par
}
{\xe \v count\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename KeyT > {\b size_type} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::count (KeyT &&  {\i key}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the number of occurrences of a key in a JSON object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of elements with key {\i key} . If ObjectType is the default {\f2 std::map}  type, the return value will always be {\f2 0}  ({\i key}  was not found) or {\f2 1}  ({\i key}  was found).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This method always returns {\f2 0}  when executed on a JSON type that is not an object.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key value of the element to count\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Number of elements with key {\i key} . If the JSON value is not an object, the return value will be {\f2 0} .\par
}}@complexity Logarithmic in the size of the JSON object.\par
@liveexample\{The example shows how {\f2 {\b count()}}  is used.,count\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21972} of file {\b json.hpp}.}\par
}
{\xe \v crbegin\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:crbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reverse_iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::crbegin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const reverse iterator to the last element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to the reverse-beginning; that is, the last element.\par
@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 ReversibleContainer} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 const_cast<const {\b basic_json}&>(*this).{\b rbegin()}} .\par}
@liveexample\{The following code shows an example for {\f2 {\b crbegin()}} .,crbegin\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b rbegin()} \'96 returns a reverse {\b iterator} to the beginning \par
see {\b rend()} \'96 returns a reverse {\b iterator} to the {\b end} \par
see {\b crend()} \'96 returns a const reverse {\b iterator} to the {\b end}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22290} of file {\b json.hpp}.}\par
}
{\xe \v crend\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:crend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reverse_iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::crend () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const reverse iterator to one before the first }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const reverse iterator to the reverse-end; that is, one before the first element.\par
@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 ReversibleContainer} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 const_cast<const {\b basic_json}&>(*this).{\b rend()}} .\par}
@liveexample\{The following code shows an example for {\f2 {\b crend()}} .,crend\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b rend()} \'96 returns a reverse {\b iterator} to the {\b end} \par
see {\b rbegin()} \'96 returns a reverse {\b iterator} to the beginning \par
see {\b crbegin()} \'96 returns a const reverse {\b iterator} to the beginning\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22319} of file {\b json.hpp}.}\par
}
{\xe \v diff\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:diff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::diff (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i source}, const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i target}, const std::string &  {\i path} = {\f2 ""}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
creates a diff as a JSON patch }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\f2 JSON Patch} so that value {\i source}  can be changed into the value {\i target}  by calling {\b patch} function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Invariant\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
For two JSON values {\i source}  and {\i target} , the following code yields always {\f2 true} : {
\par
\pard\plain \s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid source.patch(diff(source, target)) == target;\par
}
\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Currently, only {\f2 remove} , {\f2 add} , and {\f2 replace}  operations are generated.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i source} \cell }{JSON value to compare from \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i target} \cell }{JSON value to compare against \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i path} \cell }{helper value to create JSON pointers\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a JSON patch to convert the {\i source}  to {\i target}  \par
}}@complexity Linear in the lengths of {\i source}  and {\i target} .\par
@liveexample\{The following code shows how a JSON patch is created as a diff for two JSON values.,diff\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b patch} \'96 apply a JSON {\b patch} \par
see {\b merge_patch} \'96 apply a JSON Merge Patch\par
{\f2 RFC 6902 (JSON Patch)}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 26136} of file {\b json.hpp}.}\par
}
{\xe \v dump\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b string_t} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::dump (const int  {\i indent} = {\f2 -1}, const char  {\i indent_char} = {\f2 '\~ '}, const bool  {\i ensure_ascii} = {\f2 false}, const {\b error_handler_t}  {\i error_handler} = {\f2 error_handler_t::strict}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serialization }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serialization function for JSON values. The function tries to mimic Python's {\f2 json.dumps()}  function, and currently supports its {\i indent}  and {\i ensure_ascii}  parameters.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i indent} \cell }{If indent is nonnegative, then array elements and object members will be pretty-printed with that indent level. An indent level of {\f2 0}  will only insert newlines. {\f2 -1}  (the default) selects the most compact representation. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i indent_char} \cell }{The character to use for indentation if {\i indent}  is greater than {\f2 0} . The default is (space). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ensure_ascii} \cell }{If {\i ensure_ascii}  is true, all non-ASCII characters in the output are escaped with {\f2 \\uXXXX}  sequences, and the result consists of ASCII characters only. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i error_handler} \cell }{how to react on decoding errors; there are three possible values: {\f2 strict}  (throws and exception in case a decoding error occurs; default), {\f2 replace}  (replace invalid UTF-8 sequences with U+FFFD), and {\f2 ignore}  (ignore invalid UTF-8 sequences during serialization; all bytes are copied to the output unchanged).\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
string containing the serialization of the JSON value\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.316} \cell }{if a string stored inside the JSON value is not UTF-8 encoded and {\i error_handler}  is set to strict\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Binary values are serialized as object containing two keys:{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"bytes": an array of bytes as integers\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
"subtype": the subtype as integer or "null" if the binary has no subtype\par}
}}@complexity Linear.\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes in the JSON value.\par
@liveexample\{The following example shows the effect of different {\i indent\\} , {\i indent_char\\} , and {\i ensure_ascii}  parameters to the result of the serialization.,dump\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://docs.python.org/2/library/json.html#json.dump}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0; indentation character {\i indent_char} , option {\i ensure_ascii}  and exceptions added in version 3.0.0; error handlers added in version 3.4.0; serialization of binary values added in version 3.8.0. \par
}}}{
Definition at line {\b 19823} of file {\b json.hpp}.}\par
}
{\xe \v emplace\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:emplace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<class... Args> std::pair< {\b iterator}, bool > {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::emplace (Args &&...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object if key does not exist }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts a new element into a JSON object constructed in-place with the given {\i args}  if there is no element with the key in the container. If the function is called on a JSON null value, an empty object is created before appending the value created from {\i args} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i args} \cell }{arguments to forward to a constructor of {\b basic_json} \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Args} \cell }{compatible types to create a {\b basic_json} object\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.311} \cell }{when called on a type other than JSON object or null; example: {\f2 "cannot use emplace() with number"} \cell }
{\row }
}
@complexity Logarithmic in the size of the container, O(log({\f2 {\b size()}} )).\par
@liveexample\{The example shows how {\f2 {\b emplace()}}  can be used to add elements to a JSON object. Note how the {\f2 null}  value was silently converted to a JSON object. Further note how no value is added if there was already one value stored with the same key.,emplace\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.8 \par
}}}{
Definition at line {\b 23089} of file {\b json.hpp}.}\par
}
{\xe \v emplace_back\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:emplace_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<class... Args> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::emplace_back (Args &&...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a JSON value from the passed parameters {\i args}  to the end of the JSON value. If the function is called on a JSON null value, an empty array is created before appending the value created from {\i args} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i args} \cell }{arguments to forward to a constructor of {\b basic_json} \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Args} \cell }{compatible types to create a {\b basic_json} object\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the inserted element\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.311} \cell }{when called on a type other than JSON array or null; example: {\f2 "cannot use emplace_back() with number"} \cell }
{\row }
}
@complexity Amortized constant.\par
@liveexample\{The example shows how {\f2 {\b push_back()}}  can be used to add elements to a JSON array. Note how the {\f2 null}  value was silently converted to a JSON array.,emplace_back\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.8, returns reference since 3.7.0 \par
}}}{
Definition at line {\b 23039} of file {\b json.hpp}.}\par
}
{\xe \v empty\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::empty () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
checks whether the container is empty. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Checks if a JSON value has no elements (i.e. whether its {\b size} is {\f2 0} ).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The return value depends on the different types and is defined as follows: \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Value type   \cell }{return value    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 true}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 false}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\f2 false}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number   \cell }{{\f2 false}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\f2 false}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{result of function {\f2 object_t::empty()}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{result of function {\f2 array_t::empty()}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}@liveexample\{The following code uses {\f2 {\b empty()}}  to check if a JSON object contains any elements.,empty\}\par
@complexity Constant, as long as {\b array_t} and {\b object_t} satisfy the Container concept; that is, their {\f2 {\b empty()}}  functions have constant complexity.\par
@iterators No changes.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This function does not return whether a string stored as JSON value is empty - it returns whether the JSON container itself is empty which is false in the case of a string.\par
}}@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 {\b begin()} == {\b end()}} .\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b size()} \'96 returns the number of elements\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22530} of file {\b json.hpp}.}\par
}
{\xe \v end\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::end () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const iterator to one past the last element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to one past the last element.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const iterator one past the last element\par
}}@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 const_cast<const {\b basic_json}&>(*this).{\b end()}} .\par}
@liveexample\{The following code shows an example for {\f2 {\b cend()}} .,cend\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b end()} \'96 returns an {\b iterator} to the {\b end} \par
see {\b begin()} \'96 returns an {\b iterator} to the beginning \par
see {\b cbegin()} \'96 returns a const {\b iterator} to the beginning\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22156} of file {\b json.hpp}.}\par
}
{\xe \v end\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::end (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns an iterator to one past the last element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an iterator to one past the last element.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
iterator one past the last element\par
}}@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par}
@liveexample\{The following code shows an example for {\f2 {\b end()}} .,end\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b cend()} \'96 returns a const {\b iterator} to the {\b end} \par
see {\b begin()} \'96 returns an {\b iterator} to the beginning \par
see {\b cbegin()} \'96 returns a const {\b iterator} to the beginning\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22146} of file {\b json.hpp}.}\par
}
{\xe \v erase\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::erase (const {\b size_type}  {\i idx}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove element from a JSON array given an index }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes element from a JSON array at the index {\i idx} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i idx} \cell }{index of the element to remove\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.307} \cell }{when called on a type other than JSON object; example: {\f2 "cannot use erase() with null"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.401} \cell }{when {\f2 idx >= {\b size()}} ; example: {\f2 "array index 17
is out of range"} \cell }
{\row }
}
@complexity Linear in distance between {\i idx}  and the end of the container.\par
@liveexample\{The example shows the effect of {\f2 {\b erase()}} .,erase__size_type\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b erase(IteratorType)} \'96 removes the element {\b at} a given position \par
see {\b erase(IteratorType, IteratorType)} \'96 removes the elements in the given range \par
see {\b erase(const typename object_t::key_type&)} \'96 removes the element from an {\b object} {\b at} the given key\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21868} of file {\b json.hpp}.}\par
}
{\xe \v erase\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b size_type} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::erase (const typename object_t::key_type &  {\i key}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove element from a JSON object given a key }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes elements from a JSON object with the key value {\i key} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{value of the elements to remove\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Number of elements removed. If {\i ObjectType}  is the default {\f2 std::map}  type, the return value will always be {\f2 0}  ({\i key}  was not found) or {\f2 1}  ({\i key}  was found).\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
References and iterators to the erased elements are invalidated. Other references and iterators are not affected.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.307} \cell }{when called on a type other than JSON object; example: {\f2 "cannot use erase() with null"} \cell }
{\row }
}
@complexity {\f2 log(size()) + count(key)} \par
@liveexample\{The example shows the effect of {\f2 {\b erase()}} .,erase__key_type\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b erase(IteratorType)} \'96 removes the element {\b at} a given position \par
see {\b erase(IteratorType, IteratorType)} \'96 removes the elements in the given range \par
see {\b erase(const size_type)} \'96 removes the element from an array {\b at} the given index\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21833} of file {\b json.hpp}.}\par
}
{\xe \v erase\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<class IteratorType , typename std::enable_if< std::is_same< IteratorType, typename basic_json_t::iterator >::{\b value}||std::is_same< IteratorType, typename basic_json_t::const_iterator >::{\b value}, int >::{\b type}  = 0> IteratorType {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::erase (IteratorType  {\i first}, IteratorType  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove elements given an iterator range }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the element specified by the range {\f2 [first; last)} . The iterator {\i first}  does not need to be dereferenceable if {\f2 first == last} : erasing an empty range is a no-op.\par
If called on a primitive type other than {\f2 null} , the resulting JSON value will be {\f2 null} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i first} \cell }{iterator to the beginning of the range to remove \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i last} \cell }{iterator past the end of the range to remove \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Iterator following the last removed element. If the iterator {\i second}  refers to the last element, the {\f2 {\b end()}}  iterator is returned.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i IteratorType} \cell }{an {\b iterator} or {\b const_iterator}\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Invalidates iterators and references at or after the point of the erase, including the {\f2 {\b end()}}  iterator.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.307} \cell }{if called on a {\f2 null}  value; example: {\f2 "cannot use
erase() with null"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.203} \cell }{if called on iterators which does not belong to the current JSON value; example: {\f2 "iterators do not fit current value"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.204} \cell }{if called on a primitive type with invalid iterators (i.e., if {\f2 first != {\b begin()}}  and {\f2 last != {\b end()}} ); example: {\f2 "iterators out of range"} \cell }
{\row }
}
@complexity The complexity depends on the type:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
objects: {\f2 log(size()) + std::distance(first, last)} \par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
arrays: linear in the distance between {\i first}  and {\i last} , plus linear in the distance between {\i last}  and end of the container\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
strings and binary: linear in the length of the member\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
other types: constant\par}
@liveexample\{The example shows the result of {\f2 {\b erase()}}  for different JSON types.,erase__IteratorType_IteratorType\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b erase(IteratorType)} \'96 removes the element {\b at} a given position \par
see {\b erase(const typename object_t::key_type&)} \'96 removes the element from an {\b object} {\b at} the given key \par
see {\b erase(const size_type)} \'96 removes the element from an array {\b at} the given index\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21736} of file {\b json.hpp}.}\par
}
{\xe \v erase\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<class IteratorType , typename std::enable_if< std::is_same< IteratorType, typename basic_json_t::iterator >::{\b value}||std::is_same< IteratorType, typename basic_json_t::const_iterator >::{\b value}, int >::{\b type}  = 0> IteratorType {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::erase (IteratorType  {\i pos}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove element given an iterator }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Removes the element specified by iterator {\i pos} . The iterator {\i pos}  must be valid and dereferenceable. Thus the {\f2 {\b end()}}  iterator (which is valid, but is not dereferenceable) cannot be used as a value for {\i pos} .\par
If called on a primitive type other than {\f2 null} , the resulting JSON value will be {\f2 null} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i pos} \cell }{iterator to the element to remove \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Iterator following the last removed element. If the iterator {\i pos}  refers to the last element, the {\f2 {\b end()}}  iterator is returned.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i IteratorType} \cell }{an {\b iterator} or {\b const_iterator}\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Invalidates iterators and references at or after the point of the erase, including the {\f2 {\b end()}}  iterator.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.307} \cell }{if called on a {\f2 null}  value; example: {\f2 "cannot use
erase() with null"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.202} \cell }{if called on an iterator which does not belong to the current JSON value; example: {\f2 "iterator does not fit current
value"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.205} \cell }{if called on a primitive type with invalid iterator (i.e., any iterator which is not {\f2 {\b begin()}} ); example: {\f2 "iterator
out of range"} \cell }
{\row }
}
@complexity The complexity depends on the type:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
objects: amortized constant\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
arrays: linear in distance between {\i pos}  and the end of the container\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
strings and binary: linear in the length of the member\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
other types: constant\par}
@liveexample\{The example shows the result of {\f2 {\b erase()}}  for different JSON types.,erase__IteratorType\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b erase(IteratorType, IteratorType)} \'96 removes the elements in the given range \par
see {\b erase(const typename object_t::key_type&)} \'96 removes the element from an {\b object} {\b at} the given key \par
see {\b erase(const size_type)} \'96 removes the element from an array {\b at} the given index\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21621} of file {\b json.hpp}.}\par
}
{\xe \v find\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename KeyT > {\b iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::find (KeyT &&  {\i key}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
find an element in a JSON object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Finds an element in a JSON object with key equivalent to {\i key} . If the element is not found or the JSON value is not an object, {\b end()} is returned.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This method always returns {\b end()} when executed on a JSON type that is not an object.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key value of the element to search for.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Iterator to an element with key equivalent to {\i key} . If no such element is found or the JSON value is not an object, past-the-end (see {\b end()}) iterator is returned.\par
}}@complexity Logarithmic in the size of the JSON object.\par
@liveexample\{The example shows how {\f2 {\b find()}}  is used.,find__key_type\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b contains(KeyT&&) const} \'96 checks whether a key exists\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21921} of file {\b json.hpp}.}\par
}
{\xe \v find\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename KeyT > {\b const_iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::find (KeyT &&  {\i key}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
find an element in a JSON object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
find an element in a JSON object Finds an element in a JSON object with key equivalent to {\i key} . If the element is not found or the JSON value is not an object, {\b end()} is returned.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This method always returns {\b end()} when executed on a JSON type that is not an object.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key value of the element to search for.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Iterator to an element with key equivalent to {\i key} . If no such element is found or the JSON value is not an object, past-the-end (see {\b end()}) iterator is returned.\par
}}@complexity Logarithmic in the size of the JSON object.\par
@liveexample\{The example shows how {\f2 {\b find()}}  is used.,find__key_type\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b contains(KeyT&&) const} \'96 checks whether a key exists\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21938} of file {\b json.hpp}.}\par
}
{\xe \v flatten\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:flatten}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::flatten () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return flattened JSON value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function creates a JSON object whose keys are JSON pointers (see {\f2 RFC 6901}) and whose values are all primitive. The original JSON value can be restored using the {\b unflatten()} function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
an object that maps JSON pointers to primitive values\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Empty objects and arrays are flattened to {\f2 null}  and will not be reconstructed correctly by the {\b unflatten()} function.\par
}}@complexity Linear in the size the JSON value.\par
@liveexample\{The following code shows how a JSON object is flattened to an object whose keys consist of JSON pointers.,flatten\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b unflatten()} for the reverse function\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 25732} of file {\b json.hpp}.}\par
}
{\xe \v from_bson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_bson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename T > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_bson (const T *  {\i ptr}, std::size_t  {\i len}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25529} of file {\b json.hpp}.}\par
}
{\xe \v from_bson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_bson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_bson ({\b detail::span_input_adapter} &&  {\i i}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25538} of file {\b json.hpp}.}\par
}
{\xe \v from_bson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_bson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename InputType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_bson (InputType &&  {\i i}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a JSON value from an input in BSON format. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deserializes a given input {\i i}  to a JSON value using the BSON (Binary JSON) serialization format.\par
The library maps BSON record types to JSON value types as follows:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{BSON type   \cell }{BSON marker byte   \cell }{JSON value type    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{double   \cell }{0x01   \cell }{number_float    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{0x02   \cell }{string    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{document   \cell }{0x03   \cell }{object    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{0x04   \cell }{array    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{0x05   \cell }{binary    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{undefined   \cell }{0x06   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{ObjectId   \cell }{0x07   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{0x08   \cell }{boolean    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTC Date-Time   \cell }{0x09   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{0x0A   \cell }{null    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Regular Expr.   \cell }{0x0B   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{DB Pointer   \cell }{0x0C   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{JavaScript Code   \cell }{0x0D   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Symbol   \cell }{0x0E   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{JavaScript Code   \cell }{0x0F   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int32   \cell }{0x10   \cell }{number_integer    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Timestamp   \cell }{0x11   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{128-bit decimal float   \cell }{0x13   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Max Key   \cell }{0x7F   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Min Key   \cell }{0xFF   \cell }{still unsupported   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The mapping is {\b incomplete} . The unsupported mappings are indicated in the table above.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{an input in BSON format convertible to an input adapter \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether to expect the input to be consumed until EOF (true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i allow_exceptions} \cell }{whether to throw exceptions in case of a parse error (optional, true by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
deserialized JSON value; in case of a parse error and {\i allow_exceptions}  set to {\f2 false} , the return value will be {\b value_t::discarded}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.114} \cell }{if an unsupported BSON record type is encountered\cell }
{\row }
}
@complexity Linear in the size of the input {\i i} .\par
@liveexample\{The example shows the deserialization of a byte vector in BSON format to a JSON value.,from_bson\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://bsonspec.org/spec.html} \par
see {\b to_bson(const basic_json&)} for the analogous serialization \par
see {\b from_cbor(InputType&&, const bool, const bool, const cbor_tag_handler_t)} for the related CBOR format \par
see {\b from_msgpack(InputType&&, const bool, const bool)} for the related MessagePack format \par
see {\b from_ubjson(InputType&&, const bool, const bool)} for the related UBJSON format \par
}}}{
Definition at line {\b 25499} of file {\b json.hpp}.}\par
}
{\xe \v from_bson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_bson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename IteratorType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_bson (IteratorType  {\i first}, IteratorType  {\i last}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a JSON value from an input in BSON format. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deserializes a given input {\i i}  to a JSON value using the BSON (Binary JSON) serialization format.\par
The library maps BSON record types to JSON value types as follows:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{BSON type   \cell }{BSON marker byte   \cell }{JSON value type    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{double   \cell }{0x01   \cell }{number_float    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{0x02   \cell }{string    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{document   \cell }{0x03   \cell }{object    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{0x04   \cell }{array    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{0x05   \cell }{binary    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{undefined   \cell }{0x06   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{ObjectId   \cell }{0x07   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{0x08   \cell }{boolean    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTC Date-Time   \cell }{0x09   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{0x0A   \cell }{null    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Regular Expr.   \cell }{0x0B   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{DB Pointer   \cell }{0x0C   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{JavaScript Code   \cell }{0x0D   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Symbol   \cell }{0x0E   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{JavaScript Code   \cell }{0x0F   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int32   \cell }{0x10   \cell }{number_integer    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Timestamp   \cell }{0x11   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{128-bit decimal float   \cell }{0x13   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Max Key   \cell }{0x7F   \cell }{still unsupported    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Min Key   \cell }{0xFF   \cell }{still unsupported   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The mapping is {\b incomplete} . The unsupported mappings are indicated in the table above.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{an input in BSON format convertible to an input adapter \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether to expect the input to be consumed until EOF (true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i allow_exceptions} \cell }{whether to throw exceptions in case of a parse error (optional, true by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
deserialized JSON value; in case of a parse error and {\i allow_exceptions}  set to {\f2 false} , the return value will be {\b value_t::discarded}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.114} \cell }{if an unsupported BSON record type is encountered\cell }
{\row }
}
@complexity Linear in the size of the input {\i i} .\par
@liveexample\{The example shows the deserialization of a byte vector in BSON format to a JSON value.,from_bson\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://bsonspec.org/spec.html} \par
see {\b to_bson(const basic_json&)} for the analogous serialization \par
see {\b from_cbor(InputType&&, const bool, const bool, const cbor_tag_handler_t)} for the related CBOR format \par
see {\b from_msgpack(InputType&&, const bool, const bool)} for the related MessagePack format \par
see {\b from_ubjson(InputType&&, const bool, const bool)} for the related UBJSON format \par
}}}{
Definition at line {\b 25515} of file {\b json.hpp}.}\par
}
{\xe \v from_cbor\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_cbor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename T > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_cbor (const T *  {\i ptr}, std::size_t  {\i len}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}, const {\b cbor_tag_handler_t}  {\i tag_handler} = {\f2 cbor_tag_handler_t::error}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25156} of file {\b json.hpp}.}\par
}
{\xe \v from_cbor\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_cbor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_cbor ({\b detail::span_input_adapter} &&  {\i i}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}, const {\b cbor_tag_handler_t}  {\i tag_handler} = {\f2 cbor_tag_handler_t::error}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25167} of file {\b json.hpp}.}\par
}
{\xe \v from_cbor\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_cbor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename InputType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_cbor (InputType &&  {\i i}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}, const {\b cbor_tag_handler_t}  {\i tag_handler} = {\f2 cbor_tag_handler_t::error}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in CBOR format }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deserializes a given input {\i i}  to a JSON value using the CBOR (Concise Binary Object Representation) serialization format.\par
The library maps CBOR types to JSON value types as follows:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{CBOR type   \cell }{JSON value type   \cell }{first byte    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Integer   \cell }{number_unsigned   \cell }{0x00..0x17    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Unsigned integer   \cell }{number_unsigned   \cell }{0x18    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Unsigned integer   \cell }{number_unsigned   \cell }{0x19    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Unsigned integer   \cell }{number_unsigned   \cell }{0x1A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Unsigned integer   \cell }{number_unsigned   \cell }{0x1B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Negative integer   \cell }{number_integer   \cell }{0x20..0x37    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Negative integer   \cell }{number_integer   \cell }{0x38    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Negative integer   \cell }{number_integer   \cell }{0x39    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Negative integer   \cell }{number_integer   \cell }{0x3A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Negative integer   \cell }{number_integer   \cell }{0x3B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Byte string   \cell }{binary   \cell }{0x40..0x57    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Byte string   \cell }{binary   \cell }{0x58    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Byte string   \cell }{binary   \cell }{0x59    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Byte string   \cell }{binary   \cell }{0x5A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Byte string   \cell }{binary   \cell }{0x5B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x60..0x77    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x78    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x79    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x7A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x7B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x7F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x80..0x97    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x98    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x99    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x9A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x9B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x9F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xA0..0xB7    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xB8    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xB9    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xBA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xBB    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xBF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{False   \cell }{{\f2 false}    \cell }{0xF4    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{True   \cell }{{\f2 true}    \cell }{0xF5    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Null   \cell }{{\f2 null}    \cell }{0xF6    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Half-Precision Float   \cell }{number_float   \cell }{0xF9    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Single-Precision Float   \cell }{number_float   \cell }{0xFA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Double-Precision Float   \cell }{number_float   \cell }{0xFB   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The mapping is {\b incomplete}  in the sense that not all CBOR types can be converted to a JSON value. The following CBOR types are not supported and will yield parse errors (parse_error.112):{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
date/time (0xC0..0xC1)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bignum (0xC2..0xC3)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
decimal fraction (0xC4)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bigfloat (0xC5)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
expected conversions (0xD5..0xD7)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
simple values (0xE0..0xF3, 0xF8)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
undefined (0xF7)\par}
CBOR allows map keys of any type, whereas JSON only allows strings as keys in object values. Therefore, CBOR maps with keys other than UTF-8 strings are rejected (parse_error.113).\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Any CBOR output created {\b to_cbor} can be successfully parsed by {\b from_cbor}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{an input in CBOR format convertible to an input adapter \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether to expect the input to be consumed until EOF (true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i allow_exceptions} \cell }{whether to throw exceptions in case of a parse error (optional, true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i tag_handler} \cell }{how to treat CBOR tags (optional, error by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
deserialized JSON value; in case of a parse error and {\i allow_exceptions}  set to {\f2 false} , the return value will be {\b value_t::discarded}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.110} \cell }{if the given input ends prematurely or the end of file was not reached when {\i strict}  was set to true \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.112} \cell }{if unsupported features from CBOR were used in the given input {\i v}  or if the input is not valid CBOR \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.113} \cell }{if a string was expected as map key, but not found\cell }
{\row }
}
@complexity Linear in the size of the input {\i i} .\par
@liveexample\{The example shows the deserialization of a byte vector in CBOR format to a JSON value.,from_cbor\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://cbor.io} \par
see {\b to_cbor(const basic_json&)} for the analogous serialization \par
see {\b from_msgpack(InputType&&, const bool, const bool)} for the related MessagePack format \par
see {\b from_ubjson(InputType&&, const bool, const bool)} for the related UBJSON format\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.9; parameter {\i start_index}  since 2.1.1; changed to consume input adapters, removed start_index parameter, and added {\i strict}  parameter since 3.0.0; added {\i allow_exceptions}  parameter since 3.2.0; added {\i tag_handler}  parameter since 3.9.0. \par
}}}{
Definition at line {\b 25124} of file {\b json.hpp}.}\par
}
{\xe \v from_cbor\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_cbor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename IteratorType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_cbor (IteratorType  {\i first}, IteratorType  {\i last}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}, const {\b cbor_tag_handler_t}  {\i tag_handler} = {\f2 cbor_tag_handler_t::error}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in CBOR format }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deserializes a given input {\i i}  to a JSON value using the CBOR (Concise Binary Object Representation) serialization format.\par
The library maps CBOR types to JSON value types as follows:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{CBOR type   \cell }{JSON value type   \cell }{first byte    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Integer   \cell }{number_unsigned   \cell }{0x00..0x17    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Unsigned integer   \cell }{number_unsigned   \cell }{0x18    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Unsigned integer   \cell }{number_unsigned   \cell }{0x19    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Unsigned integer   \cell }{number_unsigned   \cell }{0x1A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Unsigned integer   \cell }{number_unsigned   \cell }{0x1B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Negative integer   \cell }{number_integer   \cell }{0x20..0x37    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Negative integer   \cell }{number_integer   \cell }{0x38    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Negative integer   \cell }{number_integer   \cell }{0x39    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Negative integer   \cell }{number_integer   \cell }{0x3A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Negative integer   \cell }{number_integer   \cell }{0x3B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Byte string   \cell }{binary   \cell }{0x40..0x57    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Byte string   \cell }{binary   \cell }{0x58    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Byte string   \cell }{binary   \cell }{0x59    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Byte string   \cell }{binary   \cell }{0x5A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Byte string   \cell }{binary   \cell }{0x5B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x60..0x77    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x78    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x79    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x7A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x7B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UTF-8 string   \cell }{string   \cell }{0x7F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x80..0x97    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x98    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x99    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x9A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x9B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array   \cell }{0x9F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xA0..0xB7    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xB8    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xB9    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xBA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xBB    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map   \cell }{object   \cell }{0xBF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{False   \cell }{{\f2 false}    \cell }{0xF4    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{True   \cell }{{\f2 true}    \cell }{0xF5    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Null   \cell }{{\f2 null}    \cell }{0xF6    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Half-Precision Float   \cell }{number_float   \cell }{0xF9    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Single-Precision Float   \cell }{number_float   \cell }{0xFA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Double-Precision Float   \cell }{number_float   \cell }{0xFB   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The mapping is {\b incomplete}  in the sense that not all CBOR types can be converted to a JSON value. The following CBOR types are not supported and will yield parse errors (parse_error.112):{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
date/time (0xC0..0xC1)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bignum (0xC2..0xC3)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
decimal fraction (0xC4)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bigfloat (0xC5)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
expected conversions (0xD5..0xD7)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
simple values (0xE0..0xF3, 0xF8)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
undefined (0xF7)\par}
CBOR allows map keys of any type, whereas JSON only allows strings as keys in object values. Therefore, CBOR maps with keys other than UTF-8 strings are rejected (parse_error.113).\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Any CBOR output created {\b to_cbor} can be successfully parsed by {\b from_cbor}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{an input in CBOR format convertible to an input adapter \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether to expect the input to be consumed until EOF (true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i allow_exceptions} \cell }{whether to throw exceptions in case of a parse error (optional, true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i tag_handler} \cell }{how to treat CBOR tags (optional, error by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
deserialized JSON value; in case of a parse error and {\i allow_exceptions}  set to {\f2 false} , the return value will be {\b value_t::discarded}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.110} \cell }{if the given input ends prematurely or the end of file was not reached when {\i strict}  was set to true \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.112} \cell }{if unsupported features from CBOR were used in the given input {\i v}  or if the input is not valid CBOR \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.113} \cell }{if a string was expected as map key, but not found\cell }
{\row }
}
@complexity Linear in the size of the input {\i i} .\par
@liveexample\{The example shows the deserialization of a byte vector in CBOR format to a JSON value.,from_cbor\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://cbor.io} \par
see {\b to_cbor(const basic_json&)} for the analogous serialization \par
see {\b from_msgpack(InputType&&, const bool, const bool)} for the related MessagePack format \par
see {\b from_ubjson(InputType&&, const bool, const bool)} for the related UBJSON format\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.9; parameter {\i start_index}  since 2.1.1; changed to consume input adapters, removed start_index parameter, and added {\i strict}  parameter since 3.0.0; added {\i allow_exceptions}  parameter since 3.2.0; added {\i tag_handler}  parameter since 3.9.0. \par
}}}{
Definition at line {\b 25141} of file {\b json.hpp}.}\par
}
{\xe \v from_msgpack\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_msgpack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename T > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_msgpack (const T *  {\i ptr}, std::size_t  {\i len}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25299} of file {\b json.hpp}.}\par
}
{\xe \v from_msgpack\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_msgpack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_msgpack ({\b detail::span_input_adapter} &&  {\i i}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25308} of file {\b json.hpp}.}\par
}
{\xe \v from_msgpack\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_msgpack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename InputType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_msgpack (InputType &&  {\i i}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in MessagePack format }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deserializes a given input {\i i}  to a JSON value using the MessagePack serialization format.\par
The library maps MessagePack types to JSON value types as follows:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{MessagePack type   \cell }{JSON value type   \cell }{first byte    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{positive fixint   \cell }{number_unsigned   \cell }{0x00..0x7F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixmap   \cell }{object   \cell }{0x80..0x8F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixarray   \cell }{array   \cell }{0x90..0x9F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixstr   \cell }{string   \cell }{0xA0..0xBF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{nil   \cell }{{\f2 null}    \cell }{0xC0    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{false   \cell }{{\f2 false}    \cell }{0xC2    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{true   \cell }{{\f2 true}    \cell }{0xC3    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{float 32   \cell }{number_float   \cell }{0xCA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{float 64   \cell }{number_float   \cell }{0xCB    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{uint 8   \cell }{number_unsigned   \cell }{0xCC    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{uint 16   \cell }{number_unsigned   \cell }{0xCD    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{uint 32   \cell }{number_unsigned   \cell }{0xCE    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{uint 64   \cell }{number_unsigned   \cell }{0xCF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int 8   \cell }{number_integer   \cell }{0xD0    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int 16   \cell }{number_integer   \cell }{0xD1    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int 32   \cell }{number_integer   \cell }{0xD2    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int 64   \cell }{number_integer   \cell }{0xD3    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{str 8   \cell }{string   \cell }{0xD9    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{str 16   \cell }{string   \cell }{0xDA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{str 32   \cell }{string   \cell }{0xDB    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array 16   \cell }{array   \cell }{0xDC    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array 32   \cell }{array   \cell }{0xDD    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map 16   \cell }{object   \cell }{0xDE    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map 32   \cell }{object   \cell }{0xDF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{bin 8   \cell }{binary   \cell }{0xC4    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{bin 16   \cell }{binary   \cell }{0xC5    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{bin 32   \cell }{binary   \cell }{0xC6    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{ext 8   \cell }{binary   \cell }{0xC7    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{ext 16   \cell }{binary   \cell }{0xC8    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{ext 32   \cell }{binary   \cell }{0xC9    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixext 1   \cell }{binary   \cell }{0xD4    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixext 2   \cell }{binary   \cell }{0xD5    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixext 4   \cell }{binary   \cell }{0xD6    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixext 8   \cell }{binary   \cell }{0xD7    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixext 16   \cell }{binary   \cell }{0xD8    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{negative fixint   \cell }{number_integer   \cell }{0xE0-0xFF   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Any MessagePack output created {\b to_msgpack} can be successfully parsed by {\b from_msgpack}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{an input in MessagePack format convertible to an input adapter \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether to expect the input to be consumed until EOF (true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i allow_exceptions} \cell }{whether to throw exceptions in case of a parse error (optional, true by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
deserialized JSON value; in case of a parse error and {\i allow_exceptions}  set to {\f2 false} , the return value will be {\b value_t::discarded}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.110} \cell }{if the given input ends prematurely or the end of file was not reached when {\i strict}  was set to true \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.112} \cell }{if unsupported features from MessagePack were used in the given input {\i i}  or if the input is not valid MessagePack \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.113} \cell }{if a string was expected as map key, but not found\cell }
{\row }
}
@complexity Linear in the size of the input {\i i} .\par
@liveexample\{The example shows the deserialization of a byte vector in MessagePack format to a JSON value.,from_msgpack\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://msgpack.org} \par
see {\b to_msgpack(const basic_json&)} for the analogous serialization \par
see {\b from_cbor(InputType&&, const bool, const bool, const cbor_tag_handler_t)} for the related CBOR format \par
see {\b from_ubjson(InputType&&, const bool, const bool)} for the related UBJSON format \par
see {\b from_bson(InputType&&, const bool, const bool)} for the related BSON format\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.9; parameter {\i start_index}  since 2.1.1; changed to consume input adapters, removed start_index parameter, and added {\i strict}  parameter since 3.0.0; added {\i allow_exceptions}  parameter since 3.2.0 \par
}}}{
Definition at line {\b 25268} of file {\b json.hpp}.}\par
}
{\xe \v from_msgpack\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_msgpack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename IteratorType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_msgpack (IteratorType  {\i first}, IteratorType  {\i last}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in MessagePack format }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deserializes a given input {\i i}  to a JSON value using the MessagePack serialization format.\par
The library maps MessagePack types to JSON value types as follows:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{MessagePack type   \cell }{JSON value type   \cell }{first byte    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{positive fixint   \cell }{number_unsigned   \cell }{0x00..0x7F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixmap   \cell }{object   \cell }{0x80..0x8F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixarray   \cell }{array   \cell }{0x90..0x9F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixstr   \cell }{string   \cell }{0xA0..0xBF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{nil   \cell }{{\f2 null}    \cell }{0xC0    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{false   \cell }{{\f2 false}    \cell }{0xC2    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{true   \cell }{{\f2 true}    \cell }{0xC3    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{float 32   \cell }{number_float   \cell }{0xCA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{float 64   \cell }{number_float   \cell }{0xCB    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{uint 8   \cell }{number_unsigned   \cell }{0xCC    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{uint 16   \cell }{number_unsigned   \cell }{0xCD    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{uint 32   \cell }{number_unsigned   \cell }{0xCE    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{uint 64   \cell }{number_unsigned   \cell }{0xCF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int 8   \cell }{number_integer   \cell }{0xD0    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int 16   \cell }{number_integer   \cell }{0xD1    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int 32   \cell }{number_integer   \cell }{0xD2    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int 64   \cell }{number_integer   \cell }{0xD3    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{str 8   \cell }{string   \cell }{0xD9    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{str 16   \cell }{string   \cell }{0xDA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{str 32   \cell }{string   \cell }{0xDB    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array 16   \cell }{array   \cell }{0xDC    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array 32   \cell }{array   \cell }{0xDD    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map 16   \cell }{object   \cell }{0xDE    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{map 32   \cell }{object   \cell }{0xDF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{bin 8   \cell }{binary   \cell }{0xC4    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{bin 16   \cell }{binary   \cell }{0xC5    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{bin 32   \cell }{binary   \cell }{0xC6    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{ext 8   \cell }{binary   \cell }{0xC7    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{ext 16   \cell }{binary   \cell }{0xC8    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{ext 32   \cell }{binary   \cell }{0xC9    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixext 1   \cell }{binary   \cell }{0xD4    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixext 2   \cell }{binary   \cell }{0xD5    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixext 4   \cell }{binary   \cell }{0xD6    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixext 8   \cell }{binary   \cell }{0xD7    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{fixext 16   \cell }{binary   \cell }{0xD8    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{negative fixint   \cell }{number_integer   \cell }{0xE0-0xFF   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Any MessagePack output created {\b to_msgpack} can be successfully parsed by {\b from_msgpack}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{an input in MessagePack format convertible to an input adapter \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether to expect the input to be consumed until EOF (true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i allow_exceptions} \cell }{whether to throw exceptions in case of a parse error (optional, true by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
deserialized JSON value; in case of a parse error and {\i allow_exceptions}  set to {\f2 false} , the return value will be {\b value_t::discarded}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.110} \cell }{if the given input ends prematurely or the end of file was not reached when {\i strict}  was set to true \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.112} \cell }{if unsupported features from MessagePack were used in the given input {\i i}  or if the input is not valid MessagePack \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.113} \cell }{if a string was expected as map key, but not found\cell }
{\row }
}
@complexity Linear in the size of the input {\i i} .\par
@liveexample\{The example shows the deserialization of a byte vector in MessagePack format to a JSON value.,from_msgpack\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://msgpack.org} \par
see {\b to_msgpack(const basic_json&)} for the analogous serialization \par
see {\b from_cbor(InputType&&, const bool, const bool, const cbor_tag_handler_t)} for the related CBOR format \par
see {\b from_ubjson(InputType&&, const bool, const bool)} for the related UBJSON format \par
see {\b from_bson(InputType&&, const bool, const bool)} for the related BSON format\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.9; parameter {\i start_index}  since 2.1.1; changed to consume input adapters, removed start_index parameter, and added {\i strict}  parameter since 3.0.0; added {\i allow_exceptions}  parameter since 3.2.0 \par
}}}{
Definition at line {\b 25284} of file {\b json.hpp}.}\par
}
{\xe \v from_ubjson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_ubjson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename T > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_ubjson (const T *  {\i ptr}, std::size_t  {\i len}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25415} of file {\b json.hpp}.}\par
}
{\xe \v from_ubjson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_ubjson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_ubjson ({\b detail::span_input_adapter} &&  {\i i}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25424} of file {\b json.hpp}.}\par
}
{\xe \v from_ubjson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_ubjson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename InputType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_ubjson (InputType &&  {\i i}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in UBJSON format }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deserializes a given input {\i i}  to a JSON value using the UBJSON (Universal Binary JSON) serialization format.\par
The library maps UBJSON types to JSON value types as follows:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UBJSON type   \cell }{JSON value type   \cell }{marker    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{no-op   \cell }{{\i no value, next value is read}    \cell }{{\f2 N}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 null}    \cell }{{\f2 Z}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{false   \cell }{{\f2 false}    \cell }{{\f2 F}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{true   \cell }{{\f2 true}    \cell }{{\f2 T}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{float32   \cell }{number_float   \cell }{{\f2 d}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{float64   \cell }{number_float   \cell }{{\f2 D}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{uint8   \cell }{number_unsigned   \cell }{{\f2 U}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int8   \cell }{number_integer   \cell }{{\f2 i}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int16   \cell }{number_integer   \cell }{{\f2 I}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int32   \cell }{number_integer   \cell }{{\f2 l}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int64   \cell }{number_integer   \cell }{{\f2 L}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{high-precision number   \cell }{number_integer, number_unsigned, or number_float - depends on number string   \cell }{'H'    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{string   \cell }{{\f2 S}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{char   \cell }{string   \cell }{{\f2 C}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array (optimized values are supported)   \cell }{{\f2 [}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{object (optimized values are supported)   \cell }{{\f2 \{}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The mapping is {\b complete}  in the sense that any UBJSON value can be converted to a JSON value.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{an input in UBJSON format convertible to an input adapter \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether to expect the input to be consumed until EOF (true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i allow_exceptions} \cell }{whether to throw exceptions in case of a parse error (optional, true by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
deserialized JSON value; in case of a parse error and {\i allow_exceptions}  set to {\f2 false} , the return value will be {\b value_t::discarded}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.110} \cell }{if the given input ends prematurely or the end of file was not reached when {\i strict}  was set to true \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.112} \cell }{if a parse error occurs \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.113} \cell }{if a string could not be parsed successfully\cell }
{\row }
}
@complexity Linear in the size of the input {\i i} .\par
@liveexample\{The example shows the deserialization of a byte vector in UBJSON format to a JSON value.,from_ubjson\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://ubjson.org} \par
see {\b to_ubjson(const basic_json&, const bool, const bool)} for the analogous serialization \par
see {\b from_cbor(InputType&&, const bool, const bool, const cbor_tag_handler_t)} for the related CBOR format \par
see {\b from_msgpack(InputType&&, const bool, const bool)} for the related MessagePack format \par
see {\b from_bson(InputType&&, const bool, const bool)} for the related BSON format\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.1.0; added {\i allow_exceptions}  parameter since 3.2.0 \par
}}}{
Definition at line {\b 25385} of file {\b json.hpp}.}\par
}
{\xe \v from_ubjson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:from_ubjson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename IteratorType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::from_ubjson (IteratorType  {\i first}, IteratorType  {\i last}, const bool  {\i strict} = {\f2 true}, const bool  {\i allow_exceptions} = {\f2 true}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a JSON value from an input in UBJSON format }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deserializes a given input {\i i}  to a JSON value using the UBJSON (Universal Binary JSON) serialization format.\par
The library maps UBJSON types to JSON value types as follows:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{UBJSON type   \cell }{JSON value type   \cell }{marker    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{no-op   \cell }{{\i no value, next value is read}    \cell }{{\f2 N}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 null}    \cell }{{\f2 Z}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{false   \cell }{{\f2 false}    \cell }{{\f2 F}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{true   \cell }{{\f2 true}    \cell }{{\f2 T}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{float32   \cell }{number_float   \cell }{{\f2 d}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{float64   \cell }{number_float   \cell }{{\f2 D}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{uint8   \cell }{number_unsigned   \cell }{{\f2 U}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int8   \cell }{number_integer   \cell }{{\f2 i}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int16   \cell }{number_integer   \cell }{{\f2 I}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int32   \cell }{number_integer   \cell }{{\f2 l}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{int64   \cell }{number_integer   \cell }{{\f2 L}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{high-precision number   \cell }{number_integer, number_unsigned, or number_float - depends on number string   \cell }{'H'    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{string   \cell }{{\f2 S}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{char   \cell }{string   \cell }{{\f2 C}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{array (optimized values are supported)   \cell }{{\f2 [}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{object (optimized values are supported)   \cell }{{\f2 \{}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The mapping is {\b complete}  in the sense that any UBJSON value can be converted to a JSON value.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{an input in UBJSON format convertible to an input adapter \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether to expect the input to be consumed until EOF (true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i allow_exceptions} \cell }{whether to throw exceptions in case of a parse error (optional, true by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
deserialized JSON value; in case of a parse error and {\i allow_exceptions}  set to {\f2 false} , the return value will be {\b value_t::discarded}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.110} \cell }{if the given input ends prematurely or the end of file was not reached when {\i strict}  was set to true \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.112} \cell }{if a parse error occurs \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.113} \cell }{if a string could not be parsed successfully\cell }
{\row }
}
@complexity Linear in the size of the input {\i i} .\par
@liveexample\{The example shows the deserialization of a byte vector in UBJSON format to a JSON value.,from_ubjson\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://ubjson.org} \par
see {\b to_ubjson(const basic_json&, const bool, const bool)} for the analogous serialization \par
see {\b from_cbor(InputType&&, const bool, const bool, const cbor_tag_handler_t)} for the related CBOR format \par
see {\b from_msgpack(InputType&&, const bool, const bool)} for the related MessagePack format \par
see {\b from_bson(InputType&&, const bool, const bool)} for the related BSON format\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.1.0; added {\i allow_exceptions}  parameter since 3.2.0 \par
}}}{
Definition at line {\b 25401} of file {\b json.hpp}.}\par
}
{\xe \v front\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::front (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access the first element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the first element in the container. For a JSON container {\f2 c} , the expression {\f2 c.front()}  is equivalent to {\f2 *c.{\b begin()}} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
In case of a structured type (array or object), a reference to the first element is returned. In case of number, string, boolean, or binary values, a reference to the value is returned.\par
}}@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The JSON value must not be {\f2 null}  (would throw {\f2 std::out_of_range} ) or an empty array or object (undefined behavior, {\b guarded by assertions} ). \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The JSON value remains unchanged.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.214} \cell }{when called on {\f2 null}  value\cell }
{\row }
}
@liveexample\{The following code shows an example for {\f2 {\b front()}} .,front\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b back()} \'96 access the last element\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21510} of file {\b json.hpp}.}\par
}
{\xe \v front\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::front () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access the first element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the first element in the container. For a JSON container {\f2 c} , the expression {\f2 c.front()}  is equivalent to {\f2 *c.{\b begin()}} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
In case of a structured type (array or object), a reference to the first element is returned. In case of number, string, boolean, or binary values, a reference to the value is returned.\par
}}@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The JSON value must not be {\f2 null}  (would throw {\f2 std::out_of_range} ) or an empty array or object (undefined behavior, {\b guarded by assertions} ). \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The JSON value remains unchanged.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.214} \cell }{when called on {\f2 null}  value\cell }
{\row }
}
@liveexample\{The following code shows an example for {\f2 {\b front()}} .,front\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b back()} \'96 access the last element\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21518} of file {\b json.hpp}.}\par
}
{\xe \v get\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ValueTypeCV , typename ValueType  = detail::uncvref_t<ValueTypeCV>> auto {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get () const -> decltype(std::declval<const basic_json_t&>().template get_impl<ValueType>({\b detail::priority_tag}<4> \{\}))
    {\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a (pointer) value (explicit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs explicit type conversion between the JSON value and a compatible value if required.\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the requested type is a pointer to the internally stored JSON value that pointer is returned. No copies are made.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the requested type is the current {\b basic_json}, or a different {\b basic_json} convertible from the current {\b basic_json}.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Otherwise the value is converted by calling the {\b json_serializer<ValueType>} {\f2 {\b from_json()}}  method.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ValueTypeCV} \cell }{the provided value type \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ValueType} \cell }{the returned value type\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
copy of the JSON value, converted to \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ValueType} \cell }{if necessary\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i what} \cell }{{\b json_serializer<ValueType>} {\f2 {\b from_json()}}  method throws if conversion is required\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.1.0 \par
}}}{
Definition at line {\b 20612} of file {\b json.hpp}.}\par
}
{\xe \v get\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename PointerType , typename std::enable_if< std::is_pointer< PointerType >::{\b value}, int >::{\b type}  = 0> auto {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get () -> decltype(std::declval<basic_json_t&>().template {\b get_ptr}<PointerType>())
    {\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a pointer value (explicit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Explicit pointer access to the internally stored JSON value. No copies are made.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The pointer becomes invalid if the underlying JSON object changes.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i PointerType} \cell }{pointer type; must be a pointer to {\b array_t}, {\b object_t}, {\b string_t}, {\b boolean_t}, {\b number_integer_t}, {\b number_unsigned_t}, or {\b number_float_t}.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
pointer to the internally stored JSON value if the requested pointer type {\i PointerType}  fits to the JSON value; {\f2 nullptr}  otherwise\par
}}@complexity Constant.\par
@liveexample\{The example below shows how pointers to internal values of a JSON value can be requested. Note that no type conversions are made and a {\f2 nullptr}  is returned if the value and the requested pointer type does not match.,get__PointerType\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b get_ptr()} for explicit pointer-member access\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20653} of file {\b json.hpp}.}\par
}
{\xe \v get_allocator\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get_allocator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b allocator_type} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get_allocator (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the allocator associated with the container }}\par
{
Definition at line {\b 17727} of file {\b json.hpp}.}\par
}
{\xe \v get_binary\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get_binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b binary_t} & {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get_binary (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the binary value\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.302} \cell }{if the value is not binary\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b is_binary()} to check if the {\b value} is binary\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 20833} of file {\b json.hpp}.}\par
}
{\xe \v get_binary\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get_binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> const {\b binary_t} & {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get_binary () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
}}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the binary value\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.302} \cell }{if the value is not binary\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b is_binary()} to check if the {\b value} is binary\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 20844} of file {\b json.hpp}.}\par
}
{\xe \v get_ptr\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename PointerType , typename std::enable_if< std::is_pointer< PointerType >::{\b value} &&std::is_const< typename std::remove_pointer< PointerType >::{\b type} >::{\b value}, int >::{\b type}  = 0> constexpr auto {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get_ptr () const -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a pointer value (implicit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a pointer value (implicit) Implicit pointer access to the internally stored JSON value. No copies are made.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Writing data to the pointee of the result yields an undefined state.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i PointerType} \cell }{pointer type; must be a pointer to {\b array_t}, {\b object_t}, {\b string_t}, {\b boolean_t}, {\b number_integer_t}, {\b number_unsigned_t}, or {\b number_float_t}. Enforced by a static assertion.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
pointer to the internally stored JSON value if the requested pointer type {\i PointerType}  fits to the JSON value; {\f2 nullptr}  otherwise\par
}}@complexity Constant.\par
@liveexample\{The example below shows how pointers to internal values of a JSON value can be requested. Note that no type conversions are made and a {\f2 nullptr}  is returned if the value and the requested pointer type does not match.,get_ptr\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20424} of file {\b json.hpp}.}\par
}
{\xe \v get_ptr\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename PointerType , typename std::enable_if< std::is_pointer< PointerType >::{\b value}, int >::{\b type}  = 0> auto {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get_ptr () -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))
    {\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a pointer value (implicit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implicit pointer access to the internally stored JSON value. No copies are made.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Writing data to the pointee of the result yields an undefined state.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i PointerType} \cell }{pointer type; must be a pointer to {\b array_t}, {\b object_t}, {\b string_t}, {\b boolean_t}, {\b number_integer_t}, {\b number_unsigned_t}, or {\b number_float_t}. Enforced by a static assertion.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
pointer to the internally stored JSON value if the requested pointer type {\i PointerType}  fits to the JSON value; {\f2 nullptr}  otherwise\par
}}@complexity Constant.\par
@liveexample\{The example below shows how pointers to internal values of a JSON value can be requested. Note that no type conversions are made and a {\f2 nullptr}  is returned if the value and the requested pointer type does not match.,get_ptr\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20411} of file {\b json.hpp}.}\par
}
{\xe \v get_ref\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ReferenceType , typename std::enable_if< std::is_reference< ReferenceType >::{\b value}, int >::{\b type}  = 0> ReferenceType {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get_ref (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a reference value (implicit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implicit reference access to the internally stored JSON value. No copies are made.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Writing data to the referee of the result yields an undefined state.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ReferenceType} \cell }{reference type; must be a reference to {\b array_t}, {\b object_t}, {\b string_t}, {\b boolean_t}, {\b number_integer_t}, or {\b number_float_t}. Enforced by static assertion.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the internally stored JSON value if the requested reference type {\i ReferenceType}  fits to the JSON value; throws type_error.303 otherwise\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.303} \cell }{in case passed type {\i ReferenceType}  is incompatible with the stored JSON value; see example below\cell }
{\row }
}
@complexity Constant.\par
@liveexample\{The example shows several calls to {\f2 {\b get_ref()}} .,get_ref\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.1.0 \par
}}}{
Definition at line {\b 20757} of file {\b json.hpp}.}\par
}
{\xe \v get_ref\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ReferenceType , typename std::enable_if< std::is_reference< ReferenceType >::{\b value} &&std::is_const< typename std::remove_reference< ReferenceType >::{\b type} >::{\b value}, int >::{\b type}  = 0> ReferenceType {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get_ref () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a reference value (implicit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a reference value (implicit) Implicit reference access to the internally stored JSON value. No copies are made.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Writing data to the referee of the result yields an undefined state.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ReferenceType} \cell }{reference type; must be a reference to {\b array_t}, {\b object_t}, {\b string_t}, {\b boolean_t}, {\b number_integer_t}, or {\b number_float_t}. Enforced by static assertion.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the internally stored JSON value if the requested reference type {\i ReferenceType}  fits to the JSON value; throws type_error.303 otherwise\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.303} \cell }{in case passed type {\i ReferenceType}  is incompatible with the stored JSON value; see example below\cell }
{\row }
}
@complexity Constant.\par
@liveexample\{The example shows several calls to {\f2 {\b get_ref()}} .,get_ref\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.1.0 \par
}}}{
Definition at line {\b 20770} of file {\b json.hpp}.}\par
}
{\xe \v get_to\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get_to}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename T , std::size_t N, typename Array  = T (&)[N], {\b detail::enable_if_t}< {\b detail::has_from_json}< basic_json_t, Array >::{\b value}, int >  = 0> Array {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get_to (T(&)  {\i v}[N]) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20721} of file {\b json.hpp}.}\par
}
{\xe \v get_to\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get_to}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ValueType , {\b detail::enable_if_t}< {\b detail::is_basic_json}< ValueType >::{\b value}, int >  = 0> ValueType & {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get_to (ValueType &  {\i v}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20710} of file {\b json.hpp}.}\par
}
{\xe \v get_to\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:get_to}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ValueType , {\b detail::enable_if_t}< !{\b detail::is_basic_json}< ValueType >::{\b value} &&{\b detail::has_from_json}< basic_json_t, ValueType >::{\b value}, int >  = 0> ValueType & {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::get_to (ValueType &  {\i v}) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a value (explicit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Explicit type conversion between the JSON value and a compatible value. The value is filled into the input parameter by calling the {\b json_serializer<ValueType>} {\f2 {\b from_json()}}  method.\par
The function is equivalent to executing {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ValueType v;\par
JSONSerializer<ValueType>::from_json(*{\cf17 this}, v);\par
}
\par
This overloads is chosen if:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\i ValueType}  is not {\b basic_json},\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_serializer<ValueType>} has a {\f2 {\b from_json()}}  method of the form {\f2 void from_json(const basic_json&, ValueType&)} , and\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ValueType} \cell }{the input parameter type.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the input parameter, allowing chaining calls.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i what} \cell }{{\b json_serializer<ValueType>} {\f2 {\b from_json()}}  method throws\cell }
{\row }
}
@liveexample\{The example below shows several conversions from JSON values to other types. There a few things to note: (1) Floating-point numbers can be converted to integers\\, (2) A JSON array can be converted to a standard {\f2 std::vector<short>} \\, (3) A JSON object can be converted to C++ associative containers such as {\f2 std::unordered_map<std::string\\, json>} .,get_to\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.3.0 \par
}}}{
Definition at line {\b 20697} of file {\b json.hpp}.}\par
}
{\xe \v insert\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::insert ({\b const_iterator}  {\i first}, {\b const_iterator}  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts elements }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts elements from range {\f2 [first, last)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i first} \cell }{begin of the range of elements to insert \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i last} \cell }{end of the range of elements to insert\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.309} \cell }{if called on JSON values other than objects; example: {\f2 "cannot use insert() with string"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.202} \cell }{if iterator {\i first}  or {\i last}  does does not point to an object; example: {\f2 "iterators first and last must point to
objects"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.210} \cell }{if {\i first}  and {\i last}  do not belong to the same JSON value; example: {\f2 "iterators do not fit"} \cell }
{\row }
}
@complexity Logarithmic: {\f2 O(N*log({\b size()} + N))} , where {\f2 N}  is the number of elements to insert.\par
@liveexample\{The example shows how {\f2 {\b insert()}}  is used.,insert__range_object\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 23353} of file {\b json.hpp}.}\par
}
{\xe \v insert\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::insert ({\b const_iterator}  {\i pos}, {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &&  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts element Inserts element {\i val}  before iterator {\i pos} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i pos} \cell }{iterator before which the content will be inserted; may be the {\b end()} iterator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{element to insert \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
iterator pointing to the inserted {\i val} .\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.309} \cell }{if called on JSON values other than arrays; example: {\f2 "cannot use insert() with string"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.202} \cell }{if {\i pos}  is not an iterator of *this; example: {\f2 "iterator does not fit current value"} \cell }
{\row }
}
@complexity Constant plus linear in the distance between {\i pos}  and end of the container.\par
@liveexample\{The example shows how {\f2 {\b insert()}}  is used.,insert\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23182} of file {\b json.hpp}.}\par
}
{\xe \v insert\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::insert ({\b const_iterator}  {\i pos}, const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts element {\i val}  before iterator {\i pos} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i pos} \cell }{iterator before which the content will be inserted; may be the {\b end()} iterator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{element to insert \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
iterator pointing to the inserted {\i val} .\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.309} \cell }{if called on JSON values other than arrays; example: {\f2 "cannot use insert() with string"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.202} \cell }{if {\i pos}  is not an iterator of *this; example: {\f2 "iterator does not fit current value"} \cell }
{\row }
}
@complexity Constant plus linear in the distance between {\i pos}  and end of the container.\par
@liveexample\{The example shows how {\f2 {\b insert()}}  is used.,insert\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23160} of file {\b json.hpp}.}\par
}
{\xe \v insert\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::insert ({\b const_iterator}  {\i pos}, {\b const_iterator}  {\i first}, {\b const_iterator}  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts elements }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts elements from range {\f2 [first, last)}  before iterator {\i pos} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i pos} \cell }{iterator before which the content will be inserted; may be the {\b end()} iterator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i first} \cell }{begin of the range of elements to insert \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i last} \cell }{end of the range of elements to insert\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.309} \cell }{if called on JSON values other than arrays; example: {\f2 "cannot use insert() with string"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.202} \cell }{if {\i pos}  is not an iterator of *this; example: {\f2 "iterator does not fit current value"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.210} \cell }{if {\i first}  and {\i last}  do not belong to the same JSON value; example: {\f2 "iterators do not fit"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.211} \cell }{if {\i first}  or {\i last}  are iterators into container for which insert is called; example: {\f2 "passed iterators may not
belong to container"} \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
iterator pointing to the first element inserted, or {\i pos}  if {\f2 first==last} \par
}}@complexity Linear in {\f2 std::distance(first, last)}  plus linear in the distance between {\i pos}  and end of the container.\par
@liveexample\{The example shows how {\f2 {\b insert()}}  is used.,insert__range\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23259} of file {\b json.hpp}.}\par
}
{\xe \v insert\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::insert ({\b const_iterator}  {\i pos}, {\b initializer_list_t}  {\i ilist}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts elements }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts elements from initializer list {\i ilist}  before iterator {\i pos} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i pos} \cell }{iterator before which the content will be inserted; may be the {\b end()} iterator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ilist} \cell }{initializer list to insert the values from\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.309} \cell }{if called on JSON values other than arrays; example: {\f2 "cannot use insert() with string"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.202} \cell }{if {\i pos}  is not an iterator of *this; example: {\f2 "iterator does not fit current value"} \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
iterator pointing to the first element inserted, or {\i pos}  if {\f2 ilist}  is empty\par
}}@complexity Linear in {\f2 ilist.size()}  plus linear in the distance between {\i pos}  and end of the container.\par
@liveexample\{The example shows how {\f2 {\b insert()}}  is used.,insert__ilist\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23312} of file {\b json.hpp}.}\par
}
{\xe \v insert\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::insert ({\b const_iterator}  {\i pos}, {\b size_type}  {\i cnt}, const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inserts elements }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts {\i cnt}  copies of {\i val}  before iterator {\i pos} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i pos} \cell }{iterator before which the content will be inserted; may be the {\b end()} iterator \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cnt} \cell }{number of copies of {\i val}  to insert \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{element to insert \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
iterator pointing to the first element inserted, or {\i pos}  if {\f2 cnt==0} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.309} \cell }{if called on JSON values other than arrays; example: {\f2 "cannot use insert() with string"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.202} \cell }{if {\i pos}  is not an iterator of *this; example: {\f2 "iterator does not fit current value"} \cell }
{\row }
}
@complexity Linear in {\i cnt}  plus linear in the distance between {\i pos}  and end of the container.\par
@liveexample\{The example shows how {\f2 {\b insert()}}  is used.,insert__count\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23211} of file {\b json.hpp}.}\par
}
{\xe \v insert_iterator\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:insert_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename... Args> {\b iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::insert_iterator ({\b const_iterator}  {\i pos}, Args &&...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Helper for insertion of an iterator \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: This uses std::distance to support GCC 4.8, see {\f2 https://github.com/nlohmann/json/pull/1257} \par
}}}{
Definition at line {\b 23121} of file {\b json.hpp}.}\par
}
{\xe \v is_array\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_array () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is an array }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON value is an array.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is array, {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_array()}}  for all JSON types.,is_array\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20137} of file {\b json.hpp}.}\par
}
{\xe \v is_binary\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_binary () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is a binary array }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON value is a binary array.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is binary array, {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_binary()}}  for all JSON types.,is_binary\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 20181} of file {\b json.hpp}.}\par
}
{\xe \v is_boolean\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_boolean () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is a boolean }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON value is a boolean.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is boolean, {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_boolean()}}  for all JSON types.,is_boolean\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19978} of file {\b json.hpp}.}\par
}
{\xe \v is_discarded\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_discarded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_discarded () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is discarded }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON value was discarded during parsing with a callback function (see {\b parser_callback_t}).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This function will always be {\f2 false}  for JSON values after parsing. That is, discarded values can only occur during parsing, but will be removed when inside a structured value or replaced by null in other cases.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is discarded, {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_discarded()}}  for all JSON types.,is_discarded\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20208} of file {\b json.hpp}.}\par
}
{\xe \v is_null\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_null}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_null () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is null }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON value is null.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is null, {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_null()}}  for all JSON types.,is_null\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19956} of file {\b json.hpp}.}\par
}
{\xe \v is_number\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_number () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is a number }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON value is a number. This includes both integer (signed and unsigned) and floating-point values.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is number (regardless whether integer, unsigned integer or floating-type), {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_number()}}  for all JSON types.,is_number\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b is_number_integer()} \'96 check if {\b value} is an integer or unsigned integer number \par
see {\b is_number_unsigned()} \'96 check if {\b value} is an unsigned integer number \par
see {\b is_number_float()} \'96 check if {\b value} is a floating-point number\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20008} of file {\b json.hpp}.}\par
}
{\xe \v is_number_float\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_number_float}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_number_float () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is a floating-point number }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON value is a floating-point number. This excludes signed and unsigned integer values.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is a floating-point number, {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_number_float()}}  for all JSON types.,is_number_float\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b is_number()} \'96 check if {\b value} is number \par
see {\b is_number_integer()} \'96 check if {\b value} is an integer number \par
see {\b is_number_unsigned()} \'96 check if {\b value} is an unsigned integer number\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20093} of file {\b json.hpp}.}\par
}
{\xe \v is_number_integer\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_number_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_number_integer () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is an integer number }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON value is a signed or unsigned integer number. This excludes floating-point values.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is an integer or unsigned integer number, {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_number_integer()}}  for all JSON types.,is_number_integer\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b is_number()} \'96 check if {\b value} is a number \par
see {\b is_number_unsigned()} \'96 check if {\b value} is an unsigned integer number \par
see {\b is_number_float()} \'96 check if {\b value} is a floating-point number\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20037} of file {\b json.hpp}.}\par
}
{\xe \v is_number_unsigned\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_number_unsigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_number_unsigned () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is an unsigned integer number }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON value is an unsigned integer number. This excludes floating-point and signed integer values.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is an unsigned integer number, {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_number_unsigned()}}  for all JSON types.,is_number_unsigned\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b is_number()} \'96 check if {\b value} is a number \par
see {\b is_number_integer()} \'96 check if {\b value} is an integer or unsigned integer number \par
see {\b is_number_float()} \'96 check if {\b value} is a floating-point number\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 20065} of file {\b json.hpp}.}\par
}
{\xe \v is_object\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_object () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is an object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON value is an object.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is object, {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_object()}}  for all JSON types.,is_object\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20115} of file {\b json.hpp}.}\par
}
{\xe \v is_primitive\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_primitive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_primitive () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether type is primitive }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON type is primitive (string, number, boolean, or null).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is primitive (string, number, boolean, or null), {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_primitive()}}  for all JSON types.,is_primitive\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b is_structured()} \'96 returns whether JSON {\b value} is structured \par
see {\b is_null()} \'96 returns whether JSON {\b value} is {\f2 null}  \par
see {\b is_string()} \'96 returns whether JSON {\b value} is a string \par
see {\b is_boolean()} \'96 returns whether JSON {\b value} is a boolean \par
see {\b is_number()} \'96 returns whether JSON {\b value} is a number \par
see {\b is_binary()} \'96 returns whether JSON {\b value} is a binary array\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19907} of file {\b json.hpp}.}\par
}
{\xe \v is_string\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_string () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether value is a string }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON value is a string.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is string, {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_string()}}  for all JSON types.,is_string\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20159} of file {\b json.hpp}.}\par
}
{\xe \v is_structured\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:is_structured}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::is_structured () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether type is structured }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns true if and only if the JSON type is structured (array or object).\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 true}  if type is structured (array or object), {\f2 false}  otherwise.\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b is_structured()}}  for all JSON types.,is_structured\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b is_primitive()} \'96 returns whether {\b value} is primitive \par
see {\b is_array()} \'96 returns whether {\b value} is an array \par
see {\b is_object()} \'96 returns whether {\b value} is an {\b object}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19934} of file {\b json.hpp}.}\par
}
{\xe \v items\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:items}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b iteration_proxy}< {\b const_iterator} > {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::items () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
helper to access iterator member functions in range-based for }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function allows to access {\b iterator::key()} and {\b iterator::value()} during range-based for loops. In these loops, a reference to the JSON values is returned, so there is no access to the underlying iterator.\par
For loop without {\f2 {\b items()}}  function:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto} it = j_object.begin(); it != j_object.end(); ++it)\par
\{\par
    std::cout << {\cf22 "key: "} << it.key() << {\cf22 ", value:"} << it.value() << {\cf23 '\\n'};\par
\}\par
}
\par
Range-based for loop without {\f2 {\b items()}}  function:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto} it : j_object)\par
\{\par
    {\cf20 // "it" is of type json::reference and has no key() member}\par
    std::cout << {\cf22 "value: "} << it << {\cf23 '\\n'};\par
\}\par
}
\par
Range-based for loop with {\f2 {\b items()}}  function:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto}& el : j_object.items())\par
\{\par
    std::cout << {\cf22 "key: "} << el.key() << {\cf22 ", value:"} << el.value() << {\cf23 '\\n'};\par
\}\par
}
\par
The {\f2 {\b items()}}  function also allows to use {\f2 structured bindings} (C++17):\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto}& [key, val] : j_object.items())\par
\{\par
    std::cout << {\cf22 "key: "} << key << {\cf22 ", value:"} << val << {\cf23 '\\n'};\par
\}\par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
When iterating over an array, {\f2 key()}  will return the index of the element as string (see example). For primitive types (e.g., numbers), {\f2 key()}  returns an empty string.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Using {\f2 {\b items()}}  on temporary objects is dangerous. Make sure the object's lifetime exeeds the iteration. See {\f2 https://github.com/nlohmann/json/issues/2040} for more information.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
iteration proxy object wrapping {\i ref}  with an interface to use in range-based for loops\par
}}@liveexample\{The following code shows how the function is used.,items\}\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes in the JSON value.\par
@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.1.0, structured bindings support since 3.5.0. \par
}}}{
Definition at line {\b 22473} of file {\b json.hpp}.}\par
}
{\xe \v items\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:items}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b iteration_proxy}< {\b iterator} > {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::items (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
helper to access iterator member functions in range-based for }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function allows to access {\b iterator::key()} and {\b iterator::value()} during range-based for loops. In these loops, a reference to the JSON values is returned, so there is no access to the underlying iterator.\par
For loop without {\f2 {\b items()}}  function:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto} it = j_object.begin(); it != j_object.end(); ++it)\par
\{\par
    std::cout << {\cf22 "key: "} << it.key() << {\cf22 ", value:"} << it.value() << {\cf23 '\\n'};\par
\}\par
}
\par
Range-based for loop without {\f2 {\b items()}}  function:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto} it : j_object)\par
\{\par
    {\cf20 // "it" is of type json::reference and has no key() member}\par
    std::cout << {\cf22 "value: "} << it << {\cf23 '\\n'};\par
\}\par
}
\par
Range-based for loop with {\f2 {\b items()}}  function:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto}& el : j_object.items())\par
\{\par
    std::cout << {\cf22 "key: "} << el.key() << {\cf22 ", value:"} << el.value() << {\cf23 '\\n'};\par
\}\par
}
\par
The {\f2 {\b items()}}  function also allows to use {\f2 structured bindings} (C++17):\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto}& [key, val] : j_object.items())\par
\{\par
    std::cout << {\cf22 "key: "} << key << {\cf22 ", value:"} << val << {\cf23 '\\n'};\par
\}\par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
When iterating over an array, {\f2 key()}  will return the index of the element as string (see example). For primitive types (e.g., numbers), {\f2 key()}  returns an empty string.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Using {\f2 {\b items()}}  on temporary objects is dangerous. Make sure the object's lifetime exeeds the iteration. See {\f2 https://github.com/nlohmann/json/issues/2040} for more information.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
iteration proxy object wrapping {\i ref}  with an interface to use in range-based for loops\par
}}@liveexample\{The following code shows how the function is used.,items\}\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes in the JSON value.\par
@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.1.0, structured bindings support since 3.5.0. \par
}}}{
Definition at line {\b 22465} of file {\b json.hpp}.}\par
}
{\xe \v iterator_wrapper\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:iterator_wrapper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b iteration_proxy}< {\b const_iterator} > {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::iterator_wrapper ({\b const_reference}  {\i ref}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
wrapper to access iterator member functions in range-based for }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function allows to access {\b iterator::key()} and {\b iterator::value()} during range-based for loops. In these loops, a reference to the JSON values is returned, so there is no access to the underlying iterator.\par
For loop without iterator_wrapper:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto} it = j_object.begin(); it != j_object.end(); ++it)\par
\{\par
    std::cout << {\cf22 "key: "} << it.key() << {\cf22 ", value:"} << it.value() << {\cf23 '\\n'};\par
\}\par
}
\par
Range-based for loop without iterator proxy:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto} it : j_object)\par
\{\par
    {\cf20 // "it" is of type json::reference and has no key() member}\par
    std::cout << {\cf22 "value: "} << it << {\cf23 '\\n'};\par
\}\par
}
\par
Range-based for loop with iterator proxy:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto} it : json::iterator_wrapper(j_object))\par
\{\par
    std::cout << {\cf22 "key: "} << it.key() << {\cf22 ", value:"} << it.value() << {\cf23 '\\n'};\par
\}\par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
When iterating over an array, {\f2 key()}  will return the index of the element as string (see example).\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ref} \cell }{reference to a JSON value \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
iteration proxy object wrapping {\i ref}  with an interface to use in range-based for loops\par
}}@liveexample\{The following code shows how the wrapper is used,iterator_wrapper\}\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes in the JSON value.\par
@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The name of this function is not yet final and may change in the future.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Deprecated:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid This stream operator is deprecated and will be removed in future 4.0.0 of the library. Please use {\b items()} instead; that is, replace {\f2 json::iterator_wrapper(j)}  with {\f2 j.items()} . \par
}
}{
Definition at line {\b 22392} of file {\b json.hpp}.}\par
}
{\xe \v iterator_wrapper\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:iterator_wrapper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b iteration_proxy}< {\b iterator} > {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::iterator_wrapper ({\b reference}  {\i ref}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
wrapper to access iterator member functions in range-based for }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function allows to access {\b iterator::key()} and {\b iterator::value()} during range-based for loops. In these loops, a reference to the JSON values is returned, so there is no access to the underlying iterator.\par
For loop without iterator_wrapper:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto} it = j_object.begin(); it != j_object.end(); ++it)\par
\{\par
    std::cout << {\cf22 "key: "} << it.key() << {\cf22 ", value:"} << it.value() << {\cf23 '\\n'};\par
\}\par
}
\par
Range-based for loop without iterator proxy:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto} it : j_object)\par
\{\par
    {\cf20 // "it" is of type json::reference and has no key() member}\par
    std::cout << {\cf22 "value: "} << it << {\cf23 '\\n'};\par
\}\par
}
\par
Range-based for loop with iterator proxy:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 for} ({\cf17 auto} it : json::iterator_wrapper(j_object))\par
\{\par
    std::cout << {\cf22 "key: "} << it.key() << {\cf22 ", value:"} << it.value() << {\cf23 '\\n'};\par
\}\par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
When iterating over an array, {\f2 key()}  will return the index of the element as string (see example).\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ref} \cell }{reference to a JSON value \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
iteration proxy object wrapping {\i ref}  with an interface to use in range-based for loops\par
}}@liveexample\{The following code shows how the wrapper is used,iterator_wrapper\}\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes in the JSON value.\par
@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The name of this function is not yet final and may change in the future.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Deprecated:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid This stream operator is deprecated and will be removed in future 4.0.0 of the library. Please use {\b items()} instead; that is, replace {\f2 json::iterator_wrapper(j)}  with {\f2 j.items()} . \par
}
}{
Definition at line {\b 22383} of file {\b json.hpp}.}\par
}
{\xe \v max_size\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:max_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b size_type} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::max_size () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the maximum possible number of elements }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the maximum number of elements a JSON value is able to hold due to system or library implementation limitations, i.e. {\f2 std::distance({\b begin()}, {\b end()})}  for the JSON value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The return value depends on the different types and is defined as follows: \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Value type   \cell }{return value    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 0}  (same as {\f2 {\b size()}} )    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 1}  (same as {\f2 {\b size()}} )    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\f2 1}  (same as {\f2 {\b size()}} )    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number   \cell }{{\f2 1}  (same as {\f2 {\b size()}} )    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\f2 1}  (same as {\f2 {\b size()}} )    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{result of function {\f2 object_t::max_size()}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{result of function {\f2 array_t::max_size()}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}@liveexample\{The following code calls {\f2 {\b max_size()}}  on the different value types. Note the output is implementation specific.,max_size\}\par
@complexity Constant, as long as {\b array_t} and {\b object_t} satisfy the Container concept; that is, their {\f2 {\b max_size()}}  functions have constant complexity.\par
@iterators No changes.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of returning {\f2 b.size()}  where {\f2 b}  is the largest possible JSON value.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b size()} \'96 returns the number of elements\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22688} of file {\b json.hpp}.}\par
}
{\xe \v merge_patch\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:merge_patch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::merge_patch (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i apply_patch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
applies a JSON Merge Patch }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content. This function applies a merge patch to the current JSON value.\par
The function implements the following algorithm from Section 2 of {\f2 RFC 7396 (JSON Merge Patch)}:\par
{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid define MergePatch(Target, Patch):\par
  if Patch is an Object:\par
    if Target is not an Object:\par
      Target = \{\} {\cf20 // Ignore the contents and set it to an empty Object}\par
    {\cf19 for each} Name/Value pair in Patch:\par
      {\cf19 if} Value is {\cf17 null}:\par
        {\cf19 if} Name exists in Target:\par
          remove the Name/Value pair from Target\par
      {\cf19 else}:\par
        Target[Name] = MergePatch(Target[Name], Value)\par
    {\cf19 return} Target\par
  {\cf19 else}:\par
    {\cf19 return} Patch\par
}
\par
Thereby, {\f2 Target}  is the current object; that is, the patch is applied to the current value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i apply_patch} \cell }{the patch to apply\cell }
{\row }
}
@complexity Linear in the lengths of {\i patch} .\par
@liveexample\{The following code shows how a JSON Merge Patch is applied to a JSON document.,merge_patch\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b patch} \'96 apply a JSON {\b patch} \par
{\f2 RFC 7396 (JSON Merge Patch)}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 26319} of file {\b json.hpp}.}\par
}
{\xe \v meta\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:meta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::meta (){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns version information on the library }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns a JSON object with information about the library, including the version number and information on the platform and compiler.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
JSON object holding version information \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{key   \cell }{description    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\f2 compiler}    \cell }{Information on the used compiler. It is an object with the following keys: {\f2 c++}  (the used C++ standard), {\f2 family}  (the compiler family; possible values are {\f2 clang} , {\f2 icc} , {\f2 gcc} , {\f2 ilecpp} , {\f2 msvc} , {\f2 pgcpp} , {\f2 sunpro} , and {\f2 unknown} ), and {\f2 version}  (the compiler version).    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\f2 copyright}    \cell }{The copyright line for the library as string.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\f2 name}    \cell }{The name of the library as string.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\f2 platform}    \cell }{The used platform as string. Possible values are {\f2 win32} , {\f2 linux} , {\f2 apple} , {\f2 unix} , and {\f2 unknown} .    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\f2 url}    \cell }{The URL of the project as string.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\f2 version}    \cell }{The version of the library. It is an object with the following keys: {\f2 major} , {\f2 minor} , and {\f2 patch}  as defined by {\f2 Semantic Versioning}, and {\f2 string}  (the version string).   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}@liveexample\{The following code shows an example output of the {\f2 {\b meta()}}  function.,meta\}\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
2.1.0 \par
}}}{
Definition at line {\b 17759} of file {\b json.hpp}.}\par
}
{\xe \v object\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::object ({\b initializer_list_t}  {\i init} = {\f2 \{\}}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
explicitly create an object from an initializer list }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a JSON object value from a given initializer list. The initializer lists elements must be pairs, and their first elements must be strings. If the initializer list is empty, the empty object {\f2 \{\}}  is created.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This function is only added for symmetry reasons. In contrast to the related function {\b array(initializer_list_t)}, there are no cases which can only be expressed by this function. That is, any initializer list {\i init}  can also be passed to the initializer list constructor {\b basic_json(initializer_list_t, bool, value_t)}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i init} \cell }{initializer list to create an object from (optional)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
JSON object value\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.301} \cell }{if {\i init}  is not a list of pairs whose first elements are strings. In this case, no object can be created. When such a value is passed to {\b basic_json(initializer_list_t, bool, value_t)}, an array would have been created from the passed initializer list {\i init} . See example below.\cell }
{\row }
}
@complexity Linear in the size of {\i init} .\par
@exceptionsafety Strong guarantee: if an exception is thrown, there are no changes to any JSON value.\par
@liveexample\{The following code shows an example for the {\f2 object}  function.,object\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b basic_json(initializer_list_t, bool, value_t)} \'96 create a JSON {\b value} from an initializer list \par
see {\b array(initializer_list_t)} \'96 create a JSON array {\b value} from an initializer list\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19365} of file {\b json.hpp}.}\par
}
{\xe \v operator value_t\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator value_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator {\b value_t} () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the type of the JSON value (implicit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implicitly return the type of the JSON value as a value from the {\b value_t} enumeration.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the type of the JSON value\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies the {\b value_t} operator for all JSON types.,operator__value_t\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b type()} \'96 return the {\b type} of the JSON {\b value} (explicit) \par
see {\b type_name()} \'96 return the {\b type} as string\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20234} of file {\b json.hpp}.}\par
}
{\xe \v operator ValueType\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator ValueType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ValueType , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_pointer< ValueType > >, {\b detail::negation}< std::is_same< ValueType, {\b detail::json_ref}< {\b basic_json} > > >, {\b detail::negation}< std::is_same< ValueType, typename string_t::value_type > >, {\b detail::negation}< {\b detail::is_basic_json}< ValueType > >, {\b detail::negation}< std::is_same< ValueType, std::initializer_list< typename string_t::value_type > > >, {\b detail::is_detected_lazy}< {\b detail::get_template_function}, const basic_json_t &, ValueType > >::{\b value}, int >::{\b type}  = 0> {\b JSON_EXPLICIT} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator ValueType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
get a value (implicit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Implicit type conversion between the JSON value and a compatible value. The call is realized by calling {\b get() const}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ValueType} \cell }{non-pointer type compatible to the JSON value, for instance {\f2 int}  for JSON integer numbers, {\f2 bool}  for JSON booleans, or {\f2 std::vector}  types for JSON arrays. The character type of {\b string_t} as well as an initializer list of this type is excluded to avoid ambiguities as these types implicitly convert to {\f2 std::string} .\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
copy of the JSON value, converted to type {\i ValueType}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.302} \cell }{in case passed type {\i ValueType}  is incompatible to the JSON value type (e.g., the JSON value is of type boolean, but a string is requested); see example below\cell }
{\row }
}
@complexity Linear in the size of the JSON value.\par
@liveexample\{The example below shows several conversions from JSON values to other types. There a few things to note: (1) Floating-point numbers can be converted to integers\\, (2) A JSON array can be converted to a standard {\f2 std::vector<short>} \\, (3) A JSON object can be converted to C++ associative containers such as {\f2 std::unordered_map<std::string\\, json>} .,operator__ValueType\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 20818} of file {\b json.hpp}.}\par
}
{\xe \v operator+=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator+= ({\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &&  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array Appends the given element {\i val}  to the end of the JSON value. If the function is called on a JSON null value, an empty array is created before appending {\i val} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{the value to add to the JSON array\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.308} \cell }{when called on a type other than JSON array or null; example: {\f2 "cannot use push_back() with number"} \cell }
{\row }
}
@complexity Amortized constant.\par
@liveexample\{The example shows how {\f2 {\b push_back()}}  and {\f2 +=}  can be used to add elements to a JSON array. Note how the {\f2 null}  value was silently converted to a JSON array.,push_back\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22873} of file {\b json.hpp}.}\par
}
{\xe \v operator+=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator+= (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array Appends the given element {\i val}  to the end of the JSON value. If the function is called on a JSON null value, an empty array is created before appending {\i val} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{the value to add to the JSON array\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.308} \cell }{when called on a type other than JSON array or null; example: {\f2 "cannot use push_back() with number"} \cell }
{\row }
}
@complexity Amortized constant.\par
@liveexample\{The example shows how {\f2 {\b push_back()}}  and {\f2 +=}  can be used to add elements to a JSON array. Note how the {\f2 null}  value was silently converted to a JSON array.,push_back\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22909} of file {\b json.hpp}.}\par
}
{\xe \v operator+=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator+= (const typename object_t::value_type &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object Inserts the given element {\i val}  to the JSON object. If the function is called on a JSON null value, an empty object is created before inserting {\i val} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{the value to add to the JSON object\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.308} \cell }{when called on a type other than JSON object or null; example: {\f2 "cannot use push_back() with number"} \cell }
{\row }
}
@complexity Logarithmic in the size of the container, O(log({\f2 {\b size()}} )).\par
@liveexample\{The example shows how {\f2 {\b push_back()}}  and {\f2 +=}  can be used to add elements to a JSON object. Note how the {\f2 null}  value was silently converted to a JSON object.,push_back__object_t__value\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22960} of file {\b json.hpp}.}\par
}
{\xe \v operator+=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator+= ({\b initializer_list_t}  {\i init}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object This function allows to use {\f2 push_back}  with an initializer list. In case\par
{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab the current value is an object,\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab the initializer list {\i init}  contains only two elements, and\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab the first element of {\i init}  is a string,\par}
{\i init}  is converted into an object element and added using {\b push_back(const typename object_t::value_type&)}. Otherwise, {\i init}  is converted to a JSON value and added using {\b push_back(basic_json&&)}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i init} \cell }{an initializer list\cell }
{\row }
}
@complexity Linear in the size of the initializer list {\i init} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This function is required to resolve an ambiguous overload error, because pairs like {\f2 \{"key", "value"\}}  can be both interpreted as {\f2 object_t::value_type}  or {\f2 std::initializer_list<{\b basic_json}>} , see {\f2 https://github.com/nlohmann/json/issues/235} for more information.\par
}}@liveexample\{The example shows how initializer lists are treated as objects when possible.,push_back__initializer_list\} \par
}{
Definition at line {\b 23009} of file {\b json.hpp}.}\par
}
{\xe \v operator=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b basic_json} & {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator= ({\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >  {\i other}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
copy assignment }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copy assignment operator. Copies a JSON value via the "copy and swap" strategy: It is expressed in terms of the copy constructor, destructor, and the {\f2 {\b swap()}}  member function.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i other} \cell }{value to copy from\cell }
{\row }
}
@complexity Linear.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is linear.\par}
@liveexample\{The code below shows and example for the copy assignment. It creates a copy of value {\f2 a}  which is then swapped with {\f2 b} . Finally\\, the copy of {\f2 a}  (which is the null value after the swap) is destroyed.,basic_json__copyassignment\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19725} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator[] (const {\b json_pointer} &  {\i ptr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified element via JSON Pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses a JSON pointer to retrieve a reference to the respective JSON value. No bound checking is performed. Similar to {\b operator[]}(const typename object_t::key_type&), {\f2 null}  values are created in arrays and objects if necessary.\par
In particular:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the JSON pointer points to an object key that does not exist, it is created an filled with a {\f2 null}  value before a reference to it is returned.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If the JSON pointer points to an array index that does not exist, it is created an filled with a {\f2 null}  value before a reference to it is returned. All indices between the current maximum and the given index are also filled with {\f2 null} .\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The special value {\f2 -}  is treated as a synonym for the index past the end.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ptr} \cell }{a JSON pointer\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the element pointed to by {\i ptr}  \par
}}@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.106} \cell }{if an array index begins with '0' \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.109} \cell }{if an array index was not a number \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.404} \cell }{if the JSON pointer can not be resolved\cell }
{\row }
}
@liveexample\{The behavior is shown in the example.,operatorjson_pointer\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 25591} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator[] (const {\b json_pointer} &  {\i ptr}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified element via JSON Pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Uses a JSON pointer to retrieve a reference to the respective JSON value. No bound checking is performed. The function does not change the JSON value; no {\f2 null}  values are created. In particular, the special value {\f2 -}  yields an exception.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ptr} \cell }{JSON pointer to the desired element\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const reference to the element pointed to by {\i ptr}  \par
}}@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.106} \cell }{if an array index begins with '0' \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.109} \cell }{if an array index was not a number \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.402} \cell }{if the array index '-' is used \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.404} \cell }{if the JSON pointer can not be resolved\cell }
{\row }
}
@liveexample\{The behavior is shown in the example.,operatorjson_pointer_const\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 25619} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator[] (const typename object_t::key_type &  {\i key}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the element at with specified key {\i key} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If {\i key}  is not found in the object, then it is silently added to the object and filled with a {\f2 null}  value to make {\f2 key}  a valid reference. In case the value was {\f2 null}  before, it is converted to an object.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key of the element to access\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the element at key {\i key}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.305} \cell }{if the JSON value is not an object or null; in that cases, using the [] operator with a key makes no sense.\cell }
{\row }
}
@complexity Logarithmic in the size of the container.\par
@liveexample\{The example below shows how object elements can be read and written using the {\f2 []}  operator.,operatorarray__key_type\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b at(const typename object_t::key_type&)} for access by {\b reference} with range checking \par
see {\b value()} for access by {\b value} with a default {\b value}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21177} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator[] (const typename object_t::key_type &  {\i key}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
read-only access specified object element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const reference to the element at with specified key {\i key} . No bounds checking is performed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If the element with key {\i key}  does not exist, the behavior is undefined.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key of the element to access\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const reference to the element at key {\i key}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The element with key {\i key}  must exist. {\b This precondition is enforced with an assertion.} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.305} \cell }{if the JSON value is not an object; in that case, using the [] operator with a key makes no sense.\cell }
{\row }
}
@complexity Logarithmic in the size of the container.\par
@liveexample\{The example below shows how object elements can be read using the {\f2 []}  operator.,operatorarray__key_type_const\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b at(const typename object_t::key_type&)} for access by {\b reference} with range checking \par
see {\b value()} for access by {\b value} with a default {\b value}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21226} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator[] ({\b size_type}  {\i idx}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified array element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the element at specified location {\i idx} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If {\i idx}  is beyond the range of the array (i.e., {\f2 idx >= {\b size()}} ), then the array is silently filled up with {\f2 null}  values to make {\f2 idx}  a valid reference to the last stored element.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i idx} \cell }{index of the element to access\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the element at index {\i idx}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.305} \cell }{if the JSON value is not an array or null; in that cases, using the [] operator with an index makes no sense.\cell }
{\row }
}
@complexity Constant if {\i idx}  is in the range of the array. Otherwise linear in {\f2 idx - {\b size()}} .\par
@liveexample\{The example below shows how array elements can be read and written using {\f2 []}  operator. Note the addition of {\f2 null}  values.,operatorarray__size_type\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21086} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator[] ({\b size_type}  {\i idx}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified array element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const reference to the element at specified location {\i idx} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i idx} \cell }{index of the element to access\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const reference to the element at index {\i idx}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.305} \cell }{if the JSON value is not an array; in that case, using the [] operator with an index makes no sense.\cell }
{\row }
}
@complexity Constant.\par
@liveexample\{The example below shows how array elements can be read using the {\f2 []}  operator.,operatorarray__size_type_const\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21139} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename T > {\b reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator[] (T *  {\i key}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the element at with specified key {\i key} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If {\i key}  is not found in the object, then it is silently added to the object and filled with a {\f2 null}  value to make {\f2 key}  a valid reference. In case the value was {\f2 null}  before, it is converted to an object.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key of the element to access\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
reference to the element at key {\i key}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.305} \cell }{if the JSON value is not an object or null; in that cases, using the [] operator with a key makes no sense.\cell }
{\row }
}
@complexity Logarithmic in the size of the container.\par
@liveexample\{The example below shows how object elements can be read and written using the {\f2 []}  operator.,operatorarray__key_type\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b at(const typename object_t::key_type&)} for access by {\b reference} with range checking \par
see {\b value()} for access by {\b value} with a default {\b value}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.1.0 \par
}}}{
Definition at line {\b 21267} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename T > {\b const_reference} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::operator[] (T *  {\i key}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
read-only access specified object element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const reference to the element at with specified key {\i key} . No bounds checking is performed.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
If the element with key {\i key}  does not exist, the behavior is undefined.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key of the element to access\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const reference to the element at key {\i key}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The element with key {\i key}  must exist. {\b This precondition is enforced with an assertion.} \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.305} \cell }{if the JSON value is not an object; in that case, using the [] operator with a key makes no sense.\cell }
{\row }
}
@complexity Logarithmic in the size of the container.\par
@liveexample\{The example below shows how object elements can be read using the {\f2 []}  operator.,operatorarray__key_type_const\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b at(const typename object_t::key_type&)} for access by {\b reference} with range checking \par
see {\b value()} for access by {\b value} with a default {\b value}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.1.0 \par
}}}{
Definition at line {\b 21318} of file {\b json.hpp}.}\par
}
{\xe \v parse\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::parse ({\b detail::span_input_adapter} &&  {\i i}, const {\b parser_callback_t}  {\i cb} = {\f2 nullptr}, const bool  {\i allow_exceptions} = {\f2 true}, const bool  {\i ignore_comments} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24337} of file {\b json.hpp}.}\par
}
{\xe \v parse\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename InputType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::parse (InputType &&  {\i i}, const {\b parser_callback_t}  {\i cb} = {\f2 nullptr}, const bool  {\i allow_exceptions} = {\f2 true}, const bool  {\i ignore_comments} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialize from a compatible input }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i InputType} \cell }{A compatible input, for instance{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
an std::istream object\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
a FILE pointer\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
a C-style array of characters\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
a pointer to a null-terminated string of single byte characters\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
an object obj for which begin(obj) and end(obj) produces a valid pair of iterators.\par}
\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{input to read from \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cb} \cell }{a parser callback function of type {\b parser_callback_t} which is used to control the deserialization by filtering unwanted values (optional) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i allow_exceptions} \cell }{whether to throw exceptions in case of a parse error (optional, true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ignore_comments} \cell }{whether comments should be ignored and treated like whitespace (true) or yield a parse error (true); (optional, false by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
deserialized JSON value; in case of a parse error and {\i allow_exceptions}  set to {\f2 false} , the return value will be {\b value_t::discarded}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.101} \cell }{if a parse error occurs; example: {\f2 ""unexpected end of input; expected string literal""}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.102} \cell }{if to_unicode fails or surrogate error \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.103} \cell }{if to_unicode fails\cell }
{\row }
}
@complexity Linear in the length of the input. The parser is a predictive LL(1) parser. The complexity can be higher if the parser callback function {\i cb}  or reading from the input {\i i}  has a super-linear complexity.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A UTF-8 byte order mark is silently ignored.\par
}}@liveexample\{The example below demonstrates the {\f2 {\b parse()}}  function reading from an array.,parse__array__parser_callback_t\}\par
@liveexample\{The example below demonstrates the {\f2 {\b parse()}}  function with and without callback function.,parse__string__parser_callback_t\}\par
@liveexample\{The example below demonstrates the {\f2 {\b parse()}}  function with and without callback function.,parse__istream__parser_callback_t\}\par
@liveexample\{The example below demonstrates the {\f2 {\b parse()}}  function reading from a contiguous container.,parse__contiguouscontainer__parser_callback_t\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.3 (contiguous containers); version 3.9.0 allowed to ignore comments. \par
}}}{
Definition at line {\b 24286} of file {\b json.hpp}.}\par
}
{\xe \v parse\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename IteratorType > static {\b JSON_HEDLEY_WARN_UNUSED_RESULT} {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::parse (IteratorType  {\i first}, IteratorType  {\i last}, const {\b parser_callback_t}  {\i cb} = {\f2 nullptr}, const bool  {\i allow_exceptions} = {\f2 true}, const bool  {\i ignore_comments} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialize from a pair of character iterators }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The value_type of the iterator must be a integral type with size of 1, 2 or 4 bytes, which will be interpreted respectively as UTF-8, UTF-16 and UTF-32.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i first} \cell }{iterator to start of character range \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i last} \cell }{iterator to end of character range \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i cb} \cell }{a parser callback function of type {\b parser_callback_t} which is used to control the deserialization by filtering unwanted values (optional) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i allow_exceptions} \cell }{whether to throw exceptions in case of a parse error (optional, true by default) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ignore_comments} \cell }{whether comments should be ignored and treated like whitespace (true) or yield a parse error (true); (optional, false by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
deserialized JSON value; in case of a parse error and {\i allow_exceptions}  set to {\f2 false} , the return value will be {\b value_t::discarded}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.101} \cell }{if a parse error occurs; example: {\f2 ""unexpected end of input; expected string literal""}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.102} \cell }{if to_unicode fails or surrogate error \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.103} \cell }{if to_unicode fails \cell }
{\row }
}
}{
Definition at line {\b 24324} of file {\b json.hpp}.}\par
}
{\xe \v patch\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:patch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::patch (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i json_patch}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
applies a JSON patch }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\f2 JSON Patch} defines a JSON document structure for expressing a sequence of operations to apply to a JSON) document. With this function, a JSON Patch is applied to the current JSON value by executing all operations from the patch.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i json_patch} \cell }{JSON patch document \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
patched document\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The application of a patch is atomic: Either all operations succeed and the patched document is returned or an exception is thrown. In any case, the original value is not changed: the patch is applied to a copy of the value.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.104} \cell }{if the JSON patch does not consist of an array of objects\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.105} \cell }{if the JSON patch is malformed (e.g., mandatory attributes are missing); example: {\f2 "operation add must have member path"} \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.401} \cell }{if an array index is out of range.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.403} \cell }{if a JSON pointer inside the patch could not be resolved successfully in the current JSON value; example: {\f2 "key baz not
found"} \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.405} \cell }{if JSON pointer has no parent ("add", "remove", "move")\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other_error.501} \cell }{if "test" operation was unsuccessful\cell }
{\row }
}
@complexity Linear in the size of the JSON value and the length of the JSON patch. As usually only a fraction of the JSON value is affected by the patch, the complexity can usually be neglected.\par
@liveexample\{The following code shows how a JSON patch is applied to a value.,patch\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b diff} \'96 create a JSON {\b patch} by comparing two JSON values\par
{\f2 RFC 6902 (JSON Patch)} \par
{\f2 RFC 6901 (JSON Pointer)}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 25830} of file {\b json.hpp}.}\par
}
{\xe \v push_back\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::push_back ({\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &&  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Appends the given element {\i val}  to the end of the JSON value. If the function is called on a JSON null value, an empty array is created before appending {\i val} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{the value to add to the JSON array\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.308} \cell }{when called on a type other than JSON array or null; example: {\f2 "cannot use push_back() with number"} \cell }
{\row }
}
@complexity Amortized constant.\par
@liveexample\{The example shows how {\f2 {\b push_back()}}  and {\f2 +=}  can be used to add elements to a JSON array. Note how the {\f2 null}  value was silently converted to a JSON array.,push_back\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22846} of file {\b json.hpp}.}\par
}
{\xe \v push_back\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::push_back (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an array Appends the given element {\i val}  to the end of the JSON value. If the function is called on a JSON null value, an empty array is created before appending {\i val} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{the value to add to the JSON array\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.308} \cell }{when called on a type other than JSON array or null; example: {\f2 "cannot use push_back() with number"} \cell }
{\row }
}
@complexity Amortized constant.\par
@liveexample\{The example shows how {\f2 {\b push_back()}}  and {\f2 +=}  can be used to add elements to a JSON array. Note how the {\f2 null}  value was silently converted to a JSON array.,push_back\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22883} of file {\b json.hpp}.}\par
}
{\xe \v push_back\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::push_back (const typename object_t::value_type &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts the given element {\i val}  to the JSON object. If the function is called on a JSON null value, an empty object is created before inserting {\i val} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{the value to add to the JSON object\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.308} \cell }{when called on a type other than JSON object or null; example: {\f2 "cannot use push_back() with number"} \cell }
{\row }
}
@complexity Logarithmic in the size of the container, O(log({\f2 {\b size()}} )).\par
@liveexample\{The example shows how {\f2 {\b push_back()}}  and {\f2 +=}  can be used to add elements to a JSON object. Note how the {\f2 null}  value was silently converted to a JSON object.,push_back__object_t__value\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22935} of file {\b json.hpp}.}\par
}
{\xe \v push_back\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::push_back ({\b initializer_list_t}  {\i init}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add an object to an object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function allows to use {\f2 push_back}  with an initializer list. In case\par
{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab the current value is an object,\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab the initializer list {\i init}  contains only two elements, and\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab the first element of {\i init}  is a string,\par}
{\i init}  is converted into an object element and added using {\b push_back(const typename object_t::value_type&)}. Otherwise, {\i init}  is converted to a JSON value and added using {\b push_back(basic_json&&)}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i init} \cell }{an initializer list\cell }
{\row }
}
@complexity Linear in the size of the initializer list {\i init} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This function is required to resolve an ambiguous overload error, because pairs like {\f2 \{"key", "value"\}}  can be both interpreted as {\f2 object_t::value_type}  or {\f2 std::initializer_list<{\b basic_json}>} , see {\f2 https://github.com/nlohmann/json/issues/235} for more information.\par
}}@liveexample\{The example shows how initializer lists are treated as objects when possible.,push_back__initializer_list\} \par
}{
Definition at line {\b 22991} of file {\b json.hpp}.}\par
}
{\xe \v rbegin\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:rbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reverse_iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::rbegin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const reverse iterator to the last element }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const iterator to the reverse-beginning; that is, the last element.\par
@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 ReversibleContainer} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 const_cast<const {\b basic_json}&>(*this).{\b rbegin()}} .\par}
@liveexample\{The following code shows an example for {\f2 {\b crbegin()}} .,crbegin\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b rbegin()} \'96 returns a reverse {\b iterator} to the beginning \par
see {\b rend()} \'96 returns a reverse {\b iterator} to the {\b end} \par
see {\b crend()} \'96 returns a const reverse {\b iterator} to the {\b end}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22224} of file {\b json.hpp}.}\par
}
{\xe \v rbegin\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:rbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reverse_iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::rbegin (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns an iterator to the reverse-beginning }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an iterator to the reverse-beginning; that is, the last element.\par
@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 ReversibleContainer} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 reverse_iterator(end())} .\par}
@liveexample\{The following code shows an example for {\f2 {\b rbegin()}} .,rbegin\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b crbegin()} \'96 returns a const reverse {\b iterator} to the beginning \par
see {\b rend()} \'96 returns a reverse {\b iterator} to the {\b end} \par
see {\b crend()} \'96 returns a const reverse {\b iterator} to the {\b end}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22216} of file {\b json.hpp}.}\par
}
{\xe \v rend\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:rend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b const_reverse_iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::rend () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns a const reverse iterator to one before the first }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a const reverse iterator to the reverse-end; that is, one before the first element.\par
@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 ReversibleContainer} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 const_cast<const {\b basic_json}&>(*this).{\b rend()}} .\par}
@liveexample\{The following code shows an example for {\f2 {\b crend()}} .,crend\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b rend()} \'96 returns a reverse {\b iterator} to the {\b end} \par
see {\b rbegin()} \'96 returns a reverse {\b iterator} to the beginning \par
see {\b crbegin()} \'96 returns a const reverse {\b iterator} to the beginning\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22261} of file {\b json.hpp}.}\par
}
{\xe \v rend\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:rend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b reverse_iterator} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::rend (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns an iterator to the reverse-end }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an iterator to the reverse-end; that is, one before the first element.\par
@complexity Constant.\par
@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 ReversibleContainer} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 reverse_iterator(begin())} .\par}
@liveexample\{The following code shows an example for {\f2 {\b rend()}} .,rend\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b crend()} \'96 returns a const reverse {\b iterator} to the {\b end} \par
see {\b rbegin()} \'96 returns a reverse {\b iterator} to the beginning \par
see {\b crbegin()} \'96 returns a const reverse {\b iterator} to the beginning\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22253} of file {\b json.hpp}.}\par
}
{\xe \v sax_parse\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:sax_parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename SAX > static bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::sax_parse ({\b detail::span_input_adapter} &&  {\i i}, SAX *  {\i sax}, {\b input_format_t}  {\i format} = {\f2 {\b input_format_t::json}}, const bool  {\i strict} = {\f2 true}, const bool  {\i ignore_comments} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24468} of file {\b json.hpp}.}\par
}
{\xe \v sax_parse\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:sax_parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename InputType , typename SAX > static bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::sax_parse (InputType &&  {\i i}, SAX *  {\i sax}, {\b input_format_t}  {\i format} = {\f2 {\b input_format_t::json}}, const bool  {\i strict} = {\f2 true}, const bool  {\i ignore_comments} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
generate SAX events }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The SAX event lister must follow the interface of {\b json_sax}.\par
This function reads from a compatible input. Examples are:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
an std::istream object\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
a FILE pointer\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
a C-style array of characters\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
a pointer to a null-terminated string of single byte characters\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
an object obj for which begin(obj) and end(obj) produces a valid pair of iterators.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i i} \cell }{input to read from \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i sax} \cell }{SAX event listener \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i format} \cell }{the format to parse (JSON, CBOR, MessagePack, or UBJSON) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether the input has to be consumed completely \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ignore_comments} \cell }{whether comments should be ignored and treated like whitespace (true) or yield a parse error (true); (optional, false by default); only applies to the JSON file format.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
return value of the last processed SAX event\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.101} \cell }{if a parse error occurs; example: {\f2 ""unexpected end of input; expected string literal""}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.102} \cell }{if to_unicode fails or surrogate error \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.103} \cell }{if to_unicode fails\cell }
{\row }
}
@complexity Linear in the length of the input. The parser is a predictive LL(1) parser. The complexity can be higher if the SAX consumer {\i sax}  has a super-linear complexity.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A UTF-8 byte order mark is silently ignored.\par
}}@liveexample\{The example below demonstrates the {\f2 {\b sax_parse()}}  function reading from string and processing the events with a user-defined SAX event consumer.,sax_parse\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.2.0 \par
}}}{
Definition at line {\b 24441} of file {\b json.hpp}.}\par
}
{\xe \v sax_parse\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:sax_parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<class IteratorType , class SAX > static bool {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::sax_parse (IteratorType  {\i first}, IteratorType  {\i last}, SAX *  {\i sax}, {\b input_format_t}  {\i format} = {\f2 {\b input_format_t::json}}, const bool  {\i strict} = {\f2 true}, const bool  {\i ignore_comments} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24454} of file {\b json.hpp}.}\par
}
{\xe \v size\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b size_type} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::size () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the number of elements }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of elements in a JSON value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The return value depends on the different types and is defined as follows: \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Value type   \cell }{return value    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 0}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 1}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\f2 1}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number   \cell }{{\f2 1}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\f2 1}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{result of function object_t::size()    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{result of function array_t::size()   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}@liveexample\{The following code calls {\f2 {\b size()}}  on the different value types.,size\}\par
@complexity Constant, as long as {\b array_t} and {\b object_t} satisfy the Container concept; that is, their {\b size()} functions have constant complexity.\par
@iterators No changes.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This function does not return the length of a string stored as JSON value - it returns the number of elements in the JSON value which is 1 in the case of a string.\par
}}@requirement This function helps {\f2 {\b basic_json}}  satisfying the {\f2 Container} requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The complexity is constant.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Has the semantics of {\f2 std::distance({\b begin()}, {\b end()})} .\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b empty()} \'96 checks whether the container is {\b empty} \par
see {\b max_size()} \'96 returns the maximal number of elements\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 22610} of file {\b json.hpp}.}\par
}
{\xe \v swap\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::swap ({\b array_t} &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exchanges the contents of a JSON array with those of {\i other} . Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i other} \cell }{array to exchange the contents with\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.310} \cell }{when JSON value is not an array; example: {\f2 "cannot
use swap() with string"} \cell }
{\row }
}
@complexity Constant.\par
@liveexample\{The example below shows how arrays can be swapped with {\f2 {\b swap()}} .,swap__array_t\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23560} of file {\b json.hpp}.}\par
}
{\xe \v swap\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::swap ({\b binary_t} &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exchanges the contents of a JSON string with those of {\i other} . Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i other} \cell }{binary to exchange the contents with\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.310} \cell }{when JSON value is not a string; example: {\f2 "cannot
use swap() with boolean"} \cell }
{\row }
}
@complexity Constant.\par
@liveexample\{The example below shows how strings can be swapped with {\f2 {\b swap()}} .,swap__binary_t\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 23659} of file {\b json.hpp}.}\par
}
{\xe \v swap\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::swap ({\b object_t} &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exchanges the contents of a JSON object with those of {\i other} . Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i other} \cell }{object to exchange the contents with\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.310} \cell }{when JSON value is not an object; example: {\f2 "cannot use swap() with string"} \cell }
{\row }
}
@complexity Constant.\par
@liveexample\{The example below shows how objects can be swapped with {\f2 {\b swap()}} .,swap__object_t\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23593} of file {\b json.hpp}.}\par
}
{\xe \v swap\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::swap ({\b reference}  {\i other}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exchanges the contents of the JSON value with those of {\i other} . Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i other} \cell }{JSON value to exchange the contents with\cell }
{\row }
}
@complexity Constant.\par
@liveexample\{The example below shows how JSON values can be swapped with {\f2 {\b swap()}} .,swap__reference\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23497} of file {\b json.hpp}.}\par
}
{\xe \v swap\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::swap ({\b string_t} &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exchanges the contents of a JSON string with those of {\i other} . Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i other} \cell }{string to exchange the contents with\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.310} \cell }{when JSON value is not a string; example: {\f2 "cannot
use swap() with boolean"} \cell }
{\row }
}
@complexity Constant.\par
@liveexample\{The example below shows how strings can be swapped with {\f2 {\b swap()}} .,swap__string_t\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23626} of file {\b json.hpp}.}\par
}
{\xe \v swap\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::swap (typename {\b binary_t::container_type} &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exchanges the contents of a JSON string with those of {\i other} . Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i other} \cell }{binary to exchange the contents with\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.310} \cell }{when JSON value is not a string; example: {\f2 "cannot
use swap() with boolean"} \cell }
{\row }
}
@complexity Constant.\par
@liveexample\{The example below shows how strings can be swapped with {\f2 {\b swap()}} .,swap__binary_t\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 23673} of file {\b json.hpp}.}\par
}
{\xe \v to_bson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_bson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static std::vector< std::uint8_t > {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_bson (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serializes the given JSON object {\f2 j}  to BSON and returns a vector containing the corresponding BSON-representation. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BSON (Binary JSON) is a binary format in which zero or more ordered key/value pairs are stored as a single entity (a so-called document).\par
The library uses the following mapping from JSON values types to BSON types:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{JSON value type   \cell }{value/range   \cell }{BSON type   \cell }{marker    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 null}    \cell }{null   \cell }{0x0A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 true} , {\f2 false}    \cell }{boolean   \cell }{0x08    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-9223372036854775808..-2147483649   \cell }{int64   \cell }{0x12    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-2147483648..2147483647   \cell }{int32   \cell }{0x10    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{2147483648..9223372036854775807   \cell }{int64   \cell }{0x12    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{0..2147483647   \cell }{int32   \cell }{0x10    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{2147483648..9223372036854775807   \cell }{int64   \cell }{0x12    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{9223372036854775808..18446744073709551615   \cell }{\'96   \cell }{\'96    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_float   \cell }{{\i any value}    \cell }{double   \cell }{0x01    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\i any value}    \cell }{string   \cell }{0x02    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\i any value}    \cell }{document   \cell }{0x04    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\i any value}    \cell }{document   \cell }{0x03    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\i any value}    \cell }{binary   \cell }{0x05   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Warning\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The mapping is {\b incomplete} , since only JSON-objects (and things contained therein) can be serialized to BSON. Also, integers larger than 9223372036854775807 cannot be serialized to BSON, and the keys may not contain U+0000, since they are serialized a zero-terminated c-strings.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.407} \cell }{if {\f2 j.is_number_unsigned() && j.get<std::uint64_t>() > 9223372036854775807}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.409} \cell }{if a key in {\f2 j}  contains a NULL (U+0000) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.317} \cell }{if {\f2 !j.{\b is_object()}} \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The input {\f2 j}  is required to be an object: {\f2 j.is_object() == true} .\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Any BSON output created via {\b to_bson} can be successfully parsed by {\b from_bson}.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON value to serialize \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
BSON serialization as byte vector\par
}}@complexity Linear in the size of the JSON value {\i j} .\par
@liveexample\{The example shows the serialization of a JSON value to a byte vector in BSON format.,to_bson\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://bsonspec.org/spec.html} \par
see from_bson(detail::input_adapter&&, const bool strict) for the analogous deserialization \par
see {\b to_ubjson(const basic_json&, const bool, const bool)} for the related UBJSON format \par
see {\b to_cbor(const basic_json&)} for the related CBOR format \par
see {\b to_msgpack(const basic_json&)} for the related MessagePack format \par
}}}{
Definition at line {\b 24991} of file {\b json.hpp}.}\par
}
{\xe \v to_bson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_bson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_bson (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}, {\b detail::output_adapter}< char >  {\i o}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serializes the given JSON object {\f2 j}  to BSON and forwards the corresponding BSON-representation to the given output_adapter {\f2 o} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i j} \cell }{The JSON object to convert to BSON. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i o} \cell }{The output adapter that receives the binary BSON representation. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The input {\f2 j}  shall be an object: {\f2 j.is_object() == true}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b to_bson(const basic_json&)} \par
}}}{
Definition at line {\b 25014} of file {\b json.hpp}.}\par
}
{\xe \v to_bson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_bson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_bson (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}, {\b detail::output_adapter}< std::uint8_t >  {\i o}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serializes the given JSON object {\f2 j}  to BSON and forwards the corresponding BSON-representation to the given output_adapter {\f2 o} . }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i j} \cell }{The JSON object to convert to BSON. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i o} \cell }{The output adapter that receives the binary BSON representation. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The input {\f2 j}  shall be an object: {\f2 j.is_object() == true}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b to_bson(const basic_json&)} \par
}}}{
Definition at line {\b 25006} of file {\b json.hpp}.}\par
}
{\xe \v to_cbor\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_cbor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static std::vector< std::uint8_t > {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_cbor (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a CBOR serialization of a given JSON value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serializes a given JSON value {\i j}  to a byte vector using the CBOR (Concise Binary Object Representation) serialization format. CBOR is a binary serialization format which aims to be more compact than JSON itself, yet more efficient to parse.\par
The library uses the following mapping from JSON values types to CBOR types according to the CBOR specification (RFC 7049):\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{JSON value type   \cell }{value/range   \cell }{CBOR type   \cell }{first byte    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 null}    \cell }{Null   \cell }{0xF6    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 true}    \cell }{True   \cell }{0xF5    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 false}    \cell }{False   \cell }{0xF4    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-9223372036854775808..-2147483649   \cell }{Negative integer (8 bytes follow)   \cell }{0x3B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-2147483648..-32769   \cell }{Negative integer (4 bytes follow)   \cell }{0x3A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-32768..-129   \cell }{Negative integer (2 bytes follow)   \cell }{0x39    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-128..-25   \cell }{Negative integer (1 byte follow)   \cell }{0x38    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-24..-1   \cell }{Negative integer   \cell }{0x20..0x37    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{0..23   \cell }{Integer   \cell }{0x00..0x17    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{24..255   \cell }{Unsigned integer (1 byte follow)   \cell }{0x18    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{256..65535   \cell }{Unsigned integer (2 bytes follow)   \cell }{0x19    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{65536..4294967295   \cell }{Unsigned integer (4 bytes follow)   \cell }{0x1A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{4294967296..18446744073709551615   \cell }{Unsigned integer (8 bytes follow)   \cell }{0x1B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{0..23   \cell }{Integer   \cell }{0x00..0x17    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{24..255   \cell }{Unsigned integer (1 byte follow)   \cell }{0x18    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{256..65535   \cell }{Unsigned integer (2 bytes follow)   \cell }{0x19    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{65536..4294967295   \cell }{Unsigned integer (4 bytes follow)   \cell }{0x1A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{4294967296..18446744073709551615   \cell }{Unsigned integer (8 bytes follow)   \cell }{0x1B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_float   \cell }{{\i any value representable by a float}    \cell }{Single-Precision Float   \cell }{0xFA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_float   \cell }{{\i any value NOT representable by a float}    \cell }{Double-Precision Float   \cell }{0xFB    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\i length} : 0..23   \cell }{UTF-8 string   \cell }{0x60..0x77    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\i length} : 23..255   \cell }{UTF-8 string (1 byte follow)   \cell }{0x78    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\i length} : 256..65535   \cell }{UTF-8 string (2 bytes follow)   \cell }{0x79    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\i length} : 65536..4294967295   \cell }{UTF-8 string (4 bytes follow)   \cell }{0x7A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\i length} : 4294967296..18446744073709551615   \cell }{UTF-8 string (8 bytes follow)   \cell }{0x7B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\i size} : 0..23   \cell }{array   \cell }{0x80..0x97    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\i size} : 23..255   \cell }{array (1 byte follow)   \cell }{0x98    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\i size} : 256..65535   \cell }{array (2 bytes follow)   \cell }{0x99    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\i size} : 65536..4294967295   \cell }{array (4 bytes follow)   \cell }{0x9A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\i size} : 4294967296..18446744073709551615   \cell }{array (8 bytes follow)   \cell }{0x9B    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\i size} : 0..23   \cell }{map   \cell }{0xA0..0xB7    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\i size} : 23..255   \cell }{map (1 byte follow)   \cell }{0xB8    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\i size} : 256..65535   \cell }{map (2 bytes follow)   \cell }{0xB9    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\i size} : 65536..4294967295   \cell }{map (4 bytes follow)   \cell }{0xBA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\i size} : 4294967296..18446744073709551615   \cell }{map (8 bytes follow)   \cell }{0xBB    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\i size} : 0..23   \cell }{byte string   \cell }{0x40..0x57    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\i size} : 23..255   \cell }{byte string (1 byte follow)   \cell }{0x58    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\i size} : 256..65535   \cell }{byte string (2 bytes follow)   \cell }{0x59    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\i size} : 65536..4294967295   \cell }{byte string (4 bytes follow)   \cell }{0x5A    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\i size} : 4294967296..18446744073709551615   \cell }{byte string (8 bytes follow)   \cell }{0x5B   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
Binary values with subtype are mapped to tagged values (0xD8..0xDB) depending on the subtype, followed by a byte string, see "binary" cells in the table above.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The mapping is {\b complete}  in the sense that any JSON value type can be converted to a CBOR value.\par
If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the {\b dump()} function which serializes NaN or Infinity to {\f2 null} .\par
The following CBOR types are not used in the conversion:{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
UTF-8 strings terminated by "break" (0x7F)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
arrays terminated by "break" (0x9F)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
maps terminated by "break" (0xBF)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte strings terminated by "break" (0x5F)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
date/time (0xC0..0xC1)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bignum (0xC2..0xC3)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
decimal fraction (0xC4)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bigfloat (0xC5)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
expected conversions (0xD5..0xD7)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
simple values (0xE0..0xF3, 0xF8)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
undefined (0xF7)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
half-precision floats (0xF9)\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
break (0xFF)\par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON value to serialize \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
CBOR serialization as byte vector\par
}}@complexity Linear in the size of the JSON value {\i j} .\par
@liveexample\{The example shows the serialization of a JSON value to a byte vector in CBOR format.,to_cbor\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://cbor.io} \par
see {\b from_cbor(InputType&&, const bool, const bool, const cbor_tag_handler_t)} for the analogous deserialization \par
see {\b to_msgpack(const basic_json&)} for the related MessagePack format \par
see {\b to_ubjson(const basic_json&, const bool, const bool)} for the related UBJSON format\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.9; compact representation of floating-point numbers since version 3.8.0 \par
}}}{
Definition at line {\b 24715} of file {\b json.hpp}.}\par
}
{\xe \v to_cbor\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_cbor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_cbor (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}, {\b detail::output_adapter}< char >  {\i o}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24727} of file {\b json.hpp}.}\par
}
{\xe \v to_cbor\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_cbor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_cbor (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}, {\b detail::output_adapter}< std::uint8_t >  {\i o}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24722} of file {\b json.hpp}.}\par
}
{\xe \v to_msgpack\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_msgpack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static std::vector< std::uint8_t > {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_msgpack (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a MessagePack serialization of a given JSON value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serializes a given JSON value {\i j}  to a byte vector using the MessagePack serialization format. MessagePack is a binary serialization format which aims to be more compact than JSON itself, yet more efficient to parse.\par
The library uses the following mapping from JSON values types to MessagePack types according to the MessagePack specification:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{JSON value type   \cell }{value/range   \cell }{MessagePack type   \cell }{first byte    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 null}    \cell }{nil   \cell }{0xC0    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 true}    \cell }{true   \cell }{0xC3    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 false}    \cell }{false   \cell }{0xC2    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-9223372036854775808..-2147483649   \cell }{int64   \cell }{0xD3    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-2147483648..-32769   \cell }{int32   \cell }{0xD2    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-32768..-129   \cell }{int16   \cell }{0xD1    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-128..-33   \cell }{int8   \cell }{0xD0    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-32..-1   \cell }{negative fixint   \cell }{0xE0..0xFF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{0..127   \cell }{positive fixint   \cell }{0x00..0x7F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{128..255   \cell }{uint 8   \cell }{0xCC    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{256..65535   \cell }{uint 16   \cell }{0xCD    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{65536..4294967295   \cell }{uint 32   \cell }{0xCE    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{4294967296..18446744073709551615   \cell }{uint 64   \cell }{0xCF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{0..127   \cell }{positive fixint   \cell }{0x00..0x7F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{128..255   \cell }{uint 8   \cell }{0xCC    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{256..65535   \cell }{uint 16   \cell }{0xCD    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{65536..4294967295   \cell }{uint 32   \cell }{0xCE    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{4294967296..18446744073709551615   \cell }{uint 64   \cell }{0xCF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_float   \cell }{{\i any value representable by a float}    \cell }{float 32   \cell }{0xCA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_float   \cell }{{\i any value NOT representable by a float}    \cell }{float 64   \cell }{0xCB    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\i length} : 0..31   \cell }{fixstr   \cell }{0xA0..0xBF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\i length} : 32..255   \cell }{str 8   \cell }{0xD9    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\i length} : 256..65535   \cell }{str 16   \cell }{0xDA    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\i length} : 65536..4294967295   \cell }{str 32   \cell }{0xDB    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\i size} : 0..15   \cell }{fixarray   \cell }{0x90..0x9F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\i size} : 16..65535   \cell }{array 16   \cell }{0xDC    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\i size} : 65536..4294967295   \cell }{array 32   \cell }{0xDD    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\i size} : 0..15   \cell }{fix map   \cell }{0x80..0x8F    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\i size} : 16..65535   \cell }{map 16   \cell }{0xDE    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\i size} : 65536..4294967295   \cell }{map 32   \cell }{0xDF    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\i size} : 0..255   \cell }{bin 8   \cell }{0xC4    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\i size} : 256..65535   \cell }{bin 16   \cell }{0xC5    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\i size} : 65536..4294967295   \cell }{bin 32   \cell }{0xC6   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The mapping is {\b complete}  in the sense that any JSON value type can be converted to a MessagePack value.\par
The following values can {\b not}  be converted to a MessagePack value:{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
strings with more than 4294967295 bytes\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
byte strings with more than 4294967295 bytes\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
arrays with more than 4294967295 elements\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
objects with more than 4294967295 elements\par}
Any MessagePack output created {\b to_msgpack} can be successfully parsed by {\b from_msgpack}.\par
If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the {\b dump()} function which serializes NaN or Infinity to {\f2 null} .\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON value to serialize \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
MessagePack serialization as byte vector\par
}}@complexity Linear in the size of the JSON value {\i j} .\par
@liveexample\{The example shows the serialization of a JSON value to a byte vector in MessagePack format.,to_msgpack\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://msgpack.org} \par
see {\b from_msgpack} for the analogous deserialization \par
see {\b to_cbor}(const {\b basic_json}& for the related CBOR format \par
see {\b to_ubjson(const basic_json&, const bool, const bool)} for the related UBJSON format\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.9 \par
}}}{
Definition at line {\b 24810} of file {\b json.hpp}.}\par
}
{\xe \v to_msgpack\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_msgpack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_msgpack (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}, {\b detail::output_adapter}< char >  {\i o}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24822} of file {\b json.hpp}.}\par
}
{\xe \v to_msgpack\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_msgpack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_msgpack (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}, {\b detail::output_adapter}< std::uint8_t >  {\i o}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24817} of file {\b json.hpp}.}\par
}
{\xe \v to_ubjson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_ubjson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static std::vector< std::uint8_t > {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_ubjson (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}, const bool  {\i use_size} = {\f2 false}, const bool  {\i use_type} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a UBJSON serialization of a given JSON value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serializes a given JSON value {\i j}  to a byte vector using the UBJSON (Universal Binary JSON) serialization format. UBJSON aims to be more compact than JSON itself, yet more efficient to parse.\par
The library uses the following mapping from JSON values types to UBJSON types according to the UBJSON specification:\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{JSON value type   \cell }{value/range   \cell }{UBJSON type   \cell }{marker    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 null}    \cell }{null   \cell }{{\f2 Z}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 true}    \cell }{true   \cell }{{\f2 T}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 false}    \cell }{false   \cell }{{\f2 F}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-9223372036854775808..-2147483649   \cell }{int64   \cell }{{\f2 L}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-2147483648..-32769   \cell }{int32   \cell }{{\f2 l}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-32768..-129   \cell }{int16   \cell }{{\f2 I}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{-128..127   \cell }{int8   \cell }{{\f2 i}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{128..255   \cell }{uint8   \cell }{{\f2 U}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{256..32767   \cell }{int16   \cell }{{\f2 I}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{32768..2147483647   \cell }{int32   \cell }{{\f2 l}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_integer   \cell }{2147483648..9223372036854775807   \cell }{int64   \cell }{{\f2 L}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{0..127   \cell }{int8   \cell }{{\f2 i}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{128..255   \cell }{uint8   \cell }{{\f2 U}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{256..32767   \cell }{int16   \cell }{{\f2 I}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{32768..2147483647   \cell }{int32   \cell }{{\f2 l}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{2147483648..9223372036854775807   \cell }{int64   \cell }{{\f2 L}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_unsigned   \cell }{2147483649..18446744073709551615   \cell }{high-precision   \cell }{{\f2 H}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number_float   \cell }{{\i any value}    \cell }{float64   \cell }{{\f2 D}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\i with shortest length indicator}    \cell }{string   \cell }{{\f2 S}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\i see notes on optimized format}    \cell }{array   \cell }{{\f2 [}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx6561
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\i see notes on optimized format}    \cell }{map   \cell }{{\f2 \{}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The mapping is {\b complete}  in the sense that any JSON value type can be converted to a UBJSON value.\par
The following values can {\b not}  be converted to a UBJSON value:{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
strings with more than 9223372036854775807 bytes (theoretical)\par}
The following markers are not used in the conversion:{
\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 Z} : no-op values are not created.\par
\pard\plain \s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 C} : single-byte strings are serialized with {\f2 S}  markers.\par}
Any UBJSON output created {\b to_ubjson} can be successfully parsed by {\b from_ubjson}.\par
If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the {\b dump()} function which serializes NaN or Infinity to {\f2 null} .\par
The optimized formats for containers are supported: Parameter {\i use_size}  adds size information to the beginning of a container and removes the closing marker. Parameter {\i use_type}  further checks whether all elements of a container have the same type and adds the type marker to the beginning of the container. The {\i use_type}  parameter must only be used together with {\i use_size}  = true. Note that {\i use_size}  = true alone may result in larger representations - the benefit of this parameter is that the receiving side is immediately informed on the number of elements of the container.\par
If the JSON data contains the binary type, the value stored is a list of integers, as suggested by the UBJSON documentation. In particular, this means that serialization and the deserialization of a JSON containing binary values into UBJSON and back will result in a different JSON object.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON value to serialize \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i use_size} \cell }{whether to add size annotations to container types \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i use_type} \cell }{whether to add type annotations to container types (must be combined with {\i use_size}  = true) \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
UBJSON serialization as byte vector\par
}}@complexity Linear in the size of the JSON value {\i j} .\par
@liveexample\{The example shows the serialization of a JSON value to a byte vector in UBJSON format.,to_ubjson\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 http://ubjson.org} \par
see {\b from_ubjson(InputType&&, const bool, const bool)} for the analogous deserialization \par
see {\b to_cbor}(const {\b basic_json}& for the related CBOR format \par
see {\b to_msgpack(const basic_json&)} for the related MessagePack format\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.1.0 \par
}}}{
Definition at line {\b 24913} of file {\b json.hpp}.}\par
}
{\xe \v to_ubjson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_ubjson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_ubjson (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}, {\b detail::output_adapter}< char >  {\i o}, const bool  {\i use_size} = {\f2 false}, const bool  {\i use_type} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24928} of file {\b json.hpp}.}\par
}
{\xe \v to_ubjson\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:to_ubjson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> static void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::to_ubjson (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}, {\b detail::output_adapter}< std::uint8_t >  {\i o}, const bool  {\i use_size} = {\f2 false}, const bool  {\i use_type} = {\f2 false}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24922} of file {\b json.hpp}.}\par
}
{\xe \v type\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> constexpr {\b value_t} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::type () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the type of the JSON value (explicit) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the type of the JSON value as a value from the {\b value_t} enumeration.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the type of the JSON value \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Value type   \cell }{return value    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\b value_t::null}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\b value_t::boolean}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\b value_t::string}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number (integer)   \cell }{{\b value_t::number_integer}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number (unsigned integer)   \cell }{{\b value_t::number_unsigned}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number (floating-point)   \cell }{{\b value_t::number_float}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\b value_t::object}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\b value_t::array}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\b value_t::binary}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{discarded   \cell }{{\b value_t::discarded}   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
@liveexample\{The following code exemplifies {\f2 {\b type()}}  for all JSON types.,type\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b operator value_t()} \'96 return the {\b type} of the JSON {\b value} (implicit) \par
see {\b type_name()} \'96 return the {\b type} as string\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 19876} of file {\b json.hpp}.}\par
}
{\xe \v type_name\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:type_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b JSON_HEDLEY_RETURNS_NON_NULL} const char * {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::type_name () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the type as string }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the type name as string to be used in error messages - usually to indicate that a function was called on a wrong JSON type.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a string representation of a the {\i m_type}  member: \par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{Value type   \cell }{return value    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{null   \cell }{{\f2 "null"}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{boolean   \cell }{{\f2 "boolean"}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{string   \cell }{{\f2 "string"}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{number   \cell }{{\f2 "number"}  (for all number types)    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{object   \cell }{{\f2 "object"}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{array   \cell }{{\f2 "array"}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{binary   \cell }{{\f2 "binary"}     \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx4374
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{discarded   \cell }{{\f2 "discarded"}    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
}}@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@complexity Constant.\par
@liveexample\{The following code exemplifies {\f2 {\b type_name()}}  for all JSON types.,type_name\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b type()} \'96 return the {\b type} of the JSON {\b value} \par
see {\b operator value_t()} \'96 return the {\b type} of the JSON {\b value} (implicit)\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0, public since 2.1.0, {\f2 const char*}  and {\f2 noexcept}  since 3.0.0 \par
}}}{
Definition at line {\b 24564} of file {\b json.hpp}.}\par
}
{\xe \v unflatten\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:unflatten}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b basic_json} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::unflatten () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
unflatten a previously flattened JSON value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function restores the arbitrary nesting of a JSON value that has been flattened before using the {\b flatten()} function. The JSON value must meet certain constraints:{
\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab The value must be an object.\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab The keys must be JSON pointers (see {\f2 RFC 6901})\par
\pard\plain \s141\fi-360\li720\widctlpar\fs20\cgrid 
3.\tab The mapped values must be primitive JSON types.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the original JSON from a flattened version\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Empty objects and arrays are flattened by {\b flatten()} to {\f2 null}  values and can not unflattened to their original type. Apart from this example, for a JSON value {\f2 j} , the following is always true: {\f2 j == j.flatten().{\b unflatten()}} .\par
}}@complexity Linear in the size the JSON value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.314} \cell }{if value is not an object \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.315} \cell }{if object values are not primitive\cell }
{\row }
}
@liveexample\{The following code shows how a flattened JSON object is unflattened into the original nested JSON object.,unflatten\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b flatten()} for the reverse function\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 25769} of file {\b json.hpp}.}\par
}
{\xe \v update\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::update ({\b const_iterator}  {\i first}, {\b const_iterator}  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
updates a JSON object from another object, overwriting existing keys }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts all values from from range {\f2 [first, last)}  and overwrites existing keys.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i first} \cell }{begin of the range of elements to insert \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i last} \cell }{end of the range of elements to insert\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.312} \cell }{if called on JSON values other than objects; example: {\f2 "cannot use update() with string"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.202} \cell }{if iterator {\i first}  or {\i last}  does does not point to an object; example: {\f2 "iterators first and last must point to
objects"}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i invalid_iterator.210} \cell }{if {\i first}  and {\i last}  do not belong to the same JSON value; example: {\f2 "iterators do not fit"} \cell }
{\row }
}
@complexity O(N*log({\b size()} + N)), where N is the number of elements to insert.\par
@liveexample\{The example shows how {\f2 {\b update()}}  is used__range.,update\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://docs.python.org/3.6/library/stdtypes.html#dict.update}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 23446} of file {\b json.hpp}.}\par
}
{\xe \v update\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::update ({\b const_reference}  {\i j}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
updates a JSON object from another object, overwriting existing keys }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Inserts all values from JSON object {\i j}  and overwrites existing keys.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON object to read values from\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.312} \cell }{if called on JSON values other than objects; example: {\f2 "cannot use update() with string"} \cell }
{\row }
}
@complexity O(N*log({\b size()} + N)), where N is the number of elements to insert.\par
@liveexample\{The example shows how {\f2 {\b update()}}  is used.,update\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 https://docs.python.org/3.6/library/stdtypes.html#dict.update}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 23395} of file {\b json.hpp}.}\par
}
{\xe \v value\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b string_t} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::value (const {\b json_pointer} &  {\i ptr}, const char *  {\i default_value}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
overload for a default value of type const char* }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definition at line {\b 21480} of file {\b json.hpp}.}\par
}
{\xe \v value\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<class ValueType , typename std::enable_if< {\b detail::is_getable}< basic_json_t, ValueType >::value, int >::{\b type}  = 0> ValueType {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::value (const {\b json_pointer} &  {\i ptr}, const ValueType &  {\i default_value}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element via JSON Pointer with default value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns either a copy of an object's element at the specified key {\i key}  or a given default value if no element with key {\i key}  exists.\par
The function is basically equivalent to executing {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 try} \{\par
    {\cf19 return} at(ptr);\par
\} {\cf19 catch}(out_of_range) \{\par
    {\cf19 return} default_value;\par
\}\par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Unlike {\b at(const json_pointer&)}, this function does not throw if the given key {\i key}  was not found.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ptr} \cell }{a JSON pointer to the element to access \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i default_value} \cell }{the value to return if {\i ptr}  found no value\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ValueType} \cell }{type compatible to JSON values, for instance {\f2 int}  for JSON integer numbers, {\f2 bool}  for JSON booleans, or {\f2 std::vector}  types for JSON arrays. Note the type of the expected value at {\i key}  and the default value {\i default_value}  must be compatible.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
copy of the element at key {\i key}  or {\i default_value}  if {\i key}  is not found\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.302} \cell }{if {\i default_value}  does not match the type of the value at {\i ptr}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.306} \cell }{if the JSON value is not an object; in that case, using {\f2 {\b value()}}  with a key makes no sense.\cell }
{\row }
}
@complexity Logarithmic in the size of the container.\par
@liveexample\{The example below shows how object elements can be queried with a default value.,basic_json__value_ptr\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b operator[](const json_pointer&)} for unchecked access by {\b reference}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.2 \par
}}}{
Definition at line {\b 21456} of file {\b json.hpp}.}\par
}
{\xe \v value\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b string_t} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::value (const typename object_t::key_type &  {\i key}, const char *  {\i default_value}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
overload for a default value of type const char* }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element with default value Returns either a copy of an object's element at the specified key {\i key}  or a given default value if no element with key {\i key}  exists.\par
The function is basically equivalent to executing {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 try} \{\par
    {\cf19 return} at(key);\par
\} {\cf19 catch}(out_of_range) \{\par
    {\cf19 return} default_value;\par
\}\par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Unlike {\b at(const typename object_t::key_type&)}, this function does not throw if the given key {\i key}  was not found.\par
Unlike {\b operator[](const typename object_t::key_type& key)}, this function does not implicitly add an element to the position defined by {\i key} . This function is furthermore also applicable to const objects.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key of the element to access \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i default_value} \cell }{the value to return if {\i key}  is not found\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ValueType} \cell }{type compatible to JSON values, for instance {\f2 int}  for JSON integer numbers, {\f2 bool}  for JSON booleans, or {\f2 std::vector}  types for JSON arrays. Note the type of the expected value at {\i key}  and the default value {\i default_value}  must be compatible.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
copy of the element at key {\i key}  or {\i default_value}  if {\i key}  is not found\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.302} \cell }{if {\i default_value}  does not match the type of the value at {\i key}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.306} \cell }{if the JSON value is not an object; in that case, using {\f2 {\b value()}}  with a key makes no sense.\cell }
{\row }
}
@complexity Logarithmic in the size of the container.\par
@liveexample\{The example below shows how object elements can be queried with a default value.,basic_json__value\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b at(const typename object_t::key_type&)} for access by {\b reference} with range checking \par
see {\b operator[](const typename object_t::key_type&)} for unchecked access by {\b reference}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21406} of file {\b json.hpp}.}\par
}
{\xe \v value\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<class ValueType , typename std::enable_if< {\b detail::is_getable}< basic_json_t, ValueType >::value &&!std::is_same< {\b value_t}, ValueType >::value, int >::{\b type}  = 0> ValueType {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::value (const typename object_t::key_type &  {\i key}, const ValueType &  {\i default_value}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access specified object element with default value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns either a copy of an object's element at the specified key {\i key}  or a given default value if no element with key {\i key}  exists.\par
The function is basically equivalent to executing {
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf19 try} \{\par
    {\cf19 return} at(key);\par
\} {\cf19 catch}(out_of_range) \{\par
    {\cf19 return} default_value;\par
\}\par
}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Unlike {\b at(const typename object_t::key_type&)}, this function does not throw if the given key {\i key}  was not found.\par
Unlike {\b operator[](const typename object_t::key_type& key)}, this function does not implicitly add an element to the position defined by {\i key} . This function is furthermore also applicable to const objects.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i key} \cell }{key of the element to access \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i default_value} \cell }{the value to return if {\i key}  is not found\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i ValueType} \cell }{type compatible to JSON values, for instance {\f2 int}  for JSON integer numbers, {\f2 bool}  for JSON booleans, or {\f2 std::vector}  types for JSON arrays. Note the type of the expected value at {\i key}  and the default value {\i default_value}  must be compatible.\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
copy of the element at key {\i key}  or {\i default_value}  if {\i key}  is not found\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.302} \cell }{if {\i default_value}  does not match the type of the value at {\i key}  \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.306} \cell }{if the JSON value is not an object; in that case, using {\f2 {\b value()}}  with a key makes no sense.\cell }
{\row }
}
@complexity Logarithmic in the size of the container.\par
@liveexample\{The example below shows how object elements can be queried with a default value.,basic_json__value\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b at(const typename object_t::key_type&)} for access by {\b reference} with range checking \par
see {\b operator[](const typename object_t::key_type&)} for unchecked access by {\b reference}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 21384} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v ::nlohmann::detail::binary_reader\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:::nlohmann::detail::binary_reader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename BasicJsonType , typename InputType , typename SAX > friend class ::{\b nlohmann::detail::binary_reader}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17595} of file {\b json.hpp}.}\par
}
{\xe \v ::nlohmann::detail::binary_writer\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:::nlohmann::detail::binary_writer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename BasicJsonType , typename CharType > friend class ::{\b nlohmann::detail::binary_writer}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17593} of file {\b json.hpp}.}\par
}
{\xe \v ::nlohmann::detail::exception\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:::nlohmann::detail::exception}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> friend class ::{\b nlohmann::detail::exception}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17600} of file {\b json.hpp}.}\par
}
{\xe \v ::nlohmann::detail::iter_impl\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:::nlohmann::detail::iter_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename BasicJsonType > friend class ::{\b nlohmann::detail::iter_impl}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17591} of file {\b json.hpp}.}\par
}
{\xe \v ::nlohmann::detail::json_sax_dom_callback_parser\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:::nlohmann::detail::json_sax_dom_callback_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename BasicJsonType > friend class ::{\b nlohmann::detail::json_sax_dom_callback_parser}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17599} of file {\b json.hpp}.}\par
}
{\xe \v ::nlohmann::detail::json_sax_dom_parser\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:::nlohmann::detail::json_sax_dom_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename BasicJsonType > friend class ::{\b nlohmann::detail::json_sax_dom_parser}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17597} of file {\b json.hpp}.}\par
}
{\xe \v ::nlohmann::detail::parser\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:::nlohmann::detail::parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename BasicJsonType , typename InputType > friend class ::{\b nlohmann::detail::parser}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17588} of file {\b json.hpp}.}\par
}
{\xe \v detail::external_constructor\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:detail::external_constructor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<{\b detail::value_t} > friend struct {\b detail::external_constructor}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17584} of file {\b json.hpp}.}\par
}
{\xe \v operator!=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> bool operator!= ({\b const_reference}  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: not equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares two JSON values for inequality by calculating {\f2 not (lhs == rhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether the values {\i lhs}  and {\i rhs}  are not equal\par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__notequal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23867} of file {\b json.hpp}.}\par
}
{\xe \v operator!=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator!= ({\b const_reference}  {\i lhs}, ScalarType  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: not equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: not equal Compares two JSON values for inequality by calculating {\f2 not (lhs == rhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether the values {\i lhs}  and {\i rhs}  are not equal\par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__notequal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23878} of file {\b json.hpp}.}\par
}
{\xe \v operator!=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator!= (ScalarType  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: not equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: not equal Compares two JSON values for inequality by calculating {\f2 not (lhs == rhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether the values {\i lhs}  and {\i rhs}  are not equal\par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__notequal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23889} of file {\b json.hpp}.}\par
}
{\xe \v operator<\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> bool operator< ({\b const_reference}  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares whether one JSON value {\i lhs}  is less than another JSON value {\i rhs}  according to the following rules:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If {\i lhs}  and {\i rhs}  have the same type, the values are compared using the default {\f2 <}  operator.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Integer and floating-point numbers are automatically converted before comparison\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In case {\i lhs}  and {\i rhs}  have different types, the values are ignored and the order of the types is considered, see operator<(const value_t, const value_t).\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is less than {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__less\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23920} of file {\b json.hpp}.}\par
}
{\xe \v operator<\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator< ({\b const_reference}  {\i lhs}, ScalarType  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than Compares whether one JSON value {\i lhs}  is less than another JSON value {\i rhs}  according to the following rules:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If {\i lhs}  and {\i rhs}  have the same type, the values are compared using the default {\f2 <}  operator.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Integer and floating-point numbers are automatically converted before comparison\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In case {\i lhs}  and {\i rhs}  have different types, the values are ignored and the order of the types is considered, see operator<(const value_t, const value_t).\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is less than {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__less\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24000} of file {\b json.hpp}.}\par
}
{\xe \v operator<\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator< (ScalarType  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than Compares whether one JSON value {\i lhs}  is less than another JSON value {\i rhs}  according to the following rules:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
If {\i lhs}  and {\i rhs}  have the same type, the values are compared using the default {\f2 <}  operator.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Integer and floating-point numbers are automatically converted before comparison\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
In case {\i lhs}  and {\i rhs}  have different types, the values are ignored and the order of the types is considered, see operator<(const value_t, const value_t).\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is less than {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__less\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24011} of file {\b json.hpp}.}\par
}
{\xe \v operator<<\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> std::istream & operator<< ({\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}, std::istream &  {\i i}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialize from stream }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Deprecated:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid This stream operator is deprecated and will be removed in version 4.0.0 of the library. Please use {\b operator>>(std::istream&, basic_json&)} instead; that is, replace calls like {\f2 j << i;}  with {\f2 i >> j;} . \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0; deprecated since version 3.0.0 \par
}}}{
Definition at line {\b 24490} of file {\b json.hpp}.}\par
}
{\xe \v operator<<\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> std::ostream & operator<< (std::ostream &  {\i o}, const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serialize to stream }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Serialize the given JSON value {\i j}  to the output stream {\i o} . The JSON value will be serialized using the {\b dump} member function.\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The indentation of the output can be controlled with the member variable {\f2 width}  of the output stream {\i o} . For instance, using the manipulator {\f2 std::setw(4)}  on {\i o}  sets the indentation level to {\f2 4}  and the serialization result is the same as calling {\f2 dump(4)} .\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
The indentation character can be controlled with the member variable {\f2 fill}  of the output stream {\i o} . For instance, the manipulator \'91std::setfill(\'92\\t')` sets indentation to use a tab character rather than the default space character.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i o} \cell }{stream to serialize to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON value to serialize\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the stream {\i o}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type_error.316} \cell }{if a string stored inside the JSON value is not UTF-8 encoded\cell }
{\row }
}
@complexity Linear.\par
@liveexample\{The example below shows the serialization with different parameters to {\f2 width}  to adjust the indentation level.,operator_serialize\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0; indentation character added in version 3.0.0 \par
}}}{
Definition at line {\b 24194} of file {\b json.hpp}.}\par
}
{\xe \v operator<=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> bool operator<= ({\b const_reference}  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than or equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares whether one JSON value {\i lhs}  is less than or equal to another JSON value by calculating {\f2 not (rhs < lhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is less than or equal to {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__greater\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24035} of file {\b json.hpp}.}\par
}
{\xe \v operator<=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator<= ({\b const_reference}  {\i lhs}, ScalarType  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than or equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than or equal Compares whether one JSON value {\i lhs}  is less than or equal to another JSON value by calculating {\f2 not (rhs < lhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is less than or equal to {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__greater\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24046} of file {\b json.hpp}.}\par
}
{\xe \v operator<=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator<= (ScalarType  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than or equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than or equal Compares whether one JSON value {\i lhs}  is less than or equal to another JSON value by calculating {\f2 not (rhs < lhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is less than or equal to {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__greater\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24057} of file {\b json.hpp}.}\par
}
{\xe \v operator==\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> bool operator== ({\b const_reference}  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares two JSON values for equality according to the following rules:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Two JSON values are equal if (1) they are from the same type and (2) their stored values are the same according to their respective {\f2 operator==} .\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Integer and floating-point numbers are automatically converted before comparison. Note that two NaN values are always treated as unequal.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Two JSON null values are equal.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Floating-point inside JSON values numbers are compared with {\f2 json::number_float_t::operator==}  which is {\f2 double::operator==}  by default. To compare floating-point while respecting an epsilon, an alternative {\f2 comparison function} could be used, for instance {
\par
\pard\plain \s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid template<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>\par
{\cf17 inline} {\cf18 bool} is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept\par
\{\par
    {\cf19 return} std::abs(a - b) <= epsilon;\par
\}\par
}
 Or you can self-defined operator equal function like this: {
\par
\pard\plain \s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 bool} my_equal(const_reference lhs, const_reference rhs) \{\par
{\cf17 const} {\cf17 auto} lhs_type lhs.type();\par
{\cf17 const} {\cf17 auto} rhs_type rhs.type();\par
{\cf19 if} (lhs_type == rhs_type) \{\par
    {\cf19 switch}(lhs_type)\par
        {\cf20 // self_defined case}\par
        {\cf19 case} value_t::number_float:\par
            {\cf19 return} std::abs(lhs - rhs) <= std::numeric_limits<float>::epsilon();\par
        {\cf20 // other cases remain the same with the original}\par
        ...\par
\}\par
...\par
\}\par
}
\par
NaN values never compare equal to themselves or to other NaN values.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether the values {\i lhs}  and {\i rhs}  are equal\par
}}@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@complexity Linear.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__equal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23751} of file {\b json.hpp}.}\par
}
{\xe \v operator==\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator== ({\b const_reference}  {\i lhs}, ScalarType  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: equal Compares two JSON values for equality according to the following rules:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Two JSON values are equal if (1) they are from the same type and (2) their stored values are the same according to their respective {\f2 operator==} .\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Integer and floating-point numbers are automatically converted before comparison. Note that two NaN values are always treated as unequal.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Two JSON null values are equal.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Floating-point inside JSON values numbers are compared with {\f2 json::number_float_t::operator==}  which is {\f2 double::operator==}  by default. To compare floating-point while respecting an epsilon, an alternative {\f2 comparison function} could be used, for instance {
\par
\pard\plain \s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid template<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>\par
{\cf17 inline} {\cf18 bool} is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept\par
\{\par
    {\cf19 return} std::abs(a - b) <= epsilon;\par
\}\par
}
 Or you can self-defined operator equal function like this: {
\par
\pard\plain \s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 bool} my_equal(const_reference lhs, const_reference rhs) \{\par
{\cf17 const} {\cf17 auto} lhs_type lhs.type();\par
{\cf17 const} {\cf17 auto} rhs_type rhs.type();\par
{\cf19 if} (lhs_type == rhs_type) \{\par
    {\cf19 switch}(lhs_type)\par
        {\cf20 // self_defined case}\par
        {\cf19 case} value_t::number_float:\par
            {\cf19 return} std::abs(lhs - rhs) <= std::numeric_limits<float>::epsilon();\par
        {\cf20 // other cases remain the same with the original}\par
        ...\par
\}\par
...\par
\}\par
}
\par
NaN values never compare equal to themselves or to other NaN values.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether the values {\i lhs}  and {\i rhs}  are equal\par
}}@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@complexity Linear.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__equal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23833} of file {\b json.hpp}.}\par
}
{\xe \v operator==\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator== (ScalarType  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: equal Compares two JSON values for equality according to the following rules:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Two JSON values are equal if (1) they are from the same type and (2) their stored values are the same according to their respective {\f2 operator==} .\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Integer and floating-point numbers are automatically converted before comparison. Note that two NaN values are always treated as unequal.\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Two JSON null values are equal.\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Floating-point inside JSON values numbers are compared with {\f2 json::number_float_t::operator==}  which is {\f2 double::operator==}  by default. To compare floating-point while respecting an epsilon, an alternative {\f2 comparison function} could be used, for instance {
\par
\pard\plain \s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid template<typename T, typename = typename std::enable_if<std::is_floating_point<T>::value, T>::type>\par
{\cf17 inline} {\cf18 bool} is_same(T a, T b, T epsilon = std::numeric_limits<T>::epsilon()) noexcept\par
\{\par
    {\cf19 return} std::abs(a - b) <= epsilon;\par
\}\par
}
 Or you can self-defined operator equal function like this: {
\par
\pard\plain \s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf18 bool} my_equal(const_reference lhs, const_reference rhs) \{\par
{\cf17 const} {\cf17 auto} lhs_type lhs.type();\par
{\cf17 const} {\cf17 auto} rhs_type rhs.type();\par
{\cf19 if} (lhs_type == rhs_type) \{\par
    {\cf19 switch}(lhs_type)\par
        {\cf20 // self_defined case}\par
        {\cf19 case} value_t::number_float:\par
            {\cf19 return} std::abs(lhs - rhs) <= std::numeric_limits<float>::epsilon();\par
        {\cf20 // other cases remain the same with the original}\par
        ...\par
\}\par
...\par
\}\par
}
\par
NaN values never compare equal to themselves or to other NaN values.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether the values {\i lhs}  and {\i rhs}  are equal\par
}}@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@complexity Linear.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__equal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23844} of file {\b json.hpp}.}\par
}
{\xe \v operator>\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> bool operator> ({\b const_reference}  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares whether one JSON value {\i lhs}  is greater than another JSON value by calculating {\f2 not (lhs <= rhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is greater than to {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__lessequal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24081} of file {\b json.hpp}.}\par
}
{\xe \v operator>\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator> ({\b const_reference}  {\i lhs}, ScalarType  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than Compares whether one JSON value {\i lhs}  is greater than another JSON value by calculating {\f2 not (lhs <= rhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is greater than to {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__lessequal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24092} of file {\b json.hpp}.}\par
}
{\xe \v operator>\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator> (ScalarType  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than Compares whether one JSON value {\i lhs}  is greater than another JSON value by calculating {\f2 not (lhs <= rhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is greater than to {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__lessequal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24103} of file {\b json.hpp}.}\par
}
{\xe \v operator>=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> bool operator>= ({\b const_reference}  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than or equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compares whether one JSON value {\i lhs}  is greater than or equal to another JSON value by calculating {\f2 not (lhs < rhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is greater than or equal to {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__greaterequal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24127} of file {\b json.hpp}.}\par
}
{\xe \v operator>=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator>= ({\b const_reference}  {\i lhs}, ScalarType  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than or equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than or equal Compares whether one JSON value {\i lhs}  is greater than or equal to another JSON value by calculating {\f2 not (lhs < rhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is greater than or equal to {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__greaterequal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24138} of file {\b json.hpp}.}\par
}
{\xe \v operator>=\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> template<typename ScalarType , typename std::enable_if< std::is_scalar< ScalarType >::{\b value}, int >::{\b type}  = 0> bool operator>= (ScalarType  {\i lhs}, {\b const_reference}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than or equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than or equal Compares whether one JSON value {\i lhs}  is greater than or equal to another JSON value by calculating {\f2 not (lhs < rhs)} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{first JSON value to consider \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{second JSON value to consider \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is greater than or equal to {\i rhs}  \par
}}@complexity Linear.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example demonstrates comparing several JSON types.,operator__greaterequal\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24149} of file {\b json.hpp}.}\par
}
{\xe \v operator>>\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> std::ostream & operator>> (const {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}, std::ostream &  {\i o}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serialize to stream }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Deprecated:\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid This stream operator is deprecated and will be removed in future 4.0.0 of the library. Please use {\b operator<<(std::ostream&, const basic_json&)} instead; that is, replace calls like {\f2 j >> o;}  with {\f2 o << j;} . \par
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0; deprecated since version 3.0.0 \par
}}}{
Definition at line {\b 24218} of file {\b json.hpp}.}\par
}
{\xe \v operator>>\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> std::istream & operator>> (std::istream &  {\i i}, {\b basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType > &  {\i j}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialize from stream }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deserializes an input stream to a JSON value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i i} \cell }{input stream to read a serialized JSON value from \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i j} \cell }{JSON value to write the deserialized input to\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.101} \cell }{in case of an unexpected token \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.102} \cell }{if to_unicode fails or surrogate error \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.103} \cell }{if to_unicode fails\cell }
{\row }
}
@complexity Linear in the length of the input. The parser is a predictive LL(1) parser.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
A UTF-8 byte order mark is silently ignored.\par
}}@liveexample\{The example below shows how a JSON value is constructed by reading a serialization from a stream.,operator_deserialize\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
parse(std::istream&, const parser_callback_t) for a variant with a parser callback function to filter values while parsing\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 24520} of file {\b json.hpp}.}\par
}
{\xe \v swap\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> void swap ({\b reference}  {\i left}, {\b reference}  {\i right}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exchanges the contents of the JSON value from {\i left}  with those of {\i right} . Does not invoke any move, copy, or swap operations on individual elements. All iterators and references remain valid. The past-the-end iterator is invalidated. implemented as a friend function callable via ADL.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i left} \cell }{JSON value to exchange the contents with \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i right} \cell }{JSON value to exchange the contents with\cell }
{\row }
}
@complexity Constant.\par
@liveexample\{The example below shows how JSON values can be swapped with {\f2 {\b swap()}} .,swap__reference\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 23530} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v __pad3__\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:__pad3__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> {\b JSON_PRIVATE_UNLESS_TESTED} {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::__pad3__}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24593} of file {\b json.hpp}.}\par
}
{\xe \v m_value\:nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}
{\xe \v nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >\:m_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< typename U, typename V, typename... Args > class ObjectType = std::map, template< typename U, typename... Args > class ArrayType = std::vector, class StringType  = std::string, class BooleanType  = bool, class NumberIntegerType  = std::int64_t, class NumberUnsignedType  = std::uint64_t, class NumberFloatType  = double, template< typename U > class AllocatorType = std::allocator, template< typename T, typename SFINAE=void > class JSONSerializer = adl_serializer, class BinaryType  = std::vector<std::uint8_t>> json_value {\b nlohmann::basic_json}< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >::m_value = \{\}}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the value of the current element }}\par
{
Definition at line {\b 24602} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >}
{\xe \v nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >}
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialization of CBOR, MessagePack, and UBJSON values }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b binary_reader} (InputAdapterType &&adapter) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a binary reader }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b binary_reader} (const {\b binary_reader} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b binary_reader} ({\b binary_reader} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b binary_reader} & {\b operator=} (const {\b binary_reader} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b binary_reader} & {\b operator=} ({\b binary_reader} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~binary_reader} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b sax_parse} (const {\b input_format_t} format, json_sax_t *sax_, const bool strict=true, const {\b cbor_tag_handler_t} tag_handler={\b cbor_tag_handler_t::error})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename InputAdapterType, typename SAX = json_sax_dom_parser<BasicJsonType>>\par
class nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialization of CBOR, MessagePack, and UBJSON values \par
}{
Definition at line {\b 8353} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v binary_reader\:nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >}
{\xe \v nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >\:binary_reader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType , typename SAX  = json_sax_dom_parser<BasicJsonType>> {\b nlohmann::detail::binary_reader}< BasicJsonType, InputAdapterType, SAX >::{\b binary_reader} (InputAdapterType &&  {\i adapter}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a binary reader }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i adapter} \cell }{input adapter to read from \cell }
{\row }
}
}{
Definition at line {\b 8370} of file {\b json.hpp}.}\par
}
{\xe \v binary_reader\:nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >}
{\xe \v nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >\:binary_reader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType , typename SAX  = json_sax_dom_parser<BasicJsonType>> {\b nlohmann::detail::binary_reader}< BasicJsonType, InputAdapterType, SAX >::{\b binary_reader} (const {\b binary_reader}< BasicJsonType, InputAdapterType, SAX > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v binary_reader\:nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >}
{\xe \v nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >\:binary_reader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType , typename SAX  = json_sax_dom_parser<BasicJsonType>> {\b nlohmann::detail::binary_reader}< BasicJsonType, InputAdapterType, SAX >::{\b binary_reader} ({\b binary_reader}< BasicJsonType, InputAdapterType, SAX > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~binary_reader\:nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >}
{\xe \v nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >\:~binary_reader}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType , typename SAX  = json_sax_dom_parser<BasicJsonType>> {\b nlohmann::detail::binary_reader}< BasicJsonType, InputAdapterType, SAX >::~{\b binary_reader} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >}
{\xe \v nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType , typename SAX  = json_sax_dom_parser<BasicJsonType>> {\b binary_reader} & {\b nlohmann::detail::binary_reader}< BasicJsonType, InputAdapterType, SAX >::operator= ({\b binary_reader}< BasicJsonType, InputAdapterType, SAX > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >}
{\xe \v nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType , typename SAX  = json_sax_dom_parser<BasicJsonType>> {\b binary_reader} & {\b nlohmann::detail::binary_reader}< BasicJsonType, InputAdapterType, SAX >::operator= (const {\b binary_reader}< BasicJsonType, InputAdapterType, SAX > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v sax_parse\:nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >}
{\xe \v nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >\:sax_parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType , typename SAX  = json_sax_dom_parser<BasicJsonType>> bool {\b nlohmann::detail::binary_reader}< BasicJsonType, InputAdapterType, SAX >::sax_parse (const {\b input_format_t}  {\i format}, json_sax_t *  {\i sax_}, const bool  {\i strict} = {\f2 true}, const {\b cbor_tag_handler_t}  {\i tag_handler} = {\f2 {\b cbor_tag_handler_t::error}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i format} \cell }{the binary format to parse \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i sax_} \cell }{a SAX event processor \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether to expect the input to be consumed completed \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i tag_handler} \cell }{how to treat CBOR tags\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing was successful \par
}}}{
Definition at line {\b 8391} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::binary_writer< BasicJsonType, CharType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::binary_writer< BasicJsonType, CharType >}
{\xe \v nlohmann::detail::binary_writer< BasicJsonType, CharType >}
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serialization to CBOR and MessagePack values }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b binary_writer} ({\b output_adapter_t}< CharType > adapter)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a binary writer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_bson} (const BasicJsonType &j)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_cbor} (const BasicJsonType &j)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_msgpack} (const BasicJsonType &j)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_ubjson} (const BasicJsonType &j, const bool use_count, const bool use_type, const bool add_prefix=true)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C  = CharType, {\b enable_if_t}< std::is_signed< C >::value &&std::is_signed< char >::value > *  = nullptr> static constexpr CharType {\b to_char_type} (std::uint8_t x) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C  = CharType, {\b enable_if_t}< std::is_signed< C >::value &&std::is_unsigned< char >::value > *  = nullptr> static CharType {\b to_char_type} (std::uint8_t x) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C  = CharType, {\b enable_if_t}< std::is_unsigned< C >::value > *  = nullptr> static constexpr CharType {\b to_char_type} (std::uint8_t x) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputCharType , typename C  = CharType, {\b enable_if_t}< std::is_signed< C >::value &&std::is_signed< char >::value &&std::is_same< char, typename std::remove_cv< InputCharType >::type >::value > *  = nullptr> static constexpr CharType {\b to_char_type} (InputCharType x) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CharType>\par
class nlohmann::detail::binary_writer< BasicJsonType, CharType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serialization to CBOR and MessagePack values \par
}{
Definition at line {\b 13600} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v binary_writer\:nlohmann::detail::binary_writer< BasicJsonType, CharType >}
{\xe \v nlohmann::detail::binary_writer< BasicJsonType, CharType >\:binary_writer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CharType > {\b nlohmann::detail::binary_writer}< BasicJsonType, CharType >::{\b binary_writer} ({\b output_adapter_t}< CharType >  {\i adapter}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a binary writer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i adapter} \cell }{output adapter to write to \cell }
{\row }
}
}{
Definition at line {\b 13612} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v to_char_type\:nlohmann::detail::binary_writer< BasicJsonType, CharType >}
{\xe \v nlohmann::detail::binary_writer< BasicJsonType, CharType >\:to_char_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CharType > template<typename InputCharType , typename C  = CharType, {\b enable_if_t}< std::is_signed< C >::value &&std::is_signed< char >::value &&std::is_same< char, typename std::remove_cv< InputCharType >::type >::value > *  = nullptr> static constexpr CharType {\b nlohmann::detail::binary_writer}< BasicJsonType, CharType >::to_char_type (InputCharType  {\i x}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15194} of file {\b json.hpp}.}\par
}
{\xe \v to_char_type\:nlohmann::detail::binary_writer< BasicJsonType, CharType >}
{\xe \v nlohmann::detail::binary_writer< BasicJsonType, CharType >\:to_char_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CharType > template<typename C  = CharType, {\b enable_if_t}< std::is_signed< C >::value &&std::is_signed< char >::value > *  = nullptr> static constexpr CharType {\b nlohmann::detail::binary_writer}< BasicJsonType, CharType >::to_char_type (std::uint8_t  {\i x}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15165} of file {\b json.hpp}.}\par
}
{\xe \v to_char_type\:nlohmann::detail::binary_writer< BasicJsonType, CharType >}
{\xe \v nlohmann::detail::binary_writer< BasicJsonType, CharType >\:to_char_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CharType > template<typename C  = CharType, {\b enable_if_t}< std::is_signed< C >::value &&std::is_unsigned< char >::value > *  = nullptr> static CharType {\b nlohmann::detail::binary_writer}< BasicJsonType, CharType >::to_char_type (std::uint8_t  {\i x}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15172} of file {\b json.hpp}.}\par
}
{\xe \v to_char_type\:nlohmann::detail::binary_writer< BasicJsonType, CharType >}
{\xe \v nlohmann::detail::binary_writer< BasicJsonType, CharType >\:to_char_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CharType > template<typename C  = CharType, {\b enable_if_t}< std::is_unsigned< C >::value > *  = nullptr> static constexpr CharType {\b nlohmann::detail::binary_writer}< BasicJsonType, CharType >::to_char_type (std::uint8_t  {\i x}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15183} of file {\b json.hpp}.}\par
}
{\xe \v write_bson\:nlohmann::detail::binary_writer< BasicJsonType, CharType >}
{\xe \v nlohmann::detail::binary_writer< BasicJsonType, CharType >\:write_bson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CharType > void {\b nlohmann::detail::binary_writer}< BasicJsonType, CharType >::write_bson (const BasicJsonType &  {\i j}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON value to serialize \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
j.type() == {\b value_t::object} \par
}}}{
Definition at line {\b 13621} of file {\b json.hpp}.}\par
}
{\xe \v write_cbor\:nlohmann::detail::binary_writer< BasicJsonType, CharType >}
{\xe \v nlohmann::detail::binary_writer< BasicJsonType, CharType >\:write_cbor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CharType > void {\b nlohmann::detail::binary_writer}< BasicJsonType, CharType >::write_cbor (const BasicJsonType &  {\i j}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON value to serialize \cell }
{\row }
}
}{
Definition at line {\b 13650} of file {\b json.hpp}.}\par
}
{\xe \v write_msgpack\:nlohmann::detail::binary_writer< BasicJsonType, CharType >}
{\xe \v nlohmann::detail::binary_writer< BasicJsonType, CharType >\:write_msgpack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CharType > void {\b nlohmann::detail::binary_writer}< BasicJsonType, CharType >::write_msgpack (const BasicJsonType &  {\i j}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON value to serialize \cell }
{\row }
}
}{
Definition at line {\b 13974} of file {\b json.hpp}.}\par
}
{\xe \v write_ubjson\:nlohmann::detail::binary_writer< BasicJsonType, CharType >}
{\xe \v nlohmann::detail::binary_writer< BasicJsonType, CharType >\:write_ubjson}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CharType > void {\b nlohmann::detail::binary_writer}< BasicJsonType, CharType >::write_ubjson (const BasicJsonType &  {\i j}, const bool  {\i use_count}, const bool  {\i use_type}, const bool  {\i add_prefix} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i j} \cell }{JSON value to serialize \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i use_count} \cell }{whether to use '#' prefixes (optimized format) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i use_type} \cell }{whether to use '$' prefixes (optimized format) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i add_prefix} \cell }{whether prefixes need to be used for this value \cell }
{\row }
}
}{
Definition at line {\b 14299} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::dtoa_impl::boundaries Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::dtoa_impl::boundaries}
{\xe \v nlohmann::detail::dtoa_impl::boundaries}
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b diyfp} {\b w}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b diyfp} {\b minus}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b diyfp} {\b plus}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 15394} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v minus\:nlohmann::detail::dtoa_impl::boundaries}
{\xe \v nlohmann::detail::dtoa_impl::boundaries\:minus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b diyfp} nlohmann::detail::dtoa_impl::boundaries::minus}}
\par
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15397} of file {\b json.hpp}.}\par
}
{\xe \v plus\:nlohmann::detail::dtoa_impl::boundaries}
{\xe \v nlohmann::detail::dtoa_impl::boundaries\:plus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b diyfp} nlohmann::detail::dtoa_impl::boundaries::plus}}
\par
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15398} of file {\b json.hpp}.}\par
}
{\xe \v w\:nlohmann::detail::dtoa_impl::boundaries}
{\xe \v nlohmann::detail::dtoa_impl::boundaries\:w}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b diyfp} nlohmann::detail::dtoa_impl::boundaries::w}}
\par
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15396} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::byte_container_with_subtype< BinaryType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >}
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an internal type for a backed binary type }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::byte_container_with_subtype< BinaryType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1byte__container__with__subtype.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b container_type} = BinaryType\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of the underlying container }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b subtype_type} = std::uint64_t\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of the subtype }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b byte_container_with_subtype} () noexcept(noexcept({\b container_type}()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b byte_container_with_subtype} (const {\b container_type} &b) noexcept(noexcept({\b container_type}(b)))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b byte_container_with_subtype} ({\b container_type} &&b) noexcept(noexcept({\b container_type}(std::move(b))))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b byte_container_with_subtype} (const {\b container_type} &b, {\b subtype_type} subtype_) noexcept(noexcept({\b container_type}(b)))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b byte_container_with_subtype} ({\b container_type} &&b, {\b subtype_type} subtype_) noexcept(noexcept({\b container_type}(std::move(b))))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b byte_container_with_subtype} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b byte_container_with_subtype} &rhs) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_subtype} ({\b subtype_type} subtype_) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sets the binary subtype }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b subtype_type} {\b subtype} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the binary subtype }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b has_subtype} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether the value has a subtype }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear_subtype} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
clears the binary subtype }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BinaryType>\par
class nlohmann::byte_container_with_subtype< BinaryType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an internal type for a backed binary type \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This type extends the template parameter {\i BinaryType}  provided to {\f2 {\b basic_json}}  with a subtype used by BSON and MessagePack. This type exists so that the user does not have to specify a type themselves with a specific naming scheme in order to override the binary type.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i BinaryType} \cell }{container to store bytes ({\f2 std::vector<std::uint8_t>}  by default)\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0; changed type of subtypes to std::uint64_t in 3.10.0. \par
}}}{
Definition at line {\b 5032} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v container_type\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:container_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > using {\b nlohmann::byte_container_with_subtype}< BinaryType >::{\b container_type} =  BinaryType}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of the underlying container }}\par
{
Definition at line {\b 5036} of file {\b json.hpp}.}\par
}
{\xe \v subtype_type\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:subtype_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > using {\b nlohmann::byte_container_with_subtype}< BinaryType >::{\b subtype_type} =  std::uint64_t}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of the subtype }}\par
{
Definition at line {\b 5038} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v byte_container_with_subtype\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:byte_container_with_subtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > {\b nlohmann::byte_container_with_subtype}< BinaryType >::{\b byte_container_with_subtype} (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5040} of file {\b json.hpp}.}\par
}
{\xe \v byte_container_with_subtype\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:byte_container_with_subtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > {\b nlohmann::byte_container_with_subtype}< BinaryType >::{\b byte_container_with_subtype} (const {\b container_type} &  {\i b}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5044} of file {\b json.hpp}.}\par
}
{\xe \v byte_container_with_subtype\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:byte_container_with_subtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > {\b nlohmann::byte_container_with_subtype}< BinaryType >::{\b byte_container_with_subtype} ({\b container_type} &&  {\i b}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5048} of file {\b json.hpp}.}\par
}
{\xe \v byte_container_with_subtype\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:byte_container_with_subtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > {\b nlohmann::byte_container_with_subtype}< BinaryType >::{\b byte_container_with_subtype} (const {\b container_type} &  {\i b}, {\b subtype_type}  {\i subtype_}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5052} of file {\b json.hpp}.}\par
}
{\xe \v byte_container_with_subtype\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:byte_container_with_subtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > {\b nlohmann::byte_container_with_subtype}< BinaryType >::{\b byte_container_with_subtype} ({\b container_type} &&  {\i b}, {\b subtype_type}  {\i subtype_}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5058} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v clear_subtype\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:clear_subtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > void {\b nlohmann::byte_container_with_subtype}< BinaryType >::clear_subtype (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
clears the binary subtype }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the binary subtype and flags the value as not having a subtype, which has implications for serialization; for instance MessagePack will prefer the bin family over the ext family.\par
@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b subtype()} \'96 return the binary {\b subtype} \par
see {\b set_subtype()} \'96 sets the binary {\b subtype} \par
see {\b has_subtype()} \'96 returns whether or not the binary value has a {\b subtype}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 5166} of file {\b json.hpp}.}\par
}
{\xe \v has_subtype\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:has_subtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > constexpr bool {\b nlohmann::byte_container_with_subtype}< BinaryType >::has_subtype () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether the value has a subtype }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether the value has a subtype\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b subtype()} \'96 return the binary {\b subtype} \par
see {\b set_subtype()} \'96 sets the binary {\b subtype} \par
see {\b clear_subtype()} \'96 clears the binary {\b subtype}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 5142} of file {\b json.hpp}.}\par
}
{\xe \v operator!=\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > bool {\b nlohmann::byte_container_with_subtype}< BinaryType >::operator!= (const {\b byte_container_with_subtype}< BinaryType > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5070} of file {\b json.hpp}.}\par
}
{\xe \v operator==\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > bool {\b nlohmann::byte_container_with_subtype}< BinaryType >::operator== (const {\b byte_container_with_subtype}< BinaryType > &  {\i rhs}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5064} of file {\b json.hpp}.}\par
}
{\xe \v set_subtype\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:set_subtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > void {\b nlohmann::byte_container_with_subtype}< BinaryType >::set_subtype ({\b subtype_type}  {\i subtype_}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
sets the binary subtype }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the binary subtype of the value, also flags a binary JSON value as having a subtype, which has implications for serialization.\par
@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b subtype()} \'96 return the binary {\b subtype} \par
see {\b clear_subtype()} \'96 clears the binary {\b subtype} \par
see {\b has_subtype()} \'96 returns whether or not the binary value has a {\b subtype}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0 \par
}}}{
Definition at line {\b 5093} of file {\b json.hpp}.}\par
}
{\xe \v subtype\:nlohmann::byte_container_with_subtype< BinaryType >}
{\xe \v nlohmann::byte_container_with_subtype< BinaryType >\:subtype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BinaryType > constexpr {\b subtype_type} {\b nlohmann::byte_container_with_subtype}< BinaryType >::subtype () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the binary subtype }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the numerical subtype of the value if it has a subtype. If it does not have a subtype, this function will return subtype_type(-1) as a sentinel value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
the numerical subtype of the binary value\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this member function never throws exceptions.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b set_subtype()} \'96 sets the binary {\b subtype} \par
see {\b clear_subtype()} \'96 clears the binary {\b subtype} \par
see {\b has_subtype()} \'96 returns whether or not the binary value has a {\b subtype}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.8.0; fixed return value to properly return subtype_type(-1) as documented in version 3.10.0 \par
}}}{
Definition at line {\b 5121} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::dtoa_impl::cached_power Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::dtoa_impl::cached_power}
{\xe \v nlohmann::detail::dtoa_impl::cached_power}
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint64_t {\b f}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b e}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b k}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 15533} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v e\:nlohmann::detail::dtoa_impl::cached_power}
{\xe \v nlohmann::detail::dtoa_impl::cached_power\:e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nlohmann::detail::dtoa_impl::cached_power::e}}
\par
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15536} of file {\b json.hpp}.}\par
}
{\xe \v f\:nlohmann::detail::dtoa_impl::cached_power}
{\xe \v nlohmann::detail::dtoa_impl::cached_power\:f}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint64_t nlohmann::detail::dtoa_impl::cached_power::f}}
\par
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15535} of file {\b json.hpp}.}\par
}
{\xe \v k\:nlohmann::detail::dtoa_impl::cached_power}
{\xe \v nlohmann::detail::dtoa_impl::cached_power\:k}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nlohmann::detail::dtoa_impl::cached_power::k}}
\par
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15537} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client Class Reference\par \pard\plain 
{\tc\tcl2 \v Client}
{\xe \v Client}
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
\par
{
{\f2 #include <client.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Client} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 5} of file {\b client.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Client\:Client}
{\xe \v Client\:Client}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Client::Client ()}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b client.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b client.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b client.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CommonBlk Class Reference\par \pard\plain 
{\tc\tcl2 \v CommonBlk}
{\xe \v CommonBlk}
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CommonBlk} class creates objects of type {\b CommonBlk}. }}\par
{
{\f2 #include <Commonblk.h>}}\par
Inheritance diagram for CommonBlk:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_common_blk.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommonBlk} (QGraphicsItem *parent=NULL)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CommonBlk::CommonBlk} constructor creates a new {\b CommonBlk} with its required attributes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} (int x, int y)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CommonBlk::setPosition} sets the position of the block. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b posx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b posy} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CommonBlk} class creates objects of type {\b CommonBlk}. \par
}{
Definition at line {\b 8} of file {\b Commonblk.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CommonBlk\:CommonBlk}
{\xe \v CommonBlk\:CommonBlk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CommonBlk::CommonBlk (QGraphicsItem *  {\i parent} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CommonBlk::CommonBlk} constructor creates a new {\b CommonBlk} with its required attributes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parent} \cell }{\cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
draw a rectangle for the block\par
}{
Definition at line {\b 7} of file {\b Commonblk.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v setPosition\:CommonBlk}
{\xe \v CommonBlk\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CommonBlk::setPosition (int  {\i x}, int  {\i y})}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b CommonBlk::setPosition} sets the position of the block. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i x} \cell }{position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i y} \cell }{position \cell }
{\row }
}
}{
Definition at line {\b 21} of file {\b Commonblk.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v posx\:CommonBlk}
{\xe \v CommonBlk\:posx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CommonBlk::posx = 0}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b Commonblk.h}.}\par
}
{\xe \v posy\:CommonBlk}
{\xe \v CommonBlk\:posy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CommonBlk::posy = 0}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b Commonblk.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Commonblk.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Commonblk.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::conjunction<... > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::conjunction<... >}
{\xe \v nlohmann::detail::conjunction<... >}
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::conjunction<... >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1conjunction.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class...>\par
struct nlohmann::detail::conjunction<... >\par
}
\par
{
Definition at line {\b 3567} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::conjunction< B1 > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::conjunction< B1 >}
{\xe \v nlohmann::detail::conjunction< B1 >}
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::conjunction< B1 >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1conjunction_3_01_b1_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class B1>\par
struct nlohmann::detail::conjunction< B1 >\par
}
\par
{
Definition at line {\b 3568} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::conjunction< B1, Bn... > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::conjunction< B1, Bn... >}
{\xe \v nlohmann::detail::conjunction< B1, Bn... >}
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::conjunction< B1, Bn... >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1conjunction_3_01_b1_00_01_bn_8_8_8_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class B1, class... Bn>\par
struct nlohmann::detail::conjunction< B1, Bn... >\par
}
\par
{
Definition at line {\b 3570} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, Enable > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, Enable >}
{\xe \v nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, Enable >}
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
\par
{
{\f2 #include <json.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename ContainerType, typename Enable = void>\par
struct nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, Enable >\par
}
\par
{
Definition at line {\b 5720} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >}
{\xe \v nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >}
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b adapter_type} = decltype({\b input_adapter}(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >())))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b adapter_type} {\b create} (const ContainerType &container)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename ContainerType>\par
struct nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >\par
}
\par
{
Definition at line {\b 5723} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v adapter_type\:nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >}
{\xe \v nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >\:adapter_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ContainerType > using {\b nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory}< ContainerType, {\b void_t}< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >::{\b adapter_type} =  decltype({\b input_adapter}(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>())))}}
\par
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5726} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >}
{\xe \v nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ContainerType > static {\b adapter_type} {\b nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory}< ContainerType, {\b void_t}< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >::create (const ContainerType &  {\i container}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5728} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DeepBlk Class Reference\par \pard\plain 
{\tc\tcl2 \v DeepBlk}
{\xe \v DeepBlk}
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b DeepBlk} class creates objects of type {\b DeepBlk}. }}\par
{
{\f2 #include <Deepblk.h>}}\par
Inheritance diagram for DeepBlk:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_deep_blk.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DeepBlk} (QGraphicsItem *parent=NULL)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b DeepBlk::DeepBlk} constructor creates a new {\b DeepBlk} with its required attributes. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b posx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b posy} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b DeepBlk} class creates objects of type {\b DeepBlk}. \par
}{
Definition at line {\b 8} of file {\b Deepblk.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DeepBlk\:DeepBlk}
{\xe \v DeepBlk\:DeepBlk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DeepBlk::DeepBlk (QGraphicsItem *  {\i parent} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b DeepBlk::DeepBlk} constructor creates a new {\b DeepBlk} with its required attributes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parent} \cell }{\cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
draw a rectangle for the block\par
}{
Definition at line {\b 7} of file {\b Deepblk.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v posx\:DeepBlk}
{\xe \v DeepBlk\:posx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DeepBlk::posx = 0}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b Deepblk.h}.}\par
}
{\xe \v posy\:DeepBlk}
{\xe \v DeepBlk\:posy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DeepBlk::posy = 0}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b Deepblk.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Deepblk.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Deepblk.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::detector< Default, AlwaysVoid, Op, Args > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::detector< Default, AlwaysVoid, Op, Args >}
{\xe \v nlohmann::detail::detector< Default, AlwaysVoid, Op, Args >}
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_t} = std::false_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = Default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Default, class AlwaysVoid, template< class... > class Op, class... Args>\par
struct nlohmann::detail::detector< Default, AlwaysVoid, Op, Args >\par
}
\par
{
Definition at line {\b 3309} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:nlohmann::detail::detector< Default, AlwaysVoid, Op, Args >}
{\xe \v nlohmann::detail::detector< Default, AlwaysVoid, Op, Args >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Default , class AlwaysVoid , template< class... > class Op, class... Args> using {\b nlohmann::detail::detector}< Default, AlwaysVoid, Op, Args >::{\b type} =  Default}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3312} of file {\b json.hpp}.}\par
}
{\xe \v value_t\:nlohmann::detail::detector< Default, AlwaysVoid, Op, Args >}
{\xe \v nlohmann::detail::detector< Default, AlwaysVoid, Op, Args >\:value_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Default , class AlwaysVoid , template< class... > class Op, class... Args> using {\b nlohmann::detail::detector}< Default, AlwaysVoid, Op, Args >::{\b value_t} =  std::false_type}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3311} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::detector< Default, void_t< Op< Args... > >, Op, Args... > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::detector< Default, void_t< Op< Args... > >, Op, Args... >}
{\xe \v nlohmann::detail::detector< Default, void_t< Op< Args... > >, Op, Args... >}
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_t} = std::true_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = Op< Args... >\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Default, template< class... > class Op, class... Args>\par
struct nlohmann::detail::detector< Default, void_t< Op< Args... > >, Op, Args... >\par
}
\par
{
Definition at line {\b 3316} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:nlohmann::detail::detector< Default, void_t< Op< Args... > >, Op, Args... >}
{\xe \v nlohmann::detail::detector< Default, void_t< Op< Args... > >, Op, Args... >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Default , template< class... > class Op, class... Args> using {\b nlohmann::detail::detector}< Default, {\b void_t}< Op< Args... > >, Op, Args... >::{\b type} =  Op<Args...>}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3319} of file {\b json.hpp}.}\par
}
{\xe \v value_t\:nlohmann::detail::detector< Default, void_t< Op< Args... > >, Op, Args... >}
{\xe \v nlohmann::detail::detector< Default, void_t< Op< Args... > >, Op, Args... >\:value_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Default , template< class... > class Op, class... Args> using {\b nlohmann::detail::detector}< Default, {\b void_t}< Op< Args... > >, Op, Args... >::{\b value_t} =  std::true_type}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3318} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::dtoa_impl::diyfp Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::dtoa_impl::diyfp}
{\xe \v nlohmann::detail::dtoa_impl::diyfp}
{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b diyfp} (std::uint64_t f_, int e_) noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b diyfp} {\b sub} (const {\b diyfp} &x, const {\b diyfp} &y) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns x - y }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b diyfp} {\b mul} (const {\b diyfp} &x, const {\b diyfp} &y) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns x * y }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b diyfp} {\b normalize} ({\b diyfp} x) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
normalize x such that the significand is >= 2^(q-1) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b diyfp} {\b normalize_to} (const {\b diyfp} &x, const int target_exponent) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
normalize x such that the result has the exponent E }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint64_t {\b f} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b e} = 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr int {\b kPrecision} = 64\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 15276} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v diyfp\:nlohmann::detail::dtoa_impl::diyfp}
{\xe \v nlohmann::detail::dtoa_impl::diyfp\:diyfp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr nlohmann::detail::dtoa_impl::diyfp::diyfp (std::uint64_t  {\i f_}, int  {\i e_}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15283} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v mul\:nlohmann::detail::dtoa_impl::diyfp}
{\xe \v nlohmann::detail::dtoa_impl::diyfp\:mul}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b diyfp} nlohmann::detail::dtoa_impl::diyfp::mul (const {\b diyfp} &  {\i x}, const {\b diyfp} &  {\i y}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns x * y }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The result is rounded. (Only the upper q bits are returned.) \par
}}}{
Definition at line {\b 15301} of file {\b json.hpp}.}\par
}
{\xe \v normalize\:nlohmann::detail::dtoa_impl::diyfp}
{\xe \v nlohmann::detail::dtoa_impl::diyfp\:normalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b diyfp} nlohmann::detail::dtoa_impl::diyfp::normalize ({\b diyfp}  {\i x}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
normalize x such that the significand is >= 2^(q-1) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
x.f != 0 \par
}}}{
Definition at line {\b 15366} of file {\b json.hpp}.}\par
}
{\xe \v normalize_to\:nlohmann::detail::dtoa_impl::diyfp}
{\xe \v nlohmann::detail::dtoa_impl::diyfp\:normalize_to}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b diyfp} nlohmann::detail::dtoa_impl::diyfp::normalize_to (const {\b diyfp} &  {\i x}, const int  {\i target_exponent}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
normalize x such that the result has the exponent E }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
e >= x.e and the upper e - x.e bits of x.f must be zero. \par
}}}{
Definition at line {\b 15383} of file {\b json.hpp}.}\par
}
{\xe \v sub\:nlohmann::detail::dtoa_impl::diyfp}
{\xe \v nlohmann::detail::dtoa_impl::diyfp\:sub}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static {\b diyfp} nlohmann::detail::dtoa_impl::diyfp::sub (const {\b diyfp} &  {\i x}, const {\b diyfp} &  {\i y}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns x - y }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
x.e == y.e and x.f >= y.f \par
}}}{
Definition at line {\b 15289} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v e\:nlohmann::detail::dtoa_impl::diyfp}
{\xe \v nlohmann::detail::dtoa_impl::diyfp\:e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int nlohmann::detail::dtoa_impl::diyfp::e = 0}}
\par
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15281} of file {\b json.hpp}.}\par
}
{\xe \v f\:nlohmann::detail::dtoa_impl::diyfp}
{\xe \v nlohmann::detail::dtoa_impl::diyfp\:f}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint64_t nlohmann::detail::dtoa_impl::diyfp::f = 0}}
\par
{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15280} of file {\b json.hpp}.}\par
}
{\xe \v kPrecision\:nlohmann::detail::dtoa_impl::diyfp}
{\xe \v nlohmann::detail::dtoa_impl::diyfp\:kPrecision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr int nlohmann::detail::dtoa_impl::diyfp::kPrecision = 64{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15278} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DoubleBlk Class Reference\par \pard\plain 
{\tc\tcl2 \v DoubleBlk}
{\xe \v DoubleBlk}
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b DoubleBlk} class creates objects of type {\b DoubleBlk}. }}\par
{
{\f2 #include <Doubleblk.h>}}\par
Inheritance diagram for DoubleBlk:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_double_blk.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DoubleBlk} (QGraphicsItem *parent=NULL)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b DoubleBlk::DoubleBlk} constructor creates a new {\b DoubleBlk} with its required attributes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} (int x, int y)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b posx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b posy} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b DoubleBlk} class creates objects of type {\b DoubleBlk}. \par
}{
Definition at line {\b 8} of file {\b Doubleblk.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DoubleBlk\:DoubleBlk}
{\xe \v DoubleBlk\:DoubleBlk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DoubleBlk::DoubleBlk (QGraphicsItem *  {\i parent} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b DoubleBlk::DoubleBlk} constructor creates a new {\b DoubleBlk} with its required attributes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parent} \cell }{\cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
draw a rectangle for the block\par
}{
Definition at line {\b 7} of file {\b Doubleblk.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v setPosition\:DoubleBlk}
{\xe \v DoubleBlk\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void DoubleBlk::setPosition (int  {\i x}, int  {\i y})}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v posx\:DoubleBlk}
{\xe \v DoubleBlk\:posx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DoubleBlk::posx = 0}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b Doubleblk.h}.}\par
}
{\xe \v posy\:DoubleBlk}
{\xe \v DoubleBlk\:posy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int DoubleBlk::posy = 0}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b Doubleblk.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Doubleblk.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Doubleblk.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::exception Class Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::exception}
{\xe \v nlohmann::detail::exception}
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
general exception of the {\b basic_json} class }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::exception:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1exception.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b what} () const noexcept override\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the explanatory string }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b id}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the id of the exception }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b exception} (int id_, const char *what_arg)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b name} (const std::string &ename, int id_)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static std::string {\b diagnostics} (const BasicJsonType &leaf_element)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
general exception of the {\b basic_json} class \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class is an extension of {\f2 std::exception}  objects with a member {\i id}  for exception ids. It is used as the base class for all exceptions thrown by the {\b basic_json} class. This class can hence be used as "wildcard" to catch exceptions.\par
Subclasses:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b parse_error} for exceptions indicating a parse error\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b invalid_iterator} for exceptions indicating errors with iterators\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b type_error} for exceptions indicating executing a member function with a wrong type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b out_of_range} for exceptions indicating access out of the defined range\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b other_error} for exceptions indicating other library errors\par}
\par
@liveexample\{The following code shows how arbitrary library exceptions can be caught.,exception\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 2649} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v exception\:nlohmann::detail::exception}
{\xe \v nlohmann::detail::exception\:exception}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::exception::exception (int  {\i id_}, const char *  {\i what_arg}){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2663} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v diagnostics\:nlohmann::detail::exception}
{\xe \v nlohmann::detail::exception\:diagnostics}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static std::string nlohmann::detail::exception::diagnostics (const BasicJsonType &  {\i leaf_element}){\f2 [inline]}, {\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2671} of file {\b json.hpp}.}\par
}
{\xe \v name\:nlohmann::detail::exception}
{\xe \v nlohmann::detail::exception\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
static std::string nlohmann::detail::exception::name (const std::string &  {\i ename}, int  {\i id_}){\f2 [inline]}, {\f2 [static]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2665} of file {\b json.hpp}.}\par
}
{\xe \v what\:nlohmann::detail::exception}
{\xe \v nlohmann::detail::exception\:what}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * nlohmann::detail::exception::what () const{\f2 [inline]}, {\f2 [override]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the explanatory string }}\par
{
Definition at line {\b 2653} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v id\:nlohmann::detail::exception}
{\xe \v nlohmann::detail::exception\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int nlohmann::detail::exception::id}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the id of the exception }}\par
{
Definition at line {\b 2659} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::utility_internal::Extend< Seq, SeqSize, Rem > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::utility_internal::Extend< Seq, SeqSize, Rem >}
{\xe \v nlohmann::detail::utility_internal::Extend< Seq, SeqSize, Rem >}
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Seq, size_t SeqSize, size_t Rem>\par
struct nlohmann::detail::utility_internal::Extend< Seq, SeqSize, Rem >\par
}
\par
{
Definition at line {\b 3111} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 0 > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 0 >}
{\xe \v nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 0 >}
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b integer_sequence}< T, Ints...,(Ints+SeqSize)... >\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, T... Ints, size_t SeqSize>\par
struct nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 0 >\par
}
\par
{
Definition at line {\b 3115} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 0 >}
{\xe \v nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 0 >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , T... Ints, size_t SeqSize> using {\b nlohmann::detail::utility_internal::Extend}< {\b integer_sequence}< T, Ints... >, SeqSize, 0 >::{\b type} =  {\b integer_sequence} < T, Ints..., (Ints + SeqSize)... >}}
\par
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3117} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 1 > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 1 >}
{\xe \v nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 1 >}
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b integer_sequence}< T, Ints...,(Ints+SeqSize)..., 2 *SeqSize >\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, T... Ints, size_t SeqSize>\par
struct nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 1 >\par
}
\par
{
Definition at line {\b 3121} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 1 >}
{\xe \v nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 1 >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , T... Ints, size_t SeqSize> using {\b nlohmann::detail::utility_internal::Extend}< {\b integer_sequence}< T, Ints... >, SeqSize, 1 >::{\b type} =  {\b integer_sequence} < T, Ints..., (Ints + SeqSize)..., 2 * SeqSize >}}
\par
{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3123} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::external_constructor< value_t > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::external_constructor< value_t >}
{\xe \v nlohmann::detail::external_constructor< value_t >}
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b value_t}>\par
struct nlohmann::detail::external_constructor< value_t >\par
}
\par
{
Definition at line {\b 4562} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::external_constructor< value_t::array > Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::external_constructor< value_t::array >}
{\xe \v nlohmann::detail::external_constructor< value_t::array >}
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, const typename BasicJsonType::array_t &arr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, typename BasicJsonType::array_t &&arr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleArrayType , {\b enable_if_t}< !std::is_same< CompatibleArrayType, typename BasicJsonType::array_t >::value, int >  = 0> static void {\b construct} (BasicJsonType &j, const CompatibleArrayType &arr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, const std::vector< bool > &arr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , {\b enable_if_t}< std::is_convertible< T, BasicJsonType >::value, int >  = 0> static void {\b construct} (BasicJsonType &j, const std::valarray< T > &arr)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4672} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::array >}
{\xe \v nlohmann::detail::external_constructor< value_t::array >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleArrayType , {\b enable_if_t}< !std::is_same< CompatibleArrayType, typename BasicJsonType::array_t >::value, int >  = 0> static void {\b nlohmann::detail::external_constructor}< {\b value_t::array} >::construct (BasicJsonType &  {\i j}, const CompatibleArrayType &  {\i arr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4697} of file {\b json.hpp}.}\par
}
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::array >}
{\xe \v nlohmann::detail::external_constructor< value_t::array >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T , {\b enable_if_t}< std::is_convertible< T, BasicJsonType >::value, int >  = 0> static void {\b nlohmann::detail::external_constructor}< {\b value_t::array} >::construct (BasicJsonType &  {\i j}, const std::valarray< T > &  {\i arr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4726} of file {\b json.hpp}.}\par
}
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::array >}
{\xe \v nlohmann::detail::external_constructor< value_t::array >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::array} >::construct (BasicJsonType &  {\i j}, const std::vector< bool > &  {\i arr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4710} of file {\b json.hpp}.}\par
}
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::array >}
{\xe \v nlohmann::detail::external_constructor< value_t::array >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::array} >::construct (BasicJsonType &  {\i j}, const typename BasicJsonType::array_t &  {\i arr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4675} of file {\b json.hpp}.}\par
}
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::array >}
{\xe \v nlohmann::detail::external_constructor< value_t::array >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::array} >::construct (BasicJsonType &  {\i j}, typename BasicJsonType::array_t &&  {\i arr}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4685} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::external_constructor< value_t::binary > Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::external_constructor< value_t::binary >}
{\xe \v nlohmann::detail::external_constructor< value_t::binary >}
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, const typename BasicJsonType::binary_t &b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, typename BasicJsonType::binary_t &&b)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4611} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::binary >}
{\xe \v nlohmann::detail::external_constructor< value_t::binary >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::binary} >::construct (BasicJsonType &  {\i j}, const typename BasicJsonType::binary_t &  {\i b}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4614} of file {\b json.hpp}.}\par
}
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::binary >}
{\xe \v nlohmann::detail::external_constructor< value_t::binary >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::binary} >::construct (BasicJsonType &  {\i j}, typename BasicJsonType::binary_t &&  {\i b}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4623} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::external_constructor< value_t::boolean > Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::external_constructor< value_t::boolean >}
{\xe \v nlohmann::detail::external_constructor< value_t::boolean >}
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, typename BasicJsonType::boolean_t b) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4565} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::boolean >}
{\xe \v nlohmann::detail::external_constructor< value_t::boolean >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::boolean} >::construct (BasicJsonType &  {\i j}, typename BasicJsonType::boolean_t  {\i b}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4568} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::external_constructor< value_t::number_float > Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::external_constructor< value_t::number_float >}
{\xe \v nlohmann::detail::external_constructor< value_t::number_float >}
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, typename BasicJsonType::number_float_t val) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4633} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::number_float >}
{\xe \v nlohmann::detail::external_constructor< value_t::number_float >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::number_float} >::construct (BasicJsonType &  {\i j}, typename BasicJsonType::number_float_t  {\i val}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4636} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::external_constructor< value_t::number_integer > Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::external_constructor< value_t::number_integer >}
{\xe \v nlohmann::detail::external_constructor< value_t::number_integer >}
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, typename BasicJsonType::number_integer_t val) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4659} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::number_integer >}
{\xe \v nlohmann::detail::external_constructor< value_t::number_integer >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::number_integer} >::construct (BasicJsonType &  {\i j}, typename BasicJsonType::number_integer_t  {\i val}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4662} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::external_constructor< value_t::number_unsigned > Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::external_constructor< value_t::number_unsigned >}
{\xe \v nlohmann::detail::external_constructor< value_t::number_unsigned >}
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, typename BasicJsonType::number_unsigned_t val) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4646} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::number_unsigned >}
{\xe \v nlohmann::detail::external_constructor< value_t::number_unsigned >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::number_unsigned} >::construct (BasicJsonType &  {\i j}, typename BasicJsonType::number_unsigned_t  {\i val}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4649} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::external_constructor< value_t::object > Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::external_constructor< value_t::object >}
{\xe \v nlohmann::detail::external_constructor< value_t::object >}
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, const typename BasicJsonType::object_t &obj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, typename BasicJsonType::object_t &&obj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleObjectType , {\b enable_if_t}< !std::is_same< CompatibleObjectType, typename BasicJsonType::object_t >::value, int >  = 0> static void {\b construct} (BasicJsonType &j, const CompatibleObjectType &obj)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4742} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::object >}
{\xe \v nlohmann::detail::external_constructor< value_t::object >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleObjectType , {\b enable_if_t}< !std::is_same< CompatibleObjectType, typename BasicJsonType::object_t >::value, int >  = 0> static void {\b nlohmann::detail::external_constructor}< {\b value_t::object} >::construct (BasicJsonType &  {\i j}, const CompatibleObjectType &  {\i obj}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4766} of file {\b json.hpp}.}\par
}
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::object >}
{\xe \v nlohmann::detail::external_constructor< value_t::object >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::object} >::construct (BasicJsonType &  {\i j}, const typename BasicJsonType::object_t &  {\i obj}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4745} of file {\b json.hpp}.}\par
}
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::object >}
{\xe \v nlohmann::detail::external_constructor< value_t::object >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::object} >::construct (BasicJsonType &  {\i j}, typename BasicJsonType::object_t &&  {\i obj}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4755} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::external_constructor< value_t::string > Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::external_constructor< value_t::string >}
{\xe \v nlohmann::detail::external_constructor< value_t::string >}
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, const typename BasicJsonType::string_t &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static void {\b construct} (BasicJsonType &j, typename BasicJsonType::string_t &&s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleStringType , {\b enable_if_t}< !std::is_same< CompatibleStringType, typename BasicJsonType::string_t >::value, int >  = 0> static void {\b construct} (BasicJsonType &j, const CompatibleStringType &str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4578} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::string >}
{\xe \v nlohmann::detail::external_constructor< value_t::string >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleStringType , {\b enable_if_t}< !std::is_same< CompatibleStringType, typename BasicJsonType::string_t >::value, int >  = 0> static void {\b nlohmann::detail::external_constructor}< {\b value_t::string} >::construct (BasicJsonType &  {\i j}, const CompatibleStringType &  {\i str}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4601} of file {\b json.hpp}.}\par
}
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::string >}
{\xe \v nlohmann::detail::external_constructor< value_t::string >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::string} >::construct (BasicJsonType &  {\i j}, const typename BasicJsonType::string_t &  {\i s}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4581} of file {\b json.hpp}.}\par
}
{\xe \v construct\:nlohmann::detail::external_constructor< value_t::string >}
{\xe \v nlohmann::detail::external_constructor< value_t::string >\:construct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static void {\b nlohmann::detail::external_constructor}< {\b value_t::string} >::construct (BasicJsonType &  {\i j}, typename BasicJsonType::string_t &&  {\i s}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4590} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::file_input_adapter Class Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::file_input_adapter}
{\xe \v nlohmann::detail::file_input_adapter}
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b char_type} = char\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_input_adapter} (std::FILE *f) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_input_adapter} (const {\b file_input_adapter} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_input_adapter} ({\b file_input_adapter} &&) noexcept=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_input_adapter} & {\b operator=} (const {\b file_input_adapter} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b file_input_adapter} & {\b operator=} ({\b file_input_adapter} &&)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~file_input_adapter} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::char_traits< char >::int_type {\b get_character} () noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Input adapter for stdio file access. This adapter read only 1 byte and do not use any buffer. This adapter is a very low level adapter. \par
}{
Definition at line {\b 5368} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v char_type\:nlohmann::detail::file_input_adapter}
{\xe \v nlohmann::detail::file_input_adapter\:char_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b nlohmann::detail::file_input_adapter::char_type} =  char}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5371} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v file_input_adapter\:nlohmann::detail::file_input_adapter}
{\xe \v nlohmann::detail::file_input_adapter\:file_input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::file_input_adapter::file_input_adapter (std::FILE *  {\i f}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5374} of file {\b json.hpp}.}\par
}
{\xe \v file_input_adapter\:nlohmann::detail::file_input_adapter}
{\xe \v nlohmann::detail::file_input_adapter\:file_input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::file_input_adapter::file_input_adapter (const {\b file_input_adapter} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v file_input_adapter\:nlohmann::detail::file_input_adapter}
{\xe \v nlohmann::detail::file_input_adapter\:file_input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::file_input_adapter::file_input_adapter ({\b file_input_adapter} && ){\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~file_input_adapter\:nlohmann::detail::file_input_adapter}
{\xe \v nlohmann::detail::file_input_adapter\:~file_input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::file_input_adapter::~file_input_adapter (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_character\:nlohmann::detail::file_input_adapter}
{\xe \v nlohmann::detail::file_input_adapter\:get_character}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::char_traits< char >::int_type nlohmann::detail::file_input_adapter::get_character (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5385} of file {\b json.hpp}.}\par
}
{\xe \v operator=\:nlohmann::detail::file_input_adapter}
{\xe \v nlohmann::detail::file_input_adapter\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b file_input_adapter} & nlohmann::detail::file_input_adapter::operator= (const {\b file_input_adapter} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:nlohmann::detail::file_input_adapter}
{\xe \v nlohmann::detail::file_input_adapter\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b file_input_adapter} & nlohmann::detail::file_input_adapter::operator= ({\b file_input_adapter} && ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::from_json_fn Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::from_json_fn}
{\xe \v nlohmann::detail::from_json_fn}
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T > auto {\b operator()} (const BasicJsonType &j, T &&val) const noexcept(noexcept({\b from_json}(j, std::forward< T >(val)))) -> decltype({\b from_json}(j, std::forward< T >(val)))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4314} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:nlohmann::detail::from_json_fn}
{\xe \v nlohmann::detail::from_json_fn\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T > auto nlohmann::detail::from_json_fn::operator() (const BasicJsonType &  {\i j}, T &&  {\i val}) const -> decltype({\b from_json}(j, std::forward<T>(val)))
    {\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4317} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Game Class Reference\par \pard\plain 
{\tc\tcl2 \v Game}
{\xe \v Game}
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Game} class runs the game interface and manages all the game process. }}\par
{
{\f2 #include <Game.h>}}\par
Inheritance diagram for Game:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_game.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Game} (QWidget *parent=NULL)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::Game} Cosnstructor for the scene. Show all the game`s components. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b randomNumber} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::randomNumber} gets a random number from 1 to 5. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNickName} (QString n)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::setNickName} writes the nickname entered by the player in the label for nickname. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setScore} (QString scr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::setScore} sets the score to the label for score as a number. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addNewBall} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::addNewBall} adds a new ball to the playing area. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reducePadd} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::reducePadd} reduces the paddle width. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b increasePadd} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::increasePadd} increases paddle size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updatedepth} (QString level)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::updatedepth} sets depth level on the sceen. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addSurprise} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::addSurprise} creates surprises in the screen. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QGraphicsScene * {\b scene}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b score}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b scoreNum}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b Player}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b nickName}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b depth}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b depthNum}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Game} class runs the game interface and manages all the game process. \par
}{
Definition at line {\b 11} of file {\b Game.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Game\:Game}
{\xe \v Game\:Game}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Game::Game (QWidget *  {\i parent} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::Game} Cosnstructor for the scene. Show all the game`s components. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parent} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 18} of file {\b Game.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addNewBall\:Game}
{\xe \v Game\:addNewBall}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Game::addNewBall ()}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::addNewBall} adds a new ball to the playing area. }}\par
{
Definition at line {\b 185} of file {\b Game.cpp}.}\par
}
{\xe \v addSurprise\:Game}
{\xe \v Game\:addSurprise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Game::addSurprise ()}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::addSurprise} creates surprises in the screen. }}\par
{
Definition at line {\b 219} of file {\b Game.cpp}.}\par
}
{\xe \v increasePadd\:Game}
{\xe \v Game\:increasePadd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Game::increasePadd ()}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::increasePadd} increases paddle size. }}\par
{
Definition at line {\b 202} of file {\b Game.cpp}.}\par
}
{\xe \v randomNumber\:Game}
{\xe \v Game\:randomNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Game::randomNumber ()}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::randomNumber} gets a random number from 1 to 5. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
returns a number \par
}}}{
Definition at line {\b 144} of file {\b Game.cpp}.}\par
}
{\xe \v reducePadd\:Game}
{\xe \v Game\:reducePadd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Game::reducePadd ()}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::reducePadd} reduces the paddle width. }}\par
{
Definition at line {\b 195} of file {\b Game.cpp}.}\par
}
{\xe \v setNickName\:Game}
{\xe \v Game\:setNickName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Game::setNickName (QString  {\i n})}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::setNickName} writes the nickname entered by the player in the label for nickname. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i n} \cell }{is the nickname as a QString. \cell }
{\row }
}
}{
Definition at line {\b 158} of file {\b Game.cpp}.}\par
}
{\xe \v setScore\:Game}
{\xe \v Game\:setScore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Game::setScore (QString  {\i scr})}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::setScore} sets the score to the label for score as a number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i scr} \cell }{score as a QString \cell }
{\row }
}
}{
Definition at line {\b 176} of file {\b Game.cpp}.}\par
}
{\xe \v updatedepth\:Game}
{\xe \v Game\:updatedepth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Game::updatedepth (QString  {\i level})}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Game::updatedepth} sets depth level on the sceen. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i level} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 210} of file {\b Game.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v depth\:Game}
{\xe \v Game\:depth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* Game::depth}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b Game.h}.}\par
}
{\xe \v depthNum\:Game}
{\xe \v Game\:depthNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* Game::depthNum}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b Game.h}.}\par
}
{\xe \v nickName\:Game}
{\xe \v Game\:nickName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* Game::nickName}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b Game.h}.}\par
}
{\xe \v Player\:Game}
{\xe \v Game\:Player}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* Game::Player}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b Game.h}.}\par
}
{\xe \v scene\:Game}
{\xe \v Game\:scene}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QGraphicsScene* Game::scene}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b Game.h}.}\par
}
{\xe \v score\:Game}
{\xe \v Game\:score}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* Game::score}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b Game.h}.}\par
}
{\xe \v scoreNum\:Game}
{\xe \v Game\:scoreNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* Game::scoreNum}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b Game.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Game.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Game.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gameover Class Reference\par \pard\plain 
{\tc\tcl2 \v gameover}
{\xe \v gameover}
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
\par
{
{\f2 #include <gameover.h>}}\par
Inheritance diagram for gameover:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classgameover.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b gameover} (QWidget *parent=nullptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~gameover} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 10} of file {\b gameover.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v gameover\:gameover}
{\xe \v gameover\:gameover}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gameover::gameover (QWidget *  {\i parent} = {\f2 nullptr}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b gameover.cpp}.}\par
}
{\xe \v ~gameover\:gameover}
{\xe \v gameover\:~gameover}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gameover::~gameover ()}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b gameover.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b gameover.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b gameover.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gamewindow Class Reference\par \pard\plain 
{\tc\tcl2 \v gamewindow}
{\xe \v gamewindow}
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
\par
{
{\f2 #include <gamewindow.h>}}\par
Inheritance diagram for gamewindow:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classgamewindow.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b gamewindow} (QWidget *parent=nullptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~gamewindow} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b keyPressEvent} (QKeyEvent *evt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b randomNumber} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 12} of file {\b gamewindow.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v gamewindow\:gamewindow}
{\xe \v gamewindow\:gamewindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gamewindow::gamewindow (QWidget *  {\i parent} = {\f2 nullptr}){\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~gamewindow\:gamewindow}
{\xe \v gamewindow\:~gamewindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gamewindow::~gamewindow ()}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v keyPressEvent\:gamewindow}
{\xe \v gamewindow\:keyPressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void gamewindow::keyPressEvent (QKeyEvent *  {\i evt})}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v randomNumber\:gamewindow}
{\xe \v gamewindow\:randomNumber}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int gamewindow::randomNumber ()}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b gamewindow.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::utility_internal::Gen< T, N > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::utility_internal::Gen< T, N >}
{\xe \v nlohmann::detail::utility_internal::Gen< T, N >}
{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = typename {\b Extend}< typename {\b Gen}< T, N/2 >::{\b type}, N/2, N % 2 >::{\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, size_t N>\par
struct nlohmann::detail::utility_internal::Gen< T, N >\par
}
\par
{
Definition at line {\b 3129} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:nlohmann::detail::utility_internal::Gen< T, N >}
{\xe \v nlohmann::detail::utility_internal::Gen< T, N >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , size_t N> using {\b nlohmann::detail::utility_internal::Gen}< T, N >::{\b type} =  typename {\b Extend} < typename {\b Gen} < T, N / 2 >::{\b type}, N / 2, N % 2 >::{\b type}}}
\par
{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3131} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::utility_internal::Gen< T, 0 > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::utility_internal::Gen< T, 0 >}
{\xe \v nlohmann::detail::utility_internal::Gen< T, 0 >}
{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b integer_sequence}< T >\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct nlohmann::detail::utility_internal::Gen< T, 0 >\par
}
\par
{
Definition at line {\b 3136} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:nlohmann::detail::utility_internal::Gen< T, 0 >}
{\xe \v nlohmann::detail::utility_internal::Gen< T, 0 >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::utility_internal::Gen}< T, 0 >::{\b type} =  {\b integer_sequence}<T>}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3138} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::has_from_json< BasicJsonType, T, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::has_from_json< BasicJsonType, T, typename >}
{\xe \v nlohmann::detail::has_from_json< BasicJsonType, T, typename >}
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::has_from_json< BasicJsonType, T, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1has__from__json.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename T, typename = void>\par
struct nlohmann::detail::has_from_json< BasicJsonType, T, typename >\par
}
\par
{
Definition at line {\b 3509} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\xe \v nlohmann::detail::has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b serializer} = typename BasicJsonType::template json_serializer< T, void >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename T>\par
struct nlohmann::detail::has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\par
}
\par
{
Definition at line {\b 3522} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v serializer\:nlohmann::detail::has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\xe \v nlohmann::detail::has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\:serializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T > using {\b nlohmann::detail::has_from_json}< BasicJsonType, T, {\b enable_if_t}< !{\b is_basic_json}< T >::{\b value} > >::{\b serializer} =  typename BasicJsonType::template json_serializer<T, void>}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3524} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\xe \v nlohmann::detail::has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T > constexpr bool {\b nlohmann::detail::has_from_json}< BasicJsonType, T, {\b enable_if_t}< !{\b is_basic_json}< T >::value > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        is_detected_exact<void, from_json_function, serializer,\par
        {\cf17 const} BasicJsonType&, T&>::value\par
}
{
Definition at line {\b 3526} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::has_non_default_from_json< BasicJsonType, T, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::has_non_default_from_json< BasicJsonType, T, typename >}
{\xe \v nlohmann::detail::has_non_default_from_json< BasicJsonType, T, typename >}
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::has_non_default_from_json< BasicJsonType, T, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1has__non__default__from__json.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename T, typename = void>\par
struct nlohmann::detail::has_non_default_from_json< BasicJsonType, T, typename >\par
}
\par
{
Definition at line {\b 3534} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\xe \v nlohmann::detail::has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b serializer} = typename BasicJsonType::template json_serializer< T, void >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename T>\par
struct nlohmann::detail::has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\par
}
\par
{
Definition at line {\b 3537} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v serializer\:nlohmann::detail::has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\xe \v nlohmann::detail::has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\:serializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T > using {\b nlohmann::detail::has_non_default_from_json}< BasicJsonType, T, {\b enable_if_t}< !{\b is_basic_json}< T >::{\b value} > >::{\b serializer} =  typename BasicJsonType::template json_serializer<T, void>}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3539} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\xe \v nlohmann::detail::has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T > constexpr bool {\b nlohmann::detail::has_non_default_from_json}< BasicJsonType, T, {\b enable_if_t}< !{\b is_basic_json}< T >::value > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        is_detected_exact<T, from_json_function, serializer,\par
        {\cf17 const} BasicJsonType&>::value\par
}
{
Definition at line {\b 3541} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::has_to_json< BasicJsonType, T, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::has_to_json< BasicJsonType, T, typename >}
{\xe \v nlohmann::detail::has_to_json< BasicJsonType, T, typename >}
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::has_to_json< BasicJsonType, T, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1has__to__json.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename T, typename = void>\par
struct nlohmann::detail::has_to_json< BasicJsonType, T, typename >\par
}
\par
{
Definition at line {\b 3549} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\xe \v nlohmann::detail::has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b serializer} = typename BasicJsonType::template json_serializer< T, void >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename T>\par
struct nlohmann::detail::has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\par
}
\par
{
Definition at line {\b 3552} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v serializer\:nlohmann::detail::has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\xe \v nlohmann::detail::has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\:serializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T > using {\b nlohmann::detail::has_to_json}< BasicJsonType, T, {\b enable_if_t}< !{\b is_basic_json}< T >::{\b value} > >::{\b serializer} =  typename BasicJsonType::template json_serializer<T, void>}}
\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3554} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}
{\xe \v nlohmann::detail::has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T > constexpr bool {\b nlohmann::detail::has_to_json}< BasicJsonType, T, {\b enable_if_t}< !{\b is_basic_json}< T >::value > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        is_detected_exact<void, to_json_function, serializer, BasicJsonType&,\par
        T>::value\par
}
{
Definition at line {\b 3556} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::hash< nlohmann::json > Struct Reference\par \pard\plain 
{\tc\tcl2 \v std::hash< nlohmann::json >}
{\xe \v std::hash< nlohmann::json >}
{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
hash value for JSON objects }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b operator()} (const {\b nlohmann::json} &j) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return a hash value for a JSON object }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
hash value for JSON objects \par
}{
Definition at line {\b 26374} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:std::hash< nlohmann::json >}
{\xe \v std::hash< nlohmann::json >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t std::hash< {\b nlohmann::json} >::operator() (const {\b nlohmann::json} &  {\i j}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return a hash value for a JSON object }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 26381} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::identity_tag< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::identity_tag< T >}
{\xe \v nlohmann::detail::identity_tag< T >}
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
\par
{
{\f2 #include <json.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T>\par
struct nlohmann::detail::identity_tag< T >\par
}
\par
{
Definition at line {\b 3198} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::input_stream_adapter Class Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::input_stream_adapter}
{\xe \v nlohmann::detail::input_stream_adapter}
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b char_type} = char\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~input_stream_adapter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b input_stream_adapter} (std::istream &i)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b input_stream_adapter} (const {\b input_stream_adapter} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b input_stream_adapter} & {\b operator=} ({\b input_stream_adapter} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b input_stream_adapter} & {\b operator=} ({\b input_stream_adapter} &&)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b input_stream_adapter} ({\b input_stream_adapter} &&rhs) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::char_traits< char >::int_type {\b get_character} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Input adapter for a (caching) istream. Ignores a UFT Byte Order Mark at beginning of input. Does not support changing the underlying std::streambuf in mid-input. Maintains underlying std::istream and std::streambuf to support subsequent use of standard std::istream operations to process any input characters following those used in parsing the JSON input. Clears the std::istream flags; any input errors (e.g., EOF) will be detected by the first subsequent call for input from the std::istream. \par
}{
Definition at line {\b 5405} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v char_type\:nlohmann::detail::input_stream_adapter}
{\xe \v nlohmann::detail::input_stream_adapter\:char_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b nlohmann::detail::input_stream_adapter::char_type} =  char}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5408} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~input_stream_adapter\:nlohmann::detail::input_stream_adapter}
{\xe \v nlohmann::detail::input_stream_adapter\:~input_stream_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::input_stream_adapter::~input_stream_adapter (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5410} of file {\b json.hpp}.}\par
}
{\xe \v input_stream_adapter\:nlohmann::detail::input_stream_adapter}
{\xe \v nlohmann::detail::input_stream_adapter\:input_stream_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::input_stream_adapter::input_stream_adapter (std::istream &  {\i i}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5420} of file {\b json.hpp}.}\par
}
{\xe \v input_stream_adapter\:nlohmann::detail::input_stream_adapter}
{\xe \v nlohmann::detail::input_stream_adapter\:input_stream_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::input_stream_adapter::input_stream_adapter (const {\b input_stream_adapter} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v input_stream_adapter\:nlohmann::detail::input_stream_adapter}
{\xe \v nlohmann::detail::input_stream_adapter\:input_stream_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::input_stream_adapter::input_stream_adapter ({\b input_stream_adapter} &&  {\i rhs}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5429} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_character\:nlohmann::detail::input_stream_adapter}
{\xe \v nlohmann::detail::input_stream_adapter\:get_character}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::char_traits< char >::int_type nlohmann::detail::input_stream_adapter::get_character (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5439} of file {\b json.hpp}.}\par
}
{\xe \v operator=\:nlohmann::detail::input_stream_adapter}
{\xe \v nlohmann::detail::input_stream_adapter\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b input_stream_adapter} & nlohmann::detail::input_stream_adapter::operator= ({\b input_stream_adapter} && ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:nlohmann::detail::input_stream_adapter}
{\xe \v nlohmann::detail::input_stream_adapter\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b input_stream_adapter} & nlohmann::detail::input_stream_adapter::operator= ({\b input_stream_adapter} & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::integer_sequence< T, Ints > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::integer_sequence< T, Ints >}
{\xe \v nlohmann::detail::integer_sequence< T, Ints >}
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = T\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::size_t {\b size} () noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, T... Ints>\par
struct nlohmann::detail::integer_sequence< T, Ints >\par
}
\par
{
Definition at line {\b 3090} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v value_type\:nlohmann::detail::integer_sequence< T, Ints >}
{\xe \v nlohmann::detail::integer_sequence< T, Ints >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , T... Ints> using {\b nlohmann::detail::integer_sequence}< T, Ints >::{\b value_type} =  T}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3092} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v size\:nlohmann::detail::integer_sequence< T, Ints >}
{\xe \v nlohmann::detail::integer_sequence< T, Ints >\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , T... Ints> static constexpr std::size_t {\b nlohmann::detail::integer_sequence}< T, Ints >::size (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3093} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::internal_iterator< BasicJsonType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::internal_iterator< BasicJsonType >}
{\xe \v nlohmann::detail::internal_iterator< BasicJsonType >}
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an iterator value }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
BasicJsonType::object_t::iterator {\b object_iterator} \{\}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
iterator for JSON objects }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
BasicJsonType::array_t::iterator {\b array_iterator} \{\}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
iterator for JSON arrays }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b primitive_iterator_t} {\b primitive_iterator} \{\}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
generic iterator for all other types }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType>\par
struct nlohmann::detail::internal_iterator< BasicJsonType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an iterator value \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This structure could easily be a union, but MSVC currently does not allow unions members with complex constructors, see {\f2 https://github.com/nlohmann/json/pull/105}. \par
}}}{
Definition at line {\b 11472} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v array_iterator\:nlohmann::detail::internal_iterator< BasicJsonType >}
{\xe \v nlohmann::detail::internal_iterator< BasicJsonType >\:array_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > BasicJsonType::array_t::iterator {\b nlohmann::detail::internal_iterator}< BasicJsonType >::array_iterator \{\}}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
iterator for JSON arrays }}\par
{
Definition at line {\b 11477} of file {\b json.hpp}.}\par
}
{\xe \v object_iterator\:nlohmann::detail::internal_iterator< BasicJsonType >}
{\xe \v nlohmann::detail::internal_iterator< BasicJsonType >\:object_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > BasicJsonType::object_t::iterator {\b nlohmann::detail::internal_iterator}< BasicJsonType >::object_iterator \{\}}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
iterator for JSON objects }}\par
{
Definition at line {\b 11475} of file {\b json.hpp}.}\par
}
{\xe \v primitive_iterator\:nlohmann::detail::internal_iterator< BasicJsonType >}
{\xe \v nlohmann::detail::internal_iterator< BasicJsonType >\:primitive_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b primitive_iterator_t} {\b nlohmann::detail::internal_iterator}< BasicJsonType >::primitive_iterator \{\}}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
generic iterator for all other types }}\par
{
Definition at line {\b 11479} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InternBlk Class Reference\par \pard\plain 
{\tc\tcl2 \v InternBlk}
{\xe \v InternBlk}
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b InternBlk} class creates objects of type {\b InternBlk}. }}\par
{
{\f2 #include <Internblk.h>}}\par
Inheritance diagram for InternBlk:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_intern_blk.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InternBlk} (QGraphicsItem *parent=NULL)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b InternBlk::InternBlk} constructor creates a new {\b InternBlk} with its required attributes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} (int x, int y)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b posx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b posy} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b InternBlk} class creates objects of type {\b InternBlk}. \par
}{
Definition at line {\b 8} of file {\b Internblk.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InternBlk\:InternBlk}
{\xe \v InternBlk\:InternBlk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InternBlk::InternBlk (QGraphicsItem *  {\i parent} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b InternBlk::InternBlk} constructor creates a new {\b InternBlk} with its required attributes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parent} \cell }{\cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
draw a rectangle for the block\par
}{
Definition at line {\b 7} of file {\b Internblk.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v setPosition\:InternBlk}
{\xe \v InternBlk\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void InternBlk::setPosition (int  {\i x}, int  {\i y})}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v posx\:InternBlk}
{\xe \v InternBlk\:posx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InternBlk::posx = 0}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b Internblk.h}.}\par
}
{\xe \v posy\:InternBlk}
{\xe \v InternBlk\:posy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int InternBlk::posy = 0}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b Internblk.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Internblk.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Internblk.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::invalid_iterator Class Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::invalid_iterator}
{\xe \v nlohmann::detail::invalid_iterator}
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating errors with iterators }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::invalid_iterator:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1invalid__iterator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static {\b invalid_iterator} {\b create} (int id_, const std::string &what_arg, const BasicJsonType &context)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating errors with iterators \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exception is thrown if iterators passed to a library function do not match the expected semantics.\par
Exceptions have ids 2xx.\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{name / id   \cell }{example message   \cell }{description    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.201   \cell }{iterators are not compatible   \cell }{The iterators passed to constructor basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range ({\i first} , {\i last} ) is invalid.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.202   \cell }{iterator does not fit current value   \cell }{In an erase or insert function, the passed iterator {\i pos}  does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.203   \cell }{iterators do not fit current value   \cell }{Either iterator passed to function erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.204   \cell }{iterators out of range   \cell }{When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (begin(), end()), because this is the only way the single stored value is expressed. All other ranges are invalid.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.205   \cell }{iterator out of range   \cell }{When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the begin() iterator, because it is the only way to address the stored value. All other iterators are invalid.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.206   \cell }{cannot construct with iterators from null   \cell }{The iterators passed to constructor basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.207   \cell }{cannot use key() for non-object iterators   \cell }{The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.208   \cell }{cannot use operator[] for object iterators   \cell }{The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.209   \cell }{cannot use offsets with object iterators   \cell }{The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.210   \cell }{iterators do not fit   \cell }{The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range ({\i first} , {\i last} ) is invalid.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.211   \cell }{passed iterators may not belong to container   \cell }{The iterator range passed to the insert function must not be a subrange of the container to insert to.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.212   \cell }{cannot compare iterators of different containers   \cell }{When two iterators are compared, they must belong to the same container.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.213   \cell }{cannot compare order of object iterators   \cell }{The order of object iterators cannot be compared, because JSON objects are unordered.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.invalid_iterator.214   \cell }{cannot get value   \cell }{Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to begin().   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
@liveexample\{The following code shows how an {\f2 {\b invalid_iterator}}  exception can be caught.,{\b invalid_iterator}\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
- {\b exception} for the base class of the library exceptions \par
- {\b parse_error} for exceptions indicating a parse error \par
- {\b type_error} for exceptions indicating executing a member function with a wrong type \par
- {\b out_of_range} for exceptions indicating access out of the defined range \par
- {\b other_error} for exceptions indicating other library errors\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 2872} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:nlohmann::detail::invalid_iterator}
{\xe \v nlohmann::detail::invalid_iterator\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static {\b invalid_iterator} nlohmann::detail::invalid_iterator::create (int  {\i id_}, const std::string &  {\i what_arg}, const BasicJsonType &  {\i context}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2876} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_basic_json< typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_basic_json< typename >}
{\xe \v nlohmann::detail::is_basic_json< typename >}
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_basic_json< typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__basic__json.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename>\par
struct nlohmann::detail::is_basic_json< typename >\par
}
\par
{
Definition at line {\b 3452} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_basic_json< NLOHMANN_BASIC_JSON_TPL > Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_basic_json< NLOHMANN_BASIC_JSON_TPL >}
{\xe \v nlohmann::detail::is_basic_json< NLOHMANN_BASIC_JSON_TPL >}
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_basic_json< NLOHMANN_BASIC_JSON_TPL >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__basic__json_3_01_n_l_o_h_m_a_n_n___b_a_s_i_c___j_s_o_n___t_p_l_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 3455} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_array_type< BasicJsonType, CompatibleArrayType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_array_type< BasicJsonType, CompatibleArrayType >}
{\xe \v nlohmann::detail::is_compatible_array_type< BasicJsonType, CompatibleArrayType >}
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_compatible_array_type< BasicJsonType, CompatibleArrayType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__compatible__array__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CompatibleArrayType>\par
struct nlohmann::detail::is_compatible_array_type< BasicJsonType, CompatibleArrayType >\par
}
\par
{
Definition at line {\b 3757} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, typename >}
{\xe \v nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, typename >}
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__compatible__array__type__impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CompatibleArrayType, typename = void>\par
struct nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, typename >\par
}
\par
{
Definition at line {\b 3738} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, enable_if_t< is_detected< value_type_t, CompatibleArrayType >::value &&is_detected< iterator_t, CompatibleArrayType >::value &&!is_iterator_traits< iterator_traits< CompatibleArrayType > >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, enable_if_t< is_detected< value_type_t, CompatibleArrayType >::value &&is_detected< iterator_t, CompatibleArrayType >::value &&!is_iterator_traits< iterator_traits< CompatibleArrayType > >::value > >}
{\xe \v nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, enable_if_t< is_detected< value_type_t, CompatibleArrayType >::value &&is_detected< iterator_t, CompatibleArrayType >::value &&!is_iterator_traits< iterator_traits< CompatibleArrayType > >::value > >}
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CompatibleArrayType>\par
struct nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, enable_if_t< is_detected< value_type_t, CompatibleArrayType >::value &&is_detected< iterator_t, CompatibleArrayType >::value &&!is_iterator_traits< iterator_traits< CompatibleArrayType > >::value > >\par
}
\par
{
Definition at line {\b 3741} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, enable_if_t< is_detected< value_type_t, CompatibleArrayType >::value &&is_detected< iterator_t, CompatibleArrayType >::value &&!is_iterator_traits< iterator_traits< CompatibleArrayType > >::value > >}
{\xe \v nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, enable_if_t< is_detected< value_type_t, CompatibleArrayType >::value &&is_detected< iterator_t, CompatibleArrayType >::value &&!is_iterator_traits< iterator_traits< CompatibleArrayType > >::value > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleArrayType > constexpr bool {\b nlohmann::detail::is_compatible_array_type_impl}< BasicJsonType, CompatibleArrayType, {\b enable_if_t}< {\b is_detected}< {\b value_type_t}, CompatibleArrayType >::value &&{\b is_detected}< {\b iterator_t}, CompatibleArrayType >::value &&!{\b is_iterator_traits}< {\b iterator_traits}< CompatibleArrayType > >::value > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        is_constructible<BasicJsonType,\par
        {\cf17 typename} CompatibleArrayType::value_type>::value\par
}
{
Definition at line {\b 3751} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_integer_type< RealIntegerType, CompatibleNumberIntegerType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_integer_type< RealIntegerType, CompatibleNumberIntegerType >}
{\xe \v nlohmann::detail::is_compatible_integer_type< RealIntegerType, CompatibleNumberIntegerType >}
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_compatible_integer_type< RealIntegerType, CompatibleNumberIntegerType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__compatible__integer__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename RealIntegerType, typename CompatibleNumberIntegerType>\par
struct nlohmann::detail::is_compatible_integer_type< RealIntegerType, CompatibleNumberIntegerType >\par
}
\par
{
Definition at line {\b 3826} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, typename >}
{\xe \v nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, typename >}
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__compatible__integer__type__impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename RealIntegerType, typename CompatibleNumberIntegerType, typename = void>\par
struct nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, typename >\par
}
\par
{
Definition at line {\b 3805} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >}
{\xe \v nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >}
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b RealLimits} = std::numeric_limits< RealIntegerType >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b CompatibleLimits} = std::numeric_limits< CompatibleNumberIntegerType >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr auto {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename RealIntegerType, typename CompatibleNumberIntegerType>\par
struct nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >\par
}
\par
{
Definition at line {\b 3808} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v CompatibleLimits\:nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >}
{\xe \v nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >\:CompatibleLimits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RealIntegerType , typename CompatibleNumberIntegerType > using {\b nlohmann::detail::is_compatible_integer_type_impl}< RealIntegerType, CompatibleNumberIntegerType, {\b enable_if_t}< std::is_integral< RealIntegerType >::{\b value} &&std::is_integral< CompatibleNumberIntegerType >::{\b value} &&!std::is_same< bool, CompatibleNumberIntegerType >::{\b value} > >::{\b CompatibleLimits} =  std::numeric_limits<CompatibleNumberIntegerType>}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3816} of file {\b json.hpp}.}\par
}
{\xe \v RealLimits\:nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >}
{\xe \v nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >\:RealLimits}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RealIntegerType , typename CompatibleNumberIntegerType > using {\b nlohmann::detail::is_compatible_integer_type_impl}< RealIntegerType, CompatibleNumberIntegerType, {\b enable_if_t}< std::is_integral< RealIntegerType >::{\b value} &&std::is_integral< CompatibleNumberIntegerType >::{\b value} &&!std::is_same< bool, CompatibleNumberIntegerType >::{\b value} > >::{\b RealLimits} =  std::numeric_limits<RealIntegerType>}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3815} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >}
{\xe \v nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename RealIntegerType , typename CompatibleNumberIntegerType > constexpr auto {\b nlohmann::detail::is_compatible_integer_type_impl}< RealIntegerType, CompatibleNumberIntegerType, {\b enable_if_t}< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        is_constructible<RealIntegerType,\par
        CompatibleNumberIntegerType>::value &&\par
        CompatibleLimits::is_integer &&\par
        RealLimits::is_signed == CompatibleLimits::is_signed\par
}
{
Definition at line {\b 3818} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_object_type< BasicJsonType, CompatibleObjectType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_object_type< BasicJsonType, CompatibleObjectType >}
{\xe \v nlohmann::detail::is_compatible_object_type< BasicJsonType, CompatibleObjectType >}
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_compatible_object_type< BasicJsonType, CompatibleObjectType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__compatible__object__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CompatibleObjectType>\par
struct nlohmann::detail::is_compatible_object_type< BasicJsonType, CompatibleObjectType >\par
}
\par
{
Definition at line {\b 3664} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, typename >}
{\xe \v nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, typename >}
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__compatible__object__type__impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CompatibleObjectType, typename = void>\par
struct nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, typename >\par
}
\par
{
Definition at line {\b 3645} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > >}
{\xe \v nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > >}
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b object_t} = typename BasicJsonType::object_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CompatibleObjectType>\par
struct nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > >\par
}
\par
{
Definition at line {\b 3648} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v object_t\:nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > >}
{\xe \v nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > >\:object_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleObjectType > using {\b nlohmann::detail::is_compatible_object_type_impl}< BasicJsonType, CompatibleObjectType, {\b enable_if_t}< {\b is_detected}< {\b mapped_type_t}, CompatibleObjectType >::{\b value} &&{\b is_detected}< {\b key_type_t}, CompatibleObjectType >::{\b value} > >::{\b object_t} =  typename BasicJsonType::object_t}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3653} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > >}
{\xe \v nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleObjectType > constexpr bool {\b nlohmann::detail::is_compatible_object_type_impl}< BasicJsonType, CompatibleObjectType, {\b enable_if_t}< {\b is_detected}< {\b mapped_type_t}, CompatibleObjectType >::value &&{\b is_detected}< {\b key_type_t}, CompatibleObjectType >::value > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        is_constructible<{\cf17 typename} object_t::key_type,\par
        {\cf17 typename} CompatibleObjectType::key_type>::value &&\par
        is_constructible<{\cf17 typename} object_t::mapped_type,\par
        {\cf17 typename} CompatibleObjectType::mapped_type>::value\par
}
{
Definition at line {\b 3656} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_string_type< BasicJsonType, ConstructibleStringType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_string_type< BasicJsonType, ConstructibleStringType >}
{\xe \v nlohmann::detail::is_compatible_string_type< BasicJsonType, ConstructibleStringType >}
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_compatible_string_type< BasicJsonType, ConstructibleStringType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__compatible__string__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename ConstructibleStringType>\par
struct nlohmann::detail::is_compatible_string_type< BasicJsonType, ConstructibleStringType >\par
}
\par
{
Definition at line {\b 3715} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, typename >}
{\xe \v nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, typename >}
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__compatible__string__type__impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CompatibleStringType, typename = void>\par
struct nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, typename >\par
}
\par
{
Definition at line {\b 3702} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, CompatibleStringType >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, CompatibleStringType >::value > >}
{\xe \v nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, CompatibleStringType >::value > >}
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr auto {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CompatibleStringType>\par
struct nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, CompatibleStringType >::value > >\par
}
\par
{
Definition at line {\b 3705} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, CompatibleStringType >::value > >}
{\xe \v nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, CompatibleStringType >::value > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleStringType > constexpr auto {\b nlohmann::detail::is_compatible_string_type_impl}< BasicJsonType, CompatibleStringType, {\b enable_if_t}< {\b is_detected_exact}< typename BasicJsonType::string_t::value_type, {\b value_type_t}, CompatibleStringType >::value > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value\par
}
{
Definition at line {\b 3710} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_type< BasicJsonType, CompatibleType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_type< BasicJsonType, CompatibleType >}
{\xe \v nlohmann::detail::is_compatible_type< BasicJsonType, CompatibleType >}
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_compatible_type< BasicJsonType, CompatibleType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__compatible__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CompatibleType>\par
struct nlohmann::detail::is_compatible_type< BasicJsonType, CompatibleType >\par
}
\par
{
Definition at line {\b 3843} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, typename >}
{\xe \v nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, typename >}
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__compatible__type__impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CompatibleType, typename = void>\par
struct nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, typename >\par
}
\par
{
Definition at line {\b 3831} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, enable_if_t< is_complete_type< CompatibleType >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, enable_if_t< is_complete_type< CompatibleType >::value > >}
{\xe \v nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, enable_if_t< is_complete_type< CompatibleType >::value > >}
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename CompatibleType>\par
struct nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, enable_if_t< is_complete_type< CompatibleType >::value > >\par
}
\par
{
Definition at line {\b 3834} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, enable_if_t< is_complete_type< CompatibleType >::value > >}
{\xe \v nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, enable_if_t< is_complete_type< CompatibleType >::value > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename CompatibleType > constexpr bool {\b nlohmann::detail::is_compatible_type_impl}< BasicJsonType, CompatibleType, {\b enable_if_t}< {\b is_complete_type}< CompatibleType >::value > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        has_to_json<BasicJsonType, CompatibleType>::value\par
}
{
Definition at line {\b 3838} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_complete_type< T, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_complete_type< T, typename >}
{\xe \v nlohmann::detail::is_complete_type< T, typename >}
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_complete_type< T, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__complete__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, typename = void>\par
struct nlohmann::detail::is_complete_type< T, typename >\par
}
\par
{
Definition at line {\b 3638} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_complete_type< T, decltype(void(sizeof(T)))> Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_complete_type< T, decltype(void(sizeof(T)))>}
{\xe \v nlohmann::detail::is_complete_type< T, decltype(void(sizeof(T)))>}
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_complete_type< T, decltype(void(sizeof(T)))>:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__complete__type_3_01_t_00_01decltype_07void_07sizeof_07_t_08_08_08_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct nlohmann::detail::is_complete_type< T, decltype(void(sizeof(T)))>\par
}
\par
{
Definition at line {\b 3641} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible< T, Args > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible< T, Args >}
{\xe \v nlohmann::detail::is_constructible< T, Args >}
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible< T, Args >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, typename... Args>\par
struct nlohmann::detail::is_constructible< T, Args >\par
}
\par
{
Definition at line {\b 3600} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible< const std::pair< T1, T2 > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible< const std::pair< T1, T2 > >}
{\xe \v nlohmann::detail::is_constructible< const std::pair< T1, T2 > >}
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible< const std::pair< T1, T2 > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible_3_01const_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T1, typename T2>\par
struct nlohmann::detail::is_constructible< const std::pair< T1, T2 > >\par
}
\par
{
Definition at line {\b 3606} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible< const std::tuple< Ts... > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible< const std::tuple< Ts... > >}
{\xe \v nlohmann::detail::is_constructible< const std::tuple< Ts... > >}
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible< const std::tuple< Ts... > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible_3_01const_01std_1_1tuple_3_01_ts_8_8_8_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename... Ts>\par
struct nlohmann::detail::is_constructible< const std::tuple< Ts... > >\par
}
\par
{
Definition at line {\b 3612} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible< std::pair< T1, T2 > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible< std::pair< T1, T2 > >}
{\xe \v nlohmann::detail::is_constructible< std::pair< T1, T2 > >}
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible< std::pair< T1, T2 > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T1, typename T2>\par
struct nlohmann::detail::is_constructible< std::pair< T1, T2 > >\par
}
\par
{
Definition at line {\b 3603} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible< std::tuple< Ts... > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible< std::tuple< Ts... > >}
{\xe \v nlohmann::detail::is_constructible< std::tuple< Ts... > >}
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible< std::tuple< Ts... > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible_3_01std_1_1tuple_3_01_ts_8_8_8_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename... Ts>\par
struct nlohmann::detail::is_constructible< std::tuple< Ts... > >\par
}
\par
{
Definition at line {\b 3609} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_array_type< BasicJsonType, ConstructibleArrayType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_array_type< BasicJsonType, ConstructibleArrayType >}
{\xe \v nlohmann::detail::is_constructible_array_type< BasicJsonType, ConstructibleArrayType >}
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible_array_type< BasicJsonType, ConstructibleArrayType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible__array__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename ConstructibleArrayType>\par
struct nlohmann::detail::is_constructible_array_type< BasicJsonType, ConstructibleArrayType >\par
}
\par
{
Definition at line {\b 3800} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, typename >}
{\xe \v nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, typename >}
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible__array__type__impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename ConstructibleArrayType, typename = void>\par
struct nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, typename >\par
}
\par
{
Definition at line {\b 3761} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< !std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value &&is_default_constructible< ConstructibleArrayType >::value &&(std::is_move_assignable< ConstructibleArrayType >::value||std::is_copy_assignable< ConstructibleArrayType >::value)&&is_detected< value_type_t, ConstructibleArrayType >::value &&is_detected< iterator_t, ConstructibleArrayType >::value &&is_complete_type< detected_t< value_type_t, ConstructibleArrayType > >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< !std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value &&is_default_constructible< ConstructibleArrayType >::value &&(std::is_move_assignable< ConstructibleArrayType >::value||std::is_copy_assignable< ConstructibleArrayType >::value)&&is_detected< value_type_t, ConstructibleArrayType >::value &&is_detected< iterator_t, ConstructibleArrayType >::value &&is_complete_type< detected_t< value_type_t, ConstructibleArrayType > >::value > >}
{\xe \v nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< !std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value &&is_default_constructible< ConstructibleArrayType >::value &&(std::is_move_assignable< ConstructibleArrayType >::value||std::is_copy_assignable< ConstructibleArrayType >::value)&&is_detected< value_type_t, ConstructibleArrayType >::value &&is_detected< iterator_t, ConstructibleArrayType >::value &&is_complete_type< detected_t< value_type_t, ConstructibleArrayType > >::value > >}
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename ConstructibleArrayType>\par
struct nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< !std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value &&is_default_constructible< ConstructibleArrayType >::value &&(std::is_move_assignable< ConstructibleArrayType >::value||std::is_copy_assignable< ConstructibleArrayType >::value)&&is_detected< value_type_t, ConstructibleArrayType >::value &&is_detected< iterator_t, ConstructibleArrayType >::value &&is_complete_type< detected_t< value_type_t, ConstructibleArrayType > >::value > >\par
}
\par
{
Definition at line {\b 3771} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< !std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value &&is_default_constructible< ConstructibleArrayType >::value &&(std::is_move_assignable< ConstructibleArrayType >::value||std::is_copy_assignable< ConstructibleArrayType >::value)&&is_detected< value_type_t, ConstructibleArrayType >::value &&is_detected< iterator_t, ConstructibleArrayType >::value &&is_complete_type< detected_t< value_type_t, ConstructibleArrayType > >::value > >}
{\xe \v nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< !std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value &&is_default_constructible< ConstructibleArrayType >::value &&(std::is_move_assignable< ConstructibleArrayType >::value||std::is_copy_assignable< ConstructibleArrayType >::value)&&is_detected< value_type_t, ConstructibleArrayType >::value &&is_detected< iterator_t, ConstructibleArrayType >::value &&is_complete_type< detected_t< value_type_t, ConstructibleArrayType > >::value > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename ConstructibleArrayType > constexpr bool {\b nlohmann::detail::is_constructible_array_type_impl}< BasicJsonType, ConstructibleArrayType, {\b enable_if_t}< !std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value &&{\b is_default_constructible}< ConstructibleArrayType >::value &&(std::is_move_assignable< ConstructibleArrayType >::value||std::is_copy_assignable< ConstructibleArrayType >::value)&&{\b is_detected}< {\b value_type_t}, ConstructibleArrayType >::value &&{\b is_detected}< {\b iterator_t}, ConstructibleArrayType >::value &&{\b is_complete_type}< {\b detected_t}< {\b value_type_t}, ConstructibleArrayType > >::value > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        \par
        \par
        \par
        \par
        \par
        !is_iterator_traits<iterator_traits<ConstructibleArrayType>>::value &&\par
\par
        (std::is_same<{\cf17 typename} ConstructibleArrayType::value_type,\par
         {\cf17 typename} BasicJsonType::array_t::value_type>::value ||\par
         has_from_json<BasicJsonType,\par
         {\cf17 typename} ConstructibleArrayType::value_type>::value ||\par
         has_non_default_from_json <\par
         BasicJsonType, {\cf17 typename} ConstructibleArrayType::value_type >::value)\par
}
{
Definition at line {\b 3783} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value > >}
{\xe \v nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value > >}
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible__array__type__impl_3_01_basic_json_type_00_01_cons8cf88e17d5eaa68665a8fb4b97604b0e.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename ConstructibleArrayType>\par
struct nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value > >\par
}
\par
{
Definition at line {\b 3764} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_object_type< BasicJsonType, ConstructibleObjectType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_object_type< BasicJsonType, ConstructibleObjectType >}
{\xe \v nlohmann::detail::is_constructible_object_type< BasicJsonType, ConstructibleObjectType >}
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible_object_type< BasicJsonType, ConstructibleObjectType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible__object__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename ConstructibleObjectType>\par
struct nlohmann::detail::is_constructible_object_type< BasicJsonType, ConstructibleObjectType >\par
}
\par
{
Definition at line {\b 3696} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, typename >}
{\xe \v nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, typename >}
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible__object__type__impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename ConstructibleObjectType, typename = void>\par
struct nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, typename >\par
}
\par
{
Definition at line {\b 3669} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > >}
{\xe \v nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > >}
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b object_t} = typename BasicJsonType::object_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename ConstructibleObjectType>\par
struct nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > >\par
}
\par
{
Definition at line {\b 3672} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v object_t\:nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > >}
{\xe \v nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > >\:object_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename ConstructibleObjectType > using {\b nlohmann::detail::is_constructible_object_type_impl}< BasicJsonType, ConstructibleObjectType, {\b enable_if_t}< {\b is_detected}< {\b mapped_type_t}, ConstructibleObjectType >::{\b value} &&{\b is_detected}< {\b key_type_t}, ConstructibleObjectType >::{\b value} > >::{\b object_t} =  typename BasicJsonType::object_t}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3677} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > >}
{\xe \v nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename ConstructibleObjectType > constexpr bool {\b nlohmann::detail::is_constructible_object_type_impl}< BasicJsonType, ConstructibleObjectType, {\b enable_if_t}< {\b is_detected}< {\b mapped_type_t}, ConstructibleObjectType >::value &&{\b is_detected}< {\b key_type_t}, ConstructibleObjectType >::value > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        (is_default_constructible<ConstructibleObjectType>::value &&\par
         (std::is_move_assignable<ConstructibleObjectType>::value ||\par
          std::is_copy_assignable<ConstructibleObjectType>::value) &&\par
         (is_constructible<{\cf17 typename} ConstructibleObjectType::key_type,\par
          {\cf17 typename} object_t::key_type>::value &&\par
          std::is_same <\par
          {\cf17 typename} object_t::mapped_type,\par
          {\cf17 typename} ConstructibleObjectType::mapped_type >::value)) ||\par
        (has_from_json<BasicJsonType,\par
         {\cf17 typename} ConstructibleObjectType::mapped_type>::value ||\par
         has_non_default_from_json <\par
         BasicJsonType,\par
         {\cf17 typename} ConstructibleObjectType::mapped_type >::value)\par
}
{
Definition at line {\b 3679} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_string_type< BasicJsonType, ConstructibleStringType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_string_type< BasicJsonType, ConstructibleStringType >}
{\xe \v nlohmann::detail::is_constructible_string_type< BasicJsonType, ConstructibleStringType >}
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible_string_type< BasicJsonType, ConstructibleStringType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible__string__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename ConstructibleStringType>\par
struct nlohmann::detail::is_constructible_string_type< BasicJsonType, ConstructibleStringType >\par
}
\par
{
Definition at line {\b 3734} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, typename >}
{\xe \v nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, typename >}
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible__string__type__impl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename ConstructibleStringType, typename = void>\par
struct nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, typename >\par
}
\par
{
Definition at line {\b 3720} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, ConstructibleStringType >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, ConstructibleStringType >::value > >}
{\xe \v nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, ConstructibleStringType >::value > >}
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr auto {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename ConstructibleStringType>\par
struct nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, ConstructibleStringType >::value > >\par
}
\par
{
Definition at line {\b 3723} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, ConstructibleStringType >::value > >}
{\xe \v nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, ConstructibleStringType >::value > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename ConstructibleStringType > constexpr auto {\b nlohmann::detail::is_constructible_string_type_impl}< BasicJsonType, ConstructibleStringType, {\b enable_if_t}< {\b is_detected_exact}< typename BasicJsonType::string_t::value_type, {\b value_type_t}, ConstructibleStringType >::value > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        is_constructible<ConstructibleStringType,\par
        {\cf17 typename} BasicJsonType::string_t>::value\par
}
{
Definition at line {\b 3728} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_tuple< T1, T2 > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_tuple< T1, T2 >}
{\xe \v nlohmann::detail::is_constructible_tuple< T1, T2 >}
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible_tuple< T1, T2 >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible__tuple.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T1, typename T2>\par
struct nlohmann::detail::is_constructible_tuple< T1, T2 >\par
}
\par
{
Definition at line {\b 3847} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_constructible_tuple< T1, std::tuple< Args... > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_constructible_tuple< T1, std::tuple< Args... > >}
{\xe \v nlohmann::detail::is_constructible_tuple< T1, std::tuple< Args... > >}
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_constructible_tuple< T1, std::tuple< Args... > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__constructible__tuple_3_01_t1_00_01std_1_1tuple_3_01_args_8_8_8_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T1, typename... Args>\par
struct nlohmann::detail::is_constructible_tuple< T1, std::tuple< Args... > >\par
}
\par
{
Definition at line {\b 3850} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_default_constructible< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_default_constructible< T >}
{\xe \v nlohmann::detail::is_default_constructible< T >}
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_default_constructible< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__default__constructible.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct nlohmann::detail::is_default_constructible< T >\par
}
\par
{
Definition at line {\b 3580} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_default_constructible< const std::pair< T1, T2 > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_default_constructible< const std::pair< T1, T2 > >}
{\xe \v nlohmann::detail::is_default_constructible< const std::pair< T1, T2 > >}
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_default_constructible< const std::pair< T1, T2 > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__default__constructible_3_01const_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T1, typename T2>\par
struct nlohmann::detail::is_default_constructible< const std::pair< T1, T2 > >\par
}
\par
{
Definition at line {\b 3587} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_default_constructible< const std::tuple< Ts... > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_default_constructible< const std::tuple< Ts... > >}
{\xe \v nlohmann::detail::is_default_constructible< const std::tuple< Ts... > >}
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_default_constructible< const std::tuple< Ts... > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__default__constructible_3_01const_01std_1_1tuple_3_01_ts_8_8_8_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename... Ts>\par
struct nlohmann::detail::is_default_constructible< const std::tuple< Ts... > >\par
}
\par
{
Definition at line {\b 3595} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_default_constructible< std::pair< T1, T2 > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_default_constructible< std::pair< T1, T2 > >}
{\xe \v nlohmann::detail::is_default_constructible< std::pair< T1, T2 > >}
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_default_constructible< std::pair< T1, T2 > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__default__constructible_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T1, typename T2>\par
struct nlohmann::detail::is_default_constructible< std::pair< T1, T2 > >\par
}
\par
{
Definition at line {\b 3583} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_default_constructible< std::tuple< Ts... > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_default_constructible< std::tuple< Ts... > >}
{\xe \v nlohmann::detail::is_default_constructible< std::tuple< Ts... > >}
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_default_constructible< std::tuple< Ts... > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__default__constructible_3_01std_1_1tuple_3_01_ts_8_8_8_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename... Ts>\par
struct nlohmann::detail::is_default_constructible< std::tuple< Ts... > >\par
}
\par
{
Definition at line {\b 3591} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_detected_lazy< Op, Args > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_detected_lazy< Op, Args >}
{\xe \v nlohmann::detail::is_detected_lazy< Op, Args >}
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_detected_lazy< Op, Args >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__detected__lazy.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<template< class... > class Op, class... Args>\par
struct nlohmann::detail::is_detected_lazy< Op, Args >\par
}
\par
{
Definition at line {\b 3326} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_getable< BasicJsonType, T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_getable< BasicJsonType, T >}
{\xe \v nlohmann::detail::is_getable< BasicJsonType, T >}
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b value} = {\b is_detected}<{\b get_template_function}, const BasicJsonType&, T>::value\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename T>\par
struct nlohmann::detail::is_getable< BasicJsonType, T >\par
}
\par
{
Definition at line {\b 3516} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::is_getable< BasicJsonType, T >}
{\xe \v nlohmann::detail::is_getable< BasicJsonType, T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T > constexpr bool {\b nlohmann::detail::is_getable}< BasicJsonType, T >::value = {\b is_detected}<{\b get_template_function}, const BasicJsonType&, T>::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3518} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_iterator_of_multibyte< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_iterator_of_multibyte< T >}
{\xe \v nlohmann::detail::is_iterator_of_multibyte< T >}
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = typename std::iterator_traits< T >::{\b value_type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct nlohmann::detail::is_iterator_of_multibyte< T >\par
}
\par
{
Definition at line {\b 5678} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v value_type\:nlohmann::detail::is_iterator_of_multibyte< T >}
{\xe \v nlohmann::detail::is_iterator_of_multibyte< T >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::is_iterator_of_multibyte}< T >::{\b value_type} =  typename std::iterator_traits<T>::{\b value_type}}}
\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5680} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > anonymous enum}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5681} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_iterator_traits< T, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_iterator_traits< T, typename >}
{\xe \v nlohmann::detail::is_iterator_traits< T, typename >}
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_iterator_traits< T, typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__iterator__traits.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, typename = void>\par
struct nlohmann::detail::is_iterator_traits< T, typename >\par
}
\par
{
Definition at line {\b 3616} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_iterator_traits< iterator_traits< T > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_iterator_traits< iterator_traits< T > >}
{\xe \v nlohmann::detail::is_iterator_traits< iterator_traits< T > >}
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr auto {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct nlohmann::detail::is_iterator_traits< iterator_traits< T > >\par
}
\par
{
Definition at line {\b 3619} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::is_iterator_traits< iterator_traits< T > >}
{\xe \v nlohmann::detail::is_iterator_traits< iterator_traits< T > >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > constexpr auto {\b nlohmann::detail::is_iterator_traits}< {\b iterator_traits}< T > >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        is_detected<value_type_t, traits>::value &&\par
        is_detected<difference_type_t, traits>::value &&\par
        is_detected<pointer_t, traits>::value &&\par
        is_detected<iterator_category_t, traits>::value &&\par
        is_detected<reference_t, traits>::value\par
}
{
Definition at line {\b 3625} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_json_ref< typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_json_ref< typename >}
{\xe \v nlohmann::detail::is_json_ref< typename >}
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_json_ref< typename >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__json__ref.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename>\par
struct nlohmann::detail::is_json_ref< typename >\par
}
\par
{
Definition at line {\b 3465} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_json_ref< json_ref< T > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_json_ref< json_ref< T > >}
{\xe \v nlohmann::detail::is_json_ref< json_ref< T > >}
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::is_json_ref< json_ref< T > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1is__json__ref_3_01json__ref_3_01_t_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct nlohmann::detail::is_json_ref< json_ref< T > >\par
}
\par
{
Definition at line {\b 3468} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_ordered_map< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_ordered_map< T >}
{\xe \v nlohmann::detail::is_ordered_map< T >}
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b two}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b value} = sizeof(test<T>(nullptr)) == sizeof(char)
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b one} = char\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > static {\b one} {\b test} (decltype(&C::capacity))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C > static {\b two} {\b test} (...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct nlohmann::detail::is_ordered_map< T >\par
}
\par
{
Definition at line {\b 3855} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v one\:nlohmann::detail::is_ordered_map< T >}
{\xe \v nlohmann::detail::is_ordered_map< T >\:one}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::is_ordered_map}< T >::{\b one} =  char}}
\par
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3857} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > anonymous enum}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v value\:nlohmann::detail::is_ordered_map< T >}
{\xe \v nlohmann::detail::is_ordered_map< T >\:value}
{\qr value{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 3867} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v test\:nlohmann::detail::is_ordered_map< T >}
{\xe \v nlohmann::detail::is_ordered_map< T >\:test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename C > static {\b two} {\b nlohmann::detail::is_ordered_map}< T >::test (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v test\:nlohmann::detail::is_ordered_map< T >}
{\xe \v nlohmann::detail::is_ordered_map< T >\:test}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename C > static {\b one} {\b nlohmann::detail::is_ordered_map}< T >::test (decltype &::capacity ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_sax< SAX, BasicJsonType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_sax< SAX, BasicJsonType >}
{\xe \v nlohmann::detail::is_sax< SAX, BasicJsonType >}
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename SAX, typename BasicJsonType>\par
struct nlohmann::detail::is_sax< SAX, BasicJsonType >\par
}
\par
{
Definition at line {\b 8228} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::is_sax< SAX, BasicJsonType >}
{\xe \v nlohmann::detail::is_sax< SAX, BasicJsonType >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename SAX , typename BasicJsonType > constexpr bool {\b nlohmann::detail::is_sax}< SAX, BasicJsonType >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        is_detected_exact<bool, null_function_t, SAX>::value &&\par
        is_detected_exact<bool, boolean_function_t, SAX>::value &&\par
        is_detected_exact<bool, number_integer_function_t, SAX, number_integer_t>::value &&\par
        is_detected_exact<bool, number_unsigned_function_t, SAX, number_unsigned_t>::value &&\par
        is_detected_exact<bool, number_float_function_t, SAX, number_float_t, string_t>::value &&\par
        is_detected_exact<bool, string_function_t, SAX, string_t>::value &&\par
        is_detected_exact<bool, binary_function_t, SAX, binary_t>::value &&\par
        is_detected_exact<bool, start_object_function_t, SAX>::value &&\par
        is_detected_exact<bool, key_function_t, SAX, string_t>::value &&\par
        is_detected_exact<bool, end_object_function_t, SAX>::value &&\par
        is_detected_exact<bool, start_array_function_t, SAX>::value &&\par
        is_detected_exact<bool, end_array_function_t, SAX>::value &&\par
        is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value\par
}
{
Definition at line {\b 8242} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_sax_static_asserts< SAX, BasicJsonType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_sax_static_asserts< SAX, BasicJsonType >}
{\xe \v nlohmann::detail::is_sax_static_asserts< SAX, BasicJsonType >}
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
\par
{
{\f2 #include <json.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename SAX, typename BasicJsonType>\par
struct nlohmann::detail::is_sax_static_asserts< SAX, BasicJsonType >\par
}
\par
{
Definition at line {\b 8259} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::iter_impl< BasicJsonType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >}
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a template for a bidirectional iterator for the {\b basic_json} class This class implements a both iterators (iterator and const_iterator) for the {\b basic_json} class. }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b iterator_category} = std::bidirectional_iterator_tag\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = typename BasicJsonType::value_type\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of the values when the iterator is dereferenced }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b difference_type} = typename BasicJsonType::difference_type\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type to represent differences between iterators }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b pointer} = typename std::conditional< std::is_const< BasicJsonType >::{\b value}, typename BasicJsonType::const_pointer, typename BasicJsonType::pointer >::type\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
defines a pointer to the type iterated over (value_type) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reference} = typename std::conditional< std::is_const< BasicJsonType >::{\b value}, typename BasicJsonType::const_reference, typename BasicJsonType::reference >::type\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
defines a reference to the type iterated over (value_type) }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~iter_impl} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} ({\b iter_impl} &&) noexcept=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} & {\b operator=} ({\b iter_impl} &&) noexcept=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} ({\b pointer} object) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor for a given JSON instance }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} (const {\b iter_impl}< const BasicJsonType > &other) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
const copy constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} & {\b operator=} (const {\b iter_impl}< const BasicJsonType > &other) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
converting assignment }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} (const {\b iter_impl}< typename std::remove_const< BasicJsonType >::type > &other) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
converting constructor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} & {\b operator=} (const {\b iter_impl}< typename std::remove_const< BasicJsonType >::type > &other) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
converting assignment }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b switch} (m_object->m_type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_end} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set the iterator past the last value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator*} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return a reference to the value pointed to by the iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pointer} {\b operator->} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dereference the iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} const {\b operator++} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
post-increment (it++) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} & {\b operator++} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pre-increment (++it) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} const {\b operator--} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
post-decrement (it\'96) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} & {\b operator--} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pre-decrement (\'96it) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename IterImpl , {\b detail::enable_if_t}<(std::is_same< IterImpl, {\b iter_impl} >::{\b value}||std::is_same< IterImpl, {\b other_iter_impl} >::{\b value}), std::nullptr_t >  = nullptr> bool {\b operator==} (const IterImpl &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename IterImpl , {\b detail::enable_if_t}<(std::is_same< IterImpl, {\b iter_impl} >::{\b value}||std::is_same< IterImpl, {\b other_iter_impl} >::{\b value}), std::nullptr_t >  = nullptr> bool {\b operator!=} (const IterImpl &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: not equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b iter_impl} &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: smaller }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b iter_impl} &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than or equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b iter_impl} &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b iter_impl} &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than or equal }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} & {\b operator+=} ({\b difference_type} i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add to iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} & {\b operator-=} ({\b difference_type} i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
subtract from iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} {\b operator+} ({\b difference_type} i) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add to iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} {\b operator-} ({\b difference_type} i) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
subtract from iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b difference_type} {\b operator-} (const {\b iter_impl} &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return difference }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator[]} ({\b difference_type} n) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access to successor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const object_t::key_type & {\b key} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the key of an object iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b value} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the value of an iterator }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JSON_PRIVATE_UNLESS_TESTED} {\b __pad0__}: void set_begin() noexcept \{ {\b JSON_ASSERT}(m_object != nullptr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JSON_PRIVATE_UNLESS_TESTED} {\b __pad1__}: {\b pointer} m_object = nullptr\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b internal_iterator}< typename std::remove_const< BasicJsonType >::type > {\b m_it} \{\}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the actual iterator of the associated instance }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iter_impl} {\b operator+} ({\b difference_type} i, const {\b iter_impl} &it)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
addition of distance and iterator }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType>\par
class nlohmann::detail::iter_impl< BasicJsonType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a template for a bidirectional iterator for the {\b basic_json} class This class implements a both iterators (iterator and const_iterator) for the {\b basic_json} class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
An iterator is called {\i initialized}  when a pointer to a JSON value has been set (e.g., by a constructor or a copy assignment). If the iterator is default-constructed, it is {\i uninitialized}  and most methods are undefined. The library uses assertions to detect calls on uninitialized iterators.** @requirement The class satisfies the following concept requirements:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 BidirectionalIterator}: The iterator that can be moved can be moved in both directions (i.e. incremented and decremented). \par}
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0, simplified in version 2.0.9, change to bidirectional iterators in version 3.0.0 (see {\f2 https://github.com/nlohmann/json/issues/593}) \par
}}}{
Definition at line {\b 11530} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v difference_type\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:difference_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::iter_impl}< BasicJsonType >::{\b difference_type} =  typename BasicJsonType::difference_type}}
\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type to represent differences between iterators }}\par
{
Definition at line {\b 11558} of file {\b json.hpp}.}\par
}
{\xe \v iterator_category\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:iterator_category}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::iter_impl}< BasicJsonType >::{\b iterator_category} =  std::bidirectional_iterator_tag}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17. The C++ Standard has never required user-defined iterators to derive from std::iterator. A user-defined iterator should provide publicly accessible typedefs named iterator_category, value_type, difference_type, pointer, and reference. Note that value_type is required to be non-const, even for constant iterators. \par
}{
Definition at line {\b 11553} of file {\b json.hpp}.}\par
}
{\xe \v pointer\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::iter_impl}< BasicJsonType >::{\b pointer} =  typename std::conditional<std::is_const<BasicJsonType>::{\b value}, typename BasicJsonType::const_pointer, typename BasicJsonType::pointer>::type}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
defines a pointer to the type iterated over (value_type) }}\par
{
Definition at line {\b 11560} of file {\b json.hpp}.}\par
}
{\xe \v reference\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::iter_impl}< BasicJsonType >::{\b reference} =  typename std::conditional<std::is_const<BasicJsonType>::{\b value}, typename BasicJsonType::const_reference, typename BasicJsonType::reference>::type}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
defines a reference to the type iterated over (value_type) }}\par
{
Definition at line {\b 11564} of file {\b json.hpp}.}\par
}
{\xe \v value_type\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::iter_impl}< BasicJsonType >::{\b value_type} =  typename BasicJsonType::value_type}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the type of the values when the iterator is dereferenced }}\par
{
Definition at line {\b 11556} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v iter_impl\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:iter_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::iter_impl}< BasicJsonType >::{\b iter_impl} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~iter_impl\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:~iter_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::iter_impl}< BasicJsonType >::~{\b iter_impl} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v iter_impl\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:iter_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::iter_impl}< BasicJsonType >::{\b iter_impl} ({\b iter_impl}< BasicJsonType > && ){\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v iter_impl\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:iter_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::iter_impl}< BasicJsonType >::{\b iter_impl} ({\b pointer}  {\i object}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
constructor for a given JSON instance }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i object} \cell }{pointer to a JSON object for this iterator \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
object != nullptr \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Postcondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 11580} of file {\b json.hpp}.}\par
}
{\xe \v iter_impl\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:iter_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::iter_impl}< BasicJsonType >::{\b iter_impl} (const {\b iter_impl}< const BasicJsonType > &  {\i other}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
const copy constructor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The conventional copy constructor and copy assignment are implicitly defined. Combined with the following converting constructor and assignment, they support: (1) copy from iterator to iterator, (2) copy from const iterator to const iterator, and (3) conversion from iterator to const iterator. However conversion from const iterator to iterator is not defined.\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i other} \cell }{const iterator to copy from \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
This copy constructor had to be defined explicitly to circumvent a bug occurring on msvc v19.0 compiler (VS 2015) debug build. For more information refer to: {\f2 https://github.com/nlohmann/json/issues/1608} \par
}}}{
Definition at line {\b 11630} of file {\b json.hpp}.}\par
}
{\xe \v iter_impl\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:iter_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::iter_impl}< BasicJsonType >::{\b iter_impl} (const {\b iter_impl}< typename std::remove_const< BasicJsonType >::type > &  {\i other}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
converting constructor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i other} \cell }{non-const iterator to copy from \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
It is not checked whether {\i other}  is initialized. \par
}}}{
Definition at line {\b 11655} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v key\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > const object_t::key_type & {\b nlohmann::detail::iter_impl}< BasicJsonType >::key () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the key of an object iterator }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12202} of file {\b json.hpp}.}\par
}
{\xe \v operator!=\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > template<typename IterImpl , {\b detail::enable_if_t}<(std::is_same< IterImpl, {\b iter_impl} >::{\b value}||std::is_same< IterImpl, {\b other_iter_impl} >::{\b value}), std::nullptr_t >  = nullptr> bool {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator!= (const IterImpl &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: not equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 11985} of file {\b json.hpp}.}\par
}
{\xe \v operator*\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b reference} {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator* () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return a reference to the value pointed to by the iterator }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 11760} of file {\b json.hpp}.}\par
}
{\xe \v operator+\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator+ ({\b difference_type}  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add to iterator }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12102} of file {\b json.hpp}.}\par
}
{\xe \v operator++\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} & {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator++ (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pre-increment (++it) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 11857} of file {\b json.hpp}.}\par
}
{\xe \v operator++\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} const {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator++ (int ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
post-increment (it++) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 11846} of file {\b json.hpp}.}\par
}
{\xe \v operator+=\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} & {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator+= ({\b difference_type}  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add to iterator }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12056} of file {\b json.hpp}.}\par
}
{\xe \v operator-\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b difference_type} {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator- (const {\b iter_impl}< BasicJsonType > &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return difference }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12135} of file {\b json.hpp}.}\par
}
{\xe \v operator-\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator- ({\b difference_type}  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
subtract from iterator }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12124} of file {\b json.hpp}.}\par
}
{\xe \v operator--\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} & {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator-- (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pre-decrement (\'96it) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 11908} of file {\b json.hpp}.}\par
}
{\xe \v operator--\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} const {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator-- (int ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
post-decrement (it\'96) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 11897} of file {\b json.hpp}.}\par
}
{\xe \v operator-=\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} & {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator-= ({\b difference_type}  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
subtract from iterator }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12093} of file {\b json.hpp}.}\par
}
{\xe \v operator->\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b pointer} {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator-> () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dereference the iterator }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 11804} of file {\b json.hpp}.}\par
}
{\xe \v operator<\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator< (const {\b iter_impl}< BasicJsonType > &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: smaller }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 11994} of file {\b json.hpp}.}\par
}
{\xe \v operator<=\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator<= (const {\b iter_impl}< BasicJsonType > &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: less than or equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12029} of file {\b json.hpp}.}\par
}
{\xe \v operator=\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} & {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator= (const {\b iter_impl}< const BasicJsonType > &  {\i other}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
converting assignment }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i other} \cell }{const iterator to copy from \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const/non-const iterator \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
It is not checked whether {\i other}  is initialized. \par
}}}{
Definition at line {\b 11640} of file {\b json.hpp}.}\par
}
{\xe \v operator=\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} & {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator= (const {\b iter_impl}< typename std::remove_const< BasicJsonType >::type > &  {\i other}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
converting assignment }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i other} \cell }{non-const iterator to copy from \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
const/non-const iterator \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
It is not checked whether {\i other}  is initialized. \par
}}}{
Definition at line {\b 11665} of file {\b json.hpp}.}\par
}
{\xe \v operator=\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} & {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator= ({\b iter_impl}< BasicJsonType > && ){\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > template<typename IterImpl , {\b detail::enable_if_t}<(std::is_same< IterImpl, {\b iter_impl} >::{\b value}||std::is_same< IterImpl, {\b other_iter_impl} >::{\b value}), std::nullptr_t >  = nullptr> bool {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator== (const IterImpl &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 11949} of file {\b json.hpp}.}\par
}
{\xe \v operator>\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator> (const {\b iter_impl}< BasicJsonType > &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12038} of file {\b json.hpp}.}\par
}
{\xe \v operator>=\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator>= (const {\b iter_impl}< BasicJsonType > &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison: greater than or equal }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12047} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b reference} {\b nlohmann::detail::iter_impl}< BasicJsonType >::operator[] ({\b difference_type}  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access to successor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12164} of file {\b json.hpp}.}\par
}
{\xe \v set_end\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:set_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void {\b nlohmann::detail::iter_impl}< BasicJsonType >::set_end (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set the iterator past the last value }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 11721} of file {\b json.hpp}.}\par
}
{\xe \v switch\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:switch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::iter_impl}< BasicJsonType >::switch (m_object->  {\i m_type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11681} of file {\b json.hpp}.}\par
}
{\xe \v value\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b reference} {\b nlohmann::detail::iter_impl}< BasicJsonType >::value () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the value of an iterator }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12218} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator+\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b iter_impl} operator+ ({\b difference_type}  {\i i}, const {\b iter_impl}< BasicJsonType > &  {\i it}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
addition of distance and iterator }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The iterator is initialized; i.e. {\f2 m_object != nullptr} . \par
}}}{
Definition at line {\b 12113} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v __pad0__\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:__pad0__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b JSON_PRIVATE_UNLESS_TESTED} {\b nlohmann::detail::iter_impl}< BasicJsonType >::__pad0__}}
\par
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11672} of file {\b json.hpp}.}\par
}
{\xe \v __pad1__\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:__pad1__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b JSON_PRIVATE_UNLESS_TESTED} {\b nlohmann::detail::iter_impl}< BasicJsonType >::__pad1__}}
\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12223} of file {\b json.hpp}.}\par
}
{\xe \v m_it\:nlohmann::detail::iter_impl< BasicJsonType >}
{\xe \v nlohmann::detail::iter_impl< BasicJsonType >\:m_it}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b internal_iterator}<typename std::remove_const<BasicJsonType>::type> {\b nlohmann::detail::iter_impl}< BasicJsonType >::m_it \{\}}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the actual iterator of the associated instance }}\par
{
Definition at line {\b 12227} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::iteration_proxy< IteratorType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::iteration_proxy< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy< IteratorType >}
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
proxy class for the items() function }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iteration_proxy} (typename IteratorType::reference cont) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
construct iteration proxy from a container }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iteration_proxy_value}< IteratorType > {\b begin} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return iterator begin (needed for range-based for) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iteration_proxy_value}< IteratorType > {\b end} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return iterator end (needed for range-based for) }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename IteratorType>\par
class nlohmann::detail::iteration_proxy< IteratorType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
proxy class for the items() function \par
}{
Definition at line {\b 4470} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v iteration_proxy\:nlohmann::detail::iteration_proxy< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy< IteratorType >\:iteration_proxy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > {\b nlohmann::detail::iteration_proxy}< IteratorType >::{\b iteration_proxy} (typename IteratorType::reference  {\i cont}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
construct iteration proxy from a container }}\par
{
Definition at line {\b 4478} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:nlohmann::detail::iteration_proxy< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy< IteratorType >\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > {\b iteration_proxy_value}< IteratorType > {\b nlohmann::detail::iteration_proxy}< IteratorType >::begin (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return iterator begin (needed for range-based for) }}\par
{
Definition at line {\b 4482} of file {\b json.hpp}.}\par
}
{\xe \v end\:nlohmann::detail::iteration_proxy< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy< IteratorType >\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > {\b iteration_proxy_value}< IteratorType > {\b nlohmann::detail::iteration_proxy}< IteratorType >::end (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return iterator end (needed for range-based for) }}\par
{
Definition at line {\b 4488} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::iteration_proxy_value< IteratorType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >}
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b difference_type} = std::ptrdiff_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = {\b iteration_proxy_value}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b pointer} = {\b value_type} *\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reference} = {\b value_type} &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b iterator_category} = std::input_iterator_tag\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b string_type} = typename std::remove_cv< typename std::remove_reference< decltype(std::declval< IteratorType >().{\b key}()) >::type >::type\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iteration_proxy_value} (IteratorType it) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iteration_proxy_value} & {\b operator*} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dereference operator (needed for range-based for) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iteration_proxy_value} & {\b operator++} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
increment operator (needed for range-based for) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b iteration_proxy_value} &o) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
equality operator (needed for InputIterator) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b iteration_proxy_value} &o) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inequality operator (needed for range-based for) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b string_type} & {\b key} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return key of the iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
IteratorType::reference {\b value} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return value of the iterator }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename IteratorType>\par
class nlohmann::detail::iteration_proxy_value< IteratorType >\par
}
\par
{
Definition at line {\b 4372} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v difference_type\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:difference_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > using {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::{\b difference_type} =  std::ptrdiff_t}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4375} of file {\b json.hpp}.}\par
}
{\xe \v iterator_category\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:iterator_category}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > using {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::{\b iterator_category} =  std::input_iterator_tag}}
\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4379} of file {\b json.hpp}.}\par
}
{\xe \v pointer\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > using {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::{\b pointer} =  {\b value_type} *}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4377} of file {\b json.hpp}.}\par
}
{\xe \v reference\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > using {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::{\b reference} =  {\b value_type} &}}
\par
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4378} of file {\b json.hpp}.}\par
}
{\xe \v string_type\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:string_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > using {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::{\b string_type} =  typename std::remove_cv< typename std::remove_reference<decltype( std::declval<IteratorType>().{\b key}() ) >::type >::type}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4380} of file {\b json.hpp}.}\par
}
{\xe \v value_type\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > using {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::{\b value_type} =  {\b iteration_proxy_value}}}
\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4376} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v iteration_proxy_value\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:iteration_proxy_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::{\b iteration_proxy_value} (IteratorType  {\i it}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4395} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v key\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > const {\b string_type} & {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::key () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return key of the iterator }}\par
{
Definition at line {\b 4427} of file {\b json.hpp}.}\par
}
{\xe \v operator!=\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > bool {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::operator!= (const {\b iteration_proxy_value}< IteratorType > &  {\i o}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
inequality operator (needed for range-based for) }}\par
{
Definition at line {\b 4421} of file {\b json.hpp}.}\par
}
{\xe \v operator*\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > {\b iteration_proxy_value} & {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::operator* (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dereference operator (needed for range-based for) }}\par
{
Definition at line {\b 4400} of file {\b json.hpp}.}\par
}
{\xe \v operator++\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > {\b iteration_proxy_value} & {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::operator++ (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
increment operator (needed for range-based for) }}\par
{
Definition at line {\b 4406} of file {\b json.hpp}.}\par
}
{\xe \v operator==\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > bool {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::operator== (const {\b iteration_proxy_value}< IteratorType > &  {\i o}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
equality operator (needed for InputIterator) }}\par
{
Definition at line {\b 4415} of file {\b json.hpp}.}\par
}
{\xe \v value\:nlohmann::detail::iteration_proxy_value< IteratorType >}
{\xe \v nlohmann::detail::iteration_proxy_value< IteratorType >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > IteratorType::reference {\b nlohmann::detail::iteration_proxy_value}< IteratorType >::value () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return value of the iterator }}\par
{
Definition at line {\b 4463} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::iterator_input_adapter< IteratorType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::iterator_input_adapter< IteratorType >}
{\xe \v nlohmann::detail::iterator_input_adapter< IteratorType >}
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b char_type} = typename std::iterator_traits< IteratorType >::value_type\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator_input_adapter} (IteratorType first, IteratorType last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::char_traits< {\b char_type} >::int_type {\b get_character} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BaseInputAdapter , size_t T> struct {\b wide_string_input_helper}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename IteratorType>\par
class nlohmann::detail::iterator_input_adapter< IteratorType >\par
}
\par
{
Definition at line {\b 5460} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v char_type\:nlohmann::detail::iterator_input_adapter< IteratorType >}
{\xe \v nlohmann::detail::iterator_input_adapter< IteratorType >\:char_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > using {\b nlohmann::detail::iterator_input_adapter}< IteratorType >::{\b char_type} =  typename std::iterator_traits<IteratorType>::value_type}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5463} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v iterator_input_adapter\:nlohmann::detail::iterator_input_adapter< IteratorType >}
{\xe \v nlohmann::detail::iterator_input_adapter< IteratorType >\:iterator_input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > {\b nlohmann::detail::iterator_input_adapter}< IteratorType >::{\b iterator_input_adapter} (IteratorType  {\i first}, IteratorType  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5465} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_character\:nlohmann::detail::iterator_input_adapter< IteratorType >}
{\xe \v nlohmann::detail::iterator_input_adapter< IteratorType >\:get_character}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > std::char_traits< {\b char_type} >::int_type {\b nlohmann::detail::iterator_input_adapter}< IteratorType >::get_character (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5469} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v wide_string_input_helper\:nlohmann::detail::iterator_input_adapter< IteratorType >}
{\xe \v nlohmann::detail::iterator_input_adapter< IteratorType >\:wide_string_input_helper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > template<typename BaseInputAdapter , size_t T> friend struct {\b wide_string_input_helper}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5486} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >}
{\xe \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >}
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b iterator_type} = IteratorType\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b char_type} = typename std::iterator_traits< {\b iterator_type} >::value_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b adapter_type} = {\b iterator_input_adapter}< {\b iterator_type} >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b adapter_type} {\b create} (IteratorType first, IteratorType last)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename IteratorType, typename Enable = void>\par
struct nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >\par
}
\par
{
Definition at line {\b 5665} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v adapter_type\:nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >}
{\xe \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >\:adapter_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType , typename Enable  = void> using {\b nlohmann::detail::iterator_input_adapter_factory}< IteratorType, Enable >::{\b adapter_type} =  {\b iterator_input_adapter}<{\b iterator_type}>}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5669} of file {\b json.hpp}.}\par
}
{\xe \v char_type\:nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >}
{\xe \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >\:char_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType , typename Enable  = void> using {\b nlohmann::detail::iterator_input_adapter_factory}< IteratorType, Enable >::{\b char_type} =  typename std::iterator_traits<{\b iterator_type}>::value_type}}
\par
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5668} of file {\b json.hpp}.}\par
}
{\xe \v iterator_type\:nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >}
{\xe \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >\:iterator_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType , typename Enable  = void> using {\b nlohmann::detail::iterator_input_adapter_factory}< IteratorType, Enable >::{\b iterator_type} =  IteratorType}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5667} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >}
{\xe \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType , typename Enable  = void> static {\b adapter_type} {\b nlohmann::detail::iterator_input_adapter_factory}< IteratorType, Enable >::create (IteratorType  {\i first}, IteratorType  {\i last}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5671} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >}
{\xe \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >}
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b iterator_type} = IteratorType\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b char_type} = typename std::iterator_traits< {\b iterator_type} >::value_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b base_adapter_type} = {\b iterator_input_adapter}< {\b iterator_type} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b adapter_type} = {\b wide_string_input_adapter}< {\b base_adapter_type}, {\b char_type} >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b adapter_type} {\b create} (IteratorType first, IteratorType last)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename IteratorType>\par
struct nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >\par
}
\par
{
Definition at line {\b 5688} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v adapter_type\:nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >}
{\xe \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >\:adapter_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > using {\b nlohmann::detail::iterator_input_adapter_factory}< IteratorType, {\b enable_if_t}< {\b is_iterator_of_multibyte}< IteratorType >::value > >::{\b adapter_type} =  {\b wide_string_input_adapter}<{\b base_adapter_type}, {\b char_type}>}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5693} of file {\b json.hpp}.}\par
}
{\xe \v base_adapter_type\:nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >}
{\xe \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >\:base_adapter_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > using {\b nlohmann::detail::iterator_input_adapter_factory}< IteratorType, {\b enable_if_t}< {\b is_iterator_of_multibyte}< IteratorType >::value > >::{\b base_adapter_type} =  {\b iterator_input_adapter}<{\b iterator_type}>}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5692} of file {\b json.hpp}.}\par
}
{\xe \v char_type\:nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >}
{\xe \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >\:char_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > using {\b nlohmann::detail::iterator_input_adapter_factory}< IteratorType, {\b enable_if_t}< {\b is_iterator_of_multibyte}< IteratorType >::value > >::{\b char_type} =  typename std::iterator_traits<{\b iterator_type}>::value_type}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5691} of file {\b json.hpp}.}\par
}
{\xe \v iterator_type\:nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >}
{\xe \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >\:iterator_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > using {\b nlohmann::detail::iterator_input_adapter_factory}< IteratorType, {\b enable_if_t}< {\b is_iterator_of_multibyte}< IteratorType >::value > >::{\b iterator_type} =  IteratorType}}
\par
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5690} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >}
{\xe \v nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename IteratorType > static {\b adapter_type} {\b nlohmann::detail::iterator_input_adapter_factory}< IteratorType, {\b enable_if_t}< {\b is_iterator_of_multibyte}< IteratorType >::value > >::create (IteratorType  {\i first}, IteratorType  {\i last}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5695} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::iterator_traits< T, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::iterator_traits< T, typename >}
{\xe \v nlohmann::detail::iterator_traits< T, typename >}
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
\par
{
{\f2 #include <json.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, typename = void>\par
struct nlohmann::detail::iterator_traits< T, typename >\par
}
\par
{
Definition at line {\b 3256} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >}
{\xe \v nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >}
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b iterator_category} = std::random_access_iterator_tag\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = T\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b difference_type} = ptrdiff_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b pointer} = T *\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reference} = T &\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >\par
}
\par
{
Definition at line {\b 3267} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v difference_type\:nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >}
{\xe \v nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >\:difference_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::iterator_traits}< T *, {\b enable_if_t}< std::is_object< T >::value > >::{\b difference_type} =  ptrdiff_t}}
\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3271} of file {\b json.hpp}.}\par
}
{\xe \v iterator_category\:nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >}
{\xe \v nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >\:iterator_category}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::iterator_traits}< T *, {\b enable_if_t}< std::is_object< T >::value > >::{\b iterator_category} =  std::random_access_iterator_tag}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3269} of file {\b json.hpp}.}\par
}
{\xe \v pointer\:nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >}
{\xe \v nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >\:pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::iterator_traits}< T *, {\b enable_if_t}< std::is_object< T >::value > >::{\b pointer} =  T*}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3272} of file {\b json.hpp}.}\par
}
{\xe \v reference\:nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >}
{\xe \v nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >\:reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::iterator_traits}< T *, {\b enable_if_t}< std::is_object< T >::value > >::{\b reference} =  T&}}
\par
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3273} of file {\b json.hpp}.}\par
}
{\xe \v value_type\:nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >}
{\xe \v nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b nlohmann::detail::iterator_traits}< T *, {\b enable_if_t}< std::is_object< T >::value > >::{\b value_type} =  T}}
\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3270} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::iterator_traits< T, enable_if_t< !std::is_pointer< T >::value > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::iterator_traits< T, enable_if_t< !std::is_pointer< T >::value > >}
{\xe \v nlohmann::detail::iterator_traits< T, enable_if_t< !std::is_pointer< T >::value > >}
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::iterator_traits< T, enable_if_t< !std::is_pointer< T >::value > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1iterator__traits_3_01_t_00_01enable__if__t_3_01_9std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct nlohmann::detail::iterator_traits< T, enable_if_t< !std::is_pointer< T >::value > >\par
}
\par
{
Definition at line {\b 3261} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::iterator_types< It, typename > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::iterator_types< It, typename >}
{\xe \v nlohmann::detail::iterator_types< It, typename >}
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
\par
{
{\f2 #include <json.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename It, typename = void>\par
struct nlohmann::detail::iterator_types< It, typename >\par
}
\par
{
Definition at line {\b 3238} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >}
{\xe \v nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >}
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b difference_type} = typename It::difference_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = typename It::value_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b pointer} = typename It::pointer\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reference} = typename It::reference\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b iterator_category} = typename It::iterator_category\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename It>\par
struct nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >\par
}
\par
{
Definition at line {\b 3241} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v difference_type\:nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >}
{\xe \v nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >\:difference_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename It > using {\b nlohmann::detail::iterator_types}< It, {\b void_t}< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >::{\b difference_type} =  typename It::difference_type}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3246} of file {\b json.hpp}.}\par
}
{\xe \v iterator_category\:nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >}
{\xe \v nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >\:iterator_category}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename It > using {\b nlohmann::detail::iterator_types}< It, {\b void_t}< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >::{\b iterator_category} =  typename It::iterator_category}}
\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3250} of file {\b json.hpp}.}\par
}
{\xe \v pointer\:nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >}
{\xe \v nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >\:pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename It > using {\b nlohmann::detail::iterator_types}< It, {\b void_t}< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >::{\b pointer} =  typename It::pointer}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3248} of file {\b json.hpp}.}\par
}
{\xe \v reference\:nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >}
{\xe \v nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >\:reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename It > using {\b nlohmann::detail::iterator_types}< It, {\b void_t}< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >::{\b reference} =  typename It::reference}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3249} of file {\b json.hpp}.}\par
}
{\xe \v value_type\:nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >}
{\xe \v nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename It > using {\b nlohmann::detail::iterator_types}< It, {\b void_t}< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >::{\b value_type} =  typename It::value_type}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3247} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::json_pointer< BasicJsonType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >}
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON Pointer. }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_pointer} (const std::string &s="")\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create JSON pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b to_string} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return a string representation of the JSON pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::string} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return a string representation of the JSON pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_pointer} & {\b operator/=} (const {\b json_pointer} &ptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
append another JSON pointer at the end of this JSON pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_pointer} & {\b operator/=} (std::string token)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
append an unescaped reference token at the end of this JSON pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_pointer} & {\b operator/=} (std::size_t array_idx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
append an array index at the end of this JSON pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_pointer} {\b parent_pointer} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the parent of this JSON pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pop_back} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove last reference token }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::string & {\b back} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return last reference token }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} (const std::string &token)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
append an unescaped token at the end of the reference pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} (std::string &&token)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
append an unescaped token at the end of the reference pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b empty} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether pointer points to the root document }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b basic_json}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_pointer} {\b operator/} (const {\b json_pointer} &lhs, const {\b json_pointer} &rhs)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_pointer} {\b operator/} (const {\b json_pointer} &ptr, std::string token)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a new JSON pointer by appending the unescaped token at the end of the JSON pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_pointer} {\b operator/} (const {\b json_pointer} &ptr, std::size_t array_idx)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a new JSON pointer by appending the array-index-token at the end of the JSON pointer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} ({\b json_pointer} const &lhs, {\b json_pointer} const &rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
compares two JSON pointers for equality }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} ({\b json_pointer} const &lhs, {\b json_pointer} const &rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
compares two JSON pointers for inequality }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType>\par
class nlohmann::json_pointer< BasicJsonType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON Pointer. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A JSON pointer defines a string syntax for identifying a specific value within a JSON document. It can be used with functions {\f2 at}  and {\f2 operator[]} . Furthermore, JSON pointers are the base for JSON patches.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\f2 RFC 6901}\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 12380} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v json_pointer\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:json_pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::json_pointer}< BasicJsonType >::{\b json_pointer} (const std::string &  {\i s} = {\f2 ""}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Create a JSON pointer according to the syntax described in {\f2 Section 3 of RFC6901}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i s} \cell }{string representing the JSON pointer; if omitted, the empty string is assumed which references the whole JSON value\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.107} \cell }{if the given JSON pointer {\i s}  is nonempty and does not begin with a slash ({\f2 /} ); see example below\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.108} \cell }{if a tilde ({\f2 ~} ) in the given JSON pointer {\i s}  is not followed by {\f2 0}  (representing {\f2 ~} ) or {\f2 1}  (representing {\f2 /} ); see example below\cell }
{\row }
}
@liveexample\{The example shows the construction several valid JSON pointers as well as the exceptional behavior.,{\b json_pointer}\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 12408} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v back\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > const std::string & {\b nlohmann::json_pointer}< BasicJsonType >::back () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return last reference token }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
not {\f2 {\b empty()}}  \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
last reference token\par
}}@liveexample\{The example shows the usage of {\f2 back} .,json_pointer__back\}\par
@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.405} \cell }{if JSON pointer has no parent\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12632} of file {\b json.hpp}.}\par
}
{\xe \v empty\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::json_pointer}< BasicJsonType >::empty () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether pointer points to the root document }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true iff the JSON pointer points to the root document\par
}}@complexity Constant.\par
@exceptionsafety No-throw guarantee: this function never throws exceptions.\par
@liveexample\{The example shows the result of {\f2 empty}  for different JSON Pointers.,json_pointer__empty\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12679} of file {\b json.hpp}.}\par
}
{\xe \v operator std::string\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:operator std::string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::json_pointer}< BasicJsonType >::operator std::string () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return a string representation of the JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Invariant\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
For each JSON pointer {\f2 ptr} , it holds: {
\par
\pard\plain \s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ptr == json_pointer(ptr.to_string());\par
}
\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a string representation of the JSON pointer\par
}}@liveexample\{The example shows the result of {\f2 to_string} .,json_pointer__to_string\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 12437} of file {\b json.hpp}.}\par
}
{\xe \v operator/=\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:operator/=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_pointer} & {\b nlohmann::json_pointer}< BasicJsonType >::operator/= (const {\b json_pointer}< BasicJsonType > &  {\i ptr}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
append another JSON pointer at the end of this JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ptr} \cell }{JSON pointer to append \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
JSON pointer with {\i ptr}  appended\par
}}@liveexample\{The example shows the usage of {\f2 operator/=} .,json_pointer__operator_add\}\par
@complexity Linear in the length of {\i ptr} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b operator/=(std::string)} to append a reference token \par
see {\b operator/=(std::size_t)} to append an array index \par
see {\b operator/(const json_pointer&, const json_pointer&)} for a binary operator\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12458} of file {\b json.hpp}.}\par
}
{\xe \v operator/=\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:operator/=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_pointer} & {\b nlohmann::json_pointer}< BasicJsonType >::operator/= (std::size_t  {\i array_idx}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
append an array index at the end of this JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i array_idx} \cell }{array index to append \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
JSON pointer with {\i array_idx}  appended\par
}}@liveexample\{The example shows the usage of {\f2 operator/=} .,json_pointer__operator_add\}\par
@complexity Amortized constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b operator/=(const json_pointer&)} to append a JSON pointer \par
see {\b operator/=(std::string)} to append a reference token \par
see {\b operator/(const json_pointer&, std::string)} for a binary operator\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12504} of file {\b json.hpp}.}\par
}
{\xe \v operator/=\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:operator/=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_pointer} & {\b nlohmann::json_pointer}< BasicJsonType >::operator/= (std::string  {\i token}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
append an unescaped reference token at the end of this JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i token} \cell }{reference token to append \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
JSON pointer with {\i token}  appended without escaping {\i token}  \par
}}@liveexample\{The example shows the usage of {\f2 operator/=} .,json_pointer__operator_add\}\par
@complexity Amortized constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b operator/=(const json_pointer&)} to append a JSON pointer \par
see {\b operator/=(std::size_t)} to append an array index \par
see {\b operator/(const json_pointer&, std::size_t)} for a binary operator\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12482} of file {\b json.hpp}.}\par
}
{\xe \v parent_pointer\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:parent_pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_pointer} {\b nlohmann::json_pointer}< BasicJsonType >::parent_pointer () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
returns the parent of this JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
parent of this JSON pointer; in case this JSON pointer is the root, the root itself is returned\par
}}@complexity Linear in the length of the JSON pointer.\par
@liveexample\{The example shows the result of {\f2 parent_pointer}  for different JSON Pointers.,json_pointer__parent_pointer\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12583} of file {\b json.hpp}.}\par
}
{\xe \v pop_back\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:pop_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void {\b nlohmann::json_pointer}< BasicJsonType >::pop_back (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
remove last reference token }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Precondition\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
not {\f2 {\b empty()}} \par
}}@liveexample\{The example shows the usage of {\f2 pop_back} .,json_pointer__pop_back\}\par
@complexity Constant.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i out_of_range.405} \cell }{if JSON pointer has no parent\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12608} of file {\b json.hpp}.}\par
}
{\xe \v push_back\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void {\b nlohmann::json_pointer}< BasicJsonType >::push_back (const std::string &  {\i token}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
append an unescaped token at the end of the reference pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i token} \cell }{token to add\cell }
{\row }
}
@complexity Amortized constant.\par
@liveexample\{The example shows the result of {\f2 push_back}  for different JSON Pointers.,json_pointer__push_back\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12654} of file {\b json.hpp}.}\par
}
{\xe \v push_back\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void {\b nlohmann::json_pointer}< BasicJsonType >::push_back (std::string &&  {\i token}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
append an unescaped token at the end of the reference pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i token} \cell }{token to add\cell }
{\row }
}
@complexity Amortized constant.\par
@liveexample\{The example shows the result of {\f2 push_back}  for different JSON Pointers.,json_pointer__push_back\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12660} of file {\b json.hpp}.}\par
}
{\xe \v to_string\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > std::string {\b nlohmann::json_pointer}< BasicJsonType >::to_string () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return a string representation of the JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Invariant\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
For each JSON pointer {\f2 ptr} , it holds: {
\par
\pard\plain \s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid ptr == json_pointer(ptr.to_string());\par
}
\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a string representation of the JSON pointer\par
}}@liveexample\{The example shows the result of {\f2 to_string} .,json_pointer__to_string\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 12426} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v basic_json\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:basic_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > friend class {\b basic_json}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12384} of file {\b json.hpp}.}\par
}
{\xe \v operator!=\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool operator!= ({\b json_pointer}< BasicJsonType > const &  {\i lhs}, {\b json_pointer}< BasicJsonType > const &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
compares two JSON pointers for inequality }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{JSON pointer to compare \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{JSON pointer to compare \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is not equal {\i rhs}  \par
}}@complexity Linear in the length of the JSON pointer\par
@exceptionsafety No-throw guarantee: this function never throws exceptions. \par
}{
Definition at line {\b 13341} of file {\b json.hpp}.}\par
}
{\xe \v operator/\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_pointer} operator/ (const {\b json_pointer}< BasicJsonType > &  {\i lhs}, const {\b json_pointer}< BasicJsonType > &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a new JSON pointer by appending the right JSON pointer at the end of the left JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{JSON pointer \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{JSON pointer \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a new JSON pointer with {\i rhs}  appended to {\i lhs}  \par
}}@liveexample\{The example shows the usage of {\f2 operator/} .,json_pointer__operator_add_binary\}\par
@complexity Linear in the length of {\i lhs}  and {\i rhs} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b operator/=(const json_pointer&)} to append a JSON pointer\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12524} of file {\b json.hpp}.}\par
}
{\xe \v operator/\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_pointer} operator/ (const {\b json_pointer}< BasicJsonType > &  {\i ptr}, std::size_t  {\i array_idx}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a new JSON pointer by appending the array-index-token at the end of the JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ptr} \cell }{JSON pointer \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i array_idx} \cell }{array index \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a new JSON pointer with {\i array_idx}  appended to {\i ptr}  \par
}}@liveexample\{The example shows the usage of {\f2 operator/} .,json_pointer__operator_add_binary\}\par
@complexity Linear in the length of {\i ptr} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b operator/=(std::size_t)} to append an array index\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12565} of file {\b json.hpp}.}\par
}
{\xe \v operator/\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_pointer} operator/ (const {\b json_pointer}< BasicJsonType > &  {\i ptr}, std::string  {\i token}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a new JSON pointer by appending the unescaped token at the end of the JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ptr} \cell }{JSON pointer \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i token} \cell }{reference token \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a new JSON pointer with unescaped {\i token}  appended to {\i ptr}  \par
}}@liveexample\{The example shows the usage of {\f2 operator/} .,json_pointer__operator_add_binary\}\par
@complexity Linear in the length of {\i ptr} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
see {\b operator/=(std::string)} to append a reference token\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.6.0 \par
}}}{
Definition at line {\b 12545} of file {\b json.hpp}.}\par
}
{\xe \v operator==\:nlohmann::json_pointer< BasicJsonType >}
{\xe \v nlohmann::json_pointer< BasicJsonType >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool operator== ({\b json_pointer}< BasicJsonType > const &  {\i lhs}, {\b json_pointer}< BasicJsonType > const &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
compares two JSON pointers for equality }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lhs} \cell }{JSON pointer to compare \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i rhs} \cell }{JSON pointer to compare \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether {\i lhs}  is equal to {\i rhs}  \par
}}@complexity Linear in the length of the JSON pointer\par
@exceptionsafety No-throw guarantee: this function never throws exceptions. \par
}{
Definition at line {\b 13324} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::json_ref< BasicJsonType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >}
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = BasicJsonType\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_ref} ({\b value_type} &&value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_ref} (const {\b value_type} &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_ref} (std::initializer_list< {\b json_ref} > init)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class... Args, {\b enable_if_t}< std::is_constructible< {\b value_type}, Args... >::value, int >  = 0> {\b json_ref} (Args &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_ref} ({\b json_ref} &&) noexcept=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_ref} (const {\b json_ref} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_ref} & {\b operator=} (const {\b json_ref} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_ref} & {\b operator=} ({\b json_ref} &&)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~json_ref} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} {\b moved_or_copied} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} const & {\b operator*} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} const * {\b operator->} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType>\par
class nlohmann::detail::json_ref< BasicJsonType >\par
}
\par
{
Definition at line {\b 13366} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v value_type\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_ref}< BasicJsonType >::{\b value_type} =  BasicJsonType}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13369} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v json_ref\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:json_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_ref}< BasicJsonType >::{\b json_ref} ({\b value_type} &&  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13371} of file {\b json.hpp}.}\par
}
{\xe \v json_ref\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:json_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_ref}< BasicJsonType >::{\b json_ref} (const {\b value_type} &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13375} of file {\b json.hpp}.}\par
}
{\xe \v json_ref\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:json_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_ref}< BasicJsonType >::{\b json_ref} (std::initializer_list< {\b json_ref}< BasicJsonType > >  {\i init}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13379} of file {\b json.hpp}.}\par
}
{\xe \v json_ref\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:json_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > template<class... Args, {\b enable_if_t}< std::is_constructible< {\b value_type}, Args... >::value, int >  = 0> {\b nlohmann::detail::json_ref}< BasicJsonType >::{\b json_ref} (Args &&...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13386} of file {\b json.hpp}.}\par
}
{\xe \v json_ref\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:json_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_ref}< BasicJsonType >::{\b json_ref} ({\b json_ref}< BasicJsonType > && ){\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v json_ref\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:json_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_ref}< BasicJsonType >::{\b json_ref} (const {\b json_ref}< BasicJsonType > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~json_ref\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:~json_ref}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_ref}< BasicJsonType >::~{\b json_ref} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v moved_or_copied\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:moved_or_copied}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b value_type} {\b nlohmann::detail::json_ref}< BasicJsonType >::moved_or_copied () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13397} of file {\b json.hpp}.}\par
}
{\xe \v operator*\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b value_type} const  & {\b nlohmann::detail::json_ref}< BasicJsonType >::operator* () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13406} of file {\b json.hpp}.}\par
}
{\xe \v operator->\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b value_type} const  * {\b nlohmann::detail::json_ref}< BasicJsonType >::operator-> () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13411} of file {\b json.hpp}.}\par
}
{\xe \v operator=\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_ref} & {\b nlohmann::detail::json_ref}< BasicJsonType >::operator= (const {\b json_ref}< BasicJsonType > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:nlohmann::detail::json_ref< BasicJsonType >}
{\xe \v nlohmann::detail::json_ref< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_ref} & {\b nlohmann::detail::json_ref}< BasicJsonType >::operator= ({\b json_ref}< BasicJsonType > && ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::json_reverse_iterator< Base > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >}
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a template for a reverse iterator class }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::json_reverse_iterator< Base >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1json__reverse__iterator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b difference_type} = std::ptrdiff_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b base_iterator} = std::reverse_iterator< Base >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
shortcut to the reverse iterator adapter }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reference} = typename Base::reference\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the reference type for the pointed-to element }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_reverse_iterator} (const typename base_iterator::iterator_type &it) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create reverse iterator from iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_reverse_iterator} (const {\b base_iterator} &it) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create reverse iterator from base class }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_reverse_iterator} const {\b operator++} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
post-increment (it++) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_reverse_iterator} & {\b operator++} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pre-increment (++it) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_reverse_iterator} const {\b operator--} (int)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
post-decrement (it\'96) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_reverse_iterator} & {\b operator--} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pre-decrement (\'96it) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_reverse_iterator} & {\b operator+=} ({\b difference_type} i)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add to iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_reverse_iterator} {\b operator+} ({\b difference_type} i) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add to iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_reverse_iterator} {\b operator-} ({\b difference_type} i) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
subtract from iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b difference_type} {\b operator-} (const {\b json_reverse_iterator} &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return difference }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator[]} ({\b difference_type} n) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access to successor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
auto {\b key} () const -> decltype(std::declval< Base >().key())\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the key of an object iterator }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b value} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the value of an iterator }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename Base>\par
class nlohmann::detail::json_reverse_iterator< Base >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a template for a reverse iterator class \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Base} \cell }{the base iterator type to reverse. Valid types are iterator (to create reverse_iterator) and const_iterator (to create const_reverse_iterator).\cell }
{\row }
}
@requirement The class satisfies the following concept requirements:{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 BidirectionalIterator}: The iterator that can be moved can be moved in both directions (i.e. incremented and decremented).\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\f2 OutputIterator}: It is possible to write to the pointed-to element (only if {\i Base}  is iterator).\par}
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 12268} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v base_iterator\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:base_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > using {\b nlohmann::detail::json_reverse_iterator}< Base >::{\b base_iterator} =  std::reverse_iterator<Base>}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
shortcut to the reverse iterator adapter }}\par
{
Definition at line {\b 12273} of file {\b json.hpp}.}\par
}
{\xe \v difference_type\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:difference_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > using {\b nlohmann::detail::json_reverse_iterator}< Base >::{\b difference_type} =  std::ptrdiff_t}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12271} of file {\b json.hpp}.}\par
}
{\xe \v reference\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > using {\b nlohmann::detail::json_reverse_iterator}< Base >::{\b reference} =  typename Base::reference}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the reference type for the pointed-to element }}\par
{
Definition at line {\b 12275} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v json_reverse_iterator\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:json_reverse_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b nlohmann::detail::json_reverse_iterator}< Base >::{\b json_reverse_iterator} (const typename base_iterator::iterator_type &  {\i it}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create reverse iterator from iterator }}\par
{
Definition at line {\b 12278} of file {\b json.hpp}.}\par
}
{\xe \v json_reverse_iterator\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:json_reverse_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b nlohmann::detail::json_reverse_iterator}< Base >::{\b json_reverse_iterator} (const {\b base_iterator} &  {\i it}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create reverse iterator from base class }}\par
{
Definition at line {\b 12282} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v key\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > auto {\b nlohmann::detail::json_reverse_iterator}< Base >::key () const -> decltype(std::declval<Base>().key())
    {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the key of an object iterator }}\par
{
Definition at line {\b 12339} of file {\b json.hpp}.}\par
}
{\xe \v operator+\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b json_reverse_iterator} {\b nlohmann::detail::json_reverse_iterator}< Base >::operator+ ({\b difference_type}  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add to iterator }}\par
{
Definition at line {\b 12315} of file {\b json.hpp}.}\par
}
{\xe \v operator++\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b json_reverse_iterator} & {\b nlohmann::detail::json_reverse_iterator}< Base >::operator++ (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pre-increment (++it) }}\par
{
Definition at line {\b 12291} of file {\b json.hpp}.}\par
}
{\xe \v operator++\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b json_reverse_iterator} const {\b nlohmann::detail::json_reverse_iterator}< Base >::operator++ (int ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
post-increment (it++) }}\par
{
Definition at line {\b 12285} of file {\b json.hpp}.}\par
}
{\xe \v operator+=\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b json_reverse_iterator} & {\b nlohmann::detail::json_reverse_iterator}< Base >::operator+= ({\b difference_type}  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
add to iterator }}\par
{
Definition at line {\b 12309} of file {\b json.hpp}.}\par
}
{\xe \v operator-\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b difference_type} {\b nlohmann::detail::json_reverse_iterator}< Base >::operator- (const {\b json_reverse_iterator}< Base > &  {\i other}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return difference }}\par
{
Definition at line {\b 12327} of file {\b json.hpp}.}\par
}
{\xe \v operator-\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b json_reverse_iterator} {\b nlohmann::detail::json_reverse_iterator}< Base >::operator- ({\b difference_type}  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
subtract from iterator }}\par
{
Definition at line {\b 12321} of file {\b json.hpp}.}\par
}
{\xe \v operator--\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b json_reverse_iterator} & {\b nlohmann::detail::json_reverse_iterator}< Base >::operator-- (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pre-decrement (\'96it) }}\par
{
Definition at line {\b 12303} of file {\b json.hpp}.}\par
}
{\xe \v operator--\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b json_reverse_iterator} const {\b nlohmann::detail::json_reverse_iterator}< Base >::operator-- (int ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
post-decrement (it\'96) }}\par
{
Definition at line {\b 12297} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b reference} {\b nlohmann::detail::json_reverse_iterator}< Base >::operator[] ({\b difference_type}  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
access to successor }}\par
{
Definition at line {\b 12333} of file {\b json.hpp}.}\par
}
{\xe \v value\:nlohmann::detail::json_reverse_iterator< Base >}
{\xe \v nlohmann::detail::json_reverse_iterator< Base >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Base > {\b reference} {\b nlohmann::detail::json_reverse_iterator}< Base >::value () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the value of an iterator }}\par
{
Definition at line {\b 12346} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::json_sax< BasicJsonType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >}
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX interface. }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_integer_t} = typename BasicJsonType::number_integer_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_unsigned_t} = typename BasicJsonType::number_unsigned_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_float_t} = typename BasicJsonType::number_float_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b string_t} = typename BasicJsonType::string_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b binary_t} = typename BasicJsonType::binary_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b null} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a null value was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b boolean} (bool val)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a boolean value was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b number_integer} ({\b number_integer_t} val)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an integer number was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b number_unsigned} ({\b number_unsigned_t} val)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an unsigned integer number was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b number_float} ({\b number_float_t} val, const {\b string_t} &s)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an floating-point number was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b string} ({\b string_t} &val)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a string was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b binary} ({\b binary_t} &val)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a binary string was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b start_object} (std::size_t elements)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the beginning of an object was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b key} ({\b string_t} &val)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an object key was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b end_object} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the end of an object was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b start_array} (std::size_t elements)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the beginning of an array was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b end_array} ()=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the end of an array was read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b parse_error} (std::size_t position, const std::string &last_token, const {\b detail::exception} &ex)=0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a parse error occurred }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax} (const {\b json_sax} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax} ({\b json_sax} &&) noexcept=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax} & {\b operator=} (const {\b json_sax} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax} & {\b operator=} ({\b json_sax} &&) noexcept=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~json_sax} ()=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType>\par
struct nlohmann::json_sax< BasicJsonType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX interface. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class describes the SAX interface used by {\b nlohmann::json::sax_parse}. Each function is called in different situations while the input is parsed. The boolean return value informs the parser whether to continue processing the input. \par
}{
Definition at line {\b 5841} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v binary_t\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:binary_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::json_sax}< BasicJsonType >::{\b binary_t} =  typename BasicJsonType::binary_t}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5847} of file {\b json.hpp}.}\par
}
{\xe \v number_float_t\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:number_float_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::json_sax}< BasicJsonType >::{\b number_float_t} =  typename BasicJsonType::number_float_t}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5845} of file {\b json.hpp}.}\par
}
{\xe \v number_integer_t\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:number_integer_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::json_sax}< BasicJsonType >::{\b number_integer_t} =  typename BasicJsonType::number_integer_t}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5843} of file {\b json.hpp}.}\par
}
{\xe \v number_unsigned_t\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:number_unsigned_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::json_sax}< BasicJsonType >::{\b number_unsigned_t} =  typename BasicJsonType::number_unsigned_t}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5844} of file {\b json.hpp}.}\par
}
{\xe \v string_t\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:string_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::json_sax}< BasicJsonType >::{\b string_t} =  typename BasicJsonType::string_t}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5846} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v json_sax\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:json_sax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::json_sax}< BasicJsonType >::{\b json_sax} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v json_sax\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:json_sax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::json_sax}< BasicJsonType >::{\b json_sax} (const {\b json_sax}< BasicJsonType > & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v json_sax\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:json_sax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::json_sax}< BasicJsonType >::{\b json_sax} ({\b json_sax}< BasicJsonType > && ){\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~json_sax\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:~json_sax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual {\b nlohmann::json_sax}< BasicJsonType >::~{\b json_sax} (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v binary\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::binary ({\b binary_t} &  {\i val}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a binary string was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{binary value \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
It is safe to move the passed binary. \par
}}}}
{\xe \v boolean\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::boolean (bool  {\i val}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a boolean value was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{boolean value \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}}}
{\xe \v end_array\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:end_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::end_array (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the end of an array was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}}}
{\xe \v end_object\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:end_object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::end_object (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the end of an object was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}}}
{\xe \v key\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::key ({\b string_t} &  {\i val}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an object key was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{object key \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
It is safe to move the passed string. \par
}}}}
{\xe \v null\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:null}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::null (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a null value was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}}}
{\xe \v number_float\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:number_float}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::number_float ({\b number_float_t}  {\i val}, const {\b string_t} &  {\i s}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an floating-point number was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{floating-point value \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i s} \cell }{raw token value \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}}}
{\xe \v number_integer\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:number_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::number_integer ({\b number_integer_t}  {\i val}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an integer number was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{integer value \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}}}
{\xe \v number_unsigned\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:number_unsigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::number_unsigned ({\b number_unsigned_t}  {\i val}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an unsigned integer number was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{unsigned integer value \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}}}
{\xe \v operator=\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_sax} & {\b nlohmann::json_sax}< BasicJsonType >::operator= (const {\b json_sax}< BasicJsonType > & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_sax} & {\b nlohmann::json_sax}< BasicJsonType >::operator= ({\b json_sax}< BasicJsonType > && ){\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_error\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:parse_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::parse_error (std::size_t  {\i position}, const std::string &  {\i last_token}, const {\b detail::exception} &  {\i ex}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a parse error occurred }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i position} \cell }{the position in the input where the error occurs \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i last_token} \cell }{the last read token \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ex} \cell }{an exception object describing the error \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed (must return false) \par
}}}}
{\xe \v start_array\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:start_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::start_array (std::size_t  {\i elements}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the beginning of an array was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i elements} \cell }{number of array elements or -1 if unknown \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
binary formats may report the number of elements \par
}}}}
{\xe \v start_object\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:start_object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::start_object (std::size_t  {\i elements}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the beginning of an object was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i elements} \cell }{number of object elements or -1 if unknown \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
binary formats may report the number of elements \par
}}}}
{\xe \v string\:nlohmann::json_sax< BasicJsonType >}
{\xe \v nlohmann::json_sax< BasicJsonType >\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > virtual bool {\b nlohmann::json_sax}< BasicJsonType >::string ({\b string_t} &  {\i val}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a string was read }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{string value \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether parsing should proceed \par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
It is safe to move the passed string. \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::json_sax_acceptor< BasicJsonType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_integer_t} = typename BasicJsonType::number_integer_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_unsigned_t} = typename BasicJsonType::number_unsigned_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_float_t} = typename BasicJsonType::number_float_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b string_t} = typename BasicJsonType::string_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b binary_t} = typename BasicJsonType::binary_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b null} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b boolean} (bool)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b number_integer} ({\b number_integer_t})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b number_unsigned} ({\b number_unsigned_t})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b number_float} ({\b number_float_t}, const {\b string_t} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b string} ({\b string_t} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b binary} ({\b binary_t} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b start_object} (std::size_t=std::size_t(-1))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b key} ({\b string_t} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b end_object} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b start_array} (std::size_t=std::size_t(-1))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b end_array} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b parse_error} (std::size_t, const std::string &, const {\b detail::exception} &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType>\par
class nlohmann::detail::json_sax_acceptor< BasicJsonType >\par
}
\par
{
Definition at line {\b 6453} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v binary_t\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:binary_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::{\b binary_t} =  typename BasicJsonType::binary_t}}
\par
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6460} of file {\b json.hpp}.}\par
}
{\xe \v number_float_t\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:number_float_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::{\b number_float_t} =  typename BasicJsonType::number_float_t}}
\par
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6458} of file {\b json.hpp}.}\par
}
{\xe \v number_integer_t\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:number_integer_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::{\b number_integer_t} =  typename BasicJsonType::number_integer_t}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6456} of file {\b json.hpp}.}\par
}
{\xe \v number_unsigned_t\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:number_unsigned_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::{\b number_unsigned_t} =  typename BasicJsonType::number_unsigned_t}}
\par
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6457} of file {\b json.hpp}.}\par
}
{\xe \v string_t\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:string_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::{\b string_t} =  typename BasicJsonType::string_t}}
\par
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6459} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v binary\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::binary ({\b binary_t} & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6492} of file {\b json.hpp}.}\par
}
{\xe \v boolean\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::boolean (bool ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6467} of file {\b json.hpp}.}\par
}
{\xe \v end_array\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:end_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::end_array (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6517} of file {\b json.hpp}.}\par
}
{\xe \v end_object\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:end_object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::end_object (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6507} of file {\b json.hpp}.}\par
}
{\xe \v key\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::key ({\b string_t} & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6502} of file {\b json.hpp}.}\par
}
{\xe \v null\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:null}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::null (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6462} of file {\b json.hpp}.}\par
}
{\xe \v number_float\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:number_float}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::number_float ({\b number_float_t} , const {\b string_t} & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6482} of file {\b json.hpp}.}\par
}
{\xe \v number_integer\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:number_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::number_integer ({\b number_integer_t} ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6472} of file {\b json.hpp}.}\par
}
{\xe \v number_unsigned\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:number_unsigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::number_unsigned ({\b number_unsigned_t} ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6477} of file {\b json.hpp}.}\par
}
{\xe \v parse_error\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:parse_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::{\b parse_error} (std::size_t , const std::string & , const {\b detail::exception} & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6522} of file {\b json.hpp}.}\par
}
{\xe \v start_array\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:start_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::start_array (std::size_t  = {\f2 std::size_t(-1)}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6512} of file {\b json.hpp}.}\par
}
{\xe \v start_object\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:start_object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::start_object (std::size_t  = {\f2 std::size_t(-1)}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6497} of file {\b json.hpp}.}\par
}
{\xe \v string\:nlohmann::detail::json_sax_acceptor< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_acceptor< BasicJsonType >\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_acceptor}< BasicJsonType >::string ({\b string_t} & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6487} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_integer_t} = typename BasicJsonType::number_integer_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_unsigned_t} = typename BasicJsonType::number_unsigned_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_float_t} = typename BasicJsonType::number_float_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b string_t} = typename BasicJsonType::string_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b binary_t} = typename BasicJsonType::binary_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b parser_callback_t} = typename BasicJsonType::parser_callback_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b parse_event_t} = typename BasicJsonType::parse_event_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax_dom_callback_parser} (BasicJsonType &r, const {\b parser_callback_t} cb, const bool allow_exceptions_=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax_dom_callback_parser} (const {\b json_sax_dom_callback_parser} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax_dom_callback_parser} ({\b json_sax_dom_callback_parser} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax_dom_callback_parser} & {\b operator=} (const {\b json_sax_dom_callback_parser} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax_dom_callback_parser} & {\b operator=} ({\b json_sax_dom_callback_parser} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~json_sax_dom_callback_parser} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b null} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b boolean} (bool val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b number_integer} ({\b number_integer_t} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b number_unsigned} ({\b number_unsigned_t} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b number_float} ({\b number_float_t} val, const {\b string_t} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b string} ({\b string_t} &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b binary} ({\b binary_t} &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b start_object} (std::size_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b key} ({\b string_t} &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b end_object} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b start_array} (std::size_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b end_array} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Exception > bool {\b parse_error} (std::size_t, const std::string &, const Exception &ex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_errored} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType>\par
class nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\par
}
\par
{
Definition at line {\b 6146} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v binary_t\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:binary_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::{\b binary_t} =  typename BasicJsonType::binary_t}}
\par
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6153} of file {\b json.hpp}.}\par
}
{\xe \v number_float_t\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:number_float_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::{\b number_float_t} =  typename BasicJsonType::number_float_t}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6151} of file {\b json.hpp}.}\par
}
{\xe \v number_integer_t\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:number_integer_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::{\b number_integer_t} =  typename BasicJsonType::number_integer_t}}
\par
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6149} of file {\b json.hpp}.}\par
}
{\xe \v number_unsigned_t\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:number_unsigned_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::{\b number_unsigned_t} =  typename BasicJsonType::number_unsigned_t}}
\par
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6150} of file {\b json.hpp}.}\par
}
{\xe \v parse_event_t\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:parse_event_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::{\b parse_event_t} =  typename BasicJsonType::parse_event_t}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6155} of file {\b json.hpp}.}\par
}
{\xe \v parser_callback_t\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:parser_callback_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::{\b parser_callback_t} =  typename BasicJsonType::parser_callback_t}}
\par
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6154} of file {\b json.hpp}.}\par
}
{\xe \v string_t\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:string_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::{\b string_t} =  typename BasicJsonType::string_t}}
\par
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6152} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v json_sax_dom_callback_parser\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:json_sax_dom_callback_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::{\b json_sax_dom_callback_parser} (BasicJsonType &  {\i r}, const {\b parser_callback_t}  {\i cb}, const bool  {\i allow_exceptions_} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6157} of file {\b json.hpp}.}\par
}
{\xe \v json_sax_dom_callback_parser\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:json_sax_dom_callback_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::{\b json_sax_dom_callback_parser} (const {\b json_sax_dom_callback_parser}< BasicJsonType > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v json_sax_dom_callback_parser\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:json_sax_dom_callback_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::{\b json_sax_dom_callback_parser} ({\b json_sax_dom_callback_parser}< BasicJsonType > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~json_sax_dom_callback_parser\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:~json_sax_dom_callback_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::~{\b json_sax_dom_callback_parser} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v binary\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::binary ({\b binary_t} &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6208} of file {\b json.hpp}.}\par
}
{\xe \v boolean\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::boolean (bool  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6178} of file {\b json.hpp}.}\par
}
{\xe \v end_array\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:end_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::end_array (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6302} of file {\b json.hpp}.}\par
}
{\xe \v end_object\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:end_object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::end_object (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6249} of file {\b json.hpp}.}\par
}
{\xe \v is_errored\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:is_errored}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > constexpr bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::is_errored () const{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6347} of file {\b json.hpp}.}\par
}
{\xe \v key\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::key ({\b string_t} &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6232} of file {\b json.hpp}.}\par
}
{\xe \v null\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:null}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::null (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6172} of file {\b json.hpp}.}\par
}
{\xe \v number_float\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:number_float}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::number_float ({\b number_float_t}  {\i val}, const {\b string_t} & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6196} of file {\b json.hpp}.}\par
}
{\xe \v number_integer\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:number_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::number_integer ({\b number_integer_t}  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6184} of file {\b json.hpp}.}\par
}
{\xe \v number_unsigned\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:number_unsigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::number_unsigned ({\b number_unsigned_t}  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6190} of file {\b json.hpp}.}\par
}
{\xe \v operator=\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_sax_dom_callback_parser} & {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::operator= (const {\b json_sax_dom_callback_parser}< BasicJsonType > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_sax_dom_callback_parser} & {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::operator= ({\b json_sax_dom_callback_parser}< BasicJsonType > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_error\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:parse_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > template<class Exception > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::{\b parse_error} (std::size_t , const std::string & , const Exception &  {\i ex}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6335} of file {\b json.hpp}.}\par
}
{\xe \v start_array\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:start_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::start_array (std::size_t  {\i len}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6285} of file {\b json.hpp}.}\par
}
{\xe \v start_object\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:start_object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::start_object (std::size_t  {\i len}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6214} of file {\b json.hpp}.}\par
}
{\xe \v string\:nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_callback_parser}< BasicJsonType >::string ({\b string_t} &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6202} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::json_sax_dom_parser< BasicJsonType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX implementation to create a JSON value from SAX events. }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_integer_t} = typename BasicJsonType::number_integer_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_unsigned_t} = typename BasicJsonType::number_unsigned_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b number_float_t} = typename BasicJsonType::number_float_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b string_t} = typename BasicJsonType::string_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b binary_t} = typename BasicJsonType::binary_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax_dom_parser} (BasicJsonType &r, const bool allow_exceptions_=true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax_dom_parser} (const {\b json_sax_dom_parser} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax_dom_parser} ({\b json_sax_dom_parser} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax_dom_parser} & {\b operator=} (const {\b json_sax_dom_parser} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b json_sax_dom_parser} & {\b operator=} ({\b json_sax_dom_parser} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~json_sax_dom_parser} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b null} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b boolean} (bool val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b number_integer} ({\b number_integer_t} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b number_unsigned} ({\b number_unsigned_t} val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b number_float} ({\b number_float_t} val, const {\b string_t} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b string} ({\b string_t} &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b binary} ({\b binary_t} &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b start_object} (std::size_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b key} ({\b string_t} &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b end_object} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b start_array} (std::size_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b end_array} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Exception > bool {\b parse_error} (std::size_t, const std::string &, const Exception &ex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_errored} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType>\par
class nlohmann::detail::json_sax_dom_parser< BasicJsonType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX implementation to create a JSON value from SAX events. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class implements the {\b json_sax} interface and processes the SAX events to create a JSON value which makes it basically a DOM parser. The structure or hierarchy of the JSON value is managed by the stack {\f2 ref_stack}  which contains a pointer to the respective array or object for each recursion depth.\par
After successful parsing, the value that is passed by reference to the constructor contains the parsed value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Template Parameters\par}
\pard\plain \s80\li0\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i BasicJsonType} \cell }{the JSON type \cell }
{\row }
}
}{
Definition at line {\b 5972} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v binary_t\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:binary_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::{\b binary_t} =  typename BasicJsonType::binary_t}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5979} of file {\b json.hpp}.}\par
}
{\xe \v number_float_t\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:number_float_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::{\b number_float_t} =  typename BasicJsonType::number_float_t}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5977} of file {\b json.hpp}.}\par
}
{\xe \v number_integer_t\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:number_integer_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::{\b number_integer_t} =  typename BasicJsonType::number_integer_t}}
\par
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5975} of file {\b json.hpp}.}\par
}
{\xe \v number_unsigned_t\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:number_unsigned_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::{\b number_unsigned_t} =  typename BasicJsonType::number_unsigned_t}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5976} of file {\b json.hpp}.}\par
}
{\xe \v string_t\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:string_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > using {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::{\b string_t} =  typename BasicJsonType::string_t}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5978} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v json_sax_dom_parser\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:json_sax_dom_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::{\b json_sax_dom_parser} (BasicJsonType &  {\i r}, const bool  {\i allow_exceptions_} = {\f2 true}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i r} \cell }{reference to a JSON value that is manipulated while parsing \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i allow_exceptions_} \cell }{whether parse errors yield exceptions \cell }
{\row }
}
}{
Definition at line {\b 5986} of file {\b json.hpp}.}\par
}
{\xe \v json_sax_dom_parser\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:json_sax_dom_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::{\b json_sax_dom_parser} (const {\b json_sax_dom_parser}< BasicJsonType > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v json_sax_dom_parser\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:json_sax_dom_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::{\b json_sax_dom_parser} ({\b json_sax_dom_parser}< BasicJsonType > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~json_sax_dom_parser\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:~json_sax_dom_parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::~{\b json_sax_dom_parser} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v binary\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:binary}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::binary ({\b binary_t} &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6033} of file {\b json.hpp}.}\par
}
{\xe \v boolean\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::boolean (bool  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6003} of file {\b json.hpp}.}\par
}
{\xe \v end_array\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:end_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::end_array (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6077} of file {\b json.hpp}.}\par
}
{\xe \v end_object\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:end_object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::end_object (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6058} of file {\b json.hpp}.}\par
}
{\xe \v is_errored\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:is_errored}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > constexpr bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::is_errored () const{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6097} of file {\b json.hpp}.}\par
}
{\xe \v key\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::key ({\b string_t} &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6051} of file {\b json.hpp}.}\par
}
{\xe \v null\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:null}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::null (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5997} of file {\b json.hpp}.}\par
}
{\xe \v number_float\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:number_float}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::number_float ({\b number_float_t}  {\i val}, const {\b string_t} & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6021} of file {\b json.hpp}.}\par
}
{\xe \v number_integer\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:number_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::number_integer ({\b number_integer_t}  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6009} of file {\b json.hpp}.}\par
}
{\xe \v number_unsigned\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:number_unsigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::number_unsigned ({\b number_unsigned_t}  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6015} of file {\b json.hpp}.}\par
}
{\xe \v operator=\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_sax_dom_parser} & {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::operator= (const {\b json_sax_dom_parser}< BasicJsonType > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b json_sax_dom_parser} & {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::operator= ({\b json_sax_dom_parser}< BasicJsonType > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_error\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:parse_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > template<class Exception > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::{\b parse_error} (std::size_t , const std::string & , const Exception &  {\i ex}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6085} of file {\b json.hpp}.}\par
}
{\xe \v start_array\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:start_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::start_array (std::size_t  {\i len}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6065} of file {\b json.hpp}.}\par
}
{\xe \v start_object\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:start_object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::start_object (std::size_t  {\i len}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6039} of file {\b json.hpp}.}\par
}
{\xe \v string\:nlohmann::detail::json_sax_dom_parser< BasicJsonType >}
{\xe \v nlohmann::detail::json_sax_dom_parser< BasicJsonType >\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > bool {\b nlohmann::detail::json_sax_dom_parser}< BasicJsonType >::string ({\b string_t} &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6027} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::less<::nlohmann::detail::value_t > Struct Reference\par \pard\plain 
{\tc\tcl2 \v std::less<::nlohmann::detail::value_t >}
{\xe \v std::less<::nlohmann::detail::value_t >}
{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator()} ({\b nlohmann::detail::value_t} lhs, {\b nlohmann::detail::value_t} rhs) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
compare two value_t enum values }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
specialization for std::less<value_t> \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: do not remove the space after '<', see {\f2 https://github.com/nlohmann/json/pull/679} \par
}}}{
Definition at line {\b 26391} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:std::less<::nlohmann::detail::value_t >}
{\xe \v std::less<::nlohmann::detail::value_t >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool std::less<::{\b nlohmann::detail::value_t} >::operator() ({\b nlohmann::detail::value_t}  {\i lhs}, {\b nlohmann::detail::value_t}  {\i rhs}) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
compare two value_t enum values }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 26397} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::lexer< BasicJsonType, InputAdapterType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
lexical analysis }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::lexer< BasicJsonType, InputAdapterType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1lexer.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b token_type} = typename {\b lexer_base}< BasicJsonType >::{\b token_type}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b lexer} (InputAdapterType &&adapter, bool ignore_comments_=false) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b lexer} (const {\b lexer} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b lexer} ({\b lexer} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b lexer} & {\b operator=} ({\b lexer} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b lexer} & {\b operator=} ({\b lexer} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~lexer} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr number_integer_t {\b get_number_integer} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return integer value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr number_unsigned_t {\b get_number_unsigned} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return unsigned integer value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr number_float_t {\b get_number_float} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return floating-point value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string_t & {\b get_string} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return current string value (implicitly resets the token; useful only once) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b position_t} {\b get_position} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return position of last read token }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b get_token_string} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b JSON_HEDLEY_RETURNS_NON_NULL} const char * {\b get_error_message} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return syntax error message }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b skip_bom} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
skip the UTF-8 byte order mark }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b skip_whitespace} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b token_type} {\b scan} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename InputAdapterType>\par
class nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
lexical analysis \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class organizes the lexical analysis during JSON deserialization. \par
}{
Definition at line {\b 6637} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v token_type\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:token_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > using {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::{\b token_type} =  typename {\b lexer_base}<BasicJsonType>::{\b token_type}}}
\par
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6647} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v lexer\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:lexer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::{\b lexer} (InputAdapterType &&  {\i adapter}, bool  {\i ignore_comments_} = {\f2 false}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6649} of file {\b json.hpp}.}\par
}
{\xe \v lexer\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:lexer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::{\b lexer} (const {\b lexer}< BasicJsonType, InputAdapterType > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lexer\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:lexer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::{\b lexer} ({\b lexer}< BasicJsonType, InputAdapterType > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~lexer\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:~lexer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::~{\b lexer} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_error_message\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:get_error_message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > constexpr {\b JSON_HEDLEY_RETURNS_NON_NULL} const char * {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::get_error_message () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return syntax error message }}\par
{
Definition at line {\b 7999} of file {\b json.hpp}.}\par
}
{\xe \v get_number_float\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:get_number_float}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > constexpr number_float_t {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::get_number_float () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return floating-point value }}\par
{
Definition at line {\b 7950} of file {\b json.hpp}.}\par
}
{\xe \v get_number_integer\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:get_number_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > constexpr number_integer_t {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::get_number_integer () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return integer value }}\par
{
Definition at line {\b 7938} of file {\b json.hpp}.}\par
}
{\xe \v get_number_unsigned\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:get_number_unsigned}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > constexpr number_unsigned_t {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::get_number_unsigned () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return unsigned integer value }}\par
{
Definition at line {\b 7944} of file {\b json.hpp}.}\par
}
{\xe \v get_position\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:get_position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > constexpr {\b position_t} {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::get_position () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return position of last read token }}\par
{
Definition at line {\b 7966} of file {\b json.hpp}.}\par
}
{\xe \v get_string\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:get_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > string_t & {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::get_string (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return current string value (implicitly resets the token; useful only once) }}\par
{
Definition at line {\b 7956} of file {\b json.hpp}.}\par
}
{\xe \v get_token_string\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:get_token_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > std::string {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::get_token_string () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return the last read token (for errors only). Will never contain EOF (an arbitrary value that is not a valid char value, often -1), because 255 may legitimately occur. May contain NUL, which should be escaped. \par
}{
Definition at line {\b 7974} of file {\b json.hpp}.}\par
}
{\xe \v operator=\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > {\b lexer} & {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::operator= ({\b lexer}< BasicJsonType, InputAdapterType > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > {\b lexer} & {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::operator= ({\b lexer}< BasicJsonType, InputAdapterType > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v scan\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:scan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > {\b token_type} {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::scan (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8035} of file {\b json.hpp}.}\par
}
{\xe \v skip_bom\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:skip_bom}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > bool {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::skip_bom (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
skip the UTF-8 byte order mark }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true iff there is no BOM or the correct BOM has been skipped \par
}}}{
Definition at line {\b 8012} of file {\b json.hpp}.}\par
}
{\xe \v skip_whitespace\:nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::lexer< BasicJsonType, InputAdapterType >\:skip_whitespace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > void {\b nlohmann::detail::lexer}< BasicJsonType, InputAdapterType >::skip_whitespace (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8026} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::lexer_base< BasicJsonType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >}
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::lexer_base< BasicJsonType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1lexer__base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b token_type} \{ {\b uninitialized}
, {\b literal_true}
, {\b literal_false}
, {\b literal_null}
, {\b value_string}
, {\b value_unsigned}
, {\b value_integer}
, {\b value_float}
, {\b begin_array}
, {\b begin_object}
, {\b end_array}
, {\b end_object}
, {\b name_separator}
, {\b value_separator}
, {\b parse_error}
, {\b end_of_input}
, {\b literal_or_value}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
token types for the parser }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JSON_HEDLEY_RETURNS_NON_NULL} static {\b JSON_HEDLEY_CONST} const char * {\b token_type_name} (const {\b token_type} t) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return name of values of type token_type (only used for errors) }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType>\par
class nlohmann::detail::lexer_base< BasicJsonType >\par
}
\par
{
Definition at line {\b 6560} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v token_type\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:token_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > enum class {\b nlohmann::detail::lexer_base::token_type}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
token types for the parser }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v uninitialized\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:uninitialized}
{\qr uninitialized{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
indicating the scanner is uninitialized \par
}\cell }{\row }
{\xe \v literal_true\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:literal_true}
{\qr literal_true{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\f2 true}  literal \par
}\cell }{\row }
{\xe \v literal_false\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:literal_false}
{\qr literal_false{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\f2 false}  literal \par
}\cell }{\row }
{\xe \v literal_null\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:literal_null}
{\qr literal_null{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the {\f2 null}  literal \par
}\cell }{\row }
{\xe \v value_string\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:value_string}
{\qr value_string{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a string \'96 use get_string() for actual value \par
}\cell }{\row }
{\xe \v value_unsigned\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:value_unsigned}
{\qr value_unsigned{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an unsigned integer \'96 use get_number_unsigned() for actual value \par
}\cell }{\row }
{\xe \v value_integer\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:value_integer}
{\qr value_integer{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a signed integer \'96 use get_number_integer() for actual value \par
}\cell }{\row }
{\xe \v value_float\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:value_float}
{\qr value_float{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an floating point number \'96 use get_number_float() for actual value \par
}\cell }{\row }
{\xe \v begin_array\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:begin_array}
{\qr begin_array{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the character for array begin {\f2 [}  \par
}\cell }{\row }
{\xe \v begin_object\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:begin_object}
{\qr begin_object{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the character for object begin {\f2 \{}  \par
}\cell }{\row }
{\xe \v end_array\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:end_array}
{\qr end_array{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the character for array end {\f2 ]}  \par
}\cell }{\row }
{\xe \v end_object\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:end_object}
{\qr end_object{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the character for object end {\f2 \}}  \par
}\cell }{\row }
{\xe \v name_separator\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:name_separator}
{\qr name_separator{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the name separator {\f2 :}  \par
}\cell }{\row }
{\xe \v value_separator\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:value_separator}
{\qr value_separator{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the value separator {\f2 ,}  \par
}\cell }{\row }
{\xe \v parse_error\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:parse_error}
{\qr parse_error{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
indicating a parse error \par
}\cell }{\row }
{\xe \v end_of_input\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:end_of_input}
{\qr end_of_input{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
indicating the end of the input buffer \par
}\cell }{\row }
{\xe \v literal_or_value\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:literal_or_value}
{\qr literal_or_value{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
\cell }{{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a literal or the begin of a value (only for diagnostics) \par
}\cell }{\row }
}
{
Definition at line {\b 6564} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v token_type_name\:nlohmann::detail::lexer_base< BasicJsonType >}
{\xe \v nlohmann::detail::lexer_base< BasicJsonType >\:token_type_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b JSON_HEDLEY_RETURNS_NON_NULL} static {\b JSON_HEDLEY_CONST} const char * {\b nlohmann::detail::lexer_base}< BasicJsonType >::token_type_name (const {\b token_type}  {\i t}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return name of values of type token_type (only used for errors) }}\par
{
Definition at line {\b 6588} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MainWindow Class Reference\par \pard\plain 
{\tc\tcl2 \v MainWindow}
{\xe \v MainWindow}
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b MainWindow} class shows the first window of the game. }}\par
{
{\f2 #include <mainwindow.h>}}\par
Inheritance diagram for MainWindow:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_main_window.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b on_playBtn_clicked} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MainWindow::on_playBtn_clicked} checks when the button is clicked to start the game. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MainWindow} (QWidget *parent=nullptr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MainWindow::MainWindow} constructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~MainWindow} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MainWindow::~MainWindow} destructor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b connecting} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b IP}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b Port}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b nick}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b MainWindow} class shows the first window of the game. \par
}{
Definition at line {\b 13} of file {\b mainwindow.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MainWindow\:MainWindow}
{\xe \v MainWindow\:MainWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MainWindow::MainWindow (QWidget *  {\i parent} = {\f2 nullptr})}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MainWindow::MainWindow} constructor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parent} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 12} of file {\b mainwindow.cpp}.}\par
}
{\xe \v ~MainWindow\:MainWindow}
{\xe \v MainWindow\:~MainWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MainWindow::~MainWindow ()}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MainWindow::~MainWindow} destructor. }}\par
{
Definition at line {\b 21} of file {\b mainwindow.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v connecting\:MainWindow}
{\xe \v MainWindow\:connecting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MainWindow::connecting ()}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v on_playBtn_clicked\:MainWindow}
{\xe \v MainWindow\:on_playBtn_clicked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MainWindow::on_playBtn_clicked (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b MainWindow::on_playBtn_clicked} checks when the button is clicked to start the game. }}\par
{
Definition at line {\b 29} of file {\b mainwindow.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v IP\:MainWindow}
{\xe \v MainWindow\:IP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString MainWindow::IP}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b mainwindow.h}.}\par
}
{\xe \v nick\:MainWindow}
{\xe \v MainWindow\:nick}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString MainWindow::nick}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b mainwindow.h}.}\par
}
{\xe \v Port\:MainWindow}
{\xe \v MainWindow\:Port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString MainWindow::Port}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b mainwindow.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b mainwindow.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b mainwindow.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::make_void< Ts > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::make_void< Ts >}
{\xe \v nlohmann::detail::make_void< Ts >}
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = void\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename ... Ts>\par
struct nlohmann::detail::make_void< Ts >\par
}
\par
{
Definition at line {\b 3222} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:nlohmann::detail::make_void< Ts >}
{\xe \v nlohmann::detail::make_void< Ts >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ... Ts> using {\b nlohmann::detail::make_void}< Ts >::{\b type} =  void}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3224} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::negation< B > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::negation< B >}
{\xe \v nlohmann::detail::negation< B >}
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::negation< B >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1negation.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class B>\par
struct nlohmann::detail::negation< B >\par
}
\par
{
Definition at line {\b 3574} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::nonesuch Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::nonesuch}
{\xe \v nlohmann::detail::nonesuch}
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nonesuch} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~nonesuch} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nonesuch} ({\b nonesuch} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nonesuch} ({\b nonesuch} const &&)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator=} ({\b nonesuch} const &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator=} ({\b nonesuch} &&)=delete\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 3295} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v nonesuch\:nlohmann::detail::nonesuch}
{\xe \v nlohmann::detail::nonesuch\:nonesuch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::nonesuch::nonesuch (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~nonesuch\:nlohmann::detail::nonesuch}
{\xe \v nlohmann::detail::nonesuch\:~nonesuch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::nonesuch::~nonesuch (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nonesuch\:nlohmann::detail::nonesuch}
{\xe \v nlohmann::detail::nonesuch\:nonesuch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::nonesuch::nonesuch ({\b nonesuch} const & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nonesuch\:nlohmann::detail::nonesuch}
{\xe \v nlohmann::detail::nonesuch\:nonesuch}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
nlohmann::detail::nonesuch::nonesuch ({\b nonesuch} const && ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:nlohmann::detail::nonesuch}
{\xe \v nlohmann::detail::nonesuch\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nlohmann::detail::nonesuch::operator= ({\b nonesuch} && ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:nlohmann::detail::nonesuch}
{\xe \v nlohmann::detail::nonesuch\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nlohmann::detail::nonesuch::operator= ({\b nonesuch} const & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::ordered_map< Key, T, IgnoredLess, Allocator > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1ordered__map.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b key_type} = Key\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b mapped_type} = T\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b Container} = std::vector< std::pair< const Key, T >, Allocator >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIt > using {\b require_input_iter} = typename std::enable_if< std::is_convertible< typename std::iterator_traits< InputIt >::iterator_category, std::input_iterator_tag >::value >::type\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ordered_map} (const Allocator &alloc=Allocator())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class It > {\b ordered_map} (It first, It last, const Allocator &alloc=Allocator())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ordered_map} (std::initializer_list< T > init, const Allocator &alloc=Allocator())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::pair< iterator, bool > {\b emplace} (const {\b key_type} &key, T &&t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b operator[]} (const Key &key)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T & {\b operator[]} (const Key &key) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b at} (const Key &key)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const T & {\b at} (const Key &key) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_type {\b erase} (const Key &key)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
iterator {\b erase} (iterator pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_type {\b count} (const Key &key) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
iterator {\b find} (const Key &key)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const_iterator {\b find} (const Key &key) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::pair< iterator, bool > {\b insert} (value_type &&value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::pair< iterator, bool > {\b insert} (const value_type &value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIt , typename  = require_input_iter<InputIt>> void {\b insert} (InputIt first, InputIt last)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Key, class T, class IgnoredLess = std::less<Key>, class Allocator = std::allocator<std::pair<const Key, T>>>\par
struct nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b ordered_map}: a minimal map-like container that preserves insertion order for use within nlohmann::basic_json<ordered_map> \par
}{
Definition at line {\b 17312} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v Container\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:Container}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> using {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::{\b Container} =  std::vector<std::pair<const Key, T>, Allocator>}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17316} of file {\b json.hpp}.}\par
}
{\xe \v key_type\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:key_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> using {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::{\b key_type} =  Key}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17314} of file {\b json.hpp}.}\par
}
{\xe \v mapped_type\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:mapped_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> using {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::{\b mapped_type} =  T}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17315} of file {\b json.hpp}.}\par
}
{\xe \v require_input_iter\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:require_input_iter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> template<typename InputIt > using {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::{\b require_input_iter} =  typename std::enable_if<std::is_convertible<typename std::iterator_traits<InputIt>::iterator_category, std::input_iterator_tag>::value>::type}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17468} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ordered_map\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:ordered_map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::{\b ordered_map} (const Allocator &  {\i alloc} = {\f2 Allocator()}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17324} of file {\b json.hpp}.}\par
}
{\xe \v ordered_map\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:ordered_map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> template<class It > {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::{\b ordered_map} (It  {\i first}, It  {\i last}, const Allocator &  {\i alloc} = {\f2 Allocator()}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17326} of file {\b json.hpp}.}\par
}
{\xe \v ordered_map\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:ordered_map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::{\b ordered_map} (std::initializer_list< T >  {\i init}, const Allocator &  {\i alloc} = {\f2 Allocator()}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17328} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v at\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> T & {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::at (const Key &  {\i key}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17354} of file {\b json.hpp}.}\par
}
{\xe \v at\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> const T & {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::at (const Key &  {\i key}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17367} of file {\b json.hpp}.}\par
}
{\xe \v count\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> size_type {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::count (const Key &  {\i key}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17413} of file {\b json.hpp}.}\par
}
{\xe \v emplace\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:emplace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> std::pair< iterator, bool > {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::emplace (const {\b key_type} &  {\i key}, T &&  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17331} of file {\b json.hpp}.}\par
}
{\xe \v erase\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> size_type {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::erase (const Key &  {\i key}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17380} of file {\b json.hpp}.}\par
}
{\xe \v erase\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> iterator {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::erase (iterator  {\i pos}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17399} of file {\b json.hpp}.}\par
}
{\xe \v find\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> iterator {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::find (const Key &  {\i key}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17425} of file {\b json.hpp}.}\par
}
{\xe \v find\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> const_iterator {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::find (const Key &  {\i key}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17437} of file {\b json.hpp}.}\par
}
{\xe \v insert\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> std::pair< iterator, bool > {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::insert (const value_type &  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17454} of file {\b json.hpp}.}\par
}
{\xe \v insert\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> template<typename InputIt , typename  = require_input_iter<InputIt>> void {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::insert (InputIt  {\i first}, InputIt  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17472} of file {\b json.hpp}.}\par
}
{\xe \v insert\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> std::pair< iterator, bool > {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::insert (value_type &&  {\i value}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17449} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> T & {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::operator[] (const Key &  {\i key}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17344} of file {\b json.hpp}.}\par
}
{\xe \v operator[]\:nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}
{\xe \v nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Key , class T , class IgnoredLess  = std::less<Key>, class Allocator  = std::allocator<std::pair<const Key, T>>> const T & {\b nlohmann::ordered_map}< Key, T, IgnoredLess, Allocator >::operator[] (const Key &  {\i key}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17349} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::other_error Class Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::other_error}
{\xe \v nlohmann::detail::other_error}
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating other library errors }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::other_error:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1other__error.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static {\b other_error} {\b create} (int id_, const std::string &what_arg, const BasicJsonType &context)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating other library errors \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exception is thrown in case of errors that cannot be classified with the other exception types.\par
Exceptions have ids 5xx.\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{name / id   \cell }{example message   \cell }{description    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.other_error.501   \cell }{unsuccessful: \{"op":"test","path":"/baz", "value":"bar"\}   \cell }{A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
- {\b exception} for the base class of the library exceptions \par
- {\b parse_error} for exceptions indicating a parse error \par
- {\b invalid_iterator} for exceptions indicating errors with iterators \par
- {\b type_error} for exceptions indicating executing a member function with a wrong type \par
- {\b out_of_range} for exceptions indicating access out of the defined range\par
}}@liveexample\{The following code shows how an {\f2 {\b other_error}}  exception can be caught.,{\b other_error}\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 3014} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:nlohmann::detail::other_error}
{\xe \v nlohmann::detail::other_error\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static {\b other_error} nlohmann::detail::other_error::create (int  {\i id_}, const std::string &  {\i what_arg}, const BasicJsonType &  {\i context}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3018} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::out_of_range Class Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::out_of_range}
{\xe \v nlohmann::detail::out_of_range}
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating access out of the defined range }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::out_of_range:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1out__of__range.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static {\b out_of_range} {\b create} (int id_, const std::string &what_arg, const BasicJsonType &context)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating access out of the defined range \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exception is thrown in case a library function is called on an input parameter that exceeds the expected range, for instance in case of array indices or nonexisting object keys.\par
Exceptions have ids 4xx.\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{name / id   \cell }{example message   \cell }{description    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.401   \cell }{array index 3 is out of range   \cell }{The provided array index {\i i}  is larger than {\i size-1} .    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.402   \cell }{array index '-' (3) is out of range   \cell }{The special array index {\f2 -}  in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.403   \cell }{key 'foo' not found   \cell }{The provided key was not found in the JSON object.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.404   \cell }{unresolved reference token 'foo'   \cell }{A reference token in a JSON Pointer could not be resolved.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.405   \cell }{JSON pointer has no parent   \cell }{The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.406   \cell }{number overflow parsing '10E1000'   \cell }{A parsed number could not be stored as without changing it to NaN or INF.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.407   \cell }{number overflow serializing '9223372036854775808'   \cell }{UBJSON and BSON only support integer numbers up to 9223372036854775807. (until version 3.8.0)    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.408   \cell }{excessive array size: 8658170730974374167   \cell }{The size (following {\f2 #} ) of an UBJSON array or object exceeds the maximal capacity.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.out_of_range.409   \cell }{BSON key cannot contain code point U+0000 (at byte 2)   \cell }{Key identifiers to be serialized to BSON cannot contain code point U+0000, since the key is stored as zero-terminated c-string   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
@liveexample\{The following code shows how an {\f2 {\b out_of_range}}  exception can be caught.,{\b out_of_range}\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
- {\b exception} for the base class of the library exceptions \par
- {\b parse_error} for exceptions indicating a parse error \par
- {\b invalid_iterator} for exceptions indicating errors with iterators \par
- {\b type_error} for exceptions indicating executing a member function with a wrong type \par
- {\b other_error} for exceptions indicating other library errors\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 2975} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:nlohmann::detail::out_of_range}
{\xe \v nlohmann::detail::out_of_range\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static {\b out_of_range} nlohmann::detail::out_of_range::create (int  {\i id_}, const std::string &  {\i what_arg}, const BasicJsonType &  {\i context}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2979} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::output_adapter< CharType, StringType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::output_adapter< CharType, StringType >}
{\xe \v nlohmann::detail::output_adapter< CharType, StringType >}
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b output_adapter} (std::vector< CharType > &vec)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b output_adapter} (std::basic_ostream< CharType > &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b output_adapter} (StringType &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator output_adapter_t< CharType >} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename CharType, typename StringType = std::basic_string<CharType>>\par
class nlohmann::detail::output_adapter< CharType, StringType >\par
}
\par
{
Definition at line {\b 13562} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v output_adapter\:nlohmann::detail::output_adapter< CharType, StringType >}
{\xe \v nlohmann::detail::output_adapter< CharType, StringType >\:output_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType , typename StringType  = std::basic_string<CharType>> {\b nlohmann::detail::output_adapter}< CharType, StringType >::{\b output_adapter} (std::vector< CharType > &  {\i vec}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13565} of file {\b json.hpp}.}\par
}
{\xe \v output_adapter\:nlohmann::detail::output_adapter< CharType, StringType >}
{\xe \v nlohmann::detail::output_adapter< CharType, StringType >\:output_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType , typename StringType  = std::basic_string<CharType>> {\b nlohmann::detail::output_adapter}< CharType, StringType >::{\b output_adapter} (std::basic_ostream< CharType > &  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13569} of file {\b json.hpp}.}\par
}
{\xe \v output_adapter\:nlohmann::detail::output_adapter< CharType, StringType >}
{\xe \v nlohmann::detail::output_adapter< CharType, StringType >\:output_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType , typename StringType  = std::basic_string<CharType>> {\b nlohmann::detail::output_adapter}< CharType, StringType >::{\b output_adapter} (StringType &  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13573} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator output_adapter_t< CharType >\:nlohmann::detail::output_adapter< CharType, StringType >}
{\xe \v nlohmann::detail::output_adapter< CharType, StringType >\:operator output_adapter_t< CharType >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType , typename StringType  = std::basic_string<CharType>> {\b nlohmann::detail::output_adapter}< CharType, StringType >::operator {\b output_adapter_t}< CharType > (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13576} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::output_adapter_protocol< CharType > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::output_adapter_protocol< CharType >}
{\xe \v nlohmann::detail::output_adapter_protocol< CharType >}
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
abstract output adapter interface }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::output_adapter_protocol< CharType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structnlohmann_1_1detail_1_1output__adapter__protocol.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b write_character} (CharType c)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b write_characters} (const CharType *s, std::size_t length)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~output_adapter_protocol} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b output_adapter_protocol} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b output_adapter_protocol} (const {\b output_adapter_protocol} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b output_adapter_protocol} ({\b output_adapter_protocol} &&) noexcept=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b output_adapter_protocol} & {\b operator=} (const {\b output_adapter_protocol} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b output_adapter_protocol} & {\b operator=} ({\b output_adapter_protocol} &&) noexcept=default\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename CharType>\par
struct nlohmann::detail::output_adapter_protocol< CharType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
abstract output adapter interface \par
}{
Definition at line {\b 13470} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~output_adapter_protocol\:nlohmann::detail::output_adapter_protocol< CharType >}
{\xe \v nlohmann::detail::output_adapter_protocol< CharType >\:~output_adapter_protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > virtual {\b nlohmann::detail::output_adapter_protocol}< CharType >::~{\b output_adapter_protocol} (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v output_adapter_protocol\:nlohmann::detail::output_adapter_protocol< CharType >}
{\xe \v nlohmann::detail::output_adapter_protocol< CharType >\:output_adapter_protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > {\b nlohmann::detail::output_adapter_protocol}< CharType >::{\b output_adapter_protocol} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v output_adapter_protocol\:nlohmann::detail::output_adapter_protocol< CharType >}
{\xe \v nlohmann::detail::output_adapter_protocol< CharType >\:output_adapter_protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > {\b nlohmann::detail::output_adapter_protocol}< CharType >::{\b output_adapter_protocol} (const {\b output_adapter_protocol}< CharType > & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v output_adapter_protocol\:nlohmann::detail::output_adapter_protocol< CharType >}
{\xe \v nlohmann::detail::output_adapter_protocol< CharType >\:output_adapter_protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > {\b nlohmann::detail::output_adapter_protocol}< CharType >::{\b output_adapter_protocol} ({\b output_adapter_protocol}< CharType > && ){\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:nlohmann::detail::output_adapter_protocol< CharType >}
{\xe \v nlohmann::detail::output_adapter_protocol< CharType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > {\b output_adapter_protocol} & {\b nlohmann::detail::output_adapter_protocol}< CharType >::operator= (const {\b output_adapter_protocol}< CharType > & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:nlohmann::detail::output_adapter_protocol< CharType >}
{\xe \v nlohmann::detail::output_adapter_protocol< CharType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > {\b output_adapter_protocol} & {\b nlohmann::detail::output_adapter_protocol}< CharType >::operator= ({\b output_adapter_protocol}< CharType > && ){\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v write_character\:nlohmann::detail::output_adapter_protocol< CharType >}
{\xe \v nlohmann::detail::output_adapter_protocol< CharType >\:write_character}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > virtual void {\b nlohmann::detail::output_adapter_protocol}< CharType >::write_character (CharType  {\i c}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b nlohmann::detail::output_vector_adapter< CharType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABXX \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b nlohmann::detail::output_stream_adapter< CharType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABXY \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b nlohmann::detail::output_string_adapter< CharType, StringType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABXZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v write_characters\:nlohmann::detail::output_adapter_protocol< CharType >}
{\xe \v nlohmann::detail::output_adapter_protocol< CharType >\:write_characters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > virtual void {\b nlohmann::detail::output_adapter_protocol}< CharType >::write_characters (const CharType *  {\i s}, std::size_t  {\i length}){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implemented in {\b nlohmann::detail::output_vector_adapter< CharType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABYB \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b nlohmann::detail::output_stream_adapter< CharType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABYC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b nlohmann::detail::output_string_adapter< CharType, StringType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABYD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::output_stream_adapter< CharType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::output_stream_adapter< CharType >}
{\xe \v nlohmann::detail::output_stream_adapter< CharType >}
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for output streams }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::output_stream_adapter< CharType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1output__stream__adapter.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b output_stream_adapter} (std::basic_ostream< CharType > &s) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_character} (CharType c) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_characters} (const CharType *s, std::size_t length) override\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename CharType>\par
class nlohmann::detail::output_stream_adapter< CharType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for output streams \par
}{
Definition at line {\b 13514} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v output_stream_adapter\:nlohmann::detail::output_stream_adapter< CharType >}
{\xe \v nlohmann::detail::output_stream_adapter< CharType >\:output_stream_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > {\b nlohmann::detail::output_stream_adapter}< CharType >::{\b output_stream_adapter} (std::basic_ostream< CharType > &  {\i s}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13517} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v write_character\:nlohmann::detail::output_stream_adapter< CharType >}
{\xe \v nlohmann::detail::output_stream_adapter< CharType >\:write_character}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > void {\b nlohmann::detail::output_stream_adapter}< CharType >::write_character (CharType  {\i c}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b nlohmann::detail::output_adapter_protocol< CharType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABXW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 13521} of file {\b json.hpp}.}\par
}
{\xe \v write_characters\:nlohmann::detail::output_stream_adapter< CharType >}
{\xe \v nlohmann::detail::output_stream_adapter< CharType >\:write_characters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > void {\b nlohmann::detail::output_stream_adapter}< CharType >::write_characters (const CharType *  {\i s}, std::size_t  {\i length}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b nlohmann::detail::output_adapter_protocol< CharType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABYA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 13527} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::output_string_adapter< CharType, StringType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::output_string_adapter< CharType, StringType >}
{\xe \v nlohmann::detail::output_string_adapter< CharType, StringType >}
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for basic_string }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::output_string_adapter< CharType, StringType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1output__string__adapter.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b output_string_adapter} (StringType &s) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_character} (CharType c) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_characters} (const CharType *s, std::size_t length) override\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename CharType, typename StringType = std::basic_string<CharType>>\par
class nlohmann::detail::output_string_adapter< CharType, StringType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for basic_string \par
}{
Definition at line {\b 13539} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v output_string_adapter\:nlohmann::detail::output_string_adapter< CharType, StringType >}
{\xe \v nlohmann::detail::output_string_adapter< CharType, StringType >\:output_string_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType , typename StringType  = std::basic_string<CharType>> {\b nlohmann::detail::output_string_adapter}< CharType, StringType >::{\b output_string_adapter} (StringType &  {\i s}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13542} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v write_character\:nlohmann::detail::output_string_adapter< CharType, StringType >}
{\xe \v nlohmann::detail::output_string_adapter< CharType, StringType >\:write_character}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType , typename StringType  = std::basic_string<CharType>> void {\b nlohmann::detail::output_string_adapter}< CharType, StringType >::write_character (CharType  {\i c}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b nlohmann::detail::output_adapter_protocol< CharType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABXW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 13546} of file {\b json.hpp}.}\par
}
{\xe \v write_characters\:nlohmann::detail::output_string_adapter< CharType, StringType >}
{\xe \v nlohmann::detail::output_string_adapter< CharType, StringType >\:write_characters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType , typename StringType  = std::basic_string<CharType>> void {\b nlohmann::detail::output_string_adapter}< CharType, StringType >::write_characters (const CharType *  {\i s}, std::size_t  {\i length}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b nlohmann::detail::output_adapter_protocol< CharType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABYA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 13552} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::output_vector_adapter< CharType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::output_vector_adapter< CharType >}
{\xe \v nlohmann::detail::output_vector_adapter< CharType >}
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for byte vectors }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::output_vector_adapter< CharType >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1output__vector__adapter.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b output_vector_adapter} (std::vector< CharType > &vec) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_character} (CharType c) override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write_characters} (const CharType *s, std::size_t length) override\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename CharType>\par
class nlohmann::detail::output_vector_adapter< CharType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for byte vectors \par
}{
Definition at line {\b 13489} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v output_vector_adapter\:nlohmann::detail::output_vector_adapter< CharType >}
{\xe \v nlohmann::detail::output_vector_adapter< CharType >\:output_vector_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > {\b nlohmann::detail::output_vector_adapter}< CharType >::{\b output_vector_adapter} (std::vector< CharType > &  {\i vec}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13492} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v write_character\:nlohmann::detail::output_vector_adapter< CharType >}
{\xe \v nlohmann::detail::output_vector_adapter< CharType >\:write_character}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > void {\b nlohmann::detail::output_vector_adapter}< CharType >::write_character (CharType  {\i c}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b nlohmann::detail::output_adapter_protocol< CharType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABXW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 13496} of file {\b json.hpp}.}\par
}
{\xe \v write_characters\:nlohmann::detail::output_vector_adapter< CharType >}
{\xe \v nlohmann::detail::output_vector_adapter< CharType >\:write_characters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharType > void {\b nlohmann::detail::output_vector_adapter}< CharType >::write_characters (const CharType *  {\i s}, std::size_t  {\i length}){\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Implements {\b nlohmann::detail::output_adapter_protocol< CharType >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABYA \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 13502} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Paddle Class Reference\par \pard\plain 
{\tc\tcl2 \v Paddle}
{\xe \v Paddle}
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Paddle} class creates objects of type {\b Paddle}. }}\par
{
{\f2 #include <Paddle.h>}}\par
Inheritance diagram for Paddle:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_paddle.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Paddle} (QGraphicsItem *parent=NULL)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Paddle::Paddle} constructor creates a new {\b Paddle} with its required attributes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getCenterX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reduceSize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Paddle::reduceSize} reduces the size of the paddle. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b increaseSize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Paddle::increaseSize} add 5 pixels to total paddle size. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mouseMoveEvent} (QGraphicsSceneMouseEvent *event)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Paddle::mouseMoveEvent} sets the paddle position to the current mouse position. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QBrush {\b brush}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b reduction} = 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b padWidth} = 60\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Paddle} class creates objects of type {\b Paddle}. \par
}{
Definition at line {\b 10} of file {\b Paddle.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Paddle\:Paddle}
{\xe \v Paddle\:Paddle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Paddle::Paddle (QGraphicsItem *  {\i parent} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Paddle::Paddle} constructor creates a new {\b Paddle} with its required attributes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parent} \cell }{\cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
draw a rectangle for the block\par
}{
Definition at line {\b 6} of file {\b Paddle.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getCenterX\:Paddle}
{\xe \v Paddle\:getCenterX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Paddle::getCenterX ()}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b Paddle.cpp}.}\par
}
{\xe \v increaseSize\:Paddle}
{\xe \v Paddle\:increaseSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Paddle::increaseSize ()}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Paddle::increaseSize} add 5 pixels to total paddle size. }}\par
{
Definition at line {\b 30} of file {\b Paddle.cpp}.}\par
}
{\xe \v mouseMoveEvent\:Paddle}
{\xe \v Paddle\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Paddle::mouseMoveEvent (QGraphicsSceneMouseEvent *  {\i event})}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Paddle::mouseMoveEvent} sets the paddle position to the current mouse position. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i event} \cell }{\cell }
{\row }
}
}{
Definition at line {\b 39} of file {\b Paddle.cpp}.}\par
}
{\xe \v reduceSize\:Paddle}
{\xe \v Paddle\:reduceSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Paddle::reduceSize ()}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b Paddle::reduceSize} reduces the size of the paddle. }}\par
{
Definition at line {\b 22} of file {\b Paddle.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v brush\:Paddle}
{\xe \v Paddle\:brush}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QBrush Paddle::brush}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b Paddle.h}.}\par
}
{\xe \v padWidth\:Paddle}
{\xe \v Paddle\:padWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Paddle::padWidth = 60}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b Paddle.h}.}\par
}
{\xe \v reduction\:Paddle}
{\xe \v Paddle\:reduction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Paddle::reduction = 10}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b Paddle.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Paddle.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Paddle.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::parse_error Class Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::parse_error}
{\xe \v nlohmann::detail::parse_error}
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating a parse error }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::parse_error:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1parse__error.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static {\b parse_error} {\b create} (int id_, const {\b position_t} &pos, const std::string &what_arg, const BasicJsonType &context)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a parse error exception }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static {\b parse_error} {\b create} (int id_, std::size_t byte_, const std::string &what_arg, const BasicJsonType &context)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::size_t {\b byte}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
byte index of the parse error }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating a parse error \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exception is thrown by the library when a parse error occurs. Parse errors can occur during the deserialization of JSON text, CBOR, MessagePack, as well as when using JSON Patch.\par
Member {\i byte}  holds the byte index of the last read character in the input file.\par
Exceptions have ids 1xx.\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{name / id   \cell }{example message   \cell }{description    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.101   \cell }{parse error at 2: unexpected end of input; expected string literal   \cell }{This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member {\i byte}  indicates the error position.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.102   \cell }{parse error at 14: missing or wrong low surrogate   \cell }{JSON uses the {\f2 \\uxxxx}  format to describe Unicode characters. Code points above above 0xFFFF are split into two {\f2 \\uxxxx}  entries ("surrogate pairs"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.103   \cell }{parse error: code points above 0x10FFFF are invalid   \cell }{Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.104   \cell }{parse error: JSON patch must be an array of objects   \cell }{{\f2 RFC 6902} requires a JSON Patch document to be a JSON document that represents an array of objects.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.105   \cell }{parse error: operation must have string member 'op'   \cell }{An operation of a JSON Patch document must contain exactly one "op" member, whose value indicates the operation to perform. Its value must be one of "add", "remove", "replace", "move", "copy", or "test"; other values are errors.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.106   \cell }{parse error: array index '01' must not begin with '0'   \cell }{An array index in a JSON Pointer ({\f2 RFC 6901}) may be {\f2 0}  or any number without a leading {\f2 0} .    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.107   \cell }{parse error: JSON pointer must be empty or begin with '/' - was: 'foo'   \cell }{A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a {\f2 /}  character.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.108   \cell }{parse error: escape character '~' must be followed with '0' or '1'   \cell }{In a JSON Pointer, only {\f2 ~0}  and {\f2 ~1}  are valid escape sequences.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.109   \cell }{parse error: array index 'one' is not a number   \cell }{A JSON Pointer array index must be a number.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.110   \cell }{parse error at 1: cannot read 2 bytes from vector   \cell }{When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.112   \cell }{parse error at 1: error reading CBOR; last byte: 0xF8   \cell }{Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.113   \cell }{parse error at 2: expected a CBOR string; last byte: 0x98   \cell }{While parsing a map key, a value that is not a string has been read.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.114   \cell }{parse error: Unsupported BSON record type 0x0F   \cell }{The parsing of the corresponding BSON record type is not implemented (yet).    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.parse_error.115   \cell }{parse error at byte 5: syntax error while parsing UBJSON high-precision number: invalid number text: 1A   \cell }{A UBJSON high-precision number could not be parsed.   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
For an input with n bytes, 1 is the index of the first character and n+1 is the index of the terminating null byte or the end of file. This also holds true when reading a byte vector (CBOR or MessagePack).\par
}}@liveexample\{The following code shows how a {\f2 {\b parse_error}}  exception can be caught.,{\b parse_error}\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
- {\b exception} for the base class of the library exceptions \par
- {\b invalid_iterator} for exceptions indicating errors with iterators \par
- {\b type_error} for exceptions indicating executing a member function with a wrong type \par
- {\b out_of_range} for exceptions indicating access out of the defined range \par
- {\b other_error} for exceptions indicating other library errors\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 2784} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:nlohmann::detail::parse_error}
{\xe \v nlohmann::detail::parse_error\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static {\b parse_error} nlohmann::detail::parse_error::create (int  {\i id_}, const {\b position_t} &  {\i pos}, const std::string &  {\i what_arg}, const BasicJsonType &  {\i context}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
create a parse error exception }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i id_} \cell }{the id of the exception \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i pos} \cell }{the position where the error occurred (or with chars_read_total=0 if the position cannot be determined) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i what_arg} \cell }{the explanatory string \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b parse_error} object \par
}}}{
Definition at line {\b 2797} of file {\b json.hpp}.}\par
}
{\xe \v create\:nlohmann::detail::parse_error}
{\xe \v nlohmann::detail::parse_error\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static {\b parse_error} nlohmann::detail::parse_error::create (int  {\i id_}, std::size_t  {\i byte_}, const std::string &  {\i what_arg}, const BasicJsonType &  {\i context}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2805} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v byte\:nlohmann::detail::parse_error}
{\xe \v nlohmann::detail::parse_error\:byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::size_t nlohmann::detail::parse_error::byte}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
byte index of the parse error }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The byte index of the last read character in the input file.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Note\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
For an input with n bytes, 1 is the index of the first character and n+1 is the index of the terminating null byte or the end of file. This also holds true when reading a byte vector (CBOR or MessagePack). \par
}}}{
Definition at line {\b 2822} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::parser< BasicJsonType, InputAdapterType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::parser< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::parser< BasicJsonType, InputAdapterType >}
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
syntax analysis }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b parser} (InputAdapterType &&adapter, const {\b parser_callback_t}< BasicJsonType > cb=nullptr, const bool allow_exceptions_=true, const bool skip_comments=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a parser reading from an input adapter }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b parse} (const bool strict, BasicJsonType &result)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
public parser interface }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b accept} (const bool strict=true)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
public accept interface }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename SAX > bool {\b sax_parse} (SAX *sax, const bool strict=true)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType, typename InputAdapterType>\par
class nlohmann::detail::parser< BasicJsonType, InputAdapterType >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
syntax analysis \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class implements a recursive descent parser. \par
}{
Definition at line {\b 10883} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v parser\:nlohmann::detail::parser< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::parser< BasicJsonType, InputAdapterType >\:parser}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > {\b nlohmann::detail::parser}< BasicJsonType, InputAdapterType >::{\b parser} (InputAdapterType &&  {\i adapter}, const {\b parser_callback_t}< BasicJsonType >  {\i cb} = {\f2 nullptr}, const bool  {\i allow_exceptions_} = {\f2 true}, const bool  {\i skip_comments} = {\f2 false}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a parser reading from an input adapter }}\par
{
Definition at line {\b 10894} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v accept\:nlohmann::detail::parser< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::parser< BasicJsonType, InputAdapterType >\:accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > bool {\b nlohmann::detail::parser}< BasicJsonType, InputAdapterType >::accept (const bool  {\i strict} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
public accept interface }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether to expect the last token to be EOF \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
whether the input is a proper JSON text \par
}}}{
Definition at line {\b 10976} of file {\b json.hpp}.}\par
}
{\xe \v parse\:nlohmann::detail::parser< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::parser< BasicJsonType, InputAdapterType >\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > void {\b nlohmann::detail::parser}< BasicJsonType, InputAdapterType >::parse (const bool  {\i strict}, BasicJsonType &  {\i result}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
public parser interface }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i strict} \cell }{whether to expect the last token to be EOF \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in,out\cell }{{\i result} \cell }{parsed JSON value\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Exceptions\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.101} \cell }{in case of an unexpected token \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.102} \cell }{if to_unicode fails or surrogate error \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parse_error.103} \cell }{if to_unicode fails \cell }
{\row }
}
}{
Definition at line {\b 10916} of file {\b json.hpp}.}\par
}
{\xe \v sax_parse\:nlohmann::detail::parser< BasicJsonType, InputAdapterType >}
{\xe \v nlohmann::detail::parser< BasicJsonType, InputAdapterType >\:sax_parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename InputAdapterType > template<typename SAX > bool {\b nlohmann::detail::parser}< BasicJsonType, InputAdapterType >::sax_parse (SAX *  {\i sax}, const bool  {\i strict} = {\f2 true}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10984} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::position_t Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::position_t}
{\xe \v nlohmann::detail::position_t}
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct to capture the start position of the current token }}\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b operator size_t} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
conversion to size_t to preserve SAX interface }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b chars_read_total} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the total number of characters read }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b chars_read_current_line} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the number of characters read in the current line }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b lines_read} = 0\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the number of lines read }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct to capture the start position of the current token \par
}{
Definition at line {\b 2591} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator size_t\:nlohmann::detail::position_t}
{\xe \v nlohmann::detail::position_t\:operator size_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr nlohmann::detail::position_t::operator size_t () const{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
conversion to size_t to preserve SAX interface }}\par
{
Definition at line {\b 2601} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v chars_read_current_line\:nlohmann::detail::position_t}
{\xe \v nlohmann::detail::position_t\:chars_read_current_line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t nlohmann::detail::position_t::chars_read_current_line = 0}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the number of characters read in the current line }}\par
{
Definition at line {\b 2596} of file {\b json.hpp}.}\par
}
{\xe \v chars_read_total\:nlohmann::detail::position_t}
{\xe \v nlohmann::detail::position_t\:chars_read_total}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t nlohmann::detail::position_t::chars_read_total = 0}}
\par
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the total number of characters read }}\par
{
Definition at line {\b 2594} of file {\b json.hpp}.}\par
}
{\xe \v lines_read\:nlohmann::detail::position_t}
{\xe \v nlohmann::detail::position_t\:lines_read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t nlohmann::detail::position_t::lines_read = 0}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the number of lines read }}\par
{
Definition at line {\b 2598} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::primitive_iterator_t Class Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t}
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr difference_type {\b get_value} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_begin} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set iterator to a defined beginning }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set_end} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set iterator to a defined past the end }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_begin} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether the iterator can be dereferenced }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_end} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether the iterator is at end }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b primitive_iterator_t} {\b operator+} (difference_type n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b primitive_iterator_t} & {\b operator++} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b primitive_iterator_t} const {\b operator++} (int) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b primitive_iterator_t} & {\b operator--} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b primitive_iterator_t} const {\b operator--} (int) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b primitive_iterator_t} & {\b operator+=} (difference_type n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b primitive_iterator_t} & {\b operator-=} (difference_type n) noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr friend bool {\b operator==} ({\b primitive_iterator_t} lhs, {\b primitive_iterator_t} rhs) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr friend bool {\b operator<} ({\b primitive_iterator_t} lhs, {\b primitive_iterator_t} rhs) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr friend difference_type {\b operator-} ({\b primitive_iterator_t} lhs, {\b primitive_iterator_t} rhs) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 11357} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_value\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:get_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr difference_type nlohmann::detail::primitive_iterator_t::get_value () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11369} of file {\b json.hpp}.}\par
}
{\xe \v is_begin\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:is_begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr bool nlohmann::detail::primitive_iterator_t::is_begin () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether the iterator can be dereferenced }}\par
{
Definition at line {\b 11387} of file {\b json.hpp}.}\par
}
{\xe \v is_end\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:is_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr bool nlohmann::detail::primitive_iterator_t::is_end () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
return whether the iterator is at end }}\par
{
Definition at line {\b 11393} of file {\b json.hpp}.}\par
}
{\xe \v operator+\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b primitive_iterator_t} nlohmann::detail::primitive_iterator_t::operator+ (difference_type  {\i n}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11408} of file {\b json.hpp}.}\par
}
{\xe \v operator++\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b primitive_iterator_t} & nlohmann::detail::primitive_iterator_t::operator++ (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11420} of file {\b json.hpp}.}\par
}
{\xe \v operator++\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b primitive_iterator_t} const nlohmann::detail::primitive_iterator_t::operator++ (int ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11426} of file {\b json.hpp}.}\par
}
{\xe \v operator+=\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b primitive_iterator_t} & nlohmann::detail::primitive_iterator_t::operator+= (difference_type  {\i n}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11446} of file {\b json.hpp}.}\par
}
{\xe \v operator--\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b primitive_iterator_t} & nlohmann::detail::primitive_iterator_t::operator-- (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11433} of file {\b json.hpp}.}\par
}
{\xe \v operator--\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b primitive_iterator_t} const nlohmann::detail::primitive_iterator_t::operator-- (int ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11439} of file {\b json.hpp}.}\par
}
{\xe \v operator-=\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b primitive_iterator_t} & nlohmann::detail::primitive_iterator_t::operator-= (difference_type  {\i n}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11452} of file {\b json.hpp}.}\par
}
{\xe \v set_begin\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:set_begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nlohmann::detail::primitive_iterator_t::set_begin (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set iterator to a defined beginning }}\par
{
Definition at line {\b 11375} of file {\b json.hpp}.}\par
}
{\xe \v set_end\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:set_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void nlohmann::detail::primitive_iterator_t::set_end (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
set iterator to a defined past the end }}\par
{
Definition at line {\b 11381} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator-\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr friend difference_type operator- ({\b primitive_iterator_t}  {\i lhs}, {\b primitive_iterator_t}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11415} of file {\b json.hpp}.}\par
}
{\xe \v operator<\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr friend bool operator< ({\b primitive_iterator_t}  {\i lhs}, {\b primitive_iterator_t}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11403} of file {\b json.hpp}.}\par
}
{\xe \v operator==\:nlohmann::detail::primitive_iterator_t}
{\xe \v nlohmann::detail::primitive_iterator_t\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr friend bool operator== ({\b primitive_iterator_t}  {\i lhs}, {\b primitive_iterator_t}  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11398} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::priority_tag< N > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::priority_tag< N >}
{\xe \v nlohmann::detail::priority_tag< N >}
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
\par
{
{\f2 #include <json.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<unsigned N>\par
struct nlohmann::detail::priority_tag< N >\par
}
\par
{
Definition at line {\b 3174} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::priority_tag< 0 > Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::priority_tag< 0 >}
{\xe \v nlohmann::detail::priority_tag< 0 >}
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
\par
{
{\f2 #include <json.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 3175} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::serializer< BasicJsonType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >}
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serializer} ({\b output_adapter_t}< char > s, const char ichar, {\b error_handler_t} error_handler_={\b error_handler_t::strict})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serializer} (const {\b serializer} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serializer} & {\b operator=} (const {\b serializer} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serializer} ({\b serializer} &&)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serializer} & {\b operator=} ({\b serializer} &&)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~serializer} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dump} (const BasicJsonType &val, const bool pretty_print, const bool {\b ensure_ascii}, const unsigned int indent_step, const unsigned int current_indent=0)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
internal implementation of the serialization function }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b for} (std::size_t i=0;i< s.size();++i)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b if} ({\b JSON_HEDLEY_LIKELY}({\b state}==UTF8_ACCEPT))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JSON_PRIVATE_UNLESS_TESTED} {\b __pad0__}: void dump_escaped(const string_t& s\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JSON_PRIVATE_UNLESS_TESTED} const bool {\b ensure_ascii}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint8_t {\b state} = UTF8_ACCEPT\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b bytes} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b bytes_after_last_accept} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b undumped_chars} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b else}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< char, 64 > {\b number_buffer} \{\{\}\}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a (hopefully) large enough character buffer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::lconv * {\b loc} = nullptr\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the locale }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b thousands_sep} = '\\0'\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the locale's thousand separator character }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b decimal_point} = '\\0'\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the locale's decimal point character }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< char, 512 > {\b string_buffer} \{\{\}\}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
string buffer }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b indent_char}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the indentation character }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string_t {\b indent_string}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the indentation string }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b error_handler_t} {\b error_handler}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
error_handler how to react on decoding errors }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BasicJsonType>\par
class nlohmann::detail::serializer< BasicJsonType >\par
}
\par
{
Definition at line {\b 16369} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v serializer\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:serializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::serializer}< BasicJsonType >::{\b serializer} ({\b output_adapter_t}< char >  {\i s}, const char  {\i ichar}, {\b error_handler_t}  {\i error_handler_} = {\f2 {\b error_handler_t::strict}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i s} \cell }{output stream to serialize to \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ichar} \cell }{indentation character to use \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i error_handler_} \cell }{how to react on decoding errors \cell }
{\row }
}
}{
Definition at line {\b 16385} of file {\b json.hpp}.}\par
}
{\xe \v serializer\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:serializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::serializer}< BasicJsonType >::{\b serializer} (const {\b serializer}< BasicJsonType > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v serializer\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:serializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::serializer}< BasicJsonType >::{\b serializer} ({\b serializer}< BasicJsonType > && ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~serializer\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:~serializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::serializer}< BasicJsonType >::~{\b serializer} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v dump\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > void {\b nlohmann::detail::serializer}< BasicJsonType >::dump (const BasicJsonType &  {\i val}, const bool  {\i pretty_print}, const bool  {\i ensure_ascii}, const unsigned int  {\i indent_step}, const unsigned int  {\i current_indent} = {\f2 0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
internal implementation of the serialization function }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called by the public member function dump and organizes the serialization internally. The indentation level is propagated as additional parameter. In case of arrays and objects, the function is called recursively.\par
{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
strings and object keys are escaped using {\f2 escape_string()} \par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
integer numbers are converted implicitly via {\f2 operator<<} \par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
floating-point numbers are converted to a string using {\f2 "%g"}  format\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
binary values are serialized as objects containing the subtype and the byte array\par}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i val} \cell }{value to serialize \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i pretty_print} \cell }{whether the output shall be pretty-printed \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i ensure_ascii} \cell }{If {\i ensure_ascii}  is true, all non-ASCII characters in the output are escaped with {\f2 \\uXXXX}  sequences, and the result consists of ASCII characters only. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i indent_step} \cell }{the indent level \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i current_indent} \cell }{the current indent level (only used internally) \cell }
{\row }
}
}{
Definition at line {\b 16425} of file {\b json.hpp}.}\par
}
{\xe \v for\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:for}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::serializer}< BasicJsonType >::for (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16719} of file {\b json.hpp}.}\par
}
{\xe \v if\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:if}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::serializer}< BasicJsonType >::if ({\b JSON_HEDLEY_LIKELY}({\b state}==UTF8_ACCEPT) ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16911} of file {\b json.hpp}.}\par
}
{\xe \v operator=\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b serializer} & {\b nlohmann::detail::serializer}< BasicJsonType >::operator= (const {\b serializer}< BasicJsonType > & ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b serializer} & {\b nlohmann::detail::serializer}< BasicJsonType >::operator= ({\b serializer}< BasicJsonType > && ){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v __pad0__\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:__pad0__}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b JSON_PRIVATE_UNLESS_TESTED} {\b nlohmann::detail::serializer}< BasicJsonType >::__pad0__}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16694} of file {\b json.hpp}.}\par
}
{\xe \v bytes\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:bytes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > std::size_t {\b nlohmann::detail::serializer}< BasicJsonType >::bytes = 0}}
\par
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16713} of file {\b json.hpp}.}\par
}
{\xe \v bytes_after_last_accept\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:bytes_after_last_accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > std::size_t {\b nlohmann::detail::serializer}< BasicJsonType >::bytes_after_last_accept = 0}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16716} of file {\b json.hpp}.}\par
}
{\xe \v decimal_point\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:decimal_point}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > const char {\b nlohmann::detail::serializer}< BasicJsonType >::decimal_point = '\\0'}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the locale's decimal point character }}\par
{
Definition at line {\b 17270} of file {\b json.hpp}.}\par
}
{\xe \v else\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b nlohmann::detail::serializer}< BasicJsonType >::else}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16919} of file {\b json.hpp}.}\par
}
{\xe \v ensure_ascii\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:ensure_ascii}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > {\b JSON_PRIVATE_UNLESS_TESTED} const bool {\b nlohmann::detail::serializer}< BasicJsonType >::ensure_ascii}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \{\par
        std::uint32_t codepoint\{\}\par
}
{
Definition at line {\b 16709} of file {\b json.hpp}.}\par
}
{\xe \v error_handler\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:error_handler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > const {\b error_handler_t} {\b nlohmann::detail::serializer}< BasicJsonType >::error_handler}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
error_handler how to react on decoding errors }}\par
{
Definition at line {\b 17281} of file {\b json.hpp}.}\par
}
{\xe \v indent_char\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:indent_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > const char {\b nlohmann::detail::serializer}< BasicJsonType >::indent_char}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the indentation character }}\par
{
Definition at line {\b 17276} of file {\b json.hpp}.}\par
}
{\xe \v indent_string\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:indent_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > string_t {\b nlohmann::detail::serializer}< BasicJsonType >::indent_string}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the indentation string }}\par
{
Definition at line {\b 17278} of file {\b json.hpp}.}\par
}
{\xe \v loc\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:loc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > const std::lconv* {\b nlohmann::detail::serializer}< BasicJsonType >::loc = nullptr}}
\par
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the locale }}\par
{
Definition at line {\b 17266} of file {\b json.hpp}.}\par
}
{\xe \v number_buffer\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:number_buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > std::array<char, 64> {\b nlohmann::detail::serializer}< BasicJsonType >::number_buffer \{\{\}\}}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a (hopefully) large enough character buffer }}\par
{
Definition at line {\b 17263} of file {\b json.hpp}.}\par
}
{\xe \v state\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:state}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > std::uint8_t {\b nlohmann::detail::serializer}< BasicJsonType >::state = UTF8_ACCEPT}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16712} of file {\b json.hpp}.}\par
}
{\xe \v string_buffer\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:string_buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > std::array<char, 512> {\b nlohmann::detail::serializer}< BasicJsonType >::string_buffer \{\{\}\}}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
string buffer }}\par
{
Definition at line {\b 17273} of file {\b json.hpp}.}\par
}
{\xe \v thousands_sep\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:thousands_sep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > const char {\b nlohmann::detail::serializer}< BasicJsonType >::thousands_sep = '\\0'}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the locale's thousand separator character }}\par
{
Definition at line {\b 17268} of file {\b json.hpp}.}\par
}
{\xe \v undumped_chars\:nlohmann::detail::serializer< BasicJsonType >}
{\xe \v nlohmann::detail::serializer< BasicJsonType >\:undumped_chars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > std::size_t {\b nlohmann::detail::serializer}< BasicJsonType >::undumped_chars = 0}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16717} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::span_input_adapter Class Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::span_input_adapter}
{\xe \v nlohmann::detail::span_input_adapter}
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharT , typename std::enable_if< std::is_pointer< CharT >::value &&std::is_integral< typename std::remove_pointer< CharT >::type >::value &&sizeof(typename std::remove_pointer< CharT >::type)==1, int >::type  = 0> {\b span_input_adapter} (CharT b, std::size_t l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class IteratorType , typename std::enable_if< std::is_same< typename {\b iterator_traits}< IteratorType >::iterator_category, std::random_access_iterator_tag >::value, int >::type  = 0> {\b span_input_adapter} (IteratorType first, IteratorType last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b contiguous_bytes_input_adapter} && {\b get} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 5786} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v span_input_adapter\:nlohmann::detail::span_input_adapter}
{\xe \v nlohmann::detail::span_input_adapter\:span_input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename CharT , typename std::enable_if< std::is_pointer< CharT >::value &&std::is_integral< typename std::remove_pointer< CharT >::type >::value &&sizeof(typename std::remove_pointer< CharT >::type)==1, int >::type  = 0> nlohmann::detail::span_input_adapter::span_input_adapter (CharT  {\i b}, std::size_t  {\i l}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5795} of file {\b json.hpp}.}\par
}
{\xe \v span_input_adapter\:nlohmann::detail::span_input_adapter}
{\xe \v nlohmann::detail::span_input_adapter\:span_input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class IteratorType , typename std::enable_if< std::is_same< typename {\b iterator_traits}< IteratorType >::iterator_category, std::random_access_iterator_tag >::value, int >::type  = 0> nlohmann::detail::span_input_adapter::span_input_adapter (IteratorType  {\i first}, IteratorType  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5802} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get\:nlohmann::detail::span_input_adapter}
{\xe \v nlohmann::detail::span_input_adapter\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b contiguous_bytes_input_adapter} && nlohmann::detail::span_input_adapter::get (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5805} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::static_const< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::static_const< T >}
{\xe \v nlohmann::detail::static_const< T >}
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr T {\b value} \{\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct nlohmann::detail::static_const< T >\par
}
\par
{
Definition at line {\b 3179} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:nlohmann::detail::static_const< T >}
{\xe \v nlohmann::detail::static_const< T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > constexpr T {\b nlohmann::detail::static_const}< T >::value \{\}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3181} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
surprise Class Reference\par \pard\plain 
{\tc\tcl2 \v surprise}
{\xe \v surprise}
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The surprise class creates surprises. }}\par
{
{\f2 #include <surprise.h>}}\par
Inheritance diagram for surprise:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classsurprise.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b surprise} (QGraphicsItem *parent=NULL)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b surprise::surprise} constructor creates a new surprise with its required attributes }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The surprise class creates surprises. \par
}{
Definition at line {\b 9} of file {\b surprise.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v surprise\:surprise}
{\xe \v surprise\:surprise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
surprise::surprise (QGraphicsItem *  {\i parent} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b surprise::surprise} constructor creates a new surprise with its required attributes }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parent} \cell }{\cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
draw a rectangle for the surprise block\par
}{
Definition at line {\b 7} of file {\b surprise.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b surprise.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b surprise.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::to_json_fn Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::to_json_fn}
{\xe \v nlohmann::detail::to_json_fn}
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T > auto {\b operator()} (BasicJsonType &j, T &&val) const noexcept(noexcept({\b to_json}(j, std::forward< T >(val)))) -> decltype({\b to_json}(j, std::forward< T >(val)), void())\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 4919} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:nlohmann::detail::to_json_fn}
{\xe \v nlohmann::detail::to_json_fn\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType , typename T > auto nlohmann::detail::to_json_fn::operator() (BasicJsonType &  {\i j}, T &&  {\i val}) const -> decltype({\b to_json}(j, std::forward<T>(val)), void())
    {\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4922} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TripleBlk Class Reference\par \pard\plain 
{\tc\tcl2 \v TripleBlk}
{\xe \v TripleBlk}
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b TripleBlk} class creates objects of type {\b TripleBlk}. }}\par
{
{\f2 #include <Tripleblk.h>}}\par
Inheritance diagram for TripleBlk:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_triple_blk.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TripleBlk} (QGraphicsItem *parent=NULL)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b TripleBlk::TripleBlk} constructor creates a new {\b TripleBlk} with its required attributes. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPosition} (int x, int y)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b posx} = 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b posy} = 0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b TripleBlk} class creates objects of type {\b TripleBlk}. \par
}{
Definition at line {\b 8} of file {\b Tripleblk.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v TripleBlk\:TripleBlk}
{\xe \v TripleBlk\:TripleBlk}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TripleBlk::TripleBlk (QGraphicsItem *  {\i parent} = {\f2 NULL})}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b TripleBlk::TripleBlk} constructor creates a new {\b TripleBlk} with its required attributes. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i parent} \cell }{\cell }
{\row }
}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
draw a rectangle for the block\par
}{
Definition at line {\b 7} of file {\b Tripleblk.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v setPosition\:TripleBlk}
{\xe \v TripleBlk\:setPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TripleBlk::setPosition (int  {\i x}, int  {\i y})}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v posx\:TripleBlk}
{\xe \v TripleBlk\:posx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TripleBlk::posx = 0}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b Tripleblk.h}.}\par
}
{\xe \v posy\:TripleBlk}
{\xe \v TripleBlk\:posy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TripleBlk::posy = 0}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b Tripleblk.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Tripleblk.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b Tripleblk.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::tuple_element< N, ::nlohmann::detail::iteration_proxy_value< IteratorType > > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v std::tuple_element< N, ::nlohmann::detail::iteration_proxy_value< IteratorType > >}
{\xe \v std::tuple_element< N, ::nlohmann::detail::iteration_proxy_value< IteratorType > >}
{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = decltype(get< N >(std::declval< ::{\b nlohmann::detail::iteration_proxy_value}< IteratorType > >()))\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<std::size_t N, typename IteratorType>\par
class std::tuple_element< N, ::nlohmann::detail::iteration_proxy_value< IteratorType > >\par
}
\par
{
Definition at line {\b 4528} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:std::tuple_element< N, ::nlohmann::detail::iteration_proxy_value< IteratorType > >}
{\xe \v std::tuple_element< N, ::nlohmann::detail::iteration_proxy_value< IteratorType > >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::size_t N, typename IteratorType > using std::tuple_element< N, ::{\b nlohmann::detail::iteration_proxy_value}< IteratorType > >::{\b type} =  decltype( get<N>(std::declval < ::{\b nlohmann::detail::iteration_proxy_value}<IteratorType > > ()))}}
\par
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4531} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std::tuple_size<::nlohmann::detail::iteration_proxy_value< IteratorType > > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v std::tuple_size<::nlohmann::detail::iteration_proxy_value< IteratorType > >}
{\xe \v std::tuple_size<::nlohmann::detail::iteration_proxy_value< IteratorType > >}
{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for std::tuple_size<::nlohmann::detail::iteration_proxy_value< IteratorType > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classstd_1_1tuple__size_3_1_1nlohmann_1_1detail_1_1iteration__proxy__value_3_01_iterator_type_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename IteratorType>\par
class std::tuple_size<::nlohmann::detail::iteration_proxy_value< IteratorType > >\par
}
\par
{
Definition at line {\b 4524} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::is_ordered_map< T >::two Struct Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::is_ordered_map< T >::two}
{\xe \v nlohmann::detail::is_ordered_map< T >::two}
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b x} [2]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct nlohmann::detail::is_ordered_map< T >::two\par
}
\par
{
Definition at line {\b 3859} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v x\:nlohmann::detail::is_ordered_map< T >::two}
{\xe \v nlohmann::detail::is_ordered_map< T >::two\:x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > char {\b nlohmann::detail::is_ordered_map}< T >::two::x[2]}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3861} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::type_error Class Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::type_error}
{\xe \v nlohmann::detail::type_error}
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating executing a member function with a wrong type }}\par
{
{\f2 #include <json.hpp>}}\par
Inheritance diagram for nlohmann::detail::type_error:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnlohmann_1_1detail_1_1type__error.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > static {\b type_error} {\b create} (int id_, const std::string &what_arg, const BasicJsonType &context)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating executing a member function with a wrong type \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This exception is thrown in case of a type error; that is, a library function is executed on a JSON value whose type does not match the expected semantics.\par
Exceptions have ids 3xx.\par
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clcbpat16\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{name / id   \cell }{example message   \cell }{description    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.301   \cell }{cannot create object from initializer list   \cell }{To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.302   \cell }{type must be object, but is array   \cell }{During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.303   \cell }{incompatible ReferenceType for get_ref, actual type is object   \cell }{To retrieve a reference to a value stored in a {\b basic_json} object with get_ref, the type of the reference must match the value type. For instance, for a JSON array, the {\i ReferenceType}  must be array_t &.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.304   \cell }{cannot use at() with string   \cell }{The at() member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.305   \cell }{cannot use operator[] with string   \cell }{The operator[] member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.306   \cell }{cannot use value() with string   \cell }{The value() member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.307   \cell }{cannot use erase() with string   \cell }{The erase() member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.308   \cell }{cannot use push_back() with string   \cell }{The push_back() and operator+= member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.309   \cell }{cannot use insert() with   \cell }{The insert() member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.310   \cell }{cannot use swap() with number   \cell }{The swap() member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.311   \cell }{cannot use emplace_back() with string   \cell }{The emplace_back() member function can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.312   \cell }{cannot use update() with string   \cell }{The update() member functions can only be executed for certain JSON types.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.313   \cell }{invalid value to unflatten   \cell }{The unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.314   \cell }{only objects can be unflattened   \cell }{The unflatten function only works for an object whose keys are JSON Pointers.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.315   \cell }{values in object must be primitive   \cell }{The unflatten function only works for an object whose keys are JSON Pointers and whose values are primitive.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.316   \cell }{invalid UTF-8 byte at index 10: 0x7E   \cell }{The dump function only works with UTF-8 encoded strings; that is, if you assign a {\f2 std::string}  to a JSON value, make sure it is UTF-8 encoded.    \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\trowd \trgaph108\trleft-108\trbrdrt\brdrs\brdrw10 \trbrdrl\brdrs\brdrw10 \trbrdrb\brdrs\brdrw10 \trbrdrr\brdrs\brdrw10 \trbrdrh\brdrs\brdrw10 \trbrdrv\brdrs\brdrw10 
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx2916
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx5832
\clvertalt\clbrdrt\brdrs\brdrw10 \clbrdrl\brdrs\brdrw10 \clbrdrb\brdrs\brdrw10 \clbrdrr \brdrs\brdrw10 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{json.exception.type_error.317   \cell }{JSON value cannot be serialized to requested format   \cell }{The dynamic type of the object cannot be represented in the requested serialization format (e.g. a raw {\f2 true}  or {\f2 null}  JSON object cannot be serialized to BSON)   \cell }
\pard \widctlpar\intbl\adjustright
{\row }
\pard\plain
\par
@liveexample\{The following code shows how a {\f2 {\b type_error}}  exception can be caught.,{\b type_error}\}\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
See also\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
- {\b exception} for the base class of the library exceptions \par
- {\b parse_error} for exceptions indicating a parse error \par
- {\b invalid_iterator} for exceptions indicating errors with iterators \par
- {\b out_of_range} for exceptions indicating access out of the defined range \par
- {\b other_error} for exceptions indicating other library errors\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.0.0 \par
}}}{
Definition at line {\b 2927} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v create\:nlohmann::detail::type_error}
{\xe \v nlohmann::detail::type_error\:create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BasicJsonType > static {\b type_error} nlohmann::detail::type_error::create (int  {\i id_}, const std::string &  {\i what_arg}, const BasicJsonType &  {\i context}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2931} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >}
{\xe \v nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >}
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b char_type} = char\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b wide_string_input_adapter} (BaseInputAdapter base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::char_traits< char >::int_type {\b get_character} () noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BaseInputAdapter, typename WideCharType>\par
class nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >\par
}
\par
{
Definition at line {\b 5620} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v char_type\:nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >}
{\xe \v nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >\:char_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BaseInputAdapter , typename WideCharType > using {\b nlohmann::detail::wide_string_input_adapter}< BaseInputAdapter, WideCharType >::{\b char_type} =  char}}
\par
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5623} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v wide_string_input_adapter\:nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >}
{\xe \v nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >\:wide_string_input_adapter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BaseInputAdapter , typename WideCharType > {\b nlohmann::detail::wide_string_input_adapter}< BaseInputAdapter, WideCharType >::{\b wide_string_input_adapter} (BaseInputAdapter  {\i base}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5625} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_character\:nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >}
{\xe \v nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >\:get_character}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BaseInputAdapter , typename WideCharType > std::char_traits< char >::int_type {\b nlohmann::detail::wide_string_input_adapter}< BaseInputAdapter, WideCharType >::get_character (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5628} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::wide_string_input_helper< BaseInputAdapter, T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::wide_string_input_helper< BaseInputAdapter, T >}
{\xe \v nlohmann::detail::wide_string_input_helper< BaseInputAdapter, T >}
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BaseInputAdapter, size_t T>\par
struct nlohmann::detail::wide_string_input_helper< BaseInputAdapter, T >\par
}
\par
{
Definition at line {\b 5496} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 2 > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 2 >}
{\xe \v nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 2 >}
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b fill_buffer} (BaseInputAdapter &input, std::array< std::char_traits< char >::int_type, 4 > &utf8_bytes, size_t &utf8_bytes_index, size_t &utf8_bytes_filled)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BaseInputAdapter>\par
struct nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 2 >\par
}
\par
{
Definition at line {\b 5557} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v fill_buffer\:nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 2 >}
{\xe \v nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 2 >\:fill_buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BaseInputAdapter > static void {\b nlohmann::detail::wide_string_input_helper}< BaseInputAdapter, 2 >::fill_buffer (BaseInputAdapter &  {\i input}, std::array< std::char_traits< char >::int_type, 4 > &  {\i utf8_bytes}, size_t &  {\i utf8_bytes_index}, size_t &  {\i utf8_bytes_filled}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5560} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 4 > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 4 >}
{\xe \v nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 4 >}
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
\par
{
{\f2 #include <json.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b fill_buffer} (BaseInputAdapter &input, std::array< std::char_traits< char >::int_type, 4 > &utf8_bytes, size_t &utf8_bytes_index, size_t &utf8_bytes_filled)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename BaseInputAdapter>\par
struct nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 4 >\par
}
\par
{
Definition at line {\b 5499} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v fill_buffer\:nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 4 >}
{\xe \v nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 4 >\:fill_buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename BaseInputAdapter > static void {\b nlohmann::detail::wide_string_input_helper}< BaseInputAdapter, 4 >::fill_buffer (BaseInputAdapter &  {\i input}, std::array< std::char_traits< char >::int_type, 4 > &  {\i utf8_bytes}, size_t &  {\i utf8_bytes_index}, size_t &  {\i utf8_bytes_filled}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5502} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Client/{\b json.hpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Ball.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Ball.cpp}
{\xe \v Client/Ball.cpp}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Ball.h"}\par
{\f2 #include <QTimer>}\par
{\f2 #include <QBrush>}\par
{\f2 #include "Game.h"}\par
{\f2 #include "Paddle.h"}\par
{\f2 #include "Commonblk.h"}\par
{\f2 #include "Doubleblk.h"}\par
{\f2 #include "Tripleblk.h"}\par
{\f2 #include "Internblk.h"}\par
{\f2 #include "Deepblk.h"}\par
{\f2 #include "Client.h"}\par
{\f2 #include "json.hpp"}\par
{\f2 #include "gameover.h"}\par
{\f2 #include "surprise.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b json} = {\b nlohmann::json}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b clientRun} (void *)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
clientRun independent method tries connecting to the server }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > string {\b ptrToStr} (T ptr)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Client} * {\b client}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b gameover} * {\b gameOver}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Game} * {\b game}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Paddle} * {\b padd}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v json\:Ball.cpp}
{\xe \v Ball.cpp\:json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b json} =  {\b nlohmann::json}}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b Ball.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v clientRun\:Ball.cpp}
{\xe \v Ball.cpp\:clientRun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void * clientRun (void * )}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
clientRun independent method tries connecting to the server }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 47} of file {\b Ball.cpp}.}\par
}
{\xe \v ptrToStr\:Ball.cpp}
{\xe \v Ball.cpp\:ptrToStr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > string ptrToStr (T  {\i ptr})}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function coverts a pointer data into a string \par
}{
Definition at line {\b 60} of file {\b Ball.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v client\:Ball.cpp}
{\xe \v Ball.cpp\:client}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Client}* client}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b Ball.cpp}.}\par
}
{\xe \v game\:Ball.cpp}
{\xe \v Ball.cpp\:game}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Game}* game{\f2 [extern]}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b mainwindow.cpp}.}\par
}
{\xe \v gameOver\:Ball.cpp}
{\xe \v Ball.cpp\:gameOver}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b gameover}* gameOver}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b Ball.cpp}.}\par
}
{\xe \v padd\:Ball.cpp}
{\xe \v Ball.cpp\:padd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Paddle}* padd}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b Ball.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ball.cpp\par \pard\plain 
{\tc\tcl2 \v Client/Ball.cpp}
{\xe \v Client/Ball.cpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Ball.h"}\par
00002 {\cf21 #include <QTimer>}\par
00003 {\cf21 #include <QBrush>}\par
00004 {\cf21 #include "Game.h"}\par
00005 {\cf21 #include "Paddle.h"}\par
00006 {\cf21 #include "Commonblk.h"}\par
00007 {\cf21 #include "Doubleblk.h"}\par
00008 {\cf21 #include "Tripleblk.h"}\par
00009 {\cf21 #include "Internblk.h"}\par
00010 {\cf21 #include "Deepblk.h"}\par
00011 {\cf21 #include "Client.h"}\par
00012 {\cf21 #include "json.hpp"}\par
00013 {\cf21 #include "gameover.h"}\par
00014 {\cf21 #include "surprise.h"}\par
00015 \par
00016 {\cf17 using} json = nlohmann::json;\par
00017 Client* client;\par
00018 gameover* gameOver;\par
00019 {\cf17 extern} Game* game;\par
00020 Paddle* padd;\par
00025 Ball::Ball(QGraphicsItem *parent): QGraphicsRectItem(parent), QObject()\{\par
00029     setRect(0,0,20,20);\par
00030     QBrush brush;\par
00031     brush.setTextureImage(QImage ({\cf22 "/home/user/Escritorio/Repos GitHub/CrazyBreakout/images/ball.png"}));\par
00032     setBrush(brush);\par
00033 \par
00034     {\cf20 // Move ball to the top when the game begins}\par
00035     velX = 0;\par
00036     velY = -3;\par
00037 \par
00038     QTimer* timer = {\cf17 new} QTimer();\par
00039     connect(timer,SIGNAL(timeout()),{\cf17 this},SLOT(moveBall()));\par
00040     timer->start(15);\par
00041     this->connecting(); \par
00042 \}\par
00047 {\cf18 void} *clientRun({\cf18 void} *)\{\par
00048     {\cf17 const} {\cf18 char} *Ip = {\cf22 "192.168.1.110"};\par
00049     {\cf18 int} port = 4050;\par
00050     {\cf19 try} \{\par
00051         client->Connect(Ip,port);\par
00052     \} {\cf19 catch} ({\cf18 string} ex) \{\par
00053         cout<< ex <<endl;\par
00054     \}\par
00055     pthread_exit({\cf17 nullptr});\par
00056 \}\par
00060 {\cf17 template} <{\cf17 typename} T> {\cf18 string} ptrToStr(T ptr)\{\par
00061     stringstream s;\par
00062     s << ptr;\par
00063     {\cf19 return} s.str();\par
00064 \}\par
00065 \par
00069 {\cf18 void} Ball::connecting()\{\par
00070     {\cf20 // Connecting to the server.}\par
00071     client = {\cf17 new} Client();\par
00072     pthread_t hiloClient;\par
00073     pthread_create(&hiloClient,0,clientRun,{\cf17 nullptr});\par
00074     pthread_detach(hiloClient);\par
00075 \}\par
00080 {\cf18 double} Ball::getCenterX()\{\par
00081     {\cf19 return} x() + rect().width()/2;\par
00082 \}\par
00086 {\cf18 void} Ball::moveBall()\{\par
00087 \par
00088     reverseVelocity();\par
00089     checkPadCollision();\par
00090     checkBlckCollision();{\cf20 // method to check a paddle collision}\par
00091     checkBallLeft();{\cf20 // method to check if the ball left the playing area}\par
00092     moveBy(velX,velY);\par
00093 \}\par
00097 {\cf18 void} Ball::reverseVelocity()\{\par
00098     {\cf20 // Check if out of bound, if so, reverse the proper velocity}\par
00099     {\cf18 double} screenW = game->width();\par
00100 \par
00101     {\cf20 // If the ball collides left edge}\par
00102     {\cf19 if} (mapToScene(rect().topLeft()).x() <= 0)\{\par
00103         velX = -1 * velX;\par
00104     \}\par
00105 \par
00106     {\cf20 // If the ball collides right edge}\par
00107     {\cf19 if} (mapToScene(rect().topRight()).x() >= screenW)\{\par
00108         velX = -1 * velX;\par
00109     \}\par
00110 \par
00111     {\cf20 // If the ball collides top edge}\par
00112     {\cf19 if} (mapToScene(rect().topLeft()).y() <= 0)\{\par
00113         velY = -1 * velY;\par
00114     \}\par
00115 \}\par
00120 {\cf18 void} Ball::checkPadCollision()\{\par
00121     QList<QGraphicsItem*> Items = collidingItems();\par
00122     {\cf19 for} ({\cf18 size_t} i = 0, n = Items.size(); i < n; ++i)\{\par
00123         Paddle* paddle = {\cf17 dynamic_cast<}Paddle*{\cf17 >}(Items[i]);\par
00124         {\cf19 if} (paddle)\{\par
00125             {\cf20 // Reverse the y velocity}\par
00126             velY = -1 * velY;\par
00127 \par
00128             {\cf20 // Add to x velocity depending on where it hits the paddle}\par
00129             {\cf18 double} ballX = getCenterX();\par
00130             {\cf18 double} paddleX = paddle->getCenterX();\par
00131 \par
00132             {\cf18 double} dvx = ballX - paddleX;\par
00133             velX = (velX + dvx)/15;\par
00134 \par
00135             {\cf19 return};\par
00136         \}\par
00137     \}\par
00138 \}\par
00142 {\cf18 void} Ball::checkBallLeft()\{\par
00143     {\cf18 double} bally = pos().y();\par
00144     QList<QGraphicsItem*> Items = collidingItems();\par
00145     {\cf19 for} ({\cf18 size_t} i = 0, n = Items.size(); i < n; ++i)\{\par
00146         Ball* ball = {\cf17 dynamic_cast<}Ball*{\cf17 >}(Items[i]);\par
00147         {\cf19 if} (ball)\{\par
00148             {\cf19 if} (bally > 650)\{\par
00149                 ballCounter--;\par
00150                 json message;\par
00151                 {\cf18 string} strball = ptrToStr(ball);\par
00152                 message[{\cf22 "type"}] = {\cf22 "ballfell"};\par
00153                 message[{\cf22 "ball"}] = to_string(i);\par
00154 \par
00155                 {\cf18 string} msg = message.dump();\par
00156                 client->setMessage(msg.c_str());\par
00157             \}\par
00158         \}\par
00159     \}\par
00160     {\cf19 if} (ballCounter <= 0)\{\par
00161         {\cf20 // Show GameOver window}\par
00162         gameOver = {\cf17 new} gameover();\par
00163         gameOver->show();\par
00164     \}\par
00165 \}\par
00170 {\cf18 void} Ball::checkBlckCollision()\{\par
00171     QList<QGraphicsItem*> bItems = collidingItems();\par
00172     QList<QGraphicsItem*> cItems = collidingItems();\par
00173     QList<QGraphicsItem*> dItems = collidingItems();\par
00174     QList<QGraphicsItem*> tItems = collidingItems();\par
00175     QList<QGraphicsItem*> iItems = collidingItems();\par
00176     QList<QGraphicsItem*> surpItems = collidingItems();\par
00177     QList<QGraphicsItem*> deepItems = collidingItems();\par
00178 \par
00179     {\cf20 // Check for collisions}\par
00180     {\cf19 for} ({\cf18 size_t} i = 0, n = cItems.size(); i < n; ++i)\{\par
00181 \par
00182         {\cf20 //Ball* ball = dynamic_cast<Ball*>(bItems[i]);}\par
00183         CommonBlk *cblock = {\cf17 dynamic_cast<}CommonBlk*{\cf17 >}(cItems[i]);\par
00184         DoubleBlk *dblock = {\cf17 dynamic_cast<}DoubleBlk*{\cf17 >}(dItems[i]);\par
00185         TripleBlk *tblock = {\cf17 dynamic_cast<}TripleBlk*{\cf17 >}(tItems[i]);\par
00186         InternBlk *iblock = {\cf17 dynamic_cast<}InternBlk*{\cf17 >}(iItems[i]);\par
00187         {\cf20 //surprise *sblock = dynamic_cast<surprise*>(surpItems[i]);}\par
00188         DeepBlk *deepblock = {\cf17 dynamic_cast<}DeepBlk*{\cf17 >}(deepItems[i]);\par
00189 \par
00190         {\cf18 double} yPad = 9;\par
00191         {\cf18 double} xPad = 59;\par
00192         {\cf18 double} ballx = pos().x();\par
00193         {\cf18 double} bally = pos().y();\par
00194 \par
00195         {\cf20 // if the ball collides with a surprise}\par
00196 {\cf20 //        if (sblock)\{}\par
00197 {\cf20 //            double blockx = sblock->pos().x();}\par
00198 {\cf20 //            double blocky = sblock->pos().y();}\par
00199 {\cf20 //            randomNum = game->randomNumber();}\par
00200 \par
00201 {\cf20 //            if ((bally > blocky + yPad && velY < 0)||(blocky > bally + yPad && velY > 0 )||}\par
00202 {\cf20 //                    (ballx > blockx + xPad && velX < 0)||(blockx > ballx + xPad && velX > 0))\{}\par
00203 {\cf20 //                if (randomNum == 1)\{}\par
00204 {\cf20 //                    // increase ball speed}\par
00205 {\cf20 //                    velX = velX+0.2;}\par
00206 {\cf20 //                    velY = velY+0.2;}\par
00207 {\cf20 //                \}}\par
00208 {\cf20 //                else if (randomNum == 2)\{}\par
00209 {\cf20 //                    // reduce ball speed}\par
00210 {\cf20 //                    velX = velX-0.2;}\par
00211 {\cf20 //                    velY = velY-0.2;}\par
00212 {\cf20 //                \}}\par
00213 {\cf20 //                else if (randomNum == 3)\{}\par
00214 {\cf20 //                    // increase paddle size}\par
00215 {\cf20 //                    game->increasePadd();}\par
00216 {\cf20 //                \}}\par
00217 {\cf20 //                else if (randomNum == 4)\{}\par
00218 {\cf20 //                    // reduce paddle size}\par
00219 {\cf20 //                    game->reducePadd();}\par
00220 {\cf20 //                \}}\par
00221 {\cf20 //            \}}\par
00222 \par
00223 {\cf20 //            game->scene->removeItem(sblock);}\par
00224 {\cf20 //            delete sblock;}\par
00225 {\cf20 //        \}}\par
00226 \par
00227         {\cf20 // If the ball collides with a cblock type}\par
00228         {\cf19 if} (cblock)\{\par
00229             {\cf18 double} blockx = cblock->pos().x();\par
00230             {\cf18 double} blocky = cblock->pos().y();\par
00231 \par
00232             {\cf19 if} (depthLvl <= 0)\{\par
00233                 {\cf20 // If ball collides from bottom}\par
00234                 {\cf19 if} (bally > blocky + yPad && velY < 0)\{\par
00235                     velY = -1 * (velY + 0.2);\par
00236                     velX = velX + 0.2;\par
00237                 \}\par
00238 \par
00239                 {\cf20 // If ball collides from top}\par
00240                 {\cf19 if} (blocky > bally + yPad && velY > 0 )\{\par
00241                     velY = -1 * (velY + 0.2);\par
00242                     velX = velX + 0.2;\par
00243                 \}\par
00244 \par
00245                 {\cf20 // If ball collides from right}\par
00246                 {\cf19 if} (ballx > blockx + xPad && velX < 0)\{\par
00247                     velX = -1 * (velX + 0.2);\par
00248                     velY = velY + 0.5;\par
00249                 \}\par
00250 \par
00251                 {\cf20 // If ball collides from left}\par
00252                 {\cf19 if} (blockx > ballx + xPad && velX > 0)\{\par
00253                     velX = -1 * (velX + 0.2);\par
00254                     velY = velY + 0.2;\par
00255                 \}\par
00256                 {\cf20 // random surprise}\par
00257 {\cf20 //                if (game->randomNumber() == 5)\{}\par
00258 {\cf20 //                    game->addSurprise();}\par
00259 {\cf20 //                \}}\par
00260                 {\cf20 // TELL SERVER ABOUT THE COLLISION //}\par
00261                 json message;\par
00262                 {\cf18 string} blkindx = to_string(i);\par
00263                 {\cf18 string} ballindx = to_string(i);\par
00264                 message[{\cf22 "type"}] = {\cf22 "collision"};\par
00265                 message[{\cf22 "blkType"}] = {\cf22 "common"};\par
00266                 message[{\cf22 "block"}] = blkindx;\par
00267                 message[{\cf22 "ball"}] = ballindx;\par
00268 \par
00269                 {\cf18 string} msg = message.dump();\par
00270                 client->setMessage(msg.c_str());\par
00271             \}\par
00272             {\cf19 else}\{\par
00273                 depthLvl --;\par
00274             \}\par
00275 \par
00276         \}\par
00277 \par
00278         {\cf20 // If the ball collides with a dblock type}\par
00279         {\cf19 if} (dblock)\{\par
00280             {\cf18 double} blockx = dblock->pos().x();\par
00281             {\cf18 double} blocky = dblock->pos().y();\par
00282 \par
00283             {\cf19 if} (depthLvl <= 0)\{\par
00284                 {\cf20 // If ball collides from bottom}\par
00285                 {\cf19 if} (bally > blocky + yPad && velY < 0)\{\par
00286                     velY = -1 * velY;\par
00287                 \}\par
00288 \par
00289                 {\cf20 // If ball collides from top}\par
00290                 {\cf19 if} (blocky > bally + yPad && velY > 0 )\{\par
00291                     velY = -1 * velY;\par
00292                 \}\par
00293 \par
00294                 {\cf20 // If ball collides from right}\par
00295                 {\cf19 if} (ballx > blockx + xPad && velX < 0)\{\par
00296                     velX = -1 * velX;\par
00297                 \}\par
00298 \par
00299                 {\cf20 // If ball collides from left}\par
00300                 {\cf19 if} (blockx > ballx + xPad && velX > 0)\{\par
00301                     velX = -1 * velX;\par
00302                 \}\par
00303                 {\cf20 // random surprise}\par
00304 {\cf20 //                if (game->randomNumber() == 5)\{}\par
00305 {\cf20 //                    game->addSurprise();}\par
00306 {\cf20 //                \}}\par
00307                 {\cf20 // TELL SERVER ABOUT THE COLLISION //}\par
00308                 json message;\par
00309                 {\cf18 string} blkindx = to_string(i);\par
00310                 {\cf18 string} ballindx = to_string(i);\par
00311                 message[{\cf22 "type"}] = {\cf22 "collision"};\par
00312                 message[{\cf22 "blkType"}] = {\cf22 "double"};\par
00313                 message[{\cf22 "block"}] = blkindx;\par
00314                 message[{\cf22 "ball"}] = ballindx;\par
00315 \par
00316                 {\cf18 string} msg = message.dump();\par
00317                 client->setMessage(msg.c_str());\par
00318             \}\par
00319             {\cf19 else}\{\par
00320                 depthLvl --;\par
00321             \}\par
00322         \}\par
00323 \par
00324         {\cf20 // If the ball collides with a tblock type}\par
00325         {\cf19 if} (tblock)\{\par
00326             {\cf18 double} blockx = tblock->pos().x();\par
00327             {\cf18 double} blocky = tblock->pos().y();\par
00328 \par
00329             {\cf19 if} (depthLvl <= 0)\{\par
00330                 {\cf20 // If ball collides from bottom}\par
00331                 {\cf19 if} (bally > blocky + yPad && velY < 0)\{\par
00332                     velY = -1 * velY;\par
00333                 \}\par
00334 \par
00335                 {\cf20 // If ball collides from top}\par
00336                 {\cf19 if} (blocky > bally + yPad && velY > 0 )\{\par
00337                     velY = -1 * velY;\par
00338                 \}\par
00339 \par
00340                 {\cf20 // If ball collides from right}\par
00341                 {\cf19 if} (ballx > blockx + xPad && velX < 0)\{\par
00342                     velX = -1 * velX;\par
00343                 \}\par
00344 \par
00345                 {\cf20 // If ball collides from left}\par
00346                 {\cf19 if} (blockx > ballx + xPad && velX > 0)\{\par
00347                     velX = -1 * velX;\par
00348                 \}\par
00349                 {\cf20 // random surprise}\par
00350 {\cf20 //                if (game->randomNumber() == 5)\{}\par
00351 {\cf20 //                    game->addSurprise();}\par
00352 {\cf20 //                \}}\par
00353                 {\cf20 // TELL SERVER ABOUT THE COLLISION //}\par
00354                 json message;\par
00355                 {\cf18 string} blkindx = to_string(i);\par
00356                 {\cf18 string} ballindx = to_string(i);\par
00357                 message[{\cf22 "type"}] = {\cf22 "collision"};\par
00358                 message[{\cf22 "blkType"}] = {\cf22 "triple"};\par
00359                 message[{\cf22 "block"}] = blkindx;\par
00360                 message[{\cf22 "ball"}] = ballindx;\par
00361 \par
00362                 {\cf18 string} msg = message.dump();\par
00363                 client->setMessage(msg.c_str());\par
00364             \}\par
00365             {\cf19 else}\{\par
00366                 depthLvl --;\par
00367             \}\par
00368         \}\par
00369 \par
00370         {\cf20 // If the ball collides with an iblock type}\par
00371         {\cf19 if} (iblock)\{\par
00372 \par
00373             {\cf18 double} blockx = iblock->pos().x();\par
00374             {\cf18 double} blocky = iblock->pos().y();\par
00375 \par
00376             {\cf20 // If ball collides from bottom}\par
00377             {\cf19 if} (bally > blocky + yPad && velY < 0)\{\par
00378                 velY = -1 * velY;\par
00379             \}\par
00380 \par
00381             {\cf20 // If ball collides from top}\par
00382             {\cf19 if} (blocky > bally + yPad && velY > 0 )\{\par
00383                 velY = -1 * velY;\par
00384             \}\par
00385 \par
00386             {\cf20 // If ball collides from right}\par
00387             {\cf19 if} (ballx > blockx + xPad && velX < 0)\{\par
00388                 velX = -1 * velX;\par
00389             \}\par
00390 \par
00391             {\cf20 // If ball collides from left}\par
00392             {\cf19 if} (blockx > ballx + xPad && velX > 0)\{\par
00393                 velX = -1 * velX;\par
00394             \}\par
00395             {\cf20 // TELL SERVER ABOUT THE COLLISION //}\par
00396             {\cf19 if} (depthLvl >= 1)\{\par
00397                 json message;\par
00398                 {\cf18 string} blkindx = to_string(i);\par
00399                 {\cf18 string} ballindx = to_string(i);\par
00400                 message[{\cf22 "type"}] = {\cf22 "collision"};\par
00401                 message[{\cf22 "blkType"}] = {\cf22 "intern"};\par
00402                 message[{\cf22 "block"}] = blkindx;\par
00403                 message[{\cf22 "ball"}] = ballindx;\par
00404 \par
00405                 {\cf18 string} msg = message.dump();\par
00406                 client->setMessage(msg.c_str());\par
00407                 depthLvl = 0;\par
00408 \par
00409             \}\par
00410         \}\par
00411 \par
00412         {\cf20 // If the ball collides with a deepblock type}\par
00413         {\cf19 if} (deepblock)\{\par
00414             {\cf18 double} blockx = deepblock->pos().x();\par
00415             {\cf18 double} blocky = deepblock->pos().y();\par
00416 \par
00417             {\cf20 // If ball collides from bottom}\par
00418             {\cf19 if} (bally > blocky + yPad && velY < 0)\{\par
00419                 velY = -1 * (velY + 0.2);\par
00420                 velX = velX + 0.2;\par
00421             \}\par
00422 \par
00423             {\cf20 // If ball collides from top}\par
00424             {\cf19 if} (blocky > bally + yPad && velY > 0 )\{\par
00425                 velY = -1 * (velY + 0.2);\par
00426                 velX = velX + 0.2;\par
00427             \}\par
00428 \par
00429             {\cf20 // If ball collides from right}\par
00430             {\cf19 if} (ballx > blockx + xPad && velX < 0)\{\par
00431                 velX = -1 * (velX + 0.2);\par
00432                 velY = velY + 0.2;\par
00433             \}\par
00434 \par
00435             {\cf20 // If ball collides from left}\par
00436             {\cf19 if} (blockx > ballx + xPad && velX > 0)\{\par
00437                 velX = -1 * (velX + 0.2);\par
00438                 velY = velY + 0.2;\par
00439             \}\par
00440 \par
00441             {\cf20 // TELL SERVER ABOUT THE COLLISION //}\par
00442             json message;\par
00443             {\cf18 string} blkindx = to_string(i);\par
00444             {\cf18 string} ballindx = to_string(i);\par
00445             message[{\cf22 "type"}] = {\cf22 "collision"};\par
00446             message[{\cf22 "blkType"}] = {\cf22 "deep"};\par
00447             message[{\cf22 "block"}] = blkindx;\par
00448             message[{\cf22 "ball"}] = ballindx;\par
00449 \par
00450             {\cf18 string} msg = message.dump();\par
00451             client->setMessage(msg.c_str());\par
00452         \}\par
00453     \}\par
00454 \}\par
00458 {\cf18 void} Ball::addBall()\par
00459 \{\par
00460     ballCounter++;\par
00461 \}\par
00465 {\cf18 void} Ball::deleteBlk({\cf18 string} type, {\cf18 string} index)\par
00466 \{\par
00467     {\cf18 size_t} x = stoi(index);\par
00468     QList<QGraphicsItem*> cItems = collidingItems();\par
00469     QList<QGraphicsItem*> dItems = collidingItems();\par
00470     QList<QGraphicsItem*> tItems = collidingItems();\par
00471     QList<QGraphicsItem*> iItems = collidingItems();\par
00472 \par
00473     {\cf20 // delete common block}\par
00474     {\cf19 if} (type == {\cf22 "common"})\{\par
00475         {\cf19 for} ({\cf18 size_t} i = 0, n = cItems.size(); i < n; ++i)\{\par
00476             {\cf19 if} (i == x)\{\par
00477             CommonBlk *cblock = {\cf17 dynamic_cast<}CommonBlk*{\cf17 >}(cItems[i]);\par
00478             game->scene->removeItem(cblock);\par
00479             {\cf17 delete} cblock;\par
00480             \}\par
00481         \}\par
00482     \}\par
00483     {\cf20 // delete double block}\par
00484     {\cf19 if} (type == {\cf22 "double"})\{\par
00485         {\cf19 for} ({\cf18 size_t} i = 0, n = dItems.size(); i < n; ++i)\{\par
00486             {\cf19 if} (i == x)\{\par
00487             DoubleBlk *dblock = {\cf17 dynamic_cast<}DoubleBlk*{\cf17 >}(dItems[i]);\par
00488             game->scene->removeItem(dblock);\par
00489             {\cf17 delete} dblock;\par
00490             \}\par
00491         \}\par
00492     \}\par
00493     {\cf20 // delete triple block}\par
00494     {\cf19 if} (type == {\cf22 "triple"})\{\par
00495         {\cf19 for} ({\cf18 size_t} i = 0, n = tItems.size(); i < n; ++i)\{\par
00496             {\cf19 if} (i == x)\{\par
00497             TripleBlk *tblock = {\cf17 dynamic_cast<}TripleBlk*{\cf17 >}(tItems[i]);\par
00498             game->scene->removeItem(tblock);\par
00499             {\cf17 delete} tblock;\par
00500             \}\par
00501         \}\par
00502     \}\par
00503     {\cf20 // delete intern block}\par
00504     {\cf19 if} (type == {\cf22 "intern"})\{\par
00505         {\cf19 for} ({\cf18 size_t} i = 0, n = iItems.size(); i < n; ++i)\{\par
00506             {\cf19 if} (i == x)\{\par
00507             InternBlk *iblock = {\cf17 dynamic_cast<}InternBlk*{\cf17 >}(iItems[i]);\par
00508             game->scene->removeItem(iblock);\par
00509             {\cf17 delete} iblock;\par
00510             \}\par
00511         \}\par
00512     \}\par
00513 \}\par
00518 {\cf18 void} Ball::deleteBall({\cf18 string} index)\par
00519 \{\par
00520     {\cf18 size_t} x = stoi(index);\par
00521     QList<QGraphicsItem*> bItems = collidingItems();\par
00522     {\cf19 for} ({\cf18 size_t} i = 0, n = bItems.size(); i < n; ++i)\{\par
00523         {\cf19 if} (i == x)\{\par
00524         Ball* ball = {\cf17 dynamic_cast<}Ball*{\cf17 >}(bItems[i]);\par
00525         game->scene->removeItem(ball);\par
00526         {\cf17 delete} ball;\par
00527         \}\par
00528     \}\par
00529 \}\par
00534 {\cf18 void} Ball::addDepthLevel(QString lvl)\par
00535 \{\par
00536     depthLvl ++;\par
00537     game->updatedepth(lvl);\par
00538 \}\par
00542 {\cf18 void} Ball::blkCreated({\cf18 string} blkType)\par
00543 \{\par
00544     json message;\par
00545     message[{\cf22 "type"}] = {\cf22 "blkCreated"};\par
00546     message[{\cf22 "block"}] = blkType;\par
00547 \par
00548     {\cf18 string} msg = message.dump();\par
00549     client->setMessage(msg.c_str());\par
00550 \}\par
00555 {\cf18 void} Ball::notify(QString nick)\par
00556 \{\par
00557     {\cf18 string} textNick = nick.toUtf8().constData(); {\cf20 // convert nick to string}\par
00558     json message;\par
00559     message[{\cf22 "type"}] = {\cf22 "nickname"};\par
00560     message[{\cf22 "nickname"}] = textNick;\par
00561 \par
00562     {\cf18 string} msg = message.dump();\par
00563     client->setMessage(msg.c_str());\par
00564 \}\par
00565 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Ball.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Ball.h}
{\xe \v Client/Ball.h}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGraphicsRectItem>}\par
{\f2 #include <iostream>}\par
{\f2 #include <sstream>}\par
{\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Ball}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Ball} class creates objects of type {\b Ball}. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Ball.h\par \pard\plain 
{\tc\tcl2 \v Client/Ball.h}
{\xe \v Client/Ball.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef BALL_H}\par
00002 {\cf21 #define BALL_H}\par
00003 \par
00004 {\cf21 #include <QGraphicsRectItem>}\par
00005 {\cf21 #include <iostream>}\par
00006 {\cf21 #include <sstream>}\par
00007 {\cf21 #include <string>}\par
00008 {\cf17 using namespace }std;\par
00012 {\cf17 class }Ball: {\cf17 public} QObject, {\cf17 public} QGraphicsRectItem\{\par
00013     Q_OBJECT\par
00014 {\cf17 public}:\par
00015     {\cf20 // constructor}\par
00016     Ball(QGraphicsItem* parent=NULL);\par
00017 \par
00018     {\cf20 // public methods}\par
00019     {\cf18 double} getCenterX();\par
00020     {\cf18 void} connecting();\par
00021     {\cf18 void} addBall();\par
00022     {\cf18 void} deleteBlk({\cf18 string} type, {\cf18 string} index);\par
00023     {\cf18 void} deleteBall({\cf18 string} index);\par
00024     {\cf18 void} addDepthLevel(QString lvl);\par
00025     {\cf18 void} blkCreated({\cf18 string} blkType);\par
00026     {\cf18 void} notify(QString str);\par
00027 \par
00028 {\cf17 public} slots:\par
00029     {\cf20 // public slots}\par
00030     {\cf18 void} moveBall();\par
00031 \par
00032 {\cf17 private}:\par
00033     {\cf20 // private attributes}\par
00034     {\cf18 double} velX;\par
00035     {\cf18 double} velY;\par
00036     {\cf18 int} depthLvl = 0;\par
00037     {\cf18 int} Counter = 0;\par
00038     {\cf18 int} randomNum = 0;\par
00039     {\cf18 int} ballCounter = 1;\par
00040 \par
00041     {\cf20 // private methods}\par
00042     {\cf18 void} reverseVelocity();\par
00043     {\cf18 void} checkPadCollision();\par
00044     {\cf18 void} checkBallLeft();\par
00045     {\cf18 void} checkBlckCollision();\par
00046 \par
00047 \};\par
00048 \par
00049 {\cf21 #endif }{\cf20 // BALL_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/client.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/client.cpp}
{\xe \v Client/client.cpp}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "client.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
client.cpp\par \pard\plain 
{\tc\tcl2 \v Client/client.cpp}
{\xe \v Client/client.cpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "client.h"}\par
00002 \par
00003 Client::Client()\par
00004 \{\par
00005 \par
00006 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/client.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/client.h}
{\xe \v Client/client.h}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Client}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
client.h\par \pard\plain 
{\tc\tcl2 \v Client/client.h}
{\xe \v Client/client.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef CLIENT_H}\par
00002 {\cf21 #define CLIENT_H}\par
00003 \par
00004 \par
00005 {\cf17 class }Client\par
00006 \{\par
00007 {\cf17 public}:\par
00008     Client();\par
00009 \};\par
00010 \par
00011 {\cf21 #endif }{\cf20 // CLIENT_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Commonblk.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Commonblk.cpp}
{\xe \v Client/Commonblk.cpp}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Commonblk.h"}\par
{\f2 #include <QBrush>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Commonblk.cpp\par \pard\plain 
{\tc\tcl2 \v Client/Commonblk.cpp}
{\xe \v Client/Commonblk.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Commonblk.h"}\par
00002 {\cf21 #include <QBrush>}\par
00007 CommonBlk::CommonBlk(QGraphicsItem *parent): QGraphicsRectItem(parent)\{\par
00011     setRect(posx,posy,60,10);\par
00012     QBrush brush;\par
00013     brush.setTextureImage(QImage ({\cf22 "/home/user/Escritorio/Repos GitHub/CrazyBreakout/images/common.png"}));\par
00014     setBrush(brush);\par
00015 \}\par
00021 {\cf18 void} CommonBlk::setPosition({\cf18 int} x, {\cf18 int} y)\par
00022 \{\par
00023     posx = x;\par
00024     posy = y;\par
00025 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Commonblk.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Commonblk.h}
{\xe \v Client/Commonblk.h}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGraphicsRectItem>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CommonBlk}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CommonBlk} class creates objects of type {\b CommonBlk}. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Commonblk.h\par \pard\plain 
{\tc\tcl2 \v Client/Commonblk.h}
{\xe \v Client/Commonblk.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef COMMONBLK_H}\par
00002 {\cf21 #define COMMONBLK_H}\par
00003 \par
00004 {\cf21 #include <QGraphicsRectItem>}\par
00008 {\cf17 class }CommonBlk: {\cf17 public} QGraphicsRectItem\{\par
00009 {\cf17 public}:\par
00010     {\cf20 // Attributes}\par
00011     {\cf18 int} posx = 0;\par
00012     {\cf18 int} posy = 0;\par
00013 \par
00014     {\cf20 // constructors}\par
00015     CommonBlk(QGraphicsItem* parent=NULL);\par
00016     {\cf18 void} setPosition({\cf18 int} x, {\cf18 int} y);\par
00017 \par
00018 \};\par
00019 \par
00020 \par
00021 {\cf21 #endif }{\cf20 // COMMONBLK_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Deepblk.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Deepblk.cpp}
{\xe \v Client/Deepblk.cpp}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Deepblk.h"}\par
{\f2 #include <QBrush>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Deepblk.cpp\par \pard\plain 
{\tc\tcl2 \v Client/Deepblk.cpp}
{\xe \v Client/Deepblk.cpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Deepblk.h"}\par
00002 {\cf21 #include <QBrush>}\par
00007 DeepBlk::DeepBlk(QGraphicsItem *parent): QGraphicsRectItem(parent)\{\par
00011     setRect(0,0,60,10);\par
00012     QBrush brush;\par
00013     brush.setTextureImage(QImage ({\cf22 "/home/user/Escritorio/Repos GitHub/CrazyBreakout/images/deep.png"}));\par
00014     setBrush(brush);\par
00015 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Deepblk.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Deepblk.h}
{\xe \v Client/Deepblk.h}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGraphicsRectItem>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DeepBlk}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b DeepBlk} class creates objects of type {\b DeepBlk}. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Deepblk.h\par \pard\plain 
{\tc\tcl2 \v Client/Deepblk.h}
{\xe \v Client/Deepblk.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef DEEPBLK_H}\par
00002 {\cf21 #define DEEPBLK_H}\par
00003 \par
00004 {\cf21 #include <QGraphicsRectItem>}\par
00008 {\cf17 class }DeepBlk: {\cf17 public} QGraphicsRectItem\{\par
00009 {\cf17 public}:\par
00010     {\cf20 // Attributes}\par
00011     {\cf18 int} posx = 0;\par
00012     {\cf18 int} posy = 0;\par
00013 \par
00014     {\cf20 // constructors}\par
00015     DeepBlk(QGraphicsItem* parent=NULL);\par
00016 \par
00017 \};\par
00018 \par
00019 {\cf21 #endif }{\cf20 // DEEPBLK_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Doubleblk.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Doubleblk.cpp}
{\xe \v Client/Doubleblk.cpp}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Doubleblk.h"}\par
{\f2 #include <QBrush>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Doubleblk.cpp\par \pard\plain 
{\tc\tcl2 \v Client/Doubleblk.cpp}
{\xe \v Client/Doubleblk.cpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Doubleblk.h"}\par
00002 {\cf21 #include <QBrush>}\par
00007 DoubleBlk::DoubleBlk(QGraphicsItem *parent): QGraphicsRectItem(parent)\{\par
00011     setRect(0,0,60,10);\par
00012     QBrush brush;\par
00013     brush.setTextureImage(QImage ({\cf22 "/home/user/Escritorio/Repos GitHub/CrazyBreakout/images/double.png"}));\par
00014     setBrush(brush);\par
00015 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Doubleblk.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Doubleblk.h}
{\xe \v Client/Doubleblk.h}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGraphicsRectItem>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DoubleBlk}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b DoubleBlk} class creates objects of type {\b DoubleBlk}. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Doubleblk.h\par \pard\plain 
{\tc\tcl2 \v Client/Doubleblk.h}
{\xe \v Client/Doubleblk.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef DOUBLEBLK_H}\par
00002 {\cf21 #define DOUBLEBLK_H}\par
00003 \par
00004 {\cf21 #include <QGraphicsRectItem>}\par
00008 {\cf17 class }DoubleBlk: {\cf17 public} QGraphicsRectItem\{\par
00009 {\cf17 public}:\par
00010     {\cf20 // Attributes}\par
00011     {\cf18 int} posx = 0;\par
00012     {\cf18 int} posy = 0;\par
00013 \par
00014     {\cf20 // constructors}\par
00015     DoubleBlk(QGraphicsItem* parent=NULL);\par
00016     {\cf18 void} setPosition({\cf18 int} x, {\cf18 int} y);\par
00017 \par
00018 \};\par
00019 \par
00020 {\cf21 #endif }{\cf20 // DOUBLEBLK_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Game.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Game.cpp}
{\xe \v Client/Game.cpp}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Game.h"}\par
{\f2 #include "Ball.h"}\par
{\f2 #include "Paddle.h"}\par
{\f2 #include "Commonblk.h"}\par
{\f2 #include "Doubleblk.h"}\par
{\f2 #include "Tripleblk.h"}\par
{\f2 #include "Internblk.h"}\par
{\f2 #include "Deepblk.h"}\par
{\f2 #include "surprise.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Ball} * {\b ball}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Paddle} * {\b paddle}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v ball\:Game.cpp}
{\xe \v Game.cpp\:ball}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Ball}* ball}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b Game.cpp}.}\par
}
{\xe \v paddle\:Game.cpp}
{\xe \v Game.cpp\:paddle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Paddle}* paddle}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b Game.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Game.cpp\par \pard\plain 
{\tc\tcl2 \v Client/Game.cpp}
{\xe \v Client/Game.cpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Game.h"}\par
00002 {\cf21 #include "Ball.h"}\par
00003 {\cf21 #include "Paddle.h"}\par
00004 {\cf21 #include "Commonblk.h"}\par
00005 {\cf21 #include "Doubleblk.h"}\par
00006 {\cf21 #include "Tripleblk.h"}\par
00007 {\cf21 #include "Internblk.h"}\par
00008 {\cf21 #include "Deepblk.h"}\par
00009 {\cf21 #include "surprise.h"}\par
00010 \par
00011 Ball* ball;\par
00012 Paddle* paddle;\par
00013 \par
00018 Game::Game(QWidget *parent): QGraphicsView(parent)\{\par
00019     {\cf20 // initialize scene}\par
00020     scene = {\cf17 new} QGraphicsScene(0,0,795,600);\par
00021     scene->setBackgroundBrush (QBrush (QImage ({\cf22 "/home/user/Escritorio/Repos GitHub/CrazyBreakout/images/fondo.jpg"})));\par
00022     setScene(scene);\par
00023 \par
00024     {\cf20 // Catch mouse motion to set the paddle`s position}\par
00025     setMouseTracking({\cf17 true});\par
00026 \par
00027     {\cf20 // Add label for "score"}\par
00028     score = {\cf17 new} QLabel();\par
00029     score->setText({\cf22 "SCORE:"});\par
00030     score->setStyleSheet({\cf22 "Background-color: darkblue; color: lightgreen"});\par
00031     score->setFont(QFont({\cf22 "Tlwg Typo BoldOblique"},16));\par
00032     score->setGeometry(615,10,85,25);\par
00033     scene->addWidget(score);\par
00034 \par
00035     {\cf20 // Add label for score in numbers}\par
00036     scoreNum = {\cf17 new} QLabel();\par
00037     scoreNum->setText({\cf22 "000000"});\par
00038     scoreNum->setStyleSheet({\cf22 "Background-color: darkblue; color: lightgreen"});\par
00039     scoreNum->setFont(QFont({\cf22 "Tlwg Typo BoldOblique"},16));\par
00040     scoreNum->setGeometry(700,10,80,25);\par
00041     scene->addWidget(scoreNum);\par
00042 \par
00043     {\cf20 // Add label for "player"}\par
00044     Player = {\cf17 new} QLabel();\par
00045     Player->setText({\cf22 "PLAYER:"});\par
00046     Player->setStyleSheet({\cf22 "Background-color: darkblue; color: lightgreen"});\par
00047     Player->setFont(QFont({\cf22 "Tlwg Typo BoldOblique"},16));\par
00048     Player->setGeometry(5,10,90,25);\par
00049     scene->addWidget(Player);\par
00050 \par
00051     {\cf20 // Add label for depth level}\par
00052     depth = {\cf17 new} QLabel();\par
00053     depth->setText({\cf22 "DEPTH:"});\par
00054     depth->setStyleSheet({\cf22 "Background-color: darkblue; color: lightgreen"});\par
00055     depth->setFont(QFont({\cf22 "Tlwg Typo BoldOblique"},16));\par
00056     depth->setGeometry(492,10,85,25);\par
00057     scene->addWidget(depth);\par
00058 \par
00059     {\cf20 // Add label for depth level in numbers}\par
00060     depthNum = {\cf17 new} QLabel();\par
00061     depthNum->setText({\cf22 "0"});\par
00062     depthNum->setStyleSheet({\cf22 "Background-color: darkblue; color: lightgreen"});\par
00063     depthNum->setFont(QFont({\cf22 "Tlwg Typo BoldOblique"},16));\par
00064     depthNum->setGeometry(577,10,28,25);\par
00065     scene->addWidget(depthNum);\par
00066 \par
00067     {\cf20 // create a ball}\par
00068     ball = {\cf17 new} Ball();\par
00069     ball->setPos(200,500);\par
00070     scene->addItem(ball);\par
00071 \par
00072     {\cf20 // create a paddle}\par
00073     paddle = {\cf17 new} Paddle();\par
00074     paddle->setPos(150,575);\par
00075     scene->addItem(paddle);\par
00076     paddle->grabMouse();\par
00077 \par
00078     {\cf20 // create the blocks grid}\par
00079     {\cf19 for} ({\cf18 int} i=0; i < totalFil; i++) \{\par
00080         py = 50 + advY;\par
00081         totalCol = 12;\par
00082         {\cf19 for} ({\cf18 int} j=0; j<totalCol; j++) \{\par
00083             random = randomNumber();\par
00084             {\cf19 if}(random <= 1)\{\par
00085                 {\cf19 if}(totalCommon != 0)\{\par
00086                     CommonBlk *cblks = {\cf17 new} CommonBlk();\par
00087                     cblks->setPos(10+advX,py);\par
00088                     scene->addItem(cblks);\par
00089                     totalCommon--;\par
00090                     advX += 65;\par
00091                     {\cf20 // notify the server}\par
00092                     ball->blkCreated({\cf22 "common"});\par
00093                 \}\par
00094             \}{\cf19 else} {\cf19 if}(random == 2)\{\par
00095                 {\cf19 if}(totaldouble != 0)\{\par
00096                     DoubleBlk *dblks = {\cf17 new} DoubleBlk();\par
00097                     dblks->setPos(10+advX,py);\par
00098                     scene->addItem(dblks);\par
00099                     totaldouble--;\par
00100                     advX += 65;\par
00101                     {\cf20 // notify the server}\par
00102                     ball->blkCreated({\cf22 "double"});\par
00103                 \}\par
00104             \}{\cf19 else} {\cf19 if}(random == 3)\{\par
00105                 {\cf19 if}(totalTriple != 0)\{\par
00106                     TripleBlk *tblks = {\cf17 new} TripleBlk();\par
00107                     tblks->setPos(10+advX,py);\par
00108                     scene->addItem(tblks);\par
00109                     totalTriple--;\par
00110                     advX += 65;\par
00111                     {\cf20 // notify the server}\par
00112                     ball->blkCreated({\cf22 "triple"});\par
00113                 \}\par
00114             \}{\cf19 else} {\cf19 if}(random == 4)\{\par
00115                 {\cf19 if}(totalIntern != 0)\{\par
00116                     InternBlk *iblks = {\cf17 new} InternBlk();\par
00117                     iblks->setPos(10+advX,py);\par
00118                     scene->addItem(iblks);\par
00119                     totalIntern--;\par
00120                     advX += 65;\par
00121                     {\cf20 // notify the server}\par
00122                     ball->blkCreated({\cf22 "intern"});\par
00123                 \}\par
00124             \}{\cf19 else} {\cf19 if}(random == 5)\{\par
00125                 {\cf19 if}(totalDeep > 0)\{\par
00126                     DeepBlk *deepblks = {\cf17 new} DeepBlk();\par
00127                     deepblks->setPos(10+advX,py);\par
00128                     scene->addItem(deepblks);\par
00129                     totalDeep -= 1;\par
00130                     advX += 65;\par
00131                     {\cf20 // notify the server}\par
00132                     ball->blkCreated({\cf22 "deep"});\par
00133                 \}\par
00134             \}\par
00135         \}\par
00136         advX = 0;\par
00137         advY += 20;\par
00138     \}\par
00139 \}\par
00144 {\cf18 int} Game::randomNumber()\par
00145 \{\par
00146    {\cf17 static} {\cf18 bool} first = {\cf17 true};\par
00147    {\cf19 if} (first)\par
00148    \{\par
00149       srand( time(NULL) );\par
00150       first = {\cf17 false};\par
00151    \}\par
00152    {\cf19 return} 1 + rand() % (( 5 + 1 ) - 1);\par
00153 \}\par
00158 {\cf18 void} Game::setNickName(QString n)\par
00159 \{\par
00160     {\cf20 // Add label for nickname}\par
00161     nick = n;\par
00162     nickName = {\cf17 new} QLabel();\par
00163     nickName->setText(nick); {\cf20 // default name}\par
00164     nickName->setStyleSheet({\cf22 "Background-color: darkblue; color: lightgreen"});\par
00165     nickName->setFont(QFont({\cf22 "Tlwg Typo BoldOblique"},16));\par
00166     nickName->setGeometry(105,10,200,25);\par
00167     scene->addWidget(nickName);\par
00168 \par
00169     {\cf20 // send the nickname to the server by ball.cpp}\par
00170     ball->notify(nick);\par
00171 \}\par
00176 {\cf18 void} Game::setScore(QString scr)\par
00177 \{\par
00178     scoreNum->setText(scr); {\cf20 // the qstring is what the server says}\par
00179     scoreNum->setStyleSheet({\cf22 "Background-color: darkblue; color: lightgreen"});\par
00180     scoreNum->setFont(QFont({\cf22 "Tlwg Typo BoldOblique"},16));\par
00181 \}\par
00185 {\cf18 void} Game::addNewBall()\par
00186 \{\par
00187     {\cf20 // create a ball}\par
00188     Ball* ball = {\cf17 new} Ball();\par
00189     ball->setPos(200,500);\par
00190     scene->addItem(ball);\par
00191 \}\par
00195 {\cf18 void} Game::reducePadd()\par
00196 \{\par
00197     paddle->reduceSize();\par
00198 \}\par
00202 {\cf18 void} Game::increasePadd()\par
00203 \{\par
00204     paddle->increaseSize();\par
00205 \}\par
00210 {\cf18 void} Game::updatedepth(QString level)\par
00211 \{\par
00212     depthNum->setText(level); {\cf20 // the qstring is what the server says}\par
00213     depthNum->setStyleSheet({\cf22 "Background-color: darkblue; color: lightgreen"});\par
00214     depthNum->setFont(QFont({\cf22 "Tlwg Typo BoldOblique"},16));\par
00215 \}\par
00219 {\cf18 void} Game::addSurprise()\par
00220 \{\par
00221     surprise* Surprise = {\cf17 new} surprise();\par
00222     Surprise->setPos(397,450);\par
00223     scene->addItem(Surprise);\par
00224 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Game.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Game.h}
{\xe \v Client/Game.h}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGraphicsView>}\par
{\f2 #include <QGraphicsScene>}\par
{\f2 #include <QLabel>}\par
{\f2 #include <QWidget>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Game}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Game} class runs the game interface and manages all the game process. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Game.h\par \pard\plain 
{\tc\tcl2 \v Client/Game.h}
{\xe \v Client/Game.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef GAME_H}\par
00002 {\cf21 #define GAME_H}\par
00003 \par
00004 {\cf21 #include <QGraphicsView>}\par
00005 {\cf21 #include <QGraphicsScene>}\par
00006 {\cf21 #include <QLabel>}\par
00007 {\cf21 #include <QWidget>}\par
00011 {\cf17 class }Game: {\cf17 public} QGraphicsView\{\par
00012 {\cf17 private}:\par
00013     {\cf20 // Private Attributes}\par
00014     {\cf18 int} totalCol;\par
00015     {\cf18 int} totalFil = 10;\par
00016     {\cf18 int} totalCommon = 60;\par
00017     {\cf18 int} totaldouble = 60;\par
00018     {\cf18 int} totalTriple = 60;\par
00019     {\cf18 int} totalIntern = 60;\par
00020     {\cf18 int} totalDeep = 20;\par
00021     {\cf18 int} totalScr = 0;\par
00022     QString nick;\par
00023 \par
00024     {\cf18 int} py;\par
00025     {\cf18 int} advY = 0;\par
00026     {\cf18 int} advX = 0;\par
00027     {\cf18 int} random;\par
00028 \par
00029 {\cf17 public}:\par
00030     {\cf20 // Public Attributes}\par
00031     QGraphicsScene* scene;\par
00032     QLabel *score;\par
00033     QLabel *scoreNum;\par
00034     QLabel *Player;\par
00035     QLabel *nickName;\par
00036     QLabel *depth;\par
00037     QLabel *depthNum;\par
00038 \par
00039     {\cf20 // Constructor}\par
00040     Game(QWidget* parent=NULL);\par
00041 \par
00042     {\cf20 // Methods}\par
00043     {\cf18 int} randomNumber();\par
00044     {\cf18 void} setNickName(QString n);\par
00045     {\cf18 void} setScore(QString scr);\par
00046     {\cf18 void} addNewBall();\par
00047     {\cf18 void} reducePadd();\par
00048     {\cf18 void} increasePadd();\par
00049     {\cf18 void} updatedepth(QString level);\par
00050     {\cf18 void} addSurprise();\par
00051 \};\par
00052 \par
00053 {\cf21 #endif }{\cf20 // GAME_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/gameover.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/gameover.cpp}
{\xe \v Client/gameover.cpp}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "gameover.h"}\par
{\f2 #include "Game.h"}\par
{\f2 #include "ui_gameover.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Game} * {\b game1}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v game1\:gameover.cpp}
{\xe \v gameover.cpp\:game1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Game}* game1}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b gameover.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gameover.cpp\par \pard\plain 
{\tc\tcl2 \v Client/gameover.cpp}
{\xe \v Client/gameover.cpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "gameover.h"}\par
00002 {\cf21 #include "Game.h"}\par
00003 {\cf21 #include "ui_gameover.h"}\par
00004 \par
00005 Game* game1;\par
00006 \par
00007 gameover::gameover(QWidget *parent) :\par
00008     QWidget(parent),\par
00009     ui(new Ui::gameover)\par
00010 \{\par
00011     ui->setupUi({\cf17 this});\par
00012 \}\par
00013 \par
00014 gameover::~gameover()\par
00015 \{\par
00016     {\cf17 delete} ui;\par
00017 \}\par
00018 \par
00019 {\cf18 void} gameover::on_pushButton_clicked()\par
00020 \{\par
00021     {\cf20 // Close the app}\par
00022     game1 = {\cf17 new} Game();\par
00023     game1->close();\par
00024     this->close();\par
00025 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/gameover.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/gameover.h}
{\xe \v Client/gameover.h}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QWidget>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b gameover}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Ui}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gameover.h\par \pard\plain 
{\tc\tcl2 \v Client/gameover.h}
{\xe \v Client/gameover.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef GAMEOVER_H}\par
00002 {\cf21 #define GAMEOVER_H}\par
00003 \par
00004 {\cf21 #include <QWidget>}\par
00005 \par
00006 {\cf17 namespace }Ui \{\par
00007 {\cf17 class }gameover;\par
00008 \}\par
00009 \par
00010 {\cf17 class }gameover : {\cf17 public} QWidget\par
00011 \{\par
00012     Q_OBJECT\par
00013 \par
00014 {\cf17 public}:\par
00015     {\cf17 explicit} gameover(QWidget *parent = {\cf17 nullptr});\par
00016     ~gameover();\par
00017 \par
00018 {\cf17 private} slots:\par
00019     {\cf18 void} on_pushButton_clicked();\par
00020 \par
00021 {\cf17 private}:\par
00022     Ui::gameover *ui;\par
00023 \};\par
00024 \par
00025 {\cf21 #endif }{\cf20 // GAMEOVER_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/gamewindow.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/gamewindow.h}
{\xe \v Client/gamewindow.h}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QWidget>}\par
{\f2 #include <QKeyEvent>}\par
{\f2 #include <QLabel>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b gamewindow}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Ui}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gamewindow.h\par \pard\plain 
{\tc\tcl2 \v Client/gamewindow.h}
{\xe \v Client/gamewindow.h}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef GAMEWINDOW_H}\par
00002 {\cf21 #define GAMEWINDOW_H}\par
00003 \par
00004 {\cf21 #include <QWidget>}\par
00005 {\cf21 #include <QKeyEvent>}\par
00006 {\cf21 #include <QLabel>}\par
00007 \par
00008 {\cf17 namespace }Ui \{\par
00009 {\cf17 class }gamewindow;\par
00010 \}\par
00011 \par
00012 {\cf17 class }gamewindow : {\cf17 public} QWidget\par
00013 \{\par
00014     Q_OBJECT\par
00015 \par
00016 {\cf17 public}:\par
00017     {\cf17 explicit} gamewindow(QWidget *parent = {\cf17 nullptr});\par
00018     ~gamewindow();\par
00019     {\cf18 void} keyPressEvent(QKeyEvent *evt);\par
00020     {\cf18 int} randomNumber();\par
00021 \par
00022 signals:\par
00023 \par
00024 {\cf17 public} slots:\par
00025 \par
00026 {\cf17 private}:\par
00027     Ui::gamewindow *ui;\par
00028 \par
00029     {\cf18 int} py;\par
00030     {\cf18 int} advY = 0;\par
00031     {\cf18 int} advX = 0;\par
00032 \par
00033     {\cf18 int} totalCol;\par
00034     {\cf18 int} totalFil = 15;\par
00035     {\cf18 int} totalCommon = 50;\par
00036     {\cf18 int} totaldouble = 50;\par
00037     {\cf18 int} totalTriple = 50;\par
00038     {\cf18 int} totalIntern = 50;\par
00039     {\cf18 int} totalDeep = 50;\par
00040 \par
00041     {\cf18 int} random; {\cf20 // between 1-5}\par
00042 \};\par
00043 \par
00044 {\cf21 #endif }{\cf20 // GAMEWINDOW_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Internblk.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Internblk.cpp}
{\xe \v Client/Internblk.cpp}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Internblk.h"}\par
{\f2 #include <QBrush>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Internblk.cpp\par \pard\plain 
{\tc\tcl2 \v Client/Internblk.cpp}
{\xe \v Client/Internblk.cpp}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Internblk.h"}\par
00002 {\cf21 #include <QBrush>}\par
00007 InternBlk::InternBlk(QGraphicsItem *parent): QGraphicsRectItem(parent)\{\par
00011     setRect(0,0,60,10);\par
00012     QBrush brush;\par
00013     brush.setTextureImage(QImage ({\cf22 "/home/user/Escritorio/Repos GitHub/CrazyBreakout/images/internos.png"}));\par
00014     setBrush(brush);\par
00015 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Internblk.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Internblk.h}
{\xe \v Client/Internblk.h}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGraphicsRectItem>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InternBlk}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b InternBlk} class creates objects of type {\b InternBlk}. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Internblk.h\par \pard\plain 
{\tc\tcl2 \v Client/Internblk.h}
{\xe \v Client/Internblk.h}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef INTERNBLK_H}\par
00002 {\cf21 #define INTERNBLK_H}\par
00003 \par
00004 {\cf21 #include <QGraphicsRectItem>}\par
00008 {\cf17 class }InternBlk: {\cf17 public} QGraphicsRectItem\{\par
00009 {\cf17 public}:\par
00010     {\cf20 // Attributes}\par
00011     {\cf18 int} posx = 0;\par
00012     {\cf18 int} posy = 0;\par
00013 \par
00014     {\cf20 // constructors}\par
00015     InternBlk(QGraphicsItem* parent=NULL);\par
00016     {\cf18 void} setPosition({\cf18 int} x, {\cf18 int} y);\par
00017 \par
00018 \};\par
00019 {\cf21 #endif }{\cf20 // INTERNBLK_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/json.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/json.hpp}
{\xe \v Client/json.hpp}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <algorithm>}\par
{\f2 #include <cstddef>}\par
{\f2 #include <functional>}\par
{\f2 #include <initializer_list>}\par
{\f2 #include <iosfwd>}\par
{\f2 #include <iterator>}\par
{\f2 #include <memory>}\par
{\f2 #include <numeric>}\par
{\f2 #include <string>}\par
{\f2 #include <utility>}\par
{\f2 #include <vector>}\par
{\f2 #include <type_traits>}\par
{\f2 #include <array>}\par
{\f2 #include <forward_list>}\par
{\f2 #include <map>}\par
{\f2 #include <tuple>}\par
{\f2 #include <unordered_map>}\par
{\f2 #include <valarray>}\par
{\f2 #include <exception>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include <cstdint>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <cassert>}\par
{\f2 #include <limits>}\par
{\f2 #include <cmath>}\par
{\f2 #include <cstdio>}\par
{\f2 #include <cstring>}\par
{\f2 #include <istream>}\par
{\f2 #include <clocale>}\par
{\f2 #include <cctype>}\par
{\f2 #include <ios>}\par
{\f2 #include <ostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::position_t}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
struct to capture the start position of the current token }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::exception}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
general exception of the {\b basic_json} class }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::parse_error}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating a parse error }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::invalid_iterator}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating errors with iterators }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::type_error}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating executing a member function with a wrong type }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::out_of_range}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating access out of the defined range }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::other_error}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exception indicating other library errors }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::integer_sequence< T, Ints >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::utility_internal::Extend< integer_sequence< T, Ints... >, SeqSize, 1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::utility_internal::Gen< T, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::utility_internal::Gen< T, 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::priority_tag< N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::priority_tag< 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::static_const< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::identity_tag< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::make_void< Ts >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::iterator_types< It, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::iterator_types< It, void_t< typename It::difference_type, typename It::value_type, typename It::pointer, typename It::reference, typename It::iterator_category > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::iterator_traits< T, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::iterator_traits< T, enable_if_t< !std::is_pointer< T >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::iterator_traits< T *, enable_if_t< std::is_object< T >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::nonesuch}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::detector< Default, AlwaysVoid, Op, Args >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::detector< Default, void_t< Op< Args... > >, Op, Args... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_detected_lazy< Op, Args >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_basic_json< typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_basic_json< NLOHMANN_BASIC_JSON_TPL >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_json_ref< typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_json_ref< json_ref< T > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::has_from_json< BasicJsonType, T, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_getable< BasicJsonType, T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::has_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::has_non_default_from_json< BasicJsonType, T, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::has_non_default_from_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::has_to_json< BasicJsonType, T, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::has_to_json< BasicJsonType, T, enable_if_t< !is_basic_json< T >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::conjunction<... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::conjunction< B1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::conjunction< B1, Bn... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::negation< B >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_default_constructible< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_default_constructible< std::pair< T1, T2 > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_default_constructible< const std::pair< T1, T2 > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_default_constructible< std::tuple< Ts... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_default_constructible< const std::tuple< Ts... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible< T, Args >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible< std::pair< T1, T2 > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible< const std::pair< T1, T2 > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible< std::tuple< Ts... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible< const std::tuple< Ts... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_iterator_traits< T, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_iterator_traits< iterator_traits< T > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_complete_type< T, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_complete_type< T, decltype(void(sizeof(T)))>}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_object_type_impl< BasicJsonType, CompatibleObjectType, enable_if_t< is_detected< mapped_type_t, CompatibleObjectType >::value &&is_detected< key_type_t, CompatibleObjectType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_object_type< BasicJsonType, CompatibleObjectType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_object_type_impl< BasicJsonType, ConstructibleObjectType, enable_if_t< is_detected< mapped_type_t, ConstructibleObjectType >::value &&is_detected< key_type_t, ConstructibleObjectType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_object_type< BasicJsonType, ConstructibleObjectType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_string_type_impl< BasicJsonType, CompatibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, CompatibleStringType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_string_type< BasicJsonType, ConstructibleStringType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_string_type_impl< BasicJsonType, ConstructibleStringType, enable_if_t< is_detected_exact< typename BasicJsonType::string_t::value_type, value_type_t, ConstructibleStringType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_string_type< BasicJsonType, ConstructibleStringType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_array_type_impl< BasicJsonType, CompatibleArrayType, enable_if_t< is_detected< value_type_t, CompatibleArrayType >::value &&is_detected< iterator_t, CompatibleArrayType >::value &&!is_iterator_traits< iterator_traits< CompatibleArrayType > >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_array_type< BasicJsonType, CompatibleArrayType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_array_type_impl< BasicJsonType, ConstructibleArrayType, enable_if_t< !std::is_same< ConstructibleArrayType, typename BasicJsonType::value_type >::value &&is_default_constructible< ConstructibleArrayType >::value &&(std::is_move_assignable< ConstructibleArrayType >::value||std::is_copy_assignable< ConstructibleArrayType >::value)&&is_detected< value_type_t, ConstructibleArrayType >::value &&is_detected< iterator_t, ConstructibleArrayType >::value &&is_complete_type< detected_t< value_type_t, ConstructibleArrayType > >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_array_type< BasicJsonType, ConstructibleArrayType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_integer_type_impl< RealIntegerType, CompatibleNumberIntegerType, enable_if_t< std::is_integral< RealIntegerType >::value &&std::is_integral< CompatibleNumberIntegerType >::value &&!std::is_same< bool, CompatibleNumberIntegerType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_integer_type< RealIntegerType, CompatibleNumberIntegerType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, typename >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_type_impl< BasicJsonType, CompatibleType, enable_if_t< is_complete_type< CompatibleType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_compatible_type< BasicJsonType, CompatibleType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_tuple< T1, T2 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_constructible_tuple< T1, std::tuple< Args... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_ordered_map< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_ordered_map< T >::two}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::from_json_fn}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::iteration_proxy_value< IteratorType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::iteration_proxy< IteratorType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
proxy class for the items() function }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tuple_size<::nlohmann::detail::iteration_proxy_value< IteratorType > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b std::tuple_element< N, ::nlohmann::detail::iteration_proxy_value< IteratorType > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::external_constructor< value_t::boolean >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::external_constructor< value_t::string >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::external_constructor< value_t::binary >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::external_constructor< value_t::number_float >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::external_constructor< value_t::number_unsigned >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::external_constructor< value_t::number_integer >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::external_constructor< value_t::array >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::external_constructor< value_t::object >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::to_json_fn}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::adl_serializer< ValueType, typename >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
default JSONSerializer template argument }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::byte_container_with_subtype< BinaryType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an internal type for a backed binary type }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::file_input_adapter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::input_stream_adapter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::iterator_input_adapter< IteratorType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 4 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::wide_string_input_helper< BaseInputAdapter, 2 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::wide_string_input_adapter< BaseInputAdapter, WideCharType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::iterator_input_adapter_factory< IteratorType, Enable >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_iterator_of_multibyte< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::iterator_input_adapter_factory< IteratorType, enable_if_t< is_iterator_of_multibyte< IteratorType >::value > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, Enable >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType, void_t< decltype(begin(std::declval< ContainerType >()), end(std::declval< ContainerType >()))> >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::span_input_adapter}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::json_sax< BasicJsonType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX interface. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::json_sax_dom_parser< BasicJsonType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SAX implementation to create a JSON value from SAX events. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::json_sax_dom_callback_parser< BasicJsonType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::json_sax_acceptor< BasicJsonType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::lexer_base< BasicJsonType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::lexer< BasicJsonType, InputAdapterType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
lexical analysis }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_sax< SAX, BasicJsonType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::is_sax_static_asserts< SAX, BasicJsonType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::binary_reader< BasicJsonType, InputAdapterType, SAX >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
deserialization of CBOR, MessagePack, and UBJSON values }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::parser< BasicJsonType, InputAdapterType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
syntax analysis }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::primitive_iterator_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::internal_iterator< BasicJsonType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
an iterator value }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::iter_impl< BasicJsonType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a template for a bidirectional iterator for the {\b basic_json} class This class implements a both iterators (iterator and const_iterator) for the {\b basic_json} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::json_reverse_iterator< Base >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a template for a reverse iterator class }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::json_pointer< BasicJsonType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
JSON Pointer. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::json_ref< BasicJsonType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::output_adapter_protocol< CharType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
abstract output adapter interface }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::output_vector_adapter< CharType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for byte vectors }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::output_stream_adapter< CharType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for output streams }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::output_string_adapter< CharType, StringType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
output adapter for basic_string }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::output_adapter< CharType, StringType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::binary_writer< BasicJsonType, CharType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
serialization to CBOR and MessagePack values }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::dtoa_impl::diyfp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::dtoa_impl::boundaries}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::detail::dtoa_impl::cached_power}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::detail::serializer< BasicJsonType >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nlohmann::ordered_map< Key, T, IgnoredLess, Allocator >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nlohmann::basic_json< ObjectType, ArrayType, StringType, BooleanType, NumberIntegerType, NumberUnsignedType, NumberFloatType, AllocatorType, JSONSerializer, BinaryType >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a class to store JSON values }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::hash< nlohmann::json >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
hash value for JSON objects }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b std::less<::nlohmann::detail::value_t >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b nlohmann}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
namespace for Niels Lohmann }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b nlohmann::detail}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
detail namespace with internal helper functions }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b nlohmann::detail::utility_internal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b std}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b nlohmann::detail::container_input_adapter_factory_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b nlohmann::detail::dtoa_impl}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
implements the Grisu2 algorithm for binary to decimal floating-point conversion. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_VERSION_MAJOR}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_VERSION_MINOR}\~ 10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_VERSION_PATCH}\~ 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_VERSION}\~ 15\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_STRINGIFY_EX}(x)\~ #x\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_STRINGIFY}(x)\~ {\b JSON_HEDLEY_STRINGIFY_EX}(x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CONCAT_EX}(a,  b)\~ a##b\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CONCAT}(a,  b)\~ {\b JSON_HEDLEY_CONCAT_EX}(a,b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CONCAT3_EX}(a,  b,  c)\~ a##b##c\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CONCAT3}(a,  b,  c)\~ {\b JSON_HEDLEY_CONCAT3_EX}(a,b,c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_VERSION_ENCODE}(major,  minor,  revision)\~ (((major) * 1000000) + ((minor) * 1000) + (revision))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_VERSION_DECODE_MAJOR}(version)\~ ((version) / 1000000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_VERSION_DECODE_MINOR}(version)\~ (((version) % 1000000) / 1000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_VERSION_DECODE_REVISION}(version)\~ ((version) % 1000)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_MSVC_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_INTEL_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_INTEL_CL_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_PGI_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_SUNPRO_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_ARM_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_IBM_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_TI_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_TI_CL2000_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_TI_CL430_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_TI_ARMCL_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_TI_CL6X_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_TI_CL7X_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_TI_CLPRU_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CRAY_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_IAR_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_TINYC_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_DMC_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_COMPCERT_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_PELLES_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_MCST_LCC_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,  minor,  patch)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_HAS_ATTRIBUTE}(attribute)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GNUC_HAS_ATTRIBUTE}(attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GCC_HAS_ATTRIBUTE}(attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_HAS_CPP_ATTRIBUTE}(attribute)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS}(ns,  attribute)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE}(attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE}(attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_HAS_BUILTIN}(builtin)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GNUC_HAS_BUILTIN}(builtin,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GCC_HAS_BUILTIN}(builtin,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_HAS_FEATURE}(feature)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GNUC_HAS_FEATURE}(feature,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GCC_HAS_FEATURE}(feature,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_HAS_EXTENSION}(extension)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GNUC_HAS_EXTENSION}(extension,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GCC_HAS_EXTENSION}(extension,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE}(attribute)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE}(attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE}(attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_HAS_WARNING}(warning)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GNUC_HAS_WARNING}(warning,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GCC_HAS_WARNING}(warning,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_PRAGMA}(value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_DIAGNOSTIC_PUSH}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_DIAGNOSTIC_POP}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_}(x)\~ x\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CONST_CAST}(T,  expr)\~ ((T) (expr))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_REINTERPRET_CAST}(T,  expr)\~ ((T) (expr))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_STATIC_CAST}(T,  expr)\~ ((T) (expr))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CPP_CAST}(T,  expr)\~ (expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_DEPRECATED}(since)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_DEPRECATED_FOR}(since,  replacement)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_UNAVAILABLE}(available_since)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_WARN_UNUSED_RESULT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_WARN_UNUSED_RESULT_MSG}(msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_SENTINEL}(position)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_NO_RETURN}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_NO_ESCAPE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_ASSUME}(expr)\~ {\b JSON_HEDLEY_STATIC_CAST}(void, expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_UNREACHABLE_RETURN}(value)\~ return (value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_UNREACHABLE}()\~ {\b JSON_HEDLEY_ASSUME}(0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_NON_NULL}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_PRINTF_FORMAT}(string_idx,  first_to_check)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CONSTEXPR}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_PREDICT}(expr,  expected,  probability)\~ ({\b JSON_HEDLEY_STATIC_CAST}(void, expected), (expr))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_PREDICT_TRUE}(expr,  probability)\~ (!!(expr))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_PREDICT_FALSE}(expr,  probability)\~ (!!(expr))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_LIKELY}(expr)\~ (!!(expr))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_UNLIKELY}(expr)\~ (!!(expr))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_UNPREDICTABLE}(expr)\~ {\b JSON_HEDLEY_PREDICT}(expr, 1, 0.5)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_MALLOC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_PURE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CONST}\~ {\b JSON_HEDLEY_PURE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_RESTRICT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_INLINE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_ALWAYS_INLINE}\~ {\b JSON_HEDLEY_INLINE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_NEVER_INLINE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_PRIVATE}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_PUBLIC}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_IMPORT}\~ extern\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_NO_THROW}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_FALL_THROUGH}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_RETURNS_NON_NULL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_ARRAY_PARAM}(name)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_IS_CONSTANT}(expr)\~ (0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_REQUIRE_CONSTEXPR}(expr)\~ (expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_BEGIN_C_DECLS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_END_C_DECLS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_C_DECL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_STATIC_ASSERT}(expr,  message)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_NULL}\~ ((void*) 0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_MESSAGE}(msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_WARNING}(msg)\~ {\b JSON_HEDLEY_MESSAGE}(msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_REQUIRE}(expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_REQUIRE_MSG}(expr,  msg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_FLAGS}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_FLAGS_CAST}(T,  expr)\~ {\b JSON_HEDLEY_STATIC_CAST}(T, expr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_EMPTY_BASES}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK}(major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CLANG_HAS_ATTRIBUTE}(attribute)\~ {\b JSON_HEDLEY_HAS_ATTRIBUTE}(attribute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE}(attribute)\~ {\b JSON_HEDLEY_HAS_CPP_ATTRIBUTE}(attribute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CLANG_HAS_BUILTIN}(builtin)\~ {\b JSON_HEDLEY_HAS_BUILTIN}(builtin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CLANG_HAS_FEATURE}(feature)\~ {\b JSON_HEDLEY_HAS_FEATURE}(feature)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CLANG_HAS_EXTENSION}(extension)\~ {\b JSON_HEDLEY_HAS_EXTENSION}(extension)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE}(attribute)\~ {\b JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE}(attribute)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HEDLEY_CLANG_HAS_WARNING}(warning)\~ {\b JSON_HEDLEY_HAS_WARNING}(warning)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_HAS_CPP_11}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_THROW}(exception)\~ std::abort()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_TRY}\~ if(true)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_CATCH}(exception)\~ if(false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_INTERNAL_CATCH}(exception)\~ if(false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_ASSERT}(x)\~ assert(x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_PRIVATE_UNLESS_TESTED}\~ private\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_SERIALIZE_ENUM}(ENUM_TYPE, ...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
macro to briefly define a mapping between an enum and JSON }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_BASIC_JSON_TPL_DECLARATION}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_BASIC_JSON_TPL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_EXPAND}(x)\~ x\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_GET_MACRO}(_1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  _10,  _11,  _12,  _13,  _14,  _15,  _16,  _17,  _18,  _19,  _20,  _21,  _22,  _23,  _24,  _25,  _26,  _27,  _28,  _29,  _30,  _31,  _32,  _33,  _34,  _35,  _36,  _37,  _38,  _39,  _40,  _41,  _42,  _43,  _44,  _45,  _46,  _47,  _48,  _49,  _50,  _51,  _52,  _53,  _54,  _55,  _56,  _57,  _58,  _59,  _60,  _61,  _62,  _63,  _64,  NAME, ...)\~ NAME\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE}(...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE2}(func,  v1)\~ func(v1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE3}(func,  v1,  v2)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE2}(func, v2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE4}(func,  v1,  v2,  v3)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE3}(func, v2, v3)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE5}(func,  v1,  v2,  v3,  v4)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE4}(func, v2, v3, v4)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE6}(func,  v1,  v2,  v3,  v4,  v5)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE5}(func, v2, v3, v4, v5)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE7}(func,  v1,  v2,  v3,  v4,  v5,  v6)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE6}(func, v2, v3, v4, v5, v6)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE8}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE7}(func, v2, v3, v4, v5, v6, v7)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE9}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE8}(func, v2, v3, v4, v5, v6, v7, v8)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE10}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE9}(func, v2, v3, v4, v5, v6, v7, v8, v9)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE11}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE10}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE12}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE11}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE13}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE12}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE14}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE13}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE15}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE14}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE16}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE15}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE17}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE16}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE18}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE17}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE19}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE18}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE20}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE19}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE21}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE20}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE22}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE21}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE23}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE22}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE24}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE23}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE25}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE24}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE26}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE25}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE27}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE26}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE28}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE27}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE29}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE28}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE30}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE29}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE31}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE30}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE32}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE31}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE33}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE32}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE34}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE33}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE35}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE34}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE36}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE35}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE37}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE36}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE38}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE37}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE39}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE38}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE40}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE39}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE41}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE40}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE42}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE41}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE43}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE42}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE44}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE43}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE45}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE44}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE46}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE45}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE47}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE46}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE48}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE47}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE49}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE48}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE50}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE49}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE51}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE50}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE52}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE51}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE53}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE52}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE54}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE53}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE55}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE54}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE56}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE55}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE57}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE56}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE58}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE57}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE59}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE58}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE60}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v59)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE59}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE61}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v60)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE60}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE62}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v60,  v61)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE61}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE63}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v60,  v61,  v62)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE62}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_PASTE64}(func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v60,  v61,  v62,  v63)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE63}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_TO}(v1)\~ nlohmann_json_j[#v1] = nlohmann_json_t.v1;\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_JSON_FROM}(v1)\~ nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_DEFINE_TYPE_INTRUSIVE}(Type, ...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
macro }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE}(Type, ...)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
macro }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_USE_IMPLICIT_CONVERSIONS}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_EXPLICIT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b JSON_DIAGNOSTICS}\~ 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b INCLUDE_NLOHMANN_JSON_FWD_HPP_}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::uncvref_t} = typename std::remove_cv< typename std::remove_reference< T >::type >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<bool B, typename T  = void> using {\b nlohmann::detail::enable_if_t} = typename std::enable_if< B, T >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<size_t... Ints> using {\b nlohmann::detail::index_sequence} = integer_sequence< size_t, Ints... >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , T N> using {\b nlohmann::detail::make_integer_sequence} = typename utility_internal::Gen< T, N >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<size_t N> using {\b nlohmann::detail::make_index_sequence} = make_integer_sequence< size_t, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename... Ts> using {\b nlohmann::detail::index_sequence_for} = make_index_sequence< sizeof...(Ts)>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> using {\b nlohmann::detail::void_t} = typename make_void< Ts... >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<template< class... > class Op, class... Args> using {\b nlohmann::detail::is_detected} = typename detector< nonesuch, void, Op, Args... >::value_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<template< class... > class Op, class... Args> using {\b nlohmann::detail::detected_t} = typename detector< nonesuch, void, Op, Args... >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Default , template< class... > class Op, class... Args> using {\b nlohmann::detail::detected_or} = detector< Default, void, Op, Args... >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Default , template< class... > class Op, class... Args> using {\b nlohmann::detail::detected_or_t} = typename detected_or< Default, Op, Args... >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class Expected , template< class... > class Op, class... Args> using {\b nlohmann::detail::is_detected_exact} = std::is_same< Expected, detected_t< Op, Args... > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class To , template< class... > class Op, class... Args> using {\b nlohmann::detail::is_detected_convertible} = std::is_convertible< detected_t< Op, Args... >, To >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b nlohmann::json} = basic_json<>\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
default JSON class }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b nlohmann::ordered_json} = basic_json< {\b nlohmann::ordered_map} >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ordered JSON class }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::mapped_type_t} = typename T::mapped_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::key_type_t} = typename T::key_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::value_type_t} = typename T::value_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::difference_type_t} = typename T::difference_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::pointer_t} = typename T::pointer\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::reference_t} = typename T::reference\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::iterator_category_t} = typename T::iterator_category\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::iterator_t} = typename T::iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename... Args> using {\b nlohmann::detail::to_json_function} = decltype(T::to_json(std::declval< Args >()...))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename... Args> using {\b nlohmann::detail::from_json_function} = decltype(T::from_json(std::declval< Args >()...))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U > using {\b nlohmann::detail::get_template_function} = decltype(std::declval< T >().template get< U >())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b nlohmann::detail::contiguous_bytes_input_adapter} = decltype(input_adapter(std::declval< const char * >(), std::declval< const char * >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::null_function_t} = decltype(std::declval< T & >().null())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::boolean_function_t} = decltype(std::declval< T & >().boolean(std::declval< bool >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Integer > using {\b nlohmann::detail::number_integer_function_t} = decltype(std::declval< T & >().number_integer(std::declval< Integer >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Unsigned > using {\b nlohmann::detail::number_unsigned_function_t} = decltype(std::declval< T & >().number_unsigned(std::declval< Unsigned >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Float , typename String > using {\b nlohmann::detail::number_float_function_t} = decltype(std::declval< T & >().number_float(std::declval< Float >(), std::declval< const String & >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename String > using {\b nlohmann::detail::string_function_t} = decltype(std::declval< T & >().string(std::declval< String & >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Binary > using {\b nlohmann::detail::binary_function_t} = decltype(std::declval< T & >().binary(std::declval< Binary & >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::start_object_function_t} = decltype(std::declval< T & >().start_object(std::declval< std::size_t >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename String > using {\b nlohmann::detail::key_function_t} = decltype(std::declval< T & >().key(std::declval< String & >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::end_object_function_t} = decltype(std::declval< T & >().end_object())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::start_array_function_t} = decltype(std::declval< T & >().start_array(std::declval< std::size_t >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b nlohmann::detail::end_array_function_t} = decltype(std::declval< T & >().end_array())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Exception > using {\b nlohmann::detail::parse_error_function_t} = decltype(std::declval< T & >().parse_error(std::declval< std::size_t >(), std::declval< const std::string & >(), std::declval< const Exception & >()))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > using {\b nlohmann::detail::parser_callback_t} = std::function< bool(int, parse_event_t, BasicJsonType &)>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharType > using {\b nlohmann::detail::output_adapter_t} = std::shared_ptr< output_adapter_protocol< CharType > >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a type to simplify interfaces }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b nlohmann::detail::value_t} : std::uint8_t \{ {\b nlohmann::detail::null}
, {\b nlohmann::detail::object}
, {\b nlohmann::detail::array}
, {\b nlohmann::detail::string}
, {\b nlohmann::detail::boolean}
, {\b nlohmann::detail::number_integer}
, {\b nlohmann::detail::number_unsigned}
, {\b nlohmann::detail::number_float}
, {\b nlohmann::detail::binary}
, {\b nlohmann::detail::discarded}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the JSON type enumeration }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b nlohmann::detail::input_format_t} \{ {\b nlohmann::detail::json}
, {\b nlohmann::detail::cbor}
, {\b nlohmann::detail::msgpack}
, {\b nlohmann::detail::ubjson}
, {\b nlohmann::detail::bson}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
the supported input formats }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b nlohmann::detail::cbor_tag_handler_t} \{ {\b nlohmann::detail::error}
, {\b nlohmann::detail::ignore}
, {\b nlohmann::detail::store}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
how to treat CBOR tags }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b nlohmann::detail::parse_event_t} : std::uint8_t \{ {\b nlohmann::detail::object_start}
, {\b nlohmann::detail::object_end}
, {\b nlohmann::detail::array_start}
, {\b nlohmann::detail::array_end}
, {\b nlohmann::detail::key}
, {\b nlohmann::detail::value}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b nlohmann::detail::error_handler_t} \{ {\b nlohmann::detail::strict}
, {\b nlohmann::detail::replace}
, {\b nlohmann::detail::ignore}
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
how to treat decoding errors }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b nlohmann::detail::operator<} (const value_t lhs, const value_t rhs) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
comparison operator for JSON types }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nlohmann::detail::replace_substring} (std::string &s, const std::string &f, const std::string &t)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
replace all occurrences of a substring by another string }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b nlohmann::detail::escape} (std::string s)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
string escaping as described in RFC 6901 (Sect. 4) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename U , enable_if_t< !std::is_same< T, U >::value, int >  = 0> T {\b nlohmann::detail::conditional_static_cast} (U value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::from_json} (const BasicJsonType &j, typename std::nullptr_t &n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ArithmeticType , enable_if_t< std::is_arithmetic< ArithmeticType >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::boolean_t >::value, int >  = 0> void {\b nlohmann::detail::get_arithmetic_value} (const BasicJsonType &j, ArithmeticType &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::from_json} (const BasicJsonType &j, typename BasicJsonType::boolean_t &b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::from_json} (const BasicJsonType &j, typename BasicJsonType::string_t &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ConstructibleStringType , enable_if_t< is_constructible_string_type< BasicJsonType, ConstructibleStringType >::value &&!std::is_same< typename BasicJsonType::string_t, ConstructibleStringType >::value, int >  = 0> void {\b nlohmann::detail::from_json} (const BasicJsonType &j, ConstructibleStringType &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::from_json} (const BasicJsonType &j, typename BasicJsonType::number_float_t &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::from_json} (const BasicJsonType &j, typename BasicJsonType::number_unsigned_t &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::from_json} (const BasicJsonType &j, typename BasicJsonType::number_integer_t &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename EnumType , enable_if_t< std::is_enum< EnumType >::value, int >  = 0> void {\b nlohmann::detail::from_json} (const BasicJsonType &j, EnumType &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , typename Allocator , enable_if_t< is_getable< BasicJsonType, T >::value, int >  = 0> void {\b nlohmann::detail::from_json} (const BasicJsonType &j, std::forward_list< T, Allocator > &l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , enable_if_t< is_getable< BasicJsonType, T >::value, int >  = 0> void {\b nlohmann::detail::from_json} (const BasicJsonType &j, std::valarray< T > &l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , std::size_t N> auto {\b nlohmann::detail::from_json} (const BasicJsonType &j, T(&arr)[N]) -> decltype(j.template get< T >(), void())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::from_json_array_impl} (const BasicJsonType &j, typename BasicJsonType::array_t &arr, priority_tag< 3 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , std::size_t N> auto {\b nlohmann::detail::from_json_array_impl} (const BasicJsonType &j, std::array< T, N > &arr, priority_tag< 2 >) -> decltype(j.template get< T >(), void())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ConstructibleArrayType , enable_if_t< std::is_assignable< ConstructibleArrayType &, ConstructibleArrayType >::value, int >  = 0> auto {\b nlohmann::detail::from_json_array_impl} (const BasicJsonType &j, ConstructibleArrayType &arr, priority_tag< 1 >) -> decltype(arr.reserve(std::declval< typename ConstructibleArrayType::size_type >()), j.template get< typename ConstructibleArrayType::value_type >(), void())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ConstructibleArrayType , enable_if_t< std::is_assignable< ConstructibleArrayType &, ConstructibleArrayType >::value, int >  = 0> void {\b nlohmann::detail::from_json_array_impl} (const BasicJsonType &j, ConstructibleArrayType &arr, priority_tag< 0 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ConstructibleArrayType , enable_if_t< is_constructible_array_type< BasicJsonType, ConstructibleArrayType >::value &&!is_constructible_object_type< BasicJsonType, ConstructibleArrayType >::value &&!is_constructible_string_type< BasicJsonType, ConstructibleArrayType >::value &&!std::is_same< ConstructibleArrayType, typename BasicJsonType::binary_t >::value &&!is_basic_json< ConstructibleArrayType >::value, int >  = 0> auto {\b nlohmann::detail::from_json} (const BasicJsonType &j, ConstructibleArrayType &arr) -> decltype(from_json_array_impl(j, arr, priority_tag< 3 > \{\}), j.template get< typename ConstructibleArrayType::value_type >(), void())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , std::size_t... Idx> std::array< T, sizeof...(Idx)> {\b nlohmann::detail::from_json_inplace_array_impl} (BasicJsonType &&j, identity_tag< std::array< T, sizeof...(Idx)> >, index_sequence< Idx... >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , std::size_t N> auto {\b nlohmann::detail::from_json} (BasicJsonType &&j, identity_tag< std::array< T, N > > tag) -> decltype(from_json_inplace_array_impl(std::forward< BasicJsonType >(j), tag, make_index_sequence< N > \{\}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::from_json} (const BasicJsonType &j, typename BasicJsonType::binary_t &bin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ConstructibleObjectType , enable_if_t< is_constructible_object_type< BasicJsonType, ConstructibleObjectType >::value, int >  = 0> void {\b nlohmann::detail::from_json} (const BasicJsonType &j, ConstructibleObjectType &obj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename ArithmeticType , enable_if_t< std::is_arithmetic< ArithmeticType >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::number_unsigned_t >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::number_integer_t >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::number_float_t >::value &&!std::is_same< ArithmeticType, typename BasicJsonType::boolean_t >::value, int >  = 0> void {\b nlohmann::detail::from_json} (const BasicJsonType &j, ArithmeticType &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename... Args, std::size_t... Idx> std::tuple< Args... > {\b nlohmann::detail::from_json_tuple_impl_base} (BasicJsonType &&j, index_sequence< Idx... >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , class A1 , class A2 > std::pair< A1, A2 > {\b nlohmann::detail::from_json_tuple_impl} (BasicJsonType &&j, identity_tag< std::pair< A1, A2 > >, priority_tag< 0 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename A1 , typename A2 > void {\b nlohmann::detail::from_json_tuple_impl} (BasicJsonType &&j, std::pair< A1, A2 > &p, priority_tag< 1 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename... Args> std::tuple< Args... > {\b nlohmann::detail::from_json_tuple_impl} (BasicJsonType &&j, identity_tag< std::tuple< Args... > >, priority_tag< 2 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename... Args> void {\b nlohmann::detail::from_json_tuple_impl} (BasicJsonType &&j, std::tuple< Args... > &t, priority_tag< 3 >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename TupleRelated > auto {\b nlohmann::detail::from_json} (BasicJsonType &&j, TupleRelated &&t) -> decltype(from_json_tuple_impl(std::forward< BasicJsonType >(j), std::forward< TupleRelated >(t), priority_tag< 3 > \{\}))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename Key , typename Value , typename Compare , typename Allocator , typename  = enable_if_t < !std::is_constructible <                                        typename BasicJsonType::string_t, Key >::value >> void {\b nlohmann::detail::from_json} (const BasicJsonType &j, std::map< Key, Value, Compare, Allocator > &m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename Key , typename Value , typename Hash , typename KeyEqual , typename Allocator , typename  = enable_if_t < !std::is_constructible <                                        typename BasicJsonType::string_t, Key >::value >> void {\b nlohmann::detail::from_json} (const BasicJsonType &j, std::unordered_map< Key, Value, Hash, KeyEqual, Allocator > &m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename string_type > void {\b nlohmann::detail::int_to_string} (string_type &target, std::size_t value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t N, typename IteratorType , enable_if_t< N==0, int >  = 0> auto {\b nlohmann::detail::get} (const {\b nlohmann::detail::iteration_proxy_value}< IteratorType > &i) -> decltype(i.key())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , enable_if_t< std::is_same< T, typename BasicJsonType::boolean_t >::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, T b) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleString , enable_if_t< std::is_constructible< typename BasicJsonType::string_t, CompatibleString >::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, const CompatibleString &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::to_json} (BasicJsonType &j, typename BasicJsonType::string_t &&s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename FloatType , enable_if_t< std::is_floating_point< FloatType >::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, FloatType val) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleNumberUnsignedType , enable_if_t< is_compatible_integer_type< typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType >::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, CompatibleNumberUnsignedType val) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleNumberIntegerType , enable_if_t< is_compatible_integer_type< typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType >::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, CompatibleNumberIntegerType val) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename EnumType , enable_if_t< std::is_enum< EnumType >::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, EnumType e) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::to_json} (BasicJsonType &j, const std::vector< bool > &e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleArrayType , enable_if_t< is_compatible_array_type< BasicJsonType, CompatibleArrayType >::value &&!is_compatible_object_type< BasicJsonType, CompatibleArrayType >::value &&!is_compatible_string_type< BasicJsonType, CompatibleArrayType >::value &&!std::is_same< typename BasicJsonType::binary_t, CompatibleArrayType >::value &&!is_basic_json< CompatibleArrayType >::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, const CompatibleArrayType &arr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::to_json} (BasicJsonType &j, const typename BasicJsonType::binary_t &bin)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , enable_if_t< std::is_convertible< T, BasicJsonType >::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, const std::valarray< T > &arr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::to_json} (BasicJsonType &j, typename BasicJsonType::array_t &&arr)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename CompatibleObjectType , enable_if_t< is_compatible_object_type< BasicJsonType, CompatibleObjectType >::value &&!is_basic_json< CompatibleObjectType >::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, const CompatibleObjectType &obj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > void {\b nlohmann::detail::to_json} (BasicJsonType &j, typename BasicJsonType::object_t &&obj)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , std::size_t N, enable_if_t< !std::is_constructible< typename BasicJsonType::string_t, const T(&)[N]>::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, const T(&arr)[N])\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T1 , typename T2 , enable_if_t< std::is_constructible< BasicJsonType, T1 >::value &&std::is_constructible< BasicJsonType, T2 >::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, const std::pair< T1, T2 > &p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename T , enable_if_t< std::is_same< T, iteration_proxy_value< typename BasicJsonType::iterator > >::value, int >  = 0> void {\b nlohmann::detail::to_json} (BasicJsonType &j, const T &b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType , typename Tuple , std::size_t... Idx> void {\b nlohmann::detail::to_json_tuple_impl} (BasicJsonType &j, const Tuple &t, index_sequence< Idx... >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b nlohmann::detail::combine} (std::size_t seed, std::size_t h) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename BasicJsonType > std::size_t {\b nlohmann::detail::hash} (const BasicJsonType &j)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
hash a JSON value }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename IteratorType > iterator_input_adapter_factory< IteratorType >::adapter_type {\b nlohmann::detail::input_adapter} (IteratorType first, IteratorType last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ContainerType > container_input_adapter_factory_impl::container_input_adapter_factory< ContainerType >::adapter_type {\b nlohmann::detail::input_adapter} (const ContainerType &container)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
file_input_adapter {\b nlohmann::detail::input_adapter} (std::FILE *file)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
input_stream_adapter {\b nlohmann::detail::input_adapter} (std::istream &stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
input_stream_adapter {\b nlohmann::detail::input_adapter} (std::istream &&stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename CharT , typename std::enable_if< std::is_pointer< CharT >::value &&!std::is_array< CharT >::value &&std::is_integral< typename std::remove_pointer< CharT >::type >::value &&sizeof(typename std::remove_pointer< CharT >::type)==1, int >::type  = 0> contiguous_bytes_input_adapter {\b nlohmann::detail::input_adapter} (CharT b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , std::size_t N> auto {\b nlohmann::detail::input_adapter} (T(&array)[N]) -> decltype(input_adapter(array, array+N))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Target , typename Source > Target {\b nlohmann::detail::dtoa_impl::reinterpret_bits} (const Source source)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename FloatType > boundaries {\b nlohmann::detail::dtoa_impl::compute_boundaries} (FloatType value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
cached_power {\b nlohmann::detail::dtoa_impl::get_cached_power_for_binary_exponent} (int e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b nlohmann::detail::dtoa_impl::find_largest_pow10} (const std::uint32_t n, std::uint32_t &pow10)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nlohmann::detail::dtoa_impl::grisu2_round} (char *buf, int len, std::uint64_t dist, std::uint64_t delta, std::uint64_t rest, std::uint64_t ten_k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nlohmann::detail::dtoa_impl::grisu2_digit_gen} (char *buffer, int &length, int &decimal_exponent, diyfp M_minus, diyfp w, diyfp M_plus)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nlohmann::detail::dtoa_impl::grisu2} (char *buf, int &len, int &decimal_exponent, diyfp m_minus, diyfp v, diyfp m_plus)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename FloatType > void {\b nlohmann::detail::dtoa_impl::grisu2} (char *buf, int &len, int &decimal_exponent, FloatType value)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JSON_HEDLEY_RETURNS_NON_NULL} char * {\b nlohmann::detail::dtoa_impl::append_exponent} (char *buf, int e)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
appends a decimal representation of e to buf }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JSON_HEDLEY_RETURNS_NON_NULL} char * {\b nlohmann::detail::dtoa_impl::format_buffer} (char *buf, int len, int decimal_exponent, int min_exp, int max_exp)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
prettify v = buf * 10^decimal_exponent }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename FloatType > {\b JSON_HEDLEY_RETURNS_NON_NULL} char * {\b nlohmann::detail::to_chars} (char *first, const char *last, FloatType value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
generates a decimal representation of the floating-point number value in [first, last). }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NLOHMANN_BASIC_JSON_TPL_DECLARATION} std::string {\b nlohmann::to_string} (const {\b NLOHMANN_BASIC_JSON_TPL} &j)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
user-defined to_string function for JSON values }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<> void {\b std::swap< nlohmann::json >} ({\b nlohmann::json} &j1, {\b nlohmann::json} &j2) noexcept(//NOLINT(readability-inconsistent-declaration-parameter-name) is_nothrow_move_constructible< {\b nlohmann::json} >::value &&//NOLINT(misc-redundant-expression) is_nothrow_move_assignable< {\b nlohmann::json} >::value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
exchanges the values of two JSON objects }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nlohmann::json} {\b operator""_json} (const char *s, std::size_t n)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
user-defined string literal for JSON values }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nlohmann::json::json_pointer} {\b operator""_json_pointer} (const char *s, std::size_t n)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
user-defined string literal for JSON pointer }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr int {\b nlohmann::detail::dtoa_impl::kAlpha} = -60\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr int {\b nlohmann::detail::dtoa_impl::kGamma} = -32\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v INCLUDE_NLOHMANN_JSON_FWD_HPP_\:json.hpp}
{\xe \v json.hpp\:INCLUDE_NLOHMANN_JSON_FWD_HPP_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define INCLUDE_NLOHMANN_JSON_FWD_HPP_}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3348} of file {\b json.hpp}.}\par
}
{\xe \v JSON_ASSERT\:json.hpp}
{\xe \v json.hpp\:JSON_ASSERT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_ASSERT( x)\~ assert(x)}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2295} of file {\b json.hpp}.}\par
}
{\xe \v JSON_CATCH\:json.hpp}
{\xe \v json.hpp\:JSON_CATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_CATCH( exception)\~ if(false)}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2268} of file {\b json.hpp}.}\par
}
{\xe \v JSON_DIAGNOSTICS\:json.hpp}
{\xe \v json.hpp\:JSON_DIAGNOSTICS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_DIAGNOSTICS\~ 0}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2518} of file {\b json.hpp}.}\par
}
{\xe \v JSON_EXPLICIT\:json.hpp}
{\xe \v json.hpp\:JSON_EXPLICIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_EXPLICIT}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2512} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HAS_CPP_11\:json.hpp}
{\xe \v json.hpp\:JSON_HAS_CPP_11}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HAS_CPP_11}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2248} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_ALWAYS_INLINE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_ALWAYS_INLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_ALWAYS_INLINE\~ {\b JSON_HEDLEY_INLINE}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1769} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_ARM_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_ARM_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_ARM_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 387} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_ARRAY_PARAM\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_ARRAY_PARAM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_ARRAY_PARAM( name)}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1913} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_ASSUME\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_ASSUME}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_ASSUME( expr)\~ {\b JSON_HEDLEY_STATIC_CAST}(void, expr)}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1416} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_BEGIN_C_DECLS\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_BEGIN_C_DECLS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_BEGIN_C_DECLS}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2020} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_C_DECL\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_C_DECL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_C_DECL}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2022} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CLANG_HAS_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CLANG_HAS_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE( attribute)\~ {\b JSON_HEDLEY_HAS_ATTRIBUTE}(attribute)}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2183} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CLANG_HAS_BUILTIN\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CLANG_HAS_BUILTIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CLANG_HAS_BUILTIN( builtin)\~ {\b JSON_HEDLEY_HAS_BUILTIN}(builtin)}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2193} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE( attribute)\~ {\b JSON_HEDLEY_HAS_CPP_ATTRIBUTE}(attribute)}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2188} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE( attribute)\~ {\b JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE}(attribute)}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2208} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CLANG_HAS_EXTENSION\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CLANG_HAS_EXTENSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CLANG_HAS_EXTENSION( extension)\~ {\b JSON_HEDLEY_HAS_EXTENSION}(extension)}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2203} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CLANG_HAS_FEATURE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CLANG_HAS_FEATURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CLANG_HAS_FEATURE( feature)\~ {\b JSON_HEDLEY_HAS_FEATURE}(feature)}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2198} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CLANG_HAS_WARNING\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CLANG_HAS_WARNING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CLANG_HAS_WARNING( warning)\~ {\b JSON_HEDLEY_HAS_WARNING}(warning)}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2213} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_COMPCERT_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_COMPCERT_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_COMPCERT_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 615} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CONCAT\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CONCAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CONCAT( a,  b)\~ {\b JSON_HEDLEY_CONCAT_EX}(a,b)}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 210} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CONCAT3\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CONCAT3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CONCAT3( a,  b,  c)\~ {\b JSON_HEDLEY_CONCAT3_EX}(a,b,c)}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CONCAT3_EX\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CONCAT3_EX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CONCAT3_EX( a,  b,  c)\~ a##b##c}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 215} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CONCAT_EX\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CONCAT_EX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CONCAT_EX( a,  b)\~ a##b}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 205} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CONST\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CONST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CONST\~ {\b JSON_HEDLEY_PURE}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1670} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CONST_CAST\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CONST_CAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CONST_CAST( T,  expr)\~ ((T) (expr))}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1011} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CONSTEXPR\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CONSTEXPR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CONSTEXPR}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1503} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CPP_CAST\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CPP_CAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CPP_CAST( T,  expr)\~ (expr)}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1051} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_CRAY_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_CRAY_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_CRAY_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 547} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_DEPRECATED\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_DEPRECATED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_DEPRECATED( since)}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1247} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_DEPRECATED_FOR\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_DEPRECATED_FOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_DEPRECATED_FOR( since,  replacement)}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1248} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1171} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_( x)\~ x}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 992} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1095} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1158} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1126} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1186} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_DIAGNOSTIC_POP\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_DIAGNOSTIC_POP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_DIAGNOSTIC_POP}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 955} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_DIAGNOSTIC_PUSH\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_DIAGNOSTIC_PUSH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_DIAGNOSTIC_PUSH}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 954} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_DMC_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_DMC_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_DMC_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 599} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_EMPTY_BASES\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_EMPTY_BASES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_EMPTY_BASES}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2166} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 369} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_END_C_DECLS\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_END_C_DECLS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_END_C_DECLS}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2021} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_FALL_THROUGH\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_FALL_THROUGH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_FALL_THROUGH}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1885} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_FLAGS\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_FLAGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_FLAGS}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2141} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_FLAGS_CAST\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_FLAGS_CAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_FLAGS_CAST( T,  expr)\~ {\b JSON_HEDLEY_STATIC_CAST}(T, expr)}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2155} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GCC_HAS_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GCC_HAS_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GCC_HAS_ATTRIBUTE( attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 709} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GCC_HAS_BUILTIN\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GCC_HAS_BUILTIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GCC_HAS_BUILTIN( builtin,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 781} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE( attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 754} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE( attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 862} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GCC_HAS_EXTENSION\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GCC_HAS_EXTENSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GCC_HAS_EXTENSION( extension,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 835} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GCC_HAS_FEATURE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GCC_HAS_FEATURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GCC_HAS_FEATURE( feature,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 808} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GCC_HAS_WARNING\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GCC_HAS_WARNING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GCC_HAS_WARNING( warning,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 889} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK( major,  minor,  patch)\~ {\b JSON_HEDLEY_GCC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2177} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GCC_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GCC_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GCC_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 678} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GNUC_HAS_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GNUC_HAS_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE( attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 700} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GNUC_HAS_BUILTIN\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GNUC_HAS_BUILTIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GNUC_HAS_BUILTIN( builtin,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 772} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE( attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 745} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE( attribute,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 853} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GNUC_HAS_EXTENSION\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GNUC_HAS_EXTENSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GNUC_HAS_EXTENSION( extension,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 826} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GNUC_HAS_FEATURE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GNUC_HAS_FEATURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GNUC_HAS_FEATURE( feature,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 799} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GNUC_HAS_WARNING\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GNUC_HAS_WARNING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GNUC_HAS_WARNING( warning,  major,  minor,  patch)\~ {\b JSON_HEDLEY_GNUC_VERSION_CHECK}(major,minor,patch)}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 880} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_GNUC_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_GNUC_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_GNUC_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 257} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_HAS_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_HAS_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_HAS_ATTRIBUTE( attribute)\~ (0)}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 691} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_HAS_BUILTIN\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_HAS_BUILTIN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_HAS_BUILTIN( builtin)\~ (0)}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 763} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_HAS_CPP_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_HAS_CPP_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_HAS_CPP_ATTRIBUTE( attribute)\~ (0)}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 721} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS( ns,  attribute)\~ (0)}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 728} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE( attribute)\~ (0)}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 844} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_HAS_EXTENSION\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_HAS_EXTENSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_HAS_EXTENSION( extension)\~ (0)}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 817} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_HAS_FEATURE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_HAS_FEATURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_HAS_FEATURE( feature)\~ (0)}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 790} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_HAS_WARNING\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_HAS_WARNING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_HAS_WARNING( warning)\~ (0)}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 871} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_IAR_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_IAR_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_IAR_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 567} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_IBM_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_IBM_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_IBM_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 407} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_IMPORT\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_IMPORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_IMPORT\~ extern}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1849} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_INLINE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_INLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_INLINE}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1725} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_INTEL_CL_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_INTEL_CL_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_INTEL_CL_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 315} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_INTEL_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_INTEL_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_INTEL_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 299} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_IS_CONSTANT\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_IS_CONSTANT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_IS_CONSTANT( expr)\~ (0)}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2001} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_LIKELY\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_LIKELY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_LIKELY( expr)\~ (!!(expr))}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1565} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_MALLOC\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_MALLOC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_MALLOC}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1602} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_MCST_LCC_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_MCST_LCC_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_MCST_LCC_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 647} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_MESSAGE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_MESSAGE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_MESSAGE( msg)}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2083} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_MSVC_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_MSVC_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_MSVC_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 275} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_NEVER_INLINE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_NEVER_INLINE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_NEVER_INLINE}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1811} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_NO_ESCAPE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_NO_ESCAPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_NO_ESCAPE}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1372} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_NO_RETURN\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_NO_RETURN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_NO_RETURN}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1363} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_NO_THROW\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_NO_THROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_NO_THROW}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1867} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_NON_NULL\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_NON_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_NON_NULL(  {\i ...})}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1458} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_NULL\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_NULL\~ ((void*) 0)}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2060} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_PELLES_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_PELLES_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_PELLES_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 631} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_PGI_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_PGI_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_PGI_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 331} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_PRAGMA\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_PRAGMA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_PRAGMA( value)}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 915} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_PREDICT\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_PREDICT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_PREDICT( expr,  expected,  probability)\~ ({\b JSON_HEDLEY_STATIC_CAST}(void, expected), (expr))}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1562} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_PREDICT_FALSE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_PREDICT_FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_PREDICT_FALSE( expr,  probability)\~ (!!(expr))}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1564} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_PREDICT_TRUE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_PREDICT_TRUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_PREDICT_TRUE( expr,  probability)\~ (!!(expr))}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1563} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_PRINTF_FORMAT\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_PRINTF_FORMAT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_PRINTF_FORMAT( string_idx,  first_to_check)}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1491} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_PRIVATE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_PRIVATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_PRIVATE}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1846} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_PUBLIC\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_PUBLIC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_PUBLIC}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1847} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_PURE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_PURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_PURE}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1639} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_REINTERPRET_CAST\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_REINTERPRET_CAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_REINTERPRET_CAST( T,  expr)\~ ((T) (expr))}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1020} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_REQUIRE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_REQUIRE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_REQUIRE( expr)}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2131} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_REQUIRE_CONSTEXPR\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_REQUIRE_CONSTEXPR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_REQUIRE_CONSTEXPR( expr)\~ (expr)}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2003} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_REQUIRE_MSG\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_REQUIRE_MSG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_REQUIRE_MSG( expr,  msg)}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2132} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_RESTRICT\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_RESTRICT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_RESTRICT}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1698} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_RETURNS_NON_NULL\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_RETURNS_NON_NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_RETURNS_NON_NULL}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1899} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_SENTINEL\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_SENTINEL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_SENTINEL( position)}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1315} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_STATIC_ASSERT\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_STATIC_ASSERT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_STATIC_ASSERT( expr,  message)}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2043} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_STATIC_CAST\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_STATIC_CAST}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_STATIC_CAST( T,  expr)\~ ((T) (expr))}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1029} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_STRINGIFY\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_STRINGIFY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_STRINGIFY( x)\~ {\b JSON_HEDLEY_STRINGIFY_EX}(x)}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_STRINGIFY_EX\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_STRINGIFY_EX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_STRINGIFY_EX( x)\~ #x}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 195} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_SUNPRO_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_SUNPRO_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_SUNPRO_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 353} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_TI_ARMCL_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_TI_ARMCL_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 479} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_TI_CL2000_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_TI_CL2000_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_TI_CL2000_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 447} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_TI_CL430_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_TI_CL430_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_TI_CL430_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 463} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_TI_CL6X_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_TI_CL6X_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_TI_CL6X_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 495} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_TI_CL7X_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_TI_CL7X_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_TI_CL7X_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 511} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_TI_CLPRU_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_TI_CLPRU_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 527} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_TI_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_TI_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_TI_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 431} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_TINYC_VERSION_CHECK\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_TINYC_VERSION_CHECK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_TINYC_VERSION_CHECK( major,  minor,  patch)\~ (0)}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 583} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_UNAVAILABLE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_UNAVAILABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_UNAVAILABLE( available_since)}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1261} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_UNLIKELY\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_UNLIKELY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_UNLIKELY( expr)\~ (!!(expr))}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1566} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_UNPREDICTABLE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_UNPREDICTABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_UNPREDICTABLE( expr)\~ {\b JSON_HEDLEY_PREDICT}(expr, 1, 0.5)}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1569} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_UNREACHABLE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_UNREACHABLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_UNREACHABLE()\~ {\b JSON_HEDLEY_ASSUME}(0)}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1431} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_UNREACHABLE_RETURN\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_UNREACHABLE_RETURN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_UNREACHABLE_RETURN( value)\~ return (value)}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1428} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_VERSION\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_VERSION\~ 15}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 190} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_VERSION_DECODE_MAJOR\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_VERSION_DECODE_MAJOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_VERSION_DECODE_MAJOR( version)\~ ((version) / 1000000)}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 230} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_VERSION_DECODE_MINOR\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_VERSION_DECODE_MINOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_VERSION_DECODE_MINOR( version)\~ (((version) % 1000000) / 1000)}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 235} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_VERSION_DECODE_REVISION\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_VERSION_DECODE_REVISION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_VERSION_DECODE_REVISION( version)\~ ((version) % 1000)}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 240} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_VERSION_ENCODE\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_VERSION_ENCODE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_VERSION_ENCODE( major,  minor,  revision)\~ (((major) * 1000000) + ((minor) * 1000) + (revision))}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_WARN_UNUSED_RESULT\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_WARN_UNUSED_RESULT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_WARN_UNUSED_RESULT}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1300} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_WARN_UNUSED_RESULT_MSG\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_WARN_UNUSED_RESULT_MSG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG( msg)}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1301} of file {\b json.hpp}.}\par
}
{\xe \v JSON_HEDLEY_WARNING\:json.hpp}
{\xe \v json.hpp\:JSON_HEDLEY_WARNING}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_HEDLEY_WARNING( msg)\~ {\b JSON_HEDLEY_MESSAGE}(msg)}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2105} of file {\b json.hpp}.}\par
}
{\xe \v JSON_INTERNAL_CATCH\:json.hpp}
{\xe \v json.hpp\:JSON_INTERNAL_CATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_INTERNAL_CATCH( exception)\~ if(false)}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2269} of file {\b json.hpp}.}\par
}
{\xe \v JSON_PRIVATE_UNLESS_TESTED\:json.hpp}
{\xe \v json.hpp\:JSON_PRIVATE_UNLESS_TESTED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_PRIVATE_UNLESS_TESTED\~ private}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2302} of file {\b json.hpp}.}\par
}
{\xe \v JSON_THROW\:json.hpp}
{\xe \v json.hpp\:JSON_THROW}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_THROW( exception)\~ std::abort()}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2266} of file {\b json.hpp}.}\par
}
{\xe \v JSON_TRY\:json.hpp}
{\xe \v json.hpp\:JSON_TRY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_TRY\~ if(true)}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2267} of file {\b json.hpp}.}\par
}
{\xe \v JSON_USE_IMPLICIT_CONVERSIONS\:json.hpp}
{\xe \v json.hpp\:JSON_USE_IMPLICIT_CONVERSIONS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define JSON_USE_IMPLICIT_CONVERSIONS\~ 1}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2508} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_BASIC_JSON_TPL\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_BASIC_JSON_TPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_BASIC_JSON_TPL}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     basic_json<ObjectType, ArrayType, StringType, BooleanType,             \\\par
    NumberIntegerType, NumberUnsignedType, NumberFloatType,                \\\par
    AllocatorType, JSONSerializer, BinaryType>\par
}
{
Definition at line {\b 2348} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_BASIC_JSON_TPL_DECLARATION\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_BASIC_JSON_TPL_DECLARATION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_BASIC_JSON_TPL_DECLARATION}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<{\cf17 template}<{\cf17 typename}, {\cf17 typename}, {\cf17 typename}...> {\cf17 class }ObjectType,   \\\par
             template<{\cf17 typename}, {\cf17 typename}...> {\cf17 class }ArrayType,              \\\par
             class StringType, {\cf17 class }BooleanType, {\cf17 class }NumberIntegerType, \\\par
             class NumberUnsignedType, {\cf17 class }NumberFloatType,              \\\par
             template<typename> {\cf17 class }AllocatorType,                       \\\par
             template<typename, typename = void> {\cf17 class }JSONSerializer,     \\\par
             class BinaryType>\par
}
{
Definition at line {\b 2339} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_DEFINE_TYPE_INTRUSIVE\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_DEFINE_TYPE_INTRUSIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_DEFINE_TYPE_INTRUSIVE( Type,   {\i ...})}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 friend} {\cf18 void} to_json(nlohmann::json& nlohmann_json_j, {\cf17 const} Type& nlohmann_json_t) \{ NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) \} \\\par
    friend {\cf18 void} from_json({\cf17 const} nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) \{ NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) \}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
macro }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.9.0 \par
}}}{
Definition at line {\b 2494} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE( Type,   {\i ...})}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 inline} {\cf18 void} to_json(nlohmann::json& nlohmann_json_j, {\cf17 const} Type& nlohmann_json_t) \{ NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) \} \\\par
    inline {\cf18 void} from_json({\cf17 const} nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) \{ NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) \}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
macro }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.9.0 \par
}}}{
Definition at line {\b 2503} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_EXPAND\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_EXPAND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_EXPAND( x)\~ x}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2355} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_FROM\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_FROM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_FROM( v1)\~ nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2487} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_GET_MACRO\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_GET_MACRO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_GET_MACRO( _1,  _2,  _3,  _4,  _5,  _6,  _7,  _8,  _9,  _10,  _11,  _12,  _13,  _14,  _15,  _16,  _17,  _18,  _19,  _20,  _21,  _22,  _23,  _24,  _25,  _26,  _27,  _28,  _29,  _30,  _31,  _32,  _33,  _34,  _35,  _36,  _37,  _38,  _39,  _40,  _41,  _42,  _43,  _44,  _45,  _46,  _47,  _48,  _49,  _50,  _51,  _52,  _53,  _54,  _55,  _56,  _57,  _58,  _59,  _60,  _61,  _62,  _63,  _64,  NAME,   {\i ...})\~ NAME}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2356} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE(  {\i ...})}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2357} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE10\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE10}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE10( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE9}(func, v2, v3, v4, v5, v6, v7, v8, v9)}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2430} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE11\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE11}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE11( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE10}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2431} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE12\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE12}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE12( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE11}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2432} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE13\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE13}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE13( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE12}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2433} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE14\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE14}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE14( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE13}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2434} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE15\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE15}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE15( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE14}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2435} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE16\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE16( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE15}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2436} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE17\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE17}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE17( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE16}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2437} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE18\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE18}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE18( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE17}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2438} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE19\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE19}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE19( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE18}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2439} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE2\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE2( func,  v1)\~ func(v1)}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2422} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE20\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE20}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE20( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE19}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2440} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE21\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE21}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE21( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE20}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2441} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE22\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE22}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE22( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE21}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2442} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE23\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE23}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE23( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE22}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2443} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE24\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE24}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE24( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE23}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2444} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE25\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE25}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE25( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE24}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2445} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE26\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE26}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE26( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE25}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2446} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE27\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE27}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE27( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE26}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2447} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE28\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE28}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE28( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE27}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2448} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE29\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE29}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE29( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE28}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2449} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE3\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE3( func,  v1,  v2)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE2}(func, v2)}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2423} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE30\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE30}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE30( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE29}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2450} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE31\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE31}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE31( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE30}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2451} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE32\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE32( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE31}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2452} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE33\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE33}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE33( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE32}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2453} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE34\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE34}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE34( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE33}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2454} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE35\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE35}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE35( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE34}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2455} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE36\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE36}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE36( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE35}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2456} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE37\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE37}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE37( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE36}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2457} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE38\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE38}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE38( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE37}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2458} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE39\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE39}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE39( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE38}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2459} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE4\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE4( func,  v1,  v2,  v3)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE3}(func, v2, v3)}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2424} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE40\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE40}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE40( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE39}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2460} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE41\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE41}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE41( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE40}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2461} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE42\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE42}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE42( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE41}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2462} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE43\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE43}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE43( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE42}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2463} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE44\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE44}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE44( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE43}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2464} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE45\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE45}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE45( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE44}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2465} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE46\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE46}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE46( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE45}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2466} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE47\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE47}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE47( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE46}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2467} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE48\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE48}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE48( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE47}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2468} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE49\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE49}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE49( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE48}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2469} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE5\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE5( func,  v1,  v2,  v3,  v4)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE4}(func, v2, v3, v4)}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2425} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE50\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE50}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE50( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE49}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2470} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE51\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE51}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE51( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE50}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2471} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE52\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE52}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE52( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE51}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2472} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE53\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE53}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE53( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE52}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2473} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE54\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE54}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE54( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE53}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2474} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE55\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE55}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE55( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE54}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2475} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE56\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE56}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE56( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE55}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2476} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE57\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE57}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE57( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE56}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2477} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE58\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE58}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE58( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE57}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2478} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE59\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE59}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE59( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE58}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2479} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE6\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE6( func,  v1,  v2,  v3,  v4,  v5)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE5}(func, v2, v3, v4, v5)}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2426} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE60\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE60}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE60( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v59)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE59}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2480} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE61\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE61}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE61( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v60)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE60}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2481} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE62\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE62}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE62( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v60,  v61)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE61}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2482} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE63\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE63}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE63( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v60,  v61,  v62)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE62}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2483} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE64\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE64( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8,  v9,  v10,  v11,  v12,  v13,  v14,  v15,  v16,  v17,  v18,  v19,  v20,  v21,  v22,  v23,  v24,  v25,  v26,  v27,  v28,  v29,  v30,  v31,  v32,  v33,  v34,  v35,  v36,  v37,  v38,  v39,  v40,  v41,  v42,  v43,  v44,  v45,  v46,  v47,  v48,  v49,  v50,  v51,  v52,  v53,  v54,  v55,  v56,  v57,  v58,  v59,  v60,  v61,  v62,  v63)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE63}(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2484} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE7\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE7( func,  v1,  v2,  v3,  v4,  v5,  v6)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE6}(func, v2, v3, v4, v5, v6)}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2427} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE8\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE8( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE7}(func, v2, v3, v4, v5, v6, v7)}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2428} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_PASTE9\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_PASTE9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_PASTE9( func,  v1,  v2,  v3,  v4,  v5,  v6,  v7,  v8)\~ {\b NLOHMANN_JSON_PASTE2}(func, v1) {\b NLOHMANN_JSON_PASTE8}(func, v2, v3, v4, v5, v6, v7, v8)}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2429} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_SERIALIZE_ENUM\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_SERIALIZE_ENUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_SERIALIZE_ENUM( ENUM_TYPE,   {\i ...})}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<{\cf17 typename} BasicJsonType>                                                            \\\par
    inline {\cf18 void} to_json(BasicJsonType& j, {\cf17 const} ENUM_TYPE& e)                                   \\\par
    \{                                                                                           \\\par
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE {\cf22 " must be an enum!"});          \\\par
        static {\cf17 const} std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \\\par
        auto it = std::find_if(std::begin(m), std::end(m),                                      \\\par
                               [e]({\cf17 const} std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> {\cf18 bool}  \\\par
        \{                                                                                       \\\par
            return ej_pair.first == e;                                                          \\\par
        \});                                                                                     \\\par
        j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \\\par
    \}                                                                                           \\\par
    template<typename BasicJsonType>                                                            \\\par
    inline {\cf18 void} from_json({\cf17 const} BasicJsonType& j, ENUM_TYPE& e)                                 \\\par
    \{                                                                                           \\\par
        static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE {\cf22 " must be an enum!"});          \\\par
        static {\cf17 const} std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \\\par
        auto it = std::find_if(std::begin(m), std::end(m),                                      \\\par
                               [&j]({\cf17 const} std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> {\cf18 bool} \\\par
        \{                                                                                       \\\par
            return ej_pair.second == j;                                                         \\\par
        \});                                                                                     \\\par
        e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \\\par
    \}\par
}
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
macro to briefly define a mapping between an enum and JSON }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 3.4.0 \par
}}}{
Definition at line {\b 2310} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_TO\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_TO}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_TO( v1)\~ nlohmann_json_j[#v1] = nlohmann_json_t.v1;}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 2486} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_VERSION_MAJOR\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_VERSION_MAJOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_VERSION_MAJOR\~ 3}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_VERSION_MINOR\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_VERSION_MINOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_VERSION_MINOR\~ 10}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b json.hpp}.}\par
}
{\xe \v NLOHMANN_JSON_VERSION_PATCH\:json.hpp}
{\xe \v json.hpp\:NLOHMANN_JSON_VERSION_PATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NLOHMANN_JSON_VERSION_PATCH\~ 2}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b json.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v operator""_json\:json.hpp}
{\xe \v json.hpp\:operator""_json}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b nlohmann::json} operator""_json (const char *  {\i s}, std::size_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
user-defined string literal for JSON values }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This operator implements a user-defined string literal for JSON objects. It can be used by adding {\f2 "_json"}  to a string literal and returns a JSON object if no parse error occurred.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i s} \cell }{a string representation of a JSON object \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i n} \cell }{the length of string {\i s}  \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a JSON object\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 1.0.0 \par
}}}{
Definition at line {\b 26439} of file {\b json.hpp}.}\par
}
{\xe \v operator""_json_pointer\:json.hpp}
{\xe \v json.hpp\:operator""_json_pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b nlohmann::json::json_pointer} operator""_json_pointer (const char *  {\i s}, std::size_t  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
user-defined string literal for JSON pointer }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This operator implements a user-defined string literal for JSON Pointers. It can be used by adding {\f2 "_json_pointer"}  to a string literal and returns a JSON pointer object if no parse error occurred.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i s} \cell }{a string representation of a JSON Pointer \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i n} \cell }{the length of string {\i s}  \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
a JSON pointer object\par
}}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Since\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
version 2.0.0 \par
}}}{
Definition at line {\b 26458} of file {\b json.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
json.hpp\par \pard\plain 
{\tc\tcl2 \v Client/json.hpp}
{\xe \v Client/json.hpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /*}\par
00002 {\cf20     __ _____ _____ _____}\par
00003 {\cf20  __|  |   __|     |   | |  JSON for Modern C++}\par
00004 {\cf20 |  |  |__   |  |  | | | |  version 3.10.2}\par
00005 {\cf20 |_____|_____|_____|_|___|  https://github.com/nlohmann/json}\par
00006 {\cf20 }\par
00007 {\cf20 Licensed under the MIT License <http://opensource.org/licenses/MIT>.}\par
00008 {\cf20 SPDX-License-Identifier: MIT}\par
00009 {\cf20 Copyright (c) 2013-2019 Niels Lohmann <http://nlohmann.me>.}\par
00010 {\cf20 }\par
00011 {\cf20 Permission is hereby  granted, free of charge, to any  person obtaining a copy}\par
00012 {\cf20 of this software and associated  documentation files (the "Software"), to deal}\par
00013 {\cf20 in the Software  without restriction, including without  limitation the rights}\par
00014 {\cf20 to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell}\par
00015 {\cf20 copies  of  the Software,  and  to  permit persons  to  whom  the Software  is}\par
00016 {\cf20 furnished to do so, subject to the following conditions:}\par
00017 {\cf20 }\par
00018 {\cf20 The above copyright notice and this permission notice shall be included in all}\par
00019 {\cf20 copies or substantial portions of the Software.}\par
00020 {\cf20 }\par
00021 {\cf20 THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR}\par
00022 {\cf20 IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,}\par
00023 {\cf20 FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE}\par
00024 {\cf20 AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER}\par
00025 {\cf20 LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,}\par
00026 {\cf20 OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE}\par
00027 {\cf20 SOFTWARE.}\par
00028 {\cf20 */}\par
00029 \par
00030 {\cf21 #ifndef INCLUDE_NLOHMANN_JSON_HPP_}\par
00031 {\cf21 #define INCLUDE_NLOHMANN_JSON_HPP_}\par
00032 \par
00033 {\cf21 #define NLOHMANN_JSON_VERSION_MAJOR 3}\par
00034 {\cf21 #define NLOHMANN_JSON_VERSION_MINOR 10}\par
00035 {\cf21 #define NLOHMANN_JSON_VERSION_PATCH 2}\par
00036 \par
00037 {\cf21 #include <algorithm>} {\cf20 // all_of, find, for_each}\par
00038 {\cf21 #include <cstddef>} {\cf20 // nullptr_t, ptrdiff_t, size_t}\par
00039 {\cf21 #include <functional>} {\cf20 // hash, less}\par
00040 {\cf21 #include <initializer_list>} {\cf20 // initializer_list}\par
00041 {\cf21 #ifndef JSON_NO_IO}\par
00042 {\cf21     #include <iosfwd>} {\cf20 // istream, ostream}\par
00043 {\cf21 #endif  }{\cf20 // JSON_NO_IO}\par
00044 {\cf21 #include <iterator>} {\cf20 // random_access_iterator_tag}\par
00045 {\cf21 #include <memory>} {\cf20 // unique_ptr}\par
00046 {\cf21 #include <numeric>} {\cf20 // accumulate}\par
00047 {\cf21 #include <string>} {\cf20 // string, stoi, to_string}\par
00048 {\cf21 #include <utility>} {\cf20 // declval, forward, move, pair, swap}\par
00049 {\cf21 #include <vector>} {\cf20 // vector}\par
00050 \par
00051 {\cf20 // #include <nlohmann/adl_serializer.hpp>}\par
00052 \par
00053 \par
00054 {\cf21 #include <type_traits>}\par
00055 {\cf21 #include <utility>}\par
00056 \par
00057 {\cf20 // #include <nlohmann/detail/conversions/from_json.hpp>}\par
00058 \par
00059 \par
00060 {\cf21 #include <algorithm>} {\cf20 // transform}\par
00061 {\cf21 #include <array>} {\cf20 // array}\par
00062 {\cf21 #include <forward_list>} {\cf20 // forward_list}\par
00063 {\cf21 #include <iterator>} {\cf20 // inserter, front_inserter, end}\par
00064 {\cf21 #include <map>} {\cf20 // map}\par
00065 {\cf21 #include <string>} {\cf20 // string}\par
00066 {\cf21 #include <tuple>} {\cf20 // tuple, make_tuple}\par
00067 {\cf21 #include <type_traits>} {\cf20 // is_arithmetic, is_same, is_enum, underlying_type, is_convertible}\par
00068 {\cf21 #include <unordered_map>} {\cf20 // unordered_map}\par
00069 {\cf21 #include <utility>} {\cf20 // pair, declval}\par
00070 {\cf21 #include <valarray>} {\cf20 // valarray}\par
00071 \par
00072 {\cf20 // #include <nlohmann/detail/exceptions.hpp>}\par
00073 \par
00074 \par
00075 {\cf21 #include <exception>} {\cf20 // exception}\par
00076 {\cf21 #include <stdexcept>} {\cf20 // runtime_error}\par
00077 {\cf21 #include <string>} {\cf20 // to_string}\par
00078 {\cf21 #include <vector>} {\cf20 // vector}\par
00079 \par
00080 {\cf20 // #include <nlohmann/detail/value_t.hpp>}\par
00081 \par
00082 \par
00083 {\cf21 #include <array>} {\cf20 // array}\par
00084 {\cf21 #include <cstddef>} {\cf20 // size_t}\par
00085 {\cf21 #include <cstdint>} {\cf20 // uint8_t}\par
00086 {\cf21 #include <string>} {\cf20 // string}\par
00087 \par
00088 {\cf17 namespace }nlohmann\par
00089 \{\par
00090 {\cf17 namespace }detail\par
00091 \{\par
00093 {\cf20 // JSON type enumeration //}\par
00095 {\cf20 }\par
00120 {\cf17 enum class} value_t : std::uint8_t\par
00121 \{\par
00122     {\cf17 null},             \par
00123     object,           \par
00124     array,            \par
00125     string,           \par
00126     boolean,          \par
00127     number_integer,   \par
00128     number_unsigned,  \par
00129     number_float,     \par
00130     binary,           \par
00131     discarded         \par
00132 \};\par
00133 \par
00147 {\cf17 inline} {\cf18 bool} operator<({\cf17 const} value_t lhs, {\cf17 const} value_t rhs) {\cf17 noexcept}\par
00148 \{\par
00149     {\cf17 static} {\cf17 constexpr} std::array<std::uint8_t, 9> order = \{\{\par
00150             0 {\cf20 /* null */}, 3 {\cf20 /* object */}, 4 {\cf20 /* array */}, 5 {\cf20 /* string */},\par
00151             1 {\cf20 /* boolean */}, 2 {\cf20 /* integer */}, 2 {\cf20 /* unsigned */}, 2 {\cf20 /* float */},\par
00152             6 {\cf20 /* binary */}\par
00153         \}\par
00154     \};\par
00155 \par
00156     {\cf17 const} {\cf17 auto} l_index = {\cf17 static_cast<}std::size_t{\cf17 >}(lhs);\par
00157     {\cf17 const} {\cf17 auto} r_index = {\cf17 static_cast<}std::size_t{\cf17 >}(rhs);\par
00158     {\cf19 return} l_index < order.size() && r_index < order.size() && order[l_index] < order[r_index];\par
00159 \}\par
00160 \}  {\cf20 // namespace detail}\par
00161 \}  {\cf20 // namespace nlohmann}\par
00162 \par
00163 {\cf20 // #include <nlohmann/detail/string_escape.hpp>}\par
00164 \par
00165 \par
00166 {\cf21 #include <string>}\par
00167 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
00168 \par
00169 \par
00170 {\cf21 #include <utility>} {\cf20 // pair}\par
00171 {\cf20 // #include <nlohmann/thirdparty/hedley/hedley.hpp>}\par
00172 \par
00173 \par
00174 {\cf20 /* Hedley - https://nemequ.github.io/hedley}\par
00175 {\cf20  * Created by Evan Nemerson <evan@nemerson.com>}\par
00176 {\cf20  *}\par
00177 {\cf20  * To the extent possible under law, the author(s) have dedicated all}\par
00178 {\cf20  * copyright and related and neighboring rights to this software to}\par
00179 {\cf20  * the public domain worldwide. This software is distributed without}\par
00180 {\cf20  * any warranty.}\par
00181 {\cf20  *}\par
00182 {\cf20  * For details, see <http://creativecommons.org/publicdomain/zero/1.0/>.}\par
00183 {\cf20  * SPDX-License-Identifier: CC0-1.0}\par
00184 {\cf20  */}\par
00185 \par
00186 {\cf21 #if !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < 15)}\par
00187 {\cf21 #if defined(JSON_HEDLEY_VERSION)}\par
00188 {\cf21     #undef JSON_HEDLEY_VERSION}\par
00189 {\cf21 #endif}\par
00190 {\cf21 #define JSON_HEDLEY_VERSION 15}\par
00191 \par
00192 {\cf21 #if defined(JSON_HEDLEY_STRINGIFY_EX)}\par
00193 {\cf21     #undef JSON_HEDLEY_STRINGIFY_EX}\par
00194 {\cf21 #endif}\par
00195 {\cf21 #define JSON_HEDLEY_STRINGIFY_EX(x) #x}\par
00196 \par
00197 {\cf21 #if defined(JSON_HEDLEY_STRINGIFY)}\par
00198 {\cf21     #undef JSON_HEDLEY_STRINGIFY}\par
00199 {\cf21 #endif}\par
00200 {\cf21 #define JSON_HEDLEY_STRINGIFY(x) JSON_HEDLEY_STRINGIFY_EX(x)}\par
00201 \par
00202 {\cf21 #if defined(JSON_HEDLEY_CONCAT_EX)}\par
00203 {\cf21     #undef JSON_HEDLEY_CONCAT_EX}\par
00204 {\cf21 #endif}\par
00205 {\cf21 #define JSON_HEDLEY_CONCAT_EX(a,b) a##b}\par
00206 \par
00207 {\cf21 #if defined(JSON_HEDLEY_CONCAT)}\par
00208 {\cf21     #undef JSON_HEDLEY_CONCAT}\par
00209 {\cf21 #endif}\par
00210 {\cf21 #define JSON_HEDLEY_CONCAT(a,b) JSON_HEDLEY_CONCAT_EX(a,b)}\par
00211 \par
00212 {\cf21 #if defined(JSON_HEDLEY_CONCAT3_EX)}\par
00213 {\cf21     #undef JSON_HEDLEY_CONCAT3_EX}\par
00214 {\cf21 #endif}\par
00215 {\cf21 #define JSON_HEDLEY_CONCAT3_EX(a,b,c) a##b##c}\par
00216 \par
00217 {\cf21 #if defined(JSON_HEDLEY_CONCAT3)}\par
00218 {\cf21     #undef JSON_HEDLEY_CONCAT3}\par
00219 {\cf21 #endif}\par
00220 {\cf21 #define JSON_HEDLEY_CONCAT3(a,b,c) JSON_HEDLEY_CONCAT3_EX(a,b,c)}\par
00221 \par
00222 {\cf21 #if defined(JSON_HEDLEY_VERSION_ENCODE)}\par
00223 {\cf21     #undef JSON_HEDLEY_VERSION_ENCODE}\par
00224 {\cf21 #endif}\par
00225 {\cf21 #define JSON_HEDLEY_VERSION_ENCODE(major,minor,revision) (((major) * 1000000) + ((minor) * 1000) + (revision))}\par
00226 \par
00227 {\cf21 #if defined(JSON_HEDLEY_VERSION_DECODE_MAJOR)}\par
00228 {\cf21     #undef JSON_HEDLEY_VERSION_DECODE_MAJOR}\par
00229 {\cf21 #endif}\par
00230 {\cf21 #define JSON_HEDLEY_VERSION_DECODE_MAJOR(version) ((version) / 1000000)}\par
00231 \par
00232 {\cf21 #if defined(JSON_HEDLEY_VERSION_DECODE_MINOR)}\par
00233 {\cf21     #undef JSON_HEDLEY_VERSION_DECODE_MINOR}\par
00234 {\cf21 #endif}\par
00235 {\cf21 #define JSON_HEDLEY_VERSION_DECODE_MINOR(version) (((version) % 1000000) / 1000)}\par
00236 \par
00237 {\cf21 #if defined(JSON_HEDLEY_VERSION_DECODE_REVISION)}\par
00238 {\cf21     #undef JSON_HEDLEY_VERSION_DECODE_REVISION}\par
00239 {\cf21 #endif}\par
00240 {\cf21 #define JSON_HEDLEY_VERSION_DECODE_REVISION(version) ((version) % 1000)}\par
00241 \par
00242 {\cf21 #if defined(JSON_HEDLEY_GNUC_VERSION)}\par
00243 {\cf21     #undef JSON_HEDLEY_GNUC_VERSION}\par
00244 {\cf21 #endif}\par
00245 {\cf21 #if defined(__GNUC__) && defined(__GNUC_PATCHLEVEL__)}\par
00246 {\cf21     #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)}\par
00247 {\cf21 #elif defined(__GNUC__)}\par
00248 {\cf21     #define JSON_HEDLEY_GNUC_VERSION JSON_HEDLEY_VERSION_ENCODE(__GNUC__, __GNUC_MINOR__, 0)}\par
00249 {\cf21 #endif}\par
00250 \par
00251 {\cf21 #if defined(JSON_HEDLEY_GNUC_VERSION_CHECK)}\par
00252 {\cf21     #undef JSON_HEDLEY_GNUC_VERSION_CHECK}\par
00253 {\cf21 #endif}\par
00254 {\cf21 #if defined(JSON_HEDLEY_GNUC_VERSION)}\par
00255 {\cf21     #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GNUC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00256 {\cf21 #else}\par
00257 {\cf21     #define JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch) (0)}\par
00258 {\cf21 #endif}\par
00259 \par
00260 {\cf21 #if defined(JSON_HEDLEY_MSVC_VERSION)}\par
00261 {\cf21     #undef JSON_HEDLEY_MSVC_VERSION}\par
00262 {\cf21 #endif}\par
00263 {\cf21 #if defined(_MSC_FULL_VER) && (_MSC_FULL_VER >= 140000000) && !defined(__ICL)}\par
00264 {\cf21     #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 10000000, (_MSC_FULL_VER % 10000000) / 100000, (_MSC_FULL_VER % 100000) / 100)}\par
00265 {\cf21 #elif defined(_MSC_FULL_VER) && !defined(__ICL)}\par
00266 {\cf21     #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_FULL_VER / 1000000, (_MSC_FULL_VER % 1000000) / 10000, (_MSC_FULL_VER % 10000) / 10)}\par
00267 {\cf21 #elif defined(_MSC_VER) && !defined(__ICL)}\par
00268 {\cf21     #define JSON_HEDLEY_MSVC_VERSION JSON_HEDLEY_VERSION_ENCODE(_MSC_VER / 100, _MSC_VER % 100, 0)}\par
00269 {\cf21 #endif}\par
00270 \par
00271 {\cf21 #if defined(JSON_HEDLEY_MSVC_VERSION_CHECK)}\par
00272 {\cf21     #undef JSON_HEDLEY_MSVC_VERSION_CHECK}\par
00273 {\cf21 #endif}\par
00274 {\cf21 #if !defined(JSON_HEDLEY_MSVC_VERSION)}\par
00275 {\cf21     #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (0)}\par
00276 {\cf21 #elif defined(_MSC_VER) && (_MSC_VER >= 1400)}\par
00277 {\cf21     #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 10000000) + (minor * 100000) + (patch)))}\par
00278 {\cf21 #elif defined(_MSC_VER) && (_MSC_VER >= 1200)}\par
00279 {\cf21     #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_FULL_VER >= ((major * 1000000) + (minor * 10000) + (patch)))}\par
00280 {\cf21 #else}\par
00281 {\cf21     #define JSON_HEDLEY_MSVC_VERSION_CHECK(major,minor,patch) (_MSC_VER >= ((major * 100) + (minor)))}\par
00282 {\cf21 #endif}\par
00283 \par
00284 {\cf21 #if defined(JSON_HEDLEY_INTEL_VERSION)}\par
00285 {\cf21     #undef JSON_HEDLEY_INTEL_VERSION}\par
00286 {\cf21 #endif}\par
00287 {\cf21 #if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && !defined(__ICL)}\par
00288 {\cf21     #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, __INTEL_COMPILER_UPDATE)}\par
00289 {\cf21 #elif defined(__INTEL_COMPILER) && !defined(__ICL)}\par
00290 {\cf21     #define JSON_HEDLEY_INTEL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER / 100, __INTEL_COMPILER % 100, 0)}\par
00291 {\cf21 #endif}\par
00292 \par
00293 {\cf21 #if defined(JSON_HEDLEY_INTEL_VERSION_CHECK)}\par
00294 {\cf21     #undef JSON_HEDLEY_INTEL_VERSION_CHECK}\par
00295 {\cf21 #endif}\par
00296 {\cf21 #if defined(JSON_HEDLEY_INTEL_VERSION)}\par
00297 {\cf21     #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00298 {\cf21 #else}\par
00299 {\cf21     #define JSON_HEDLEY_INTEL_VERSION_CHECK(major,minor,patch) (0)}\par
00300 {\cf21 #endif}\par
00301 \par
00302 {\cf21 #if defined(JSON_HEDLEY_INTEL_CL_VERSION)}\par
00303 {\cf21     #undef JSON_HEDLEY_INTEL_CL_VERSION}\par
00304 {\cf21 #endif}\par
00305 {\cf21 #if defined(__INTEL_COMPILER) && defined(__INTEL_COMPILER_UPDATE) && defined(__ICL)}\par
00306 {\cf21     #define JSON_HEDLEY_INTEL_CL_VERSION JSON_HEDLEY_VERSION_ENCODE(__INTEL_COMPILER, __INTEL_COMPILER_UPDATE, 0)}\par
00307 {\cf21 #endif}\par
00308 \par
00309 {\cf21 #if defined(JSON_HEDLEY_INTEL_CL_VERSION_CHECK)}\par
00310 {\cf21     #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK}\par
00311 {\cf21 #endif}\par
00312 {\cf21 #if defined(JSON_HEDLEY_INTEL_CL_VERSION)}\par
00313 {\cf21     #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_INTEL_CL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00314 {\cf21 #else}\par
00315 {\cf21     #define JSON_HEDLEY_INTEL_CL_VERSION_CHECK(major,minor,patch) (0)}\par
00316 {\cf21 #endif}\par
00317 \par
00318 {\cf21 #if defined(JSON_HEDLEY_PGI_VERSION)}\par
00319 {\cf21     #undef JSON_HEDLEY_PGI_VERSION}\par
00320 {\cf21 #endif}\par
00321 {\cf21 #if defined(__PGI) && defined(__PGIC__) && defined(__PGIC_MINOR__) && defined(__PGIC_PATCHLEVEL__)}\par
00322 {\cf21     #define JSON_HEDLEY_PGI_VERSION JSON_HEDLEY_VERSION_ENCODE(__PGIC__, __PGIC_MINOR__, __PGIC_PATCHLEVEL__)}\par
00323 {\cf21 #endif}\par
00324 \par
00325 {\cf21 #if defined(JSON_HEDLEY_PGI_VERSION_CHECK)}\par
00326 {\cf21     #undef JSON_HEDLEY_PGI_VERSION_CHECK}\par
00327 {\cf21 #endif}\par
00328 {\cf21 #if defined(JSON_HEDLEY_PGI_VERSION)}\par
00329 {\cf21     #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PGI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00330 {\cf21 #else}\par
00331 {\cf21     #define JSON_HEDLEY_PGI_VERSION_CHECK(major,minor,patch) (0)}\par
00332 {\cf21 #endif}\par
00333 \par
00334 {\cf21 #if defined(JSON_HEDLEY_SUNPRO_VERSION)}\par
00335 {\cf21     #undef JSON_HEDLEY_SUNPRO_VERSION}\par
00336 {\cf21 #endif}\par
00337 {\cf21 #if defined(__SUNPRO_C) && (__SUNPRO_C > 0x1000)}\par
00338 {\cf21     #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_C >> 16) & 0xf) * 10) + ((__SUNPRO_C >> 12) & 0xf), (((__SUNPRO_C >> 8) & 0xf) * 10) + ((__SUNPRO_C >> 4) & 0xf), (__SUNPRO_C & 0xf) * 10)}\par
00339 {\cf21 #elif defined(__SUNPRO_C)}\par
00340 {\cf21     #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_C >> 8) & 0xf, (__SUNPRO_C >> 4) & 0xf, (__SUNPRO_C) & 0xf)}\par
00341 {\cf21 #elif defined(__SUNPRO_CC) && (__SUNPRO_CC > 0x1000)}\par
00342 {\cf21     #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((((__SUNPRO_CC >> 16) & 0xf) * 10) + ((__SUNPRO_CC >> 12) & 0xf), (((__SUNPRO_CC >> 8) & 0xf) * 10) + ((__SUNPRO_CC >> 4) & 0xf), (__SUNPRO_CC & 0xf) * 10)}\par
00343 {\cf21 #elif defined(__SUNPRO_CC)}\par
00344 {\cf21     #define JSON_HEDLEY_SUNPRO_VERSION JSON_HEDLEY_VERSION_ENCODE((__SUNPRO_CC >> 8) & 0xf, (__SUNPRO_CC >> 4) & 0xf, (__SUNPRO_CC) & 0xf)}\par
00345 {\cf21 #endif}\par
00346 \par
00347 {\cf21 #if defined(JSON_HEDLEY_SUNPRO_VERSION_CHECK)}\par
00348 {\cf21     #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK}\par
00349 {\cf21 #endif}\par
00350 {\cf21 #if defined(JSON_HEDLEY_SUNPRO_VERSION)}\par
00351 {\cf21     #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_SUNPRO_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00352 {\cf21 #else}\par
00353 {\cf21     #define JSON_HEDLEY_SUNPRO_VERSION_CHECK(major,minor,patch) (0)}\par
00354 {\cf21 #endif}\par
00355 \par
00356 {\cf21 #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)}\par
00357 {\cf21     #undef JSON_HEDLEY_EMSCRIPTEN_VERSION}\par
00358 {\cf21 #endif}\par
00359 {\cf21 #if defined(__EMSCRIPTEN__)}\par
00360 {\cf21     #define JSON_HEDLEY_EMSCRIPTEN_VERSION JSON_HEDLEY_VERSION_ENCODE(__EMSCRIPTEN_major__, __EMSCRIPTEN_minor__, __EMSCRIPTEN_tiny__)}\par
00361 {\cf21 #endif}\par
00362 \par
00363 {\cf21 #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK)}\par
00364 {\cf21     #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK}\par
00365 {\cf21 #endif}\par
00366 {\cf21 #if defined(JSON_HEDLEY_EMSCRIPTEN_VERSION)}\par
00367 {\cf21     #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_EMSCRIPTEN_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00368 {\cf21 #else}\par
00369 {\cf21     #define JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK(major,minor,patch) (0)}\par
00370 {\cf21 #endif}\par
00371 \par
00372 {\cf21 #if defined(JSON_HEDLEY_ARM_VERSION)}\par
00373 {\cf21     #undef JSON_HEDLEY_ARM_VERSION}\par
00374 {\cf21 #endif}\par
00375 {\cf21 #if defined(__CC_ARM) && defined(__ARMCOMPILER_VERSION)}\par
00376 {\cf21     #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCOMPILER_VERSION / 1000000, (__ARMCOMPILER_VERSION % 1000000) / 10000, (__ARMCOMPILER_VERSION % 10000) / 100)}\par
00377 {\cf21 #elif defined(__CC_ARM) && defined(__ARMCC_VERSION)}\par
00378 {\cf21     #define JSON_HEDLEY_ARM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ARMCC_VERSION / 1000000, (__ARMCC_VERSION % 1000000) / 10000, (__ARMCC_VERSION % 10000) / 100)}\par
00379 {\cf21 #endif}\par
00380 \par
00381 {\cf21 #if defined(JSON_HEDLEY_ARM_VERSION_CHECK)}\par
00382 {\cf21     #undef JSON_HEDLEY_ARM_VERSION_CHECK}\par
00383 {\cf21 #endif}\par
00384 {\cf21 #if defined(JSON_HEDLEY_ARM_VERSION)}\par
00385 {\cf21     #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_ARM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00386 {\cf21 #else}\par
00387 {\cf21     #define JSON_HEDLEY_ARM_VERSION_CHECK(major,minor,patch) (0)}\par
00388 {\cf21 #endif}\par
00389 \par
00390 {\cf21 #if defined(JSON_HEDLEY_IBM_VERSION)}\par
00391 {\cf21     #undef JSON_HEDLEY_IBM_VERSION}\par
00392 {\cf21 #endif}\par
00393 {\cf21 #if defined(__ibmxl__)}\par
00394 {\cf21     #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__ibmxl_version__, __ibmxl_release__, __ibmxl_modification__)}\par
00395 {\cf21 #elif defined(__xlC__) && defined(__xlC_ver__)}\par
00396 {\cf21     #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, (__xlC_ver__ >> 8) & 0xff)}\par
00397 {\cf21 #elif defined(__xlC__)}\par
00398 {\cf21     #define JSON_HEDLEY_IBM_VERSION JSON_HEDLEY_VERSION_ENCODE(__xlC__ >> 8, __xlC__ & 0xff, 0)}\par
00399 {\cf21 #endif}\par
00400 \par
00401 {\cf21 #if defined(JSON_HEDLEY_IBM_VERSION_CHECK)}\par
00402 {\cf21     #undef JSON_HEDLEY_IBM_VERSION_CHECK}\par
00403 {\cf21 #endif}\par
00404 {\cf21 #if defined(JSON_HEDLEY_IBM_VERSION)}\par
00405 {\cf21     #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IBM_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00406 {\cf21 #else}\par
00407 {\cf21     #define JSON_HEDLEY_IBM_VERSION_CHECK(major,minor,patch) (0)}\par
00408 {\cf21 #endif}\par
00409 \par
00410 {\cf21 #if defined(JSON_HEDLEY_TI_VERSION)}\par
00411 {\cf21     #undef JSON_HEDLEY_TI_VERSION}\par
00412 {\cf21 #endif}\par
00413 {\cf21 #if \\}\par
00414 {\cf21     defined(__TI_COMPILER_VERSION__) && \\}\par
00415 {\cf21     ( \\}\par
00416 {\cf21       defined(__TMS470__) || defined(__TI_ARM__) || \\}\par
00417 {\cf21       defined(__MSP430__) || \\}\par
00418 {\cf21       defined(__TMS320C2000__) \\}\par
00419 {\cf21     )}\par
00420 {\cf21 #if (__TI_COMPILER_VERSION__ >= 16000000)}\par
00421 {\cf21     #define JSON_HEDLEY_TI_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))}\par
00422 {\cf21 #endif}\par
00423 {\cf21 #endif}\par
00424 \par
00425 {\cf21 #if defined(JSON_HEDLEY_TI_VERSION_CHECK)}\par
00426 {\cf21     #undef JSON_HEDLEY_TI_VERSION_CHECK}\par
00427 {\cf21 #endif}\par
00428 {\cf21 #if defined(JSON_HEDLEY_TI_VERSION)}\par
00429 {\cf21     #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00430 {\cf21 #else}\par
00431 {\cf21     #define JSON_HEDLEY_TI_VERSION_CHECK(major,minor,patch) (0)}\par
00432 {\cf21 #endif}\par
00433 \par
00434 {\cf21 #if defined(JSON_HEDLEY_TI_CL2000_VERSION)}\par
00435 {\cf21     #undef JSON_HEDLEY_TI_CL2000_VERSION}\par
00436 {\cf21 #endif}\par
00437 {\cf21 #if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C2000__)}\par
00438 {\cf21     #define JSON_HEDLEY_TI_CL2000_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))}\par
00439 {\cf21 #endif}\par
00440 \par
00441 {\cf21 #if defined(JSON_HEDLEY_TI_CL2000_VERSION_CHECK)}\par
00442 {\cf21     #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK}\par
00443 {\cf21 #endif}\par
00444 {\cf21 #if defined(JSON_HEDLEY_TI_CL2000_VERSION)}\par
00445 {\cf21     #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL2000_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00446 {\cf21 #else}\par
00447 {\cf21     #define JSON_HEDLEY_TI_CL2000_VERSION_CHECK(major,minor,patch) (0)}\par
00448 {\cf21 #endif}\par
00449 \par
00450 {\cf21 #if defined(JSON_HEDLEY_TI_CL430_VERSION)}\par
00451 {\cf21     #undef JSON_HEDLEY_TI_CL430_VERSION}\par
00452 {\cf21 #endif}\par
00453 {\cf21 #if defined(__TI_COMPILER_VERSION__) && defined(__MSP430__)}\par
00454 {\cf21     #define JSON_HEDLEY_TI_CL430_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))}\par
00455 {\cf21 #endif}\par
00456 \par
00457 {\cf21 #if defined(JSON_HEDLEY_TI_CL430_VERSION_CHECK)}\par
00458 {\cf21     #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK}\par
00459 {\cf21 #endif}\par
00460 {\cf21 #if defined(JSON_HEDLEY_TI_CL430_VERSION)}\par
00461 {\cf21     #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL430_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00462 {\cf21 #else}\par
00463 {\cf21     #define JSON_HEDLEY_TI_CL430_VERSION_CHECK(major,minor,patch) (0)}\par
00464 {\cf21 #endif}\par
00465 \par
00466 {\cf21 #if defined(JSON_HEDLEY_TI_ARMCL_VERSION)}\par
00467 {\cf21     #undef JSON_HEDLEY_TI_ARMCL_VERSION}\par
00468 {\cf21 #endif}\par
00469 {\cf21 #if defined(__TI_COMPILER_VERSION__) && (defined(__TMS470__) || defined(__TI_ARM__))}\par
00470 {\cf21     #define JSON_HEDLEY_TI_ARMCL_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))}\par
00471 {\cf21 #endif}\par
00472 \par
00473 {\cf21 #if defined(JSON_HEDLEY_TI_ARMCL_VERSION_CHECK)}\par
00474 {\cf21     #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK}\par
00475 {\cf21 #endif}\par
00476 {\cf21 #if defined(JSON_HEDLEY_TI_ARMCL_VERSION)}\par
00477 {\cf21     #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_ARMCL_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00478 {\cf21 #else}\par
00479 {\cf21     #define JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(major,minor,patch) (0)}\par
00480 {\cf21 #endif}\par
00481 \par
00482 {\cf21 #if defined(JSON_HEDLEY_TI_CL6X_VERSION)}\par
00483 {\cf21     #undef JSON_HEDLEY_TI_CL6X_VERSION}\par
00484 {\cf21 #endif}\par
00485 {\cf21 #if defined(__TI_COMPILER_VERSION__) && defined(__TMS320C6X__)}\par
00486 {\cf21     #define JSON_HEDLEY_TI_CL6X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))}\par
00487 {\cf21 #endif}\par
00488 \par
00489 {\cf21 #if defined(JSON_HEDLEY_TI_CL6X_VERSION_CHECK)}\par
00490 {\cf21     #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK}\par
00491 {\cf21 #endif}\par
00492 {\cf21 #if defined(JSON_HEDLEY_TI_CL6X_VERSION)}\par
00493 {\cf21     #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL6X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00494 {\cf21 #else}\par
00495 {\cf21     #define JSON_HEDLEY_TI_CL6X_VERSION_CHECK(major,minor,patch) (0)}\par
00496 {\cf21 #endif}\par
00497 \par
00498 {\cf21 #if defined(JSON_HEDLEY_TI_CL7X_VERSION)}\par
00499 {\cf21     #undef JSON_HEDLEY_TI_CL7X_VERSION}\par
00500 {\cf21 #endif}\par
00501 {\cf21 #if defined(__TI_COMPILER_VERSION__) && defined(__C7000__)}\par
00502 {\cf21     #define JSON_HEDLEY_TI_CL7X_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))}\par
00503 {\cf21 #endif}\par
00504 \par
00505 {\cf21 #if defined(JSON_HEDLEY_TI_CL7X_VERSION_CHECK)}\par
00506 {\cf21     #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK}\par
00507 {\cf21 #endif}\par
00508 {\cf21 #if defined(JSON_HEDLEY_TI_CL7X_VERSION)}\par
00509 {\cf21     #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CL7X_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00510 {\cf21 #else}\par
00511 {\cf21     #define JSON_HEDLEY_TI_CL7X_VERSION_CHECK(major,minor,patch) (0)}\par
00512 {\cf21 #endif}\par
00513 \par
00514 {\cf21 #if defined(JSON_HEDLEY_TI_CLPRU_VERSION)}\par
00515 {\cf21     #undef JSON_HEDLEY_TI_CLPRU_VERSION}\par
00516 {\cf21 #endif}\par
00517 {\cf21 #if defined(__TI_COMPILER_VERSION__) && defined(__PRU__)}\par
00518 {\cf21     #define JSON_HEDLEY_TI_CLPRU_VERSION JSON_HEDLEY_VERSION_ENCODE(__TI_COMPILER_VERSION__ / 1000000, (__TI_COMPILER_VERSION__ % 1000000) / 1000, (__TI_COMPILER_VERSION__ % 1000))}\par
00519 {\cf21 #endif}\par
00520 \par
00521 {\cf21 #if defined(JSON_HEDLEY_TI_CLPRU_VERSION_CHECK)}\par
00522 {\cf21     #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK}\par
00523 {\cf21 #endif}\par
00524 {\cf21 #if defined(JSON_HEDLEY_TI_CLPRU_VERSION)}\par
00525 {\cf21     #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TI_CLPRU_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00526 {\cf21 #else}\par
00527 {\cf21     #define JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(major,minor,patch) (0)}\par
00528 {\cf21 #endif}\par
00529 \par
00530 {\cf21 #if defined(JSON_HEDLEY_CRAY_VERSION)}\par
00531 {\cf21     #undef JSON_HEDLEY_CRAY_VERSION}\par
00532 {\cf21 #endif}\par
00533 {\cf21 #if defined(_CRAYC)}\par
00534 {\cf21     #if defined(_RELEASE_PATCHLEVEL)}\par
00535 {\cf21         #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, _RELEASE_PATCHLEVEL)}\par
00536 {\cf21     #else}\par
00537 {\cf21         #define JSON_HEDLEY_CRAY_VERSION JSON_HEDLEY_VERSION_ENCODE(_RELEASE_MAJOR, _RELEASE_MINOR, 0)}\par
00538 {\cf21     #endif}\par
00539 {\cf21 #endif}\par
00540 \par
00541 {\cf21 #if defined(JSON_HEDLEY_CRAY_VERSION_CHECK)}\par
00542 {\cf21     #undef JSON_HEDLEY_CRAY_VERSION_CHECK}\par
00543 {\cf21 #endif}\par
00544 {\cf21 #if defined(JSON_HEDLEY_CRAY_VERSION)}\par
00545 {\cf21     #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_CRAY_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00546 {\cf21 #else}\par
00547 {\cf21     #define JSON_HEDLEY_CRAY_VERSION_CHECK(major,minor,patch) (0)}\par
00548 {\cf21 #endif}\par
00549 \par
00550 {\cf21 #if defined(JSON_HEDLEY_IAR_VERSION)}\par
00551 {\cf21     #undef JSON_HEDLEY_IAR_VERSION}\par
00552 {\cf21 #endif}\par
00553 {\cf21 #if defined(__IAR_SYSTEMS_ICC__)}\par
00554 {\cf21     #if __VER__ > 1000}\par
00555 {\cf21         #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE((__VER__ / 1000000), ((__VER__ / 1000) % 1000), (__VER__ % 1000))}\par
00556 {\cf21     #else}\par
00557 {\cf21         #define JSON_HEDLEY_IAR_VERSION JSON_HEDLEY_VERSION_ENCODE(__VER__ / 100, __VER__ % 100, 0)}\par
00558 {\cf21     #endif}\par
00559 {\cf21 #endif}\par
00560 \par
00561 {\cf21 #if defined(JSON_HEDLEY_IAR_VERSION_CHECK)}\par
00562 {\cf21     #undef JSON_HEDLEY_IAR_VERSION_CHECK}\par
00563 {\cf21 #endif}\par
00564 {\cf21 #if defined(JSON_HEDLEY_IAR_VERSION)}\par
00565 {\cf21     #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_IAR_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00566 {\cf21 #else}\par
00567 {\cf21     #define JSON_HEDLEY_IAR_VERSION_CHECK(major,minor,patch) (0)}\par
00568 {\cf21 #endif}\par
00569 \par
00570 {\cf21 #if defined(JSON_HEDLEY_TINYC_VERSION)}\par
00571 {\cf21     #undef JSON_HEDLEY_TINYC_VERSION}\par
00572 {\cf21 #endif}\par
00573 {\cf21 #if defined(__TINYC__)}\par
00574 {\cf21     #define JSON_HEDLEY_TINYC_VERSION JSON_HEDLEY_VERSION_ENCODE(__TINYC__ / 1000, (__TINYC__ / 100) % 10, __TINYC__ % 100)}\par
00575 {\cf21 #endif}\par
00576 \par
00577 {\cf21 #if defined(JSON_HEDLEY_TINYC_VERSION_CHECK)}\par
00578 {\cf21     #undef JSON_HEDLEY_TINYC_VERSION_CHECK}\par
00579 {\cf21 #endif}\par
00580 {\cf21 #if defined(JSON_HEDLEY_TINYC_VERSION)}\par
00581 {\cf21     #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_TINYC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00582 {\cf21 #else}\par
00583 {\cf21     #define JSON_HEDLEY_TINYC_VERSION_CHECK(major,minor,patch) (0)}\par
00584 {\cf21 #endif}\par
00585 \par
00586 {\cf21 #if defined(JSON_HEDLEY_DMC_VERSION)}\par
00587 {\cf21     #undef JSON_HEDLEY_DMC_VERSION}\par
00588 {\cf21 #endif}\par
00589 {\cf21 #if defined(__DMC__)}\par
00590 {\cf21     #define JSON_HEDLEY_DMC_VERSION JSON_HEDLEY_VERSION_ENCODE(__DMC__ >> 8, (__DMC__ >> 4) & 0xf, __DMC__ & 0xf)}\par
00591 {\cf21 #endif}\par
00592 \par
00593 {\cf21 #if defined(JSON_HEDLEY_DMC_VERSION_CHECK)}\par
00594 {\cf21     #undef JSON_HEDLEY_DMC_VERSION_CHECK}\par
00595 {\cf21 #endif}\par
00596 {\cf21 #if defined(JSON_HEDLEY_DMC_VERSION)}\par
00597 {\cf21     #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_DMC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00598 {\cf21 #else}\par
00599 {\cf21     #define JSON_HEDLEY_DMC_VERSION_CHECK(major,minor,patch) (0)}\par
00600 {\cf21 #endif}\par
00601 \par
00602 {\cf21 #if defined(JSON_HEDLEY_COMPCERT_VERSION)}\par
00603 {\cf21     #undef JSON_HEDLEY_COMPCERT_VERSION}\par
00604 {\cf21 #endif}\par
00605 {\cf21 #if defined(__COMPCERT_VERSION__)}\par
00606 {\cf21     #define JSON_HEDLEY_COMPCERT_VERSION JSON_HEDLEY_VERSION_ENCODE(__COMPCERT_VERSION__ / 10000, (__COMPCERT_VERSION__ / 100) % 100, __COMPCERT_VERSION__ % 100)}\par
00607 {\cf21 #endif}\par
00608 \par
00609 {\cf21 #if defined(JSON_HEDLEY_COMPCERT_VERSION_CHECK)}\par
00610 {\cf21     #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK}\par
00611 {\cf21 #endif}\par
00612 {\cf21 #if defined(JSON_HEDLEY_COMPCERT_VERSION)}\par
00613 {\cf21     #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_COMPCERT_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00614 {\cf21 #else}\par
00615 {\cf21     #define JSON_HEDLEY_COMPCERT_VERSION_CHECK(major,minor,patch) (0)}\par
00616 {\cf21 #endif}\par
00617 \par
00618 {\cf21 #if defined(JSON_HEDLEY_PELLES_VERSION)}\par
00619 {\cf21     #undef JSON_HEDLEY_PELLES_VERSION}\par
00620 {\cf21 #endif}\par
00621 {\cf21 #if defined(__POCC__)}\par
00622 {\cf21     #define JSON_HEDLEY_PELLES_VERSION JSON_HEDLEY_VERSION_ENCODE(__POCC__ / 100, __POCC__ % 100, 0)}\par
00623 {\cf21 #endif}\par
00624 \par
00625 {\cf21 #if defined(JSON_HEDLEY_PELLES_VERSION_CHECK)}\par
00626 {\cf21     #undef JSON_HEDLEY_PELLES_VERSION_CHECK}\par
00627 {\cf21 #endif}\par
00628 {\cf21 #if defined(JSON_HEDLEY_PELLES_VERSION)}\par
00629 {\cf21     #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_PELLES_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00630 {\cf21 #else}\par
00631 {\cf21     #define JSON_HEDLEY_PELLES_VERSION_CHECK(major,minor,patch) (0)}\par
00632 {\cf21 #endif}\par
00633 \par
00634 {\cf21 #if defined(JSON_HEDLEY_MCST_LCC_VERSION)}\par
00635 {\cf21     #undef JSON_HEDLEY_MCST_LCC_VERSION}\par
00636 {\cf21 #endif}\par
00637 {\cf21 #if defined(__LCC__) && defined(__LCC_MINOR__)}\par
00638 {\cf21     #define JSON_HEDLEY_MCST_LCC_VERSION JSON_HEDLEY_VERSION_ENCODE(__LCC__ / 100, __LCC__ % 100, __LCC_MINOR__)}\par
00639 {\cf21 #endif}\par
00640 \par
00641 {\cf21 #if defined(JSON_HEDLEY_MCST_LCC_VERSION_CHECK)}\par
00642 {\cf21     #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK}\par
00643 {\cf21 #endif}\par
00644 {\cf21 #if defined(JSON_HEDLEY_MCST_LCC_VERSION)}\par
00645 {\cf21     #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_MCST_LCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00646 {\cf21 #else}\par
00647 {\cf21     #define JSON_HEDLEY_MCST_LCC_VERSION_CHECK(major,minor,patch) (0)}\par
00648 {\cf21 #endif}\par
00649 \par
00650 {\cf21 #if defined(JSON_HEDLEY_GCC_VERSION)}\par
00651 {\cf21     #undef JSON_HEDLEY_GCC_VERSION}\par
00652 {\cf21 #endif}\par
00653 {\cf21 #if \\}\par
00654 {\cf21     defined(JSON_HEDLEY_GNUC_VERSION) && \\}\par
00655 {\cf21     !defined(__clang__) && \\}\par
00656 {\cf21     !defined(JSON_HEDLEY_INTEL_VERSION) && \\}\par
00657 {\cf21     !defined(JSON_HEDLEY_PGI_VERSION) && \\}\par
00658 {\cf21     !defined(JSON_HEDLEY_ARM_VERSION) && \\}\par
00659 {\cf21     !defined(JSON_HEDLEY_CRAY_VERSION) && \\}\par
00660 {\cf21     !defined(JSON_HEDLEY_TI_VERSION) && \\}\par
00661 {\cf21     !defined(JSON_HEDLEY_TI_ARMCL_VERSION) && \\}\par
00662 {\cf21     !defined(JSON_HEDLEY_TI_CL430_VERSION) && \\}\par
00663 {\cf21     !defined(JSON_HEDLEY_TI_CL2000_VERSION) && \\}\par
00664 {\cf21     !defined(JSON_HEDLEY_TI_CL6X_VERSION) && \\}\par
00665 {\cf21     !defined(JSON_HEDLEY_TI_CL7X_VERSION) && \\}\par
00666 {\cf21     !defined(JSON_HEDLEY_TI_CLPRU_VERSION) && \\}\par
00667 {\cf21     !defined(__COMPCERT__) && \\}\par
00668 {\cf21     !defined(JSON_HEDLEY_MCST_LCC_VERSION)}\par
00669 {\cf21     #define JSON_HEDLEY_GCC_VERSION JSON_HEDLEY_GNUC_VERSION}\par
00670 {\cf21 #endif}\par
00671 \par
00672 {\cf21 #if defined(JSON_HEDLEY_GCC_VERSION_CHECK)}\par
00673 {\cf21     #undef JSON_HEDLEY_GCC_VERSION_CHECK}\par
00674 {\cf21 #endif}\par
00675 {\cf21 #if defined(JSON_HEDLEY_GCC_VERSION)}\par
00676 {\cf21     #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (JSON_HEDLEY_GCC_VERSION >= JSON_HEDLEY_VERSION_ENCODE(major, minor, patch))}\par
00677 {\cf21 #else}\par
00678 {\cf21     #define JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch) (0)}\par
00679 {\cf21 #endif}\par
00680 \par
00681 {\cf21 #if defined(JSON_HEDLEY_HAS_ATTRIBUTE)}\par
00682 {\cf21     #undef JSON_HEDLEY_HAS_ATTRIBUTE}\par
00683 {\cf21 #endif}\par
00684 {\cf21 #if \\}\par
00685 {\cf21   defined(__has_attribute) && \\}\par
00686 {\cf21   ( \\}\par
00687 {\cf21     (!defined(JSON_HEDLEY_IAR_VERSION) || JSON_HEDLEY_IAR_VERSION_CHECK(8,5,9)) \\}\par
00688 {\cf21   )}\par
00689 {\cf21 #  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) __has_attribute(attribute)}\par
00690 {\cf21 #else}\par
00691 {\cf21 #  define JSON_HEDLEY_HAS_ATTRIBUTE(attribute) (0)}\par
00692 {\cf21 #endif}\par
00693 \par
00694 {\cf21 #if defined(JSON_HEDLEY_GNUC_HAS_ATTRIBUTE)}\par
00695 {\cf21     #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE}\par
00696 {\cf21 #endif}\par
00697 {\cf21 #if defined(__has_attribute)}\par
00698 {\cf21     #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)}\par
00699 {\cf21 #else}\par
00700 {\cf21     #define JSON_HEDLEY_GNUC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)}\par
00701 {\cf21 #endif}\par
00702 \par
00703 {\cf21 #if defined(JSON_HEDLEY_GCC_HAS_ATTRIBUTE)}\par
00704 {\cf21     #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE}\par
00705 {\cf21 #endif}\par
00706 {\cf21 #if defined(__has_attribute)}\par
00707 {\cf21     #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)}\par
00708 {\cf21 #else}\par
00709 {\cf21     #define JSON_HEDLEY_GCC_HAS_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)}\par
00710 {\cf21 #endif}\par
00711 \par
00712 {\cf21 #if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE)}\par
00713 {\cf21     #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE}\par
00714 {\cf21 #endif}\par
00715 {\cf21 #if \\}\par
00716 {\cf21     defined(__has_cpp_attribute) && \\}\par
00717 {\cf21     defined(__cplusplus) && \\}\par
00718 {\cf21     (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0))}\par
00719 {\cf21     #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) __has_cpp_attribute(attribute)}\par
00720 {\cf21 #else}\par
00721 {\cf21     #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute) (0)}\par
00722 {\cf21 #endif}\par
00723 \par
00724 {\cf21 #if defined(JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS)}\par
00725 {\cf21     #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS}\par
00726 {\cf21 #endif}\par
00727 {\cf21 #if !defined(__cplusplus) || !defined(__has_cpp_attribute)}\par
00728 {\cf21     #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)}\par
00729 {\cf21 #elif \\}\par
00730 {\cf21     !defined(JSON_HEDLEY_PGI_VERSION) && \\}\par
00731 {\cf21     !defined(JSON_HEDLEY_IAR_VERSION) && \\}\par
00732 {\cf21     (!defined(JSON_HEDLEY_SUNPRO_VERSION) || JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0)) && \\}\par
00733 {\cf21     (!defined(JSON_HEDLEY_MSVC_VERSION) || JSON_HEDLEY_MSVC_VERSION_CHECK(19,20,0))}\par
00734 {\cf21     #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(ns::attribute)}\par
00735 {\cf21 #else}\par
00736 {\cf21     #define JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(ns,attribute) (0)}\par
00737 {\cf21 #endif}\par
00738 \par
00739 {\cf21 #if defined(JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE)}\par
00740 {\cf21     #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE}\par
00741 {\cf21 #endif}\par
00742 {\cf21 #if defined(__has_cpp_attribute) && defined(__cplusplus)}\par
00743 {\cf21     #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)}\par
00744 {\cf21 #else}\par
00745 {\cf21     #define JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)}\par
00746 {\cf21 #endif}\par
00747 \par
00748 {\cf21 #if defined(JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE)}\par
00749 {\cf21     #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE}\par
00750 {\cf21 #endif}\par
00751 {\cf21 #if defined(__has_cpp_attribute) && defined(__cplusplus)}\par
00752 {\cf21     #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) __has_cpp_attribute(attribute)}\par
00753 {\cf21 #else}\par
00754 {\cf21     #define JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)}\par
00755 {\cf21 #endif}\par
00756 \par
00757 {\cf21 #if defined(JSON_HEDLEY_HAS_BUILTIN)}\par
00758 {\cf21     #undef JSON_HEDLEY_HAS_BUILTIN}\par
00759 {\cf21 #endif}\par
00760 {\cf21 #if defined(__has_builtin)}\par
00761 {\cf21     #define JSON_HEDLEY_HAS_BUILTIN(builtin) __has_builtin(builtin)}\par
00762 {\cf21 #else}\par
00763 {\cf21     #define JSON_HEDLEY_HAS_BUILTIN(builtin) (0)}\par
00764 {\cf21 #endif}\par
00765 \par
00766 {\cf21 #if defined(JSON_HEDLEY_GNUC_HAS_BUILTIN)}\par
00767 {\cf21     #undef JSON_HEDLEY_GNUC_HAS_BUILTIN}\par
00768 {\cf21 #endif}\par
00769 {\cf21 #if defined(__has_builtin)}\par
00770 {\cf21     #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)}\par
00771 {\cf21 #else}\par
00772 {\cf21     #define JSON_HEDLEY_GNUC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)}\par
00773 {\cf21 #endif}\par
00774 \par
00775 {\cf21 #if defined(JSON_HEDLEY_GCC_HAS_BUILTIN)}\par
00776 {\cf21     #undef JSON_HEDLEY_GCC_HAS_BUILTIN}\par
00777 {\cf21 #endif}\par
00778 {\cf21 #if defined(__has_builtin)}\par
00779 {\cf21     #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) __has_builtin(builtin)}\par
00780 {\cf21 #else}\par
00781 {\cf21     #define JSON_HEDLEY_GCC_HAS_BUILTIN(builtin,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)}\par
00782 {\cf21 #endif}\par
00783 \par
00784 {\cf21 #if defined(JSON_HEDLEY_HAS_FEATURE)}\par
00785 {\cf21     #undef JSON_HEDLEY_HAS_FEATURE}\par
00786 {\cf21 #endif}\par
00787 {\cf21 #if defined(__has_feature)}\par
00788 {\cf21     #define JSON_HEDLEY_HAS_FEATURE(feature) __has_feature(feature)}\par
00789 {\cf21 #else}\par
00790 {\cf21     #define JSON_HEDLEY_HAS_FEATURE(feature) (0)}\par
00791 {\cf21 #endif}\par
00792 \par
00793 {\cf21 #if defined(JSON_HEDLEY_GNUC_HAS_FEATURE)}\par
00794 {\cf21     #undef JSON_HEDLEY_GNUC_HAS_FEATURE}\par
00795 {\cf21 #endif}\par
00796 {\cf21 #if defined(__has_feature)}\par
00797 {\cf21     #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)}\par
00798 {\cf21 #else}\par
00799 {\cf21     #define JSON_HEDLEY_GNUC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)}\par
00800 {\cf21 #endif}\par
00801 \par
00802 {\cf21 #if defined(JSON_HEDLEY_GCC_HAS_FEATURE)}\par
00803 {\cf21     #undef JSON_HEDLEY_GCC_HAS_FEATURE}\par
00804 {\cf21 #endif}\par
00805 {\cf21 #if defined(__has_feature)}\par
00806 {\cf21     #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) __has_feature(feature)}\par
00807 {\cf21 #else}\par
00808 {\cf21     #define JSON_HEDLEY_GCC_HAS_FEATURE(feature,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)}\par
00809 {\cf21 #endif}\par
00810 \par
00811 {\cf21 #if defined(JSON_HEDLEY_HAS_EXTENSION)}\par
00812 {\cf21     #undef JSON_HEDLEY_HAS_EXTENSION}\par
00813 {\cf21 #endif}\par
00814 {\cf21 #if defined(__has_extension)}\par
00815 {\cf21     #define JSON_HEDLEY_HAS_EXTENSION(extension) __has_extension(extension)}\par
00816 {\cf21 #else}\par
00817 {\cf21     #define JSON_HEDLEY_HAS_EXTENSION(extension) (0)}\par
00818 {\cf21 #endif}\par
00819 \par
00820 {\cf21 #if defined(JSON_HEDLEY_GNUC_HAS_EXTENSION)}\par
00821 {\cf21     #undef JSON_HEDLEY_GNUC_HAS_EXTENSION}\par
00822 {\cf21 #endif}\par
00823 {\cf21 #if defined(__has_extension)}\par
00824 {\cf21     #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)}\par
00825 {\cf21 #else}\par
00826 {\cf21     #define JSON_HEDLEY_GNUC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)}\par
00827 {\cf21 #endif}\par
00828 \par
00829 {\cf21 #if defined(JSON_HEDLEY_GCC_HAS_EXTENSION)}\par
00830 {\cf21     #undef JSON_HEDLEY_GCC_HAS_EXTENSION}\par
00831 {\cf21 #endif}\par
00832 {\cf21 #if defined(__has_extension)}\par
00833 {\cf21     #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) __has_extension(extension)}\par
00834 {\cf21 #else}\par
00835 {\cf21     #define JSON_HEDLEY_GCC_HAS_EXTENSION(extension,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)}\par
00836 {\cf21 #endif}\par
00837 \par
00838 {\cf21 #if defined(JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE)}\par
00839 {\cf21     #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE}\par
00840 {\cf21 #endif}\par
00841 {\cf21 #if defined(__has_declspec_attribute)}\par
00842 {\cf21     #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) __has_declspec_attribute(attribute)}\par
00843 {\cf21 #else}\par
00844 {\cf21     #define JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute) (0)}\par
00845 {\cf21 #endif}\par
00846 \par
00847 {\cf21 #if defined(JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE)}\par
00848 {\cf21     #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE}\par
00849 {\cf21 #endif}\par
00850 {\cf21 #if defined(__has_declspec_attribute)}\par
00851 {\cf21     #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)}\par
00852 {\cf21 #else}\par
00853 {\cf21     #define JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)}\par
00854 {\cf21 #endif}\par
00855 \par
00856 {\cf21 #if defined(JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE)}\par
00857 {\cf21     #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE}\par
00858 {\cf21 #endif}\par
00859 {\cf21 #if defined(__has_declspec_attribute)}\par
00860 {\cf21     #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) __has_declspec_attribute(attribute)}\par
00861 {\cf21 #else}\par
00862 {\cf21     #define JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE(attribute,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)}\par
00863 {\cf21 #endif}\par
00864 \par
00865 {\cf21 #if defined(JSON_HEDLEY_HAS_WARNING)}\par
00866 {\cf21     #undef JSON_HEDLEY_HAS_WARNING}\par
00867 {\cf21 #endif}\par
00868 {\cf21 #if defined(__has_warning)}\par
00869 {\cf21     #define JSON_HEDLEY_HAS_WARNING(warning) __has_warning(warning)}\par
00870 {\cf21 #else}\par
00871 {\cf21     #define JSON_HEDLEY_HAS_WARNING(warning) (0)}\par
00872 {\cf21 #endif}\par
00873 \par
00874 {\cf21 #if defined(JSON_HEDLEY_GNUC_HAS_WARNING)}\par
00875 {\cf21     #undef JSON_HEDLEY_GNUC_HAS_WARNING}\par
00876 {\cf21 #endif}\par
00877 {\cf21 #if defined(__has_warning)}\par
00878 {\cf21     #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)}\par
00879 {\cf21 #else}\par
00880 {\cf21     #define JSON_HEDLEY_GNUC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GNUC_VERSION_CHECK(major,minor,patch)}\par
00881 {\cf21 #endif}\par
00882 \par
00883 {\cf21 #if defined(JSON_HEDLEY_GCC_HAS_WARNING)}\par
00884 {\cf21     #undef JSON_HEDLEY_GCC_HAS_WARNING}\par
00885 {\cf21 #endif}\par
00886 {\cf21 #if defined(__has_warning)}\par
00887 {\cf21     #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) __has_warning(warning)}\par
00888 {\cf21 #else}\par
00889 {\cf21     #define JSON_HEDLEY_GCC_HAS_WARNING(warning,major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)}\par
00890 {\cf21 #endif}\par
00891 \par
00892 {\cf21 #if \\}\par
00893 {\cf21     (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \\}\par
00894 {\cf21     defined(__clang__) || \\}\par
00895 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \\}\par
00896 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
00897 {\cf21     JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \\}\par
00898 {\cf21     JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \\}\par
00899 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
00900 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
00901 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \\}\par
00902 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \\}\par
00903 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \\}\par
00904 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,0,0) || \\}\par
00905 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
00906 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
00907 {\cf21     JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0) || \\}\par
00908 {\cf21     JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,17) || \\}\par
00909 {\cf21     JSON_HEDLEY_SUNPRO_VERSION_CHECK(8,0,0) || \\}\par
00910 {\cf21     (JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) && defined(__C99_PRAGMA_OPERATOR))}\par
00911 {\cf21     #define JSON_HEDLEY_PRAGMA(value) _Pragma(#value)}\par
00912 {\cf21 #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)}\par
00913 {\cf21     #define JSON_HEDLEY_PRAGMA(value) __pragma(value)}\par
00914 {\cf21 #else}\par
00915 {\cf21     #define JSON_HEDLEY_PRAGMA(value)}\par
00916 {\cf21 #endif}\par
00917 \par
00918 {\cf21 #if defined(JSON_HEDLEY_DIAGNOSTIC_PUSH)}\par
00919 {\cf21     #undef JSON_HEDLEY_DIAGNOSTIC_PUSH}\par
00920 {\cf21 #endif}\par
00921 {\cf21 #if defined(JSON_HEDLEY_DIAGNOSTIC_POP)}\par
00922 {\cf21     #undef JSON_HEDLEY_DIAGNOSTIC_POP}\par
00923 {\cf21 #endif}\par
00924 {\cf21 #if defined(__clang__)}\par
00925 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("clang diagnostic push"})\par
00926 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("clang diagnostic pop"})\par
00927 {\cf21 #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)}\par
00928 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)"})\par
00929 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)"})\par
00930 {\cf21 #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)}\par
00931 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("GCC diagnostic push"})\par
00932 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("GCC diagnostic pop"})\par
00933 {\cf21 #elif \\}\par
00934 {\cf21     JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \\}\par
00935 {\cf21     JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
00936 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_PUSH __pragma(warning(push))}\par
00937 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_POP __pragma(warning(pop))}\par
00938 {\cf21 #elif JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0)}\par
00939 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("push"})\par
00940 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("pop"})\par
00941 {\cf21 #elif \\}\par
00942 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
00943 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
00944 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,4,0) || \\}\par
00945 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \\}\par
00946 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
00947 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)}\par
00948 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("diag_push"})\par
00949 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("diag_pop"})\par
00950 {\cf21 #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)}\par
00951 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_PUSH _Pragma("warning(push)"})\par
00952 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_POP _Pragma("warning(pop)"})\par
00953 {\cf21 #else}\par
00954 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_PUSH}\par
00955 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_POP}\par
00956 {\cf21 #endif}\par
00957 \par
00958 {\cf20 /* JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_ is for}\par
00959 {\cf20    HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */}\par
00960 {\cf21 #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)}\par
00961 {\cf21     #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_}\par
00962 {\cf21 #endif}\par
00963 {\cf21 #if defined(__cplusplus)}\par
00964 {\cf21 #  if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat"})\par
00965 {\cf21 #    if JSON_HEDLEY_HAS_WARNING("-Wc++17-extensions"})\par
00966 {\cf21 #      if JSON_HEDLEY_HAS_WARNING("-Wc++1z-extensions"})\par
00967 {\cf21 #        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \\}\par
00968 {\cf21     JSON_HEDLEY_DIAGNOSTIC_PUSH \\}\par
00969 {\cf21     _Pragma("clang diagnostic ignored \\"-Wc++98-compat\\""}) \\\par
00970     _Pragma("clang diagnostic ignored \\"-Wc++17-extensions\\"") \\\par
00971     _Pragma("clang diagnostic ignored \\"-Wc++1z-extensions\\"") \\\par
00972     xpr \\\par
00973     JSON_HEDLEY_DIAGNOSTIC_POP\par
00974 {\cf21 #      else}\par
00975 {\cf21 #        define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \\}\par
00976 {\cf21     JSON_HEDLEY_DIAGNOSTIC_PUSH \\}\par
00977 {\cf21     _Pragma("clang diagnostic ignored \\"-Wc++98-compat\\""}) \\\par
00978     _Pragma("clang diagnostic ignored \\"-Wc++17-extensions\\"") \\\par
00979     xpr \\\par
00980     JSON_HEDLEY_DIAGNOSTIC_POP\par
00981 {\cf21 #      endif}\par
00982 {\cf21 #    else}\par
00983 {\cf21 #      define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(xpr) \\}\par
00984 {\cf21     JSON_HEDLEY_DIAGNOSTIC_PUSH \\}\par
00985 {\cf21     _Pragma("clang diagnostic ignored \\"-Wc++98-compat\\""}) \\\par
00986     xpr \\\par
00987     JSON_HEDLEY_DIAGNOSTIC_POP\par
00988 {\cf21 #    endif}\par
00989 {\cf21 #  endif}\par
00990 {\cf21 #endif}\par
00991 {\cf21 #if !defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_)}\par
00992 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(x) x}\par
00993 {\cf21 #endif}\par
00994 \par
00995 {\cf21 #if defined(JSON_HEDLEY_CONST_CAST)}\par
00996 {\cf21     #undef JSON_HEDLEY_CONST_CAST}\par
00997 {\cf21 #endif}\par
00998 {\cf21 #if defined(__cplusplus)}\par
00999 {\cf21 #  define JSON_HEDLEY_CONST_CAST(T, expr) (const_cast<T>(expr))}\par
01000 {\cf21 #elif \\}\par
01001 {\cf21   JSON_HEDLEY_HAS_WARNING("-Wcast-qual"}) || \\\par
01002   JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0) || \\\par
01003   JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)\par
01004 {\cf21 #  define JSON_HEDLEY_CONST_CAST(T, expr) (__extension__ (\{ \\}\par
01005 {\cf21         JSON_HEDLEY_DIAGNOSTIC_PUSH \\}\par
01006 {\cf21         JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL \\}\par
01007 {\cf21         ((T) (expr)); \\}\par
01008 {\cf21         JSON_HEDLEY_DIAGNOSTIC_POP \\}\par
01009 {\cf21     \}))}\par
01010 {\cf21 #else}\par
01011 {\cf21 #  define JSON_HEDLEY_CONST_CAST(T, expr) ((T) (expr))}\par
01012 {\cf21 #endif}\par
01013 \par
01014 {\cf21 #if defined(JSON_HEDLEY_REINTERPRET_CAST)}\par
01015 {\cf21     #undef JSON_HEDLEY_REINTERPRET_CAST}\par
01016 {\cf21 #endif}\par
01017 {\cf21 #if defined(__cplusplus)}\par
01018 {\cf21     #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) (reinterpret_cast<T>(expr))}\par
01019 {\cf21 #else}\par
01020 {\cf21     #define JSON_HEDLEY_REINTERPRET_CAST(T, expr) ((T) (expr))}\par
01021 {\cf21 #endif}\par
01022 \par
01023 {\cf21 #if defined(JSON_HEDLEY_STATIC_CAST)}\par
01024 {\cf21     #undef JSON_HEDLEY_STATIC_CAST}\par
01025 {\cf21 #endif}\par
01026 {\cf21 #if defined(__cplusplus)}\par
01027 {\cf21     #define JSON_HEDLEY_STATIC_CAST(T, expr) (static_cast<T>(expr))}\par
01028 {\cf21 #else}\par
01029 {\cf21     #define JSON_HEDLEY_STATIC_CAST(T, expr) ((T) (expr))}\par
01030 {\cf21 #endif}\par
01031 \par
01032 {\cf21 #if defined(JSON_HEDLEY_CPP_CAST)}\par
01033 {\cf21     #undef JSON_HEDLEY_CPP_CAST}\par
01034 {\cf21 #endif}\par
01035 {\cf21 #if defined(__cplusplus)}\par
01036 {\cf21 #  if JSON_HEDLEY_HAS_WARNING("-Wold-style-cast"})\par
01037 {\cf21 #    define JSON_HEDLEY_CPP_CAST(T, expr) \\}\par
01038 {\cf21     JSON_HEDLEY_DIAGNOSTIC_PUSH \\}\par
01039 {\cf21     _Pragma("clang diagnostic ignored \\"-Wold-style-cast\\""}) \\\par
01040     ((T) (expr)) \\\par
01041     JSON_HEDLEY_DIAGNOSTIC_POP\par
01042 {\cf21 #  elif JSON_HEDLEY_IAR_VERSION_CHECK(8,3,0)}\par
01043 {\cf21 #    define JSON_HEDLEY_CPP_CAST(T, expr) \\}\par
01044 {\cf21     JSON_HEDLEY_DIAGNOSTIC_PUSH \\}\par
01045 {\cf21     _Pragma("diag_suppress=Pe137"}) \\\par
01046     JSON_HEDLEY_DIAGNOSTIC_POP\par
01047 {\cf21 #  else}\par
01048 {\cf21 #    define JSON_HEDLEY_CPP_CAST(T, expr) ((T) (expr))}\par
01049 {\cf21 #  endif}\par
01050 {\cf21 #else}\par
01051 {\cf21 #  define JSON_HEDLEY_CPP_CAST(T, expr) (expr)}\par
01052 {\cf21 #endif}\par
01053 \par
01054 {\cf21 #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED)}\par
01055 {\cf21     #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED}\par
01056 {\cf21 #endif}\par
01057 {\cf21 #if JSON_HEDLEY_HAS_WARNING("-Wdeprecated-declarations"})\par
01058 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("clang diagnostic ignored \\"-Wdeprecated-declarations\\""})\par
01059 {\cf21 #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)}\par
01060 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warning(disable:1478 1786)"})\par
01061 {\cf21 #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
01062 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:1478 1786))}\par
01063 {\cf21 #elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)}\par
01064 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1216,1444,1445"})\par
01065 {\cf21 #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)}\par
01066 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444"})\par
01067 {\cf21 #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)}\par
01068 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("GCC diagnostic ignored \\"-Wdeprecated-declarations\\""})\par
01069 {\cf21 #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)}\par
01070 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED __pragma(warning(disable:4996))}\par
01071 {\cf21 #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01072 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1215,1444"})\par
01073 {\cf21 #elif \\}\par
01074 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
01075 {\cf21     (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01076 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
01077 {\cf21     (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01078 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\}\par
01079 {\cf21     (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01080 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01081 {\cf21     (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01082 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\}\par
01083 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01084 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0)}\par
01085 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress 1291,1718"})\par
01086 {\cf21 #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && !defined(__cplusplus)}\par
01087 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,E_DEPRECATED_ATT,E_DEPRECATED_ATT_MESS)"})\par
01088 {\cf21 #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) && defined(__cplusplus)}\par
01089 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("error_messages(off,symdeprecated,symdeprecated2)"})\par
01090 {\cf21 #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)}\par
01091 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("diag_suppress=Pe1444,Pe1215"})\par
01092 {\cf21 #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,90,0)}\par
01093 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED _Pragma("warn(disable:2241)"})\par
01094 {\cf21 #else}\par
01095 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED}\par
01096 {\cf21 #endif}\par
01097 \par
01098 {\cf21 #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS)}\par
01099 {\cf21     #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS}\par
01100 {\cf21 #endif}\par
01101 {\cf21 #if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas"})\par
01102 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("clang diagnostic ignored \\"-Wunknown-pragmas\\""})\par
01103 {\cf21 #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)}\par
01104 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("warning(disable:161)"})\par
01105 {\cf21 #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
01106 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:161))}\par
01107 {\cf21 #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)}\par
01108 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 1675"})\par
01109 {\cf21 #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0)}\par
01110 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("GCC diagnostic ignored \\"-Wunknown-pragmas\\""})\par
01111 {\cf21 #elif JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0)}\par
01112 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS __pragma(warning(disable:4068))}\par
01113 {\cf21 #elif \\}\par
01114 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(16,9,0) || \\}\par
01115 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \\}\par
01116 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01117 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0)}\par
01118 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163"})\par
01119 {\cf21 #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0)}\par
01120 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 163"})\par
01121 {\cf21 #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)}\par
01122 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress=Pe161"})\par
01123 {\cf21 #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01124 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS _Pragma("diag_suppress 161"})\par
01125 {\cf21 #else}\par
01126 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS}\par
01127 {\cf21 #endif}\par
01128 \par
01129 {\cf21 #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES)}\par
01130 {\cf21     #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES}\par
01131 {\cf21 #endif}\par
01132 {\cf21 #if JSON_HEDLEY_HAS_WARNING("-Wunknown-attributes"})\par
01133 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("clang diagnostic ignored \\"-Wunknown-attributes\\""})\par
01134 {\cf21 #elif JSON_HEDLEY_GCC_VERSION_CHECK(4,6,0)}\par
01135 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("GCC diagnostic ignored \\"-Wdeprecated-declarations\\""})\par
01136 {\cf21 #elif JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0)}\par
01137 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("warning(disable:1292)"})\par
01138 {\cf21 #elif JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
01139 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:1292))}\par
01140 {\cf21 #elif JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,0)}\par
01141 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES __pragma(warning(disable:5030))}\par
01142 {\cf21 #elif JSON_HEDLEY_PGI_VERSION_CHECK(20,7,0)}\par
01143 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097,1098"})\par
01144 {\cf21 #elif JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0)}\par
01145 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097"})\par
01146 {\cf21 #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)}\par
01147 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("error_messages(off,attrskipunsup)"})\par
01148 {\cf21 #elif \\}\par
01149 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \\}\par
01150 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \\}\par
01151 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0)}\par
01152 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1173"})\par
01153 {\cf21 #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)}\par
01154 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress=Pe1097"})\par
01155 {\cf21 #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01156 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES _Pragma("diag_suppress 1097"})\par
01157 {\cf21 #else}\par
01158 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES}\par
01159 {\cf21 #endif}\par
01160 \par
01161 {\cf21 #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL)}\par
01162 {\cf21     #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL}\par
01163 {\cf21 #endif}\par
01164 {\cf21 #if JSON_HEDLEY_HAS_WARNING("-Wcast-qual"})\par
01165 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("clang diagnostic ignored \\"-Wcast-qual\\""})\par
01166 {\cf21 #elif JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)}\par
01167 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("warning(disable:2203 2331)"})\par
01168 {\cf21 #elif JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0)}\par
01169 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL _Pragma("GCC diagnostic ignored \\"-Wcast-qual\\""})\par
01170 {\cf21 #else}\par
01171 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL}\par
01172 {\cf21 #endif}\par
01173 \par
01174 {\cf21 #if defined(JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION)}\par
01175 {\cf21     #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION}\par
01176 {\cf21 #endif}\par
01177 {\cf21 #if JSON_HEDLEY_HAS_WARNING("-Wunused-function"})\par
01178 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("clang diagnostic ignored \\"-Wunused-function\\""})\par
01179 {\cf21 #elif JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0)}\par
01180 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("GCC diagnostic ignored \\"-Wunused-function\\""})\par
01181 {\cf21 #elif JSON_HEDLEY_MSVC_VERSION_CHECK(1,0,0)}\par
01182 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION __pragma(warning(disable:4505))}\par
01183 {\cf21 #elif JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01184 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION _Pragma("diag_suppress 3142"})\par
01185 {\cf21 #else}\par
01186 {\cf21     #define JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION}\par
01187 {\cf21 #endif}\par
01188 \par
01189 {\cf21 #if defined(JSON_HEDLEY_DEPRECATED)}\par
01190 {\cf21     #undef JSON_HEDLEY_DEPRECATED}\par
01191 {\cf21 #endif}\par
01192 {\cf21 #if defined(JSON_HEDLEY_DEPRECATED_FOR)}\par
01193 {\cf21     #undef JSON_HEDLEY_DEPRECATED_FOR}\par
01194 {\cf21 #endif}\par
01195 {\cf21 #if \\}\par
01196 {\cf21     JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \\}\par
01197 {\cf21     JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
01198 {\cf21     #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated("Since "} # since))\par
01199 {\cf21     #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated("Since "} #since "; use " #replacement))\par
01200 {\cf21 #elif \\}\par
01201 {\cf21     (JSON_HEDLEY_HAS_EXTENSION(attribute_deprecated_with_message) && !defined(JSON_HEDLEY_IAR_VERSION)) || \\}\par
01202 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \\}\par
01203 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01204 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \\}\par
01205 {\cf21     JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,13,0) || \\}\par
01206 {\cf21     JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \\}\par
01207 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(18,1,0) || \\}\par
01208 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(18,1,0) || \\}\par
01209 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,3,0) || \\}\par
01210 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01211 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,3,0) || \\}\par
01212 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01213 {\cf21     #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__("Since "} #since)))\par
01214 {\cf21     #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__("Since "} #since "; use " #replacement)))\par
01215 {\cf21 #elif defined(__cplusplus) && (__cplusplus >= 201402L)}\par
01216 {\cf21     #define JSON_HEDLEY_DEPRECATED(since) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since "} #since)]])\par
01217 {\cf21     #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[deprecated("Since "} #since "; use " #replacement)]])\par
01218 {\cf21 #elif \\}\par
01219 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(deprecated) || \\}\par
01220 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \\}\par
01221 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01222 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
01223 {\cf21     (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01224 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
01225 {\cf21     (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01226 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\}\par
01227 {\cf21     (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01228 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01229 {\cf21     (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01230 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\}\par
01231 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01232 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
01233 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \\}\par
01234 {\cf21     JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)}\par
01235 {\cf21     #define JSON_HEDLEY_DEPRECATED(since) __attribute__((__deprecated__))}\par
01236 {\cf21     #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __attribute__((__deprecated__))}\par
01237 {\cf21 #elif \\}\par
01238 {\cf21     JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \\}\par
01239 {\cf21     JSON_HEDLEY_PELLES_VERSION_CHECK(6,50,0) || \\}\par
01240 {\cf21     JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
01241 {\cf21     #define JSON_HEDLEY_DEPRECATED(since) __declspec(deprecated)}\par
01242 {\cf21     #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) __declspec(deprecated)}\par
01243 {\cf21 #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)}\par
01244 {\cf21     #define JSON_HEDLEY_DEPRECATED(since) _Pragma("deprecated"})\par
01245 {\cf21     #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement) _Pragma("deprecated"})\par
01246 {\cf21 #else}\par
01247 {\cf21     #define JSON_HEDLEY_DEPRECATED(since)}\par
01248 {\cf21     #define JSON_HEDLEY_DEPRECATED_FOR(since, replacement)}\par
01249 {\cf21 #endif}\par
01250 \par
01251 {\cf21 #if defined(JSON_HEDLEY_UNAVAILABLE)}\par
01252 {\cf21     #undef JSON_HEDLEY_UNAVAILABLE}\par
01253 {\cf21 #endif}\par
01254 {\cf21 #if \\}\par
01255 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(warning) || \\}\par
01256 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(4,3,0) || \\}\par
01257 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01258 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01259 {\cf21     #define JSON_HEDLEY_UNAVAILABLE(available_since) __attribute__((__warning__("Not available until "} #available_since)))\par
01260 {\cf21 #else}\par
01261 {\cf21     #define JSON_HEDLEY_UNAVAILABLE(available_since)}\par
01262 {\cf21 #endif}\par
01263 \par
01264 {\cf21 #if defined(JSON_HEDLEY_WARN_UNUSED_RESULT)}\par
01265 {\cf21     #undef JSON_HEDLEY_WARN_UNUSED_RESULT}\par
01266 {\cf21 #endif}\par
01267 {\cf21 #if defined(JSON_HEDLEY_WARN_UNUSED_RESULT_MSG)}\par
01268 {\cf21     #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG}\par
01269 {\cf21 #endif}\par
01270 {\cf21 #if \\}\par
01271 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(warn_unused_result) || \\}\par
01272 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \\}\par
01273 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01274 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
01275 {\cf21     (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01276 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
01277 {\cf21     (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01278 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\}\par
01279 {\cf21     (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01280 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01281 {\cf21     (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01282 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\}\par
01283 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01284 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
01285 {\cf21     (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \\}\par
01286 {\cf21     JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \\}\par
01287 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01288 {\cf21     #define JSON_HEDLEY_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))}\par
01289 {\cf21     #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) __attribute__((__warn_unused_result__))}\par
01290 {\cf21 #elif (JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard) >= 201907L)}\par
01291 {\cf21     #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])}\par
01292 {\cf21     #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard(msg)]])}\par
01293 {\cf21 #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(nodiscard)}\par
01294 {\cf21     #define JSON_HEDLEY_WARN_UNUSED_RESULT JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])}\par
01295 {\cf21     #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[nodiscard]])}\par
01296 {\cf21 #elif defined(_Check_return_) }{\cf20 /* SAL */}{\cf21 }\par
01297 {\cf21     #define JSON_HEDLEY_WARN_UNUSED_RESULT _Check_return_}\par
01298 {\cf21     #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg) _Check_return_}\par
01299 {\cf21 #else}\par
01300 {\cf21     #define JSON_HEDLEY_WARN_UNUSED_RESULT}\par
01301 {\cf21     #define JSON_HEDLEY_WARN_UNUSED_RESULT_MSG(msg)}\par
01302 {\cf21 #endif}\par
01303 \par
01304 {\cf21 #if defined(JSON_HEDLEY_SENTINEL)}\par
01305 {\cf21     #undef JSON_HEDLEY_SENTINEL}\par
01306 {\cf21 #endif}\par
01307 {\cf21 #if \\}\par
01308 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(sentinel) || \\}\par
01309 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \\}\par
01310 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01311 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \\}\par
01312 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01313 {\cf21     #define JSON_HEDLEY_SENTINEL(position) __attribute__((__sentinel__(position)))}\par
01314 {\cf21 #else}\par
01315 {\cf21     #define JSON_HEDLEY_SENTINEL(position)}\par
01316 {\cf21 #endif}\par
01317 \par
01318 {\cf21 #if defined(JSON_HEDLEY_NO_RETURN)}\par
01319 {\cf21     #undef JSON_HEDLEY_NO_RETURN}\par
01320 {\cf21 #endif}\par
01321 {\cf21 #if JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)}\par
01322 {\cf21     #define JSON_HEDLEY_NO_RETURN __noreturn}\par
01323 {\cf21 #elif \\}\par
01324 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01325 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01326 {\cf21     #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))}\par
01327 {\cf21 #elif defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L}\par
01328 {\cf21     #define JSON_HEDLEY_NO_RETURN _Noreturn}\par
01329 {\cf21 #elif defined(__cplusplus) && (__cplusplus >= 201103L)}\par
01330 {\cf21     #define JSON_HEDLEY_NO_RETURN JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[noreturn]])}\par
01331 {\cf21 #elif \\}\par
01332 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(noreturn) || \\}\par
01333 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(3,2,0) || \\}\par
01334 {\cf21     JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\}\par
01335 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01336 {\cf21     JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\}\par
01337 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
01338 {\cf21     (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01339 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
01340 {\cf21     (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01341 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\}\par
01342 {\cf21     (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01343 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01344 {\cf21     (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01345 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\}\par
01346 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01347 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
01348 {\cf21     JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)}\par
01349 {\cf21     #define JSON_HEDLEY_NO_RETURN __attribute__((__noreturn__))}\par
01350 {\cf21 #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)}\par
01351 {\cf21     #define JSON_HEDLEY_NO_RETURN _Pragma("does_not_return"})\par
01352 {\cf21 #elif \\}\par
01353 {\cf21     JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \\}\par
01354 {\cf21     JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
01355 {\cf21     #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)}\par
01356 {\cf21 #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)}\par
01357 {\cf21     #define JSON_HEDLEY_NO_RETURN _Pragma("FUNC_NEVER_RETURNS;"})\par
01358 {\cf21 #elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)}\par
01359 {\cf21     #define JSON_HEDLEY_NO_RETURN __attribute((noreturn))}\par
01360 {\cf21 #elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)}\par
01361 {\cf21     #define JSON_HEDLEY_NO_RETURN __declspec(noreturn)}\par
01362 {\cf21 #else}\par
01363 {\cf21     #define JSON_HEDLEY_NO_RETURN}\par
01364 {\cf21 #endif}\par
01365 \par
01366 {\cf21 #if defined(JSON_HEDLEY_NO_ESCAPE)}\par
01367 {\cf21     #undef JSON_HEDLEY_NO_ESCAPE}\par
01368 {\cf21 #endif}\par
01369 {\cf21 #if JSON_HEDLEY_HAS_ATTRIBUTE(noescape)}\par
01370 {\cf21     #define JSON_HEDLEY_NO_ESCAPE __attribute__((__noescape__))}\par
01371 {\cf21 #else}\par
01372 {\cf21     #define JSON_HEDLEY_NO_ESCAPE}\par
01373 {\cf21 #endif}\par
01374 \par
01375 {\cf21 #if defined(JSON_HEDLEY_UNREACHABLE)}\par
01376 {\cf21     #undef JSON_HEDLEY_UNREACHABLE}\par
01377 {\cf21 #endif}\par
01378 {\cf21 #if defined(JSON_HEDLEY_UNREACHABLE_RETURN)}\par
01379 {\cf21     #undef JSON_HEDLEY_UNREACHABLE_RETURN}\par
01380 {\cf21 #endif}\par
01381 {\cf21 #if defined(JSON_HEDLEY_ASSUME)}\par
01382 {\cf21     #undef JSON_HEDLEY_ASSUME}\par
01383 {\cf21 #endif}\par
01384 {\cf21 #if \\}\par
01385 {\cf21     JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \\}\par
01386 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01387 {\cf21     JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
01388 {\cf21     #define JSON_HEDLEY_ASSUME(expr) __assume(expr)}\par
01389 {\cf21 #elif JSON_HEDLEY_HAS_BUILTIN(__builtin_assume)}\par
01390 {\cf21     #define JSON_HEDLEY_ASSUME(expr) __builtin_assume(expr)}\par
01391 {\cf21 #elif \\}\par
01392 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \\}\par
01393 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)}\par
01394 {\cf21     #if defined(__cplusplus)}\par
01395 {\cf21         #define JSON_HEDLEY_ASSUME(expr) std::_nassert(expr)}\par
01396 {\cf21     #else}\par
01397 {\cf21         #define JSON_HEDLEY_ASSUME(expr) _nassert(expr)}\par
01398 {\cf21     #endif}\par
01399 {\cf21 #endif}\par
01400 {\cf21 #if \\}\par
01401 {\cf21     (JSON_HEDLEY_HAS_BUILTIN(__builtin_unreachable) && (!defined(JSON_HEDLEY_ARM_VERSION))) || \\}\par
01402 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(4,5,0) || \\}\par
01403 {\cf21     JSON_HEDLEY_PGI_VERSION_CHECK(18,10,0) || \\}\par
01404 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01405 {\cf21     JSON_HEDLEY_IBM_VERSION_CHECK(13,1,5) || \\}\par
01406 {\cf21     JSON_HEDLEY_CRAY_VERSION_CHECK(10,0,0) || \\}\par
01407 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01408 {\cf21     #define JSON_HEDLEY_UNREACHABLE() __builtin_unreachable()}\par
01409 {\cf21 #elif defined(JSON_HEDLEY_ASSUME)}\par
01410 {\cf21     #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)}\par
01411 {\cf21 #endif}\par
01412 {\cf21 #if !defined(JSON_HEDLEY_ASSUME)}\par
01413 {\cf21     #if defined(JSON_HEDLEY_UNREACHABLE)}\par
01414 {\cf21         #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, ((expr) ? 1 : (JSON_HEDLEY_UNREACHABLE(), 1)))}\par
01415 {\cf21     #else}\par
01416 {\cf21         #define JSON_HEDLEY_ASSUME(expr) JSON_HEDLEY_STATIC_CAST(void, expr)}\par
01417 {\cf21     #endif}\par
01418 {\cf21 #endif}\par
01419 {\cf21 #if defined(JSON_HEDLEY_UNREACHABLE)}\par
01420 {\cf21     #if  \\}\par
01421 {\cf21         JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \\}\par
01422 {\cf21         JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0)}\par
01423 {\cf21         #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (JSON_HEDLEY_STATIC_CAST(void, JSON_HEDLEY_ASSUME(0)), (value))}\par
01424 {\cf21     #else}\par
01425 {\cf21         #define JSON_HEDLEY_UNREACHABLE_RETURN(value) JSON_HEDLEY_UNREACHABLE()}\par
01426 {\cf21     #endif}\par
01427 {\cf21 #else}\par
01428 {\cf21     #define JSON_HEDLEY_UNREACHABLE_RETURN(value) return (value)}\par
01429 {\cf21 #endif}\par
01430 {\cf21 #if !defined(JSON_HEDLEY_UNREACHABLE)}\par
01431 {\cf21     #define JSON_HEDLEY_UNREACHABLE() JSON_HEDLEY_ASSUME(0)}\par
01432 {\cf21 #endif}\par
01433 \par
01434 JSON_HEDLEY_DIAGNOSTIC_PUSH\par
01435 {\cf21 #if JSON_HEDLEY_HAS_WARNING("-Wpedantic"})\par
01436 {\cf21     #pragma clang diagnostic ignored "-Wpedantic"}\par
01437 {\cf21 #endif}\par
01438 {\cf21 #if JSON_HEDLEY_HAS_WARNING("-Wc++98-compat-pedantic"}) && defined(__cplusplus)\par
01439 {\cf21     #pragma clang diagnostic ignored "-Wc++98-compat-pedantic"}\par
01440 {\cf21 #endif}\par
01441 {\cf21 #if JSON_HEDLEY_GCC_HAS_WARNING("-Wvariadic-macros"},4,0,0)\par
01442 {\cf21     #if defined(__clang__)}\par
01443 {\cf21         #pragma clang diagnostic ignored "-Wvariadic-macros"}\par
01444 {\cf21     #elif defined(JSON_HEDLEY_GCC_VERSION)}\par
01445 {\cf21         #pragma GCC diagnostic ignored "-Wvariadic-macros"}\par
01446 {\cf21     #endif}\par
01447 {\cf21 #endif}\par
01448 {\cf21 #if defined(JSON_HEDLEY_NON_NULL)}\par
01449 {\cf21     #undef JSON_HEDLEY_NON_NULL}\par
01450 {\cf21 #endif}\par
01451 {\cf21 #if \\}\par
01452 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(nonnull) || \\}\par
01453 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \\}\par
01454 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01455 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)}\par
01456 {\cf21     #define JSON_HEDLEY_NON_NULL(...) __attribute__((__nonnull__(__VA_ARGS__)))}\par
01457 {\cf21 #else}\par
01458 {\cf21     #define JSON_HEDLEY_NON_NULL(...)}\par
01459 {\cf21 #endif}\par
01460 JSON_HEDLEY_DIAGNOSTIC_POP\par
01461 \par
01462 {\cf21 #if defined(JSON_HEDLEY_PRINTF_FORMAT)}\par
01463 {\cf21     #undef JSON_HEDLEY_PRINTF_FORMAT}\par
01464 {\cf21 #endif}\par
01465 {\cf21 #if defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && !defined(__USE_MINGW_ANSI_STDIO)}\par
01466 {\cf21     #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(ms_printf, string_idx, first_to_check)))}\par
01467 {\cf21 #elif defined(__MINGW32__) && JSON_HEDLEY_GCC_HAS_ATTRIBUTE(format,4,4,0) && defined(__USE_MINGW_ANSI_STDIO)}\par
01468 {\cf21     #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(gnu_printf, string_idx, first_to_check)))}\par
01469 {\cf21 #elif \\}\par
01470 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(format) || \\}\par
01471 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \\}\par
01472 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01473 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(5,6,0) || \\}\par
01474 {\cf21     JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\}\par
01475 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
01476 {\cf21     (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01477 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
01478 {\cf21     (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01479 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\}\par
01480 {\cf21     (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01481 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01482 {\cf21     (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01483 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\}\par
01484 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01485 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
01486 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01487 {\cf21     #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __attribute__((__format__(__printf__, string_idx, first_to_check)))}\par
01488 {\cf21 #elif JSON_HEDLEY_PELLES_VERSION_CHECK(6,0,0)}\par
01489 {\cf21     #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check) __declspec(vaformat(printf,string_idx,first_to_check))}\par
01490 {\cf21 #else}\par
01491 {\cf21     #define JSON_HEDLEY_PRINTF_FORMAT(string_idx,first_to_check)}\par
01492 {\cf21 #endif}\par
01493 \par
01494 {\cf21 #if defined(JSON_HEDLEY_CONSTEXPR)}\par
01495 {\cf21     #undef JSON_HEDLEY_CONSTEXPR}\par
01496 {\cf21 #endif}\par
01497 {\cf21 #if defined(__cplusplus)}\par
01498 {\cf21     #if __cplusplus >= 201103L}\par
01499 {\cf21         #define JSON_HEDLEY_CONSTEXPR JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(constexpr)}\par
01500 {\cf21     #endif}\par
01501 {\cf21 #endif}\par
01502 {\cf21 #if !defined(JSON_HEDLEY_CONSTEXPR)}\par
01503 {\cf21     #define JSON_HEDLEY_CONSTEXPR}\par
01504 {\cf21 #endif}\par
01505 \par
01506 {\cf21 #if defined(JSON_HEDLEY_PREDICT)}\par
01507 {\cf21     #undef JSON_HEDLEY_PREDICT}\par
01508 {\cf21 #endif}\par
01509 {\cf21 #if defined(JSON_HEDLEY_LIKELY)}\par
01510 {\cf21     #undef JSON_HEDLEY_LIKELY}\par
01511 {\cf21 #endif}\par
01512 {\cf21 #if defined(JSON_HEDLEY_UNLIKELY)}\par
01513 {\cf21     #undef JSON_HEDLEY_UNLIKELY}\par
01514 {\cf21 #endif}\par
01515 {\cf21 #if defined(JSON_HEDLEY_UNPREDICTABLE)}\par
01516 {\cf21     #undef JSON_HEDLEY_UNPREDICTABLE}\par
01517 {\cf21 #endif}\par
01518 {\cf21 #if JSON_HEDLEY_HAS_BUILTIN(__builtin_unpredictable)}\par
01519 {\cf21     #define JSON_HEDLEY_UNPREDICTABLE(expr) __builtin_unpredictable((expr))}\par
01520 {\cf21 #endif}\par
01521 {\cf21 #if \\}\par
01522 {\cf21   (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect_with_probability) && !defined(JSON_HEDLEY_PGI_VERSION)) || \\}\par
01523 {\cf21   JSON_HEDLEY_GCC_VERSION_CHECK(9,0,0) || \\}\par
01524 {\cf21   JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01525 {\cf21 #  define JSON_HEDLEY_PREDICT(expr, value, probability) __builtin_expect_with_probability(  (expr), (value), (probability))}\par
01526 {\cf21 #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability)   __builtin_expect_with_probability(!!(expr),    1   , (probability))}\par
01527 {\cf21 #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability)  __builtin_expect_with_probability(!!(expr),    0   , (probability))}\par
01528 {\cf21 #  define JSON_HEDLEY_LIKELY(expr)                      __builtin_expect                 (!!(expr),    1                  )}\par
01529 {\cf21 #  define JSON_HEDLEY_UNLIKELY(expr)                    __builtin_expect                 (!!(expr),    0                  )}\par
01530 {\cf21 #elif \\}\par
01531 {\cf21   (JSON_HEDLEY_HAS_BUILTIN(__builtin_expect) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \\}\par
01532 {\cf21   JSON_HEDLEY_GCC_VERSION_CHECK(3,0,0) || \\}\par
01533 {\cf21   JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01534 {\cf21   (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,15,0) && defined(__cplusplus)) || \\}\par
01535 {\cf21   JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01536 {\cf21   JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\}\par
01537 {\cf21   JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
01538 {\cf21   JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,7,0) || \\}\par
01539 {\cf21   JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \\}\par
01540 {\cf21   JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,1,0) || \\}\par
01541 {\cf21   JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \\}\par
01542 {\cf21   JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01543 {\cf21   JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
01544 {\cf21   JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,27) || \\}\par
01545 {\cf21   JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \\}\par
01546 {\cf21   JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01547 {\cf21 #  define JSON_HEDLEY_PREDICT(expr, expected, probability) \\}\par
01548 {\cf21     (((probability) >= 0.9) ? __builtin_expect((expr), (expected)) : (JSON_HEDLEY_STATIC_CAST(void, expected), (expr)))}\par
01549 {\cf21 #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) \\}\par
01550 {\cf21     (__extension__ (\{ \\}\par
01551 {\cf21         double hedley_probability_ = (probability); \\}\par
01552 {\cf21         ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 1) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 0) : !!(expr))); \\}\par
01553 {\cf21     \}))}\par
01554 {\cf21 #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) \\}\par
01555 {\cf21     (__extension__ (\{ \\}\par
01556 {\cf21         double hedley_probability_ = (probability); \\}\par
01557 {\cf21         ((hedley_probability_ >= 0.9) ? __builtin_expect(!!(expr), 0) : ((hedley_probability_ <= 0.1) ? __builtin_expect(!!(expr), 1) : !!(expr))); \\}\par
01558 {\cf21     \}))}\par
01559 {\cf21 #  define JSON_HEDLEY_LIKELY(expr)   __builtin_expect(!!(expr), 1)}\par
01560 {\cf21 #  define JSON_HEDLEY_UNLIKELY(expr) __builtin_expect(!!(expr), 0)}\par
01561 {\cf21 #else}\par
01562 {\cf21 #  define JSON_HEDLEY_PREDICT(expr, expected, probability) (JSON_HEDLEY_STATIC_CAST(void, expected), (expr))}\par
01563 {\cf21 #  define JSON_HEDLEY_PREDICT_TRUE(expr, probability) (!!(expr))}\par
01564 {\cf21 #  define JSON_HEDLEY_PREDICT_FALSE(expr, probability) (!!(expr))}\par
01565 {\cf21 #  define JSON_HEDLEY_LIKELY(expr) (!!(expr))}\par
01566 {\cf21 #  define JSON_HEDLEY_UNLIKELY(expr) (!!(expr))}\par
01567 {\cf21 #endif}\par
01568 {\cf21 #if !defined(JSON_HEDLEY_UNPREDICTABLE)}\par
01569 {\cf21     #define JSON_HEDLEY_UNPREDICTABLE(expr) JSON_HEDLEY_PREDICT(expr, 1, 0.5)}\par
01570 {\cf21 #endif}\par
01571 \par
01572 {\cf21 #if defined(JSON_HEDLEY_MALLOC)}\par
01573 {\cf21     #undef JSON_HEDLEY_MALLOC}\par
01574 {\cf21 #endif}\par
01575 {\cf21 #if \\}\par
01576 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(malloc) || \\}\par
01577 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \\}\par
01578 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01579 {\cf21     JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\}\par
01580 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01581 {\cf21     JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \\}\par
01582 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
01583 {\cf21     (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01584 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
01585 {\cf21     (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01586 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\}\par
01587 {\cf21     (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01588 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01589 {\cf21     (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01590 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\}\par
01591 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01592 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
01593 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01594 {\cf21     #define JSON_HEDLEY_MALLOC __attribute__((__malloc__))}\par
01595 {\cf21 #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)}\par
01596 {\cf21     #define JSON_HEDLEY_MALLOC _Pragma("returns_new_memory"})\par
01597 {\cf21 #elif \\}\par
01598 {\cf21     JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \\}\par
01599 {\cf21     JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
01600 {\cf21     #define JSON_HEDLEY_MALLOC __declspec(restrict)}\par
01601 {\cf21 #else}\par
01602 {\cf21     #define JSON_HEDLEY_MALLOC}\par
01603 {\cf21 #endif}\par
01604 \par
01605 {\cf21 #if defined(JSON_HEDLEY_PURE)}\par
01606 {\cf21     #undef JSON_HEDLEY_PURE}\par
01607 {\cf21 #endif}\par
01608 {\cf21 #if \\}\par
01609 {\cf21   JSON_HEDLEY_HAS_ATTRIBUTE(pure) || \\}\par
01610 {\cf21   JSON_HEDLEY_GCC_VERSION_CHECK(2,96,0) || \\}\par
01611 {\cf21   JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01612 {\cf21   JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\}\par
01613 {\cf21   JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01614 {\cf21   JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\}\par
01615 {\cf21   JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
01616 {\cf21   (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01617 {\cf21   JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
01618 {\cf21   (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01619 {\cf21   JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\}\par
01620 {\cf21   (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01621 {\cf21   JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01622 {\cf21   (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01623 {\cf21   JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\}\par
01624 {\cf21   JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01625 {\cf21   JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
01626 {\cf21   JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \\}\par
01627 {\cf21   JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01628 {\cf21 #  define JSON_HEDLEY_PURE __attribute__((__pure__))}\par
01629 {\cf21 #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)}\par
01630 {\cf21 #  define JSON_HEDLEY_PURE _Pragma("does_not_write_global_data"})\par
01631 {\cf21 #elif defined(__cplusplus) && \\}\par
01632 {\cf21     ( \\}\par
01633 {\cf21       JSON_HEDLEY_TI_CL430_VERSION_CHECK(2,0,1) || \\}\par
01634 {\cf21       JSON_HEDLEY_TI_CL6X_VERSION_CHECK(4,0,0) || \\}\par
01635 {\cf21       JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) \\}\par
01636 {\cf21     )}\par
01637 {\cf21 #  define JSON_HEDLEY_PURE _Pragma("FUNC_IS_PURE;"})\par
01638 {\cf21 #else}\par
01639 {\cf21 #  define JSON_HEDLEY_PURE}\par
01640 {\cf21 #endif}\par
01641 \par
01642 {\cf21 #if defined(JSON_HEDLEY_CONST)}\par
01643 {\cf21     #undef JSON_HEDLEY_CONST}\par
01644 {\cf21 #endif}\par
01645 {\cf21 #if \\}\par
01646 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(const) || \\}\par
01647 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(2,5,0) || \\}\par
01648 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01649 {\cf21     JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\}\par
01650 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01651 {\cf21     JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\}\par
01652 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
01653 {\cf21     (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01654 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
01655 {\cf21     (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01656 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\}\par
01657 {\cf21     (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01658 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01659 {\cf21     (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01660 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\}\par
01661 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01662 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
01663 {\cf21     JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \\}\par
01664 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01665 {\cf21     #define JSON_HEDLEY_CONST __attribute__((__const__))}\par
01666 {\cf21 #elif \\}\par
01667 {\cf21     JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0)}\par
01668 {\cf21     #define JSON_HEDLEY_CONST _Pragma("no_side_effect"})\par
01669 {\cf21 #else}\par
01670 {\cf21     #define JSON_HEDLEY_CONST JSON_HEDLEY_PURE}\par
01671 {\cf21 #endif}\par
01672 \par
01673 {\cf21 #if defined(JSON_HEDLEY_RESTRICT)}\par
01674 {\cf21     #undef JSON_HEDLEY_RESTRICT}\par
01675 {\cf21 #endif}\par
01676 {\cf21 #if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && !defined(__cplusplus)}\par
01677 {\cf21     #define JSON_HEDLEY_RESTRICT restrict}\par
01678 {\cf21 #elif \\}\par
01679 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(3,1,0) || \\}\par
01680 {\cf21     JSON_HEDLEY_MSVC_VERSION_CHECK(14,0,0) || \\}\par
01681 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01682 {\cf21     JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \\}\par
01683 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01684 {\cf21     JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\}\par
01685 {\cf21     JSON_HEDLEY_PGI_VERSION_CHECK(17,10,0) || \\}\par
01686 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01687 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,4) || \\}\par
01688 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,1,0) || \\}\par
01689 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01690 {\cf21     (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,14,0) && defined(__cplusplus)) || \\}\par
01691 {\cf21     JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0) || \\}\par
01692 {\cf21     defined(__clang__) || \\}\par
01693 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01694 {\cf21     #define JSON_HEDLEY_RESTRICT __restrict}\par
01695 {\cf21 #elif JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,3,0) && !defined(__cplusplus)}\par
01696 {\cf21     #define JSON_HEDLEY_RESTRICT _Restrict}\par
01697 {\cf21 #else}\par
01698 {\cf21     #define JSON_HEDLEY_RESTRICT}\par
01699 {\cf21 #endif}\par
01700 \par
01701 {\cf21 #if defined(JSON_HEDLEY_INLINE)}\par
01702 {\cf21     #undef JSON_HEDLEY_INLINE}\par
01703 {\cf21 #endif}\par
01704 {\cf21 #if \\}\par
01705 {\cf21     (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || \\}\par
01706 {\cf21     (defined(__cplusplus) && (__cplusplus >= 199711L))}\par
01707 {\cf21     #define JSON_HEDLEY_INLINE inline}\par
01708 {\cf21 #elif \\}\par
01709 {\cf21     defined(JSON_HEDLEY_GCC_VERSION) || \\}\par
01710 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(6,2,0)}\par
01711 {\cf21     #define JSON_HEDLEY_INLINE __inline__}\par
01712 {\cf21 #elif \\}\par
01713 {\cf21     JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \\}\par
01714 {\cf21     JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \\}\par
01715 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01716 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,1,0) || \\}\par
01717 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(3,1,0) || \\}\par
01718 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,2,0) || \\}\par
01719 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(8,0,0) || \\}\par
01720 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01721 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
01722 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01723 {\cf21     #define JSON_HEDLEY_INLINE __inline}\par
01724 {\cf21 #else}\par
01725 {\cf21     #define JSON_HEDLEY_INLINE}\par
01726 {\cf21 #endif}\par
01727 \par
01728 {\cf21 #if defined(JSON_HEDLEY_ALWAYS_INLINE)}\par
01729 {\cf21     #undef JSON_HEDLEY_ALWAYS_INLINE}\par
01730 {\cf21 #endif}\par
01731 {\cf21 #if \\}\par
01732 {\cf21   JSON_HEDLEY_HAS_ATTRIBUTE(always_inline) || \\}\par
01733 {\cf21   JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \\}\par
01734 {\cf21   JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01735 {\cf21   JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\}\par
01736 {\cf21   JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01737 {\cf21   JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\}\par
01738 {\cf21   JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
01739 {\cf21   (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01740 {\cf21   JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
01741 {\cf21   (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01742 {\cf21   JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\}\par
01743 {\cf21   (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01744 {\cf21   JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01745 {\cf21   (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01746 {\cf21   JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\}\par
01747 {\cf21   JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01748 {\cf21   JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
01749 {\cf21   JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \\}\par
01750 {\cf21   JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)}\par
01751 {\cf21 #  define JSON_HEDLEY_ALWAYS_INLINE __attribute__((__always_inline__)) JSON_HEDLEY_INLINE}\par
01752 {\cf21 #elif \\}\par
01753 {\cf21   JSON_HEDLEY_MSVC_VERSION_CHECK(12,0,0) || \\}\par
01754 {\cf21   JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
01755 {\cf21 #  define JSON_HEDLEY_ALWAYS_INLINE __forceinline}\par
01756 {\cf21 #elif defined(__cplusplus) && \\}\par
01757 {\cf21     ( \\}\par
01758 {\cf21       JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
01759 {\cf21       JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01760 {\cf21       JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\}\par
01761 {\cf21       JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \\}\par
01762 {\cf21       JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01763 {\cf21       JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) \\}\par
01764 {\cf21     )}\par
01765 {\cf21 #  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("FUNC_ALWAYS_INLINE;"})\par
01766 {\cf21 #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)}\par
01767 {\cf21 #  define JSON_HEDLEY_ALWAYS_INLINE _Pragma("inline=forced"})\par
01768 {\cf21 #else}\par
01769 {\cf21 #  define JSON_HEDLEY_ALWAYS_INLINE JSON_HEDLEY_INLINE}\par
01770 {\cf21 #endif}\par
01771 \par
01772 {\cf21 #if defined(JSON_HEDLEY_NEVER_INLINE)}\par
01773 {\cf21     #undef JSON_HEDLEY_NEVER_INLINE}\par
01774 {\cf21 #endif}\par
01775 {\cf21 #if \\}\par
01776 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(noinline) || \\}\par
01777 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(4,0,0) || \\}\par
01778 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01779 {\cf21     JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\}\par
01780 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01781 {\cf21     JSON_HEDLEY_IBM_VERSION_CHECK(10,1,0) || \\}\par
01782 {\cf21     JSON_HEDLEY_TI_VERSION_CHECK(15,12,0) || \\}\par
01783 {\cf21     (JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(4,8,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01784 {\cf21     JSON_HEDLEY_TI_ARMCL_VERSION_CHECK(5,2,0) || \\}\par
01785 {\cf21     (JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01786 {\cf21     JSON_HEDLEY_TI_CL2000_VERSION_CHECK(6,4,0) || \\}\par
01787 {\cf21     (JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,0,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01788 {\cf21     JSON_HEDLEY_TI_CL430_VERSION_CHECK(4,3,0) || \\}\par
01789 {\cf21     (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01790 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) || \\}\par
01791 {\cf21     JSON_HEDLEY_TI_CL7X_VERSION_CHECK(1,2,0) || \\}\par
01792 {\cf21     JSON_HEDLEY_TI_CLPRU_VERSION_CHECK(2,1,0) || \\}\par
01793 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10) || \\}\par
01794 {\cf21     JSON_HEDLEY_IAR_VERSION_CHECK(8,10,0)}\par
01795 {\cf21     #define JSON_HEDLEY_NEVER_INLINE __attribute__((__noinline__))}\par
01796 {\cf21 #elif \\}\par
01797 {\cf21     JSON_HEDLEY_MSVC_VERSION_CHECK(13,10,0) || \\}\par
01798 {\cf21     JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
01799 {\cf21     #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)}\par
01800 {\cf21 #elif JSON_HEDLEY_PGI_VERSION_CHECK(10,2,0)}\par
01801 {\cf21     #define JSON_HEDLEY_NEVER_INLINE _Pragma("noinline"})\par
01802 {\cf21 #elif JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,0,0) && defined(__cplusplus)}\par
01803 {\cf21     #define JSON_HEDLEY_NEVER_INLINE _Pragma("FUNC_CANNOT_INLINE;"})\par
01804 {\cf21 #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)}\par
01805 {\cf21     #define JSON_HEDLEY_NEVER_INLINE _Pragma("inline=never"})\par
01806 {\cf21 #elif JSON_HEDLEY_COMPCERT_VERSION_CHECK(3,2,0)}\par
01807 {\cf21     #define JSON_HEDLEY_NEVER_INLINE __attribute((noinline))}\par
01808 {\cf21 #elif JSON_HEDLEY_PELLES_VERSION_CHECK(9,0,0)}\par
01809 {\cf21     #define JSON_HEDLEY_NEVER_INLINE __declspec(noinline)}\par
01810 {\cf21 #else}\par
01811 {\cf21     #define JSON_HEDLEY_NEVER_INLINE}\par
01812 {\cf21 #endif}\par
01813 \par
01814 {\cf21 #if defined(JSON_HEDLEY_PRIVATE)}\par
01815 {\cf21     #undef JSON_HEDLEY_PRIVATE}\par
01816 {\cf21 #endif}\par
01817 {\cf21 #if defined(JSON_HEDLEY_PUBLIC)}\par
01818 {\cf21     #undef JSON_HEDLEY_PUBLIC}\par
01819 {\cf21 #endif}\par
01820 {\cf21 #if defined(JSON_HEDLEY_IMPORT)}\par
01821 {\cf21     #undef JSON_HEDLEY_IMPORT}\par
01822 {\cf21 #endif}\par
01823 {\cf21 #if defined(_WIN32) || defined(__CYGWIN__)}\par
01824 {\cf21 #  define JSON_HEDLEY_PRIVATE}\par
01825 {\cf21 #  define JSON_HEDLEY_PUBLIC   __declspec(dllexport)}\par
01826 {\cf21 #  define JSON_HEDLEY_IMPORT   __declspec(dllimport)}\par
01827 {\cf21 #else}\par
01828 {\cf21 #  if \\}\par
01829 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(visibility) || \\}\par
01830 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \\}\par
01831 {\cf21     JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,11,0) || \\}\par
01832 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01833 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01834 {\cf21     JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \\}\par
01835 {\cf21     ( \\}\par
01836 {\cf21       defined(__TI_EABI__) && \\}\par
01837 {\cf21       ( \\}\par
01838 {\cf21         (JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,2,0) && defined(__TI_GNU_ATTRIBUTE_SUPPORT__)) || \\}\par
01839 {\cf21         JSON_HEDLEY_TI_CL6X_VERSION_CHECK(7,5,0) \\}\par
01840 {\cf21       ) \\}\par
01841 {\cf21     ) || \\}\par
01842 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01843 {\cf21 #    define JSON_HEDLEY_PRIVATE __attribute__((__visibility__("hidden"})))\par
01844 {\cf21 #    define JSON_HEDLEY_PUBLIC  __attribute__((__visibility__("default"})))\par
01845 {\cf21 #  else}\par
01846 {\cf21 #    define JSON_HEDLEY_PRIVATE}\par
01847 {\cf21 #    define JSON_HEDLEY_PUBLIC}\par
01848 {\cf21 #  endif}\par
01849 {\cf21 #  define JSON_HEDLEY_IMPORT    extern}\par
01850 {\cf21 #endif}\par
01851 \par
01852 {\cf21 #if defined(JSON_HEDLEY_NO_THROW)}\par
01853 {\cf21     #undef JSON_HEDLEY_NO_THROW}\par
01854 {\cf21 #endif}\par
01855 {\cf21 #if \\}\par
01856 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(nothrow) || \\}\par
01857 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(3,3,0) || \\}\par
01858 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01859 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01860 {\cf21     #define JSON_HEDLEY_NO_THROW __attribute__((__nothrow__))}\par
01861 {\cf21 #elif \\}\par
01862 {\cf21     JSON_HEDLEY_MSVC_VERSION_CHECK(13,1,0) || \\}\par
01863 {\cf21     JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0) || \\}\par
01864 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0)}\par
01865 {\cf21     #define JSON_HEDLEY_NO_THROW __declspec(nothrow)}\par
01866 {\cf21 #else}\par
01867 {\cf21     #define JSON_HEDLEY_NO_THROW}\par
01868 {\cf21 #endif}\par
01869 \par
01870 {\cf21 #if defined(JSON_HEDLEY_FALL_THROUGH)}\par
01871 {\cf21     #undef JSON_HEDLEY_FALL_THROUGH}\par
01872 {\cf21 #endif}\par
01873 {\cf21 #if \\}\par
01874 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(fallthrough) || \\}\par
01875 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(7,0,0) || \\}\par
01876 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01877 {\cf21     #define JSON_HEDLEY_FALL_THROUGH __attribute__((__fallthrough__))}\par
01878 {\cf21 #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS(clang,fallthrough)}\par
01879 {\cf21     #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[clang::fallthrough]])}\par
01880 {\cf21 #elif JSON_HEDLEY_HAS_CPP_ATTRIBUTE(fallthrough)}\par
01881 {\cf21     #define JSON_HEDLEY_FALL_THROUGH JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_([[fallthrough]])}\par
01882 {\cf21 #elif defined(__fallthrough) }{\cf20 /* SAL */}{\cf21 }\par
01883 {\cf21     #define JSON_HEDLEY_FALL_THROUGH __fallthrough}\par
01884 {\cf21 #else}\par
01885 {\cf21     #define JSON_HEDLEY_FALL_THROUGH}\par
01886 {\cf21 #endif}\par
01887 \par
01888 {\cf21 #if defined(JSON_HEDLEY_RETURNS_NON_NULL)}\par
01889 {\cf21     #undef JSON_HEDLEY_RETURNS_NON_NULL}\par
01890 {\cf21 #endif}\par
01891 {\cf21 #if \\}\par
01892 {\cf21     JSON_HEDLEY_HAS_ATTRIBUTE(returns_nonnull) || \\}\par
01893 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \\}\par
01894 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01895 {\cf21     #define JSON_HEDLEY_RETURNS_NON_NULL __attribute__((__returns_nonnull__))}\par
01896 {\cf21 #elif defined(_Ret_notnull_) }{\cf20 /* SAL */}{\cf21 }\par
01897 {\cf21     #define JSON_HEDLEY_RETURNS_NON_NULL _Ret_notnull_}\par
01898 {\cf21 #else}\par
01899 {\cf21     #define JSON_HEDLEY_RETURNS_NON_NULL}\par
01900 {\cf21 #endif}\par
01901 \par
01902 {\cf21 #if defined(JSON_HEDLEY_ARRAY_PARAM)}\par
01903 {\cf21     #undef JSON_HEDLEY_ARRAY_PARAM}\par
01904 {\cf21 #endif}\par
01905 {\cf21 #if \\}\par
01906 {\cf21     defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) && \\}\par
01907 {\cf21     !defined(__STDC_NO_VLA__) && \\}\par
01908 {\cf21     !defined(__cplusplus) && \\}\par
01909 {\cf21     !defined(JSON_HEDLEY_PGI_VERSION) && \\}\par
01910 {\cf21     !defined(JSON_HEDLEY_TINYC_VERSION)}\par
01911 {\cf21     #define JSON_HEDLEY_ARRAY_PARAM(name) (name)}\par
01912 {\cf21 #else}\par
01913 {\cf21     #define JSON_HEDLEY_ARRAY_PARAM(name)}\par
01914 {\cf21 #endif}\par
01915 \par
01916 {\cf21 #if defined(JSON_HEDLEY_IS_CONSTANT)}\par
01917 {\cf21     #undef JSON_HEDLEY_IS_CONSTANT}\par
01918 {\cf21 #endif}\par
01919 {\cf21 #if defined(JSON_HEDLEY_REQUIRE_CONSTEXPR)}\par
01920 {\cf21     #undef JSON_HEDLEY_REQUIRE_CONSTEXPR}\par
01921 {\cf21 #endif}\par
01922 {\cf20 /* JSON_HEDLEY_IS_CONSTEXPR_ is for}\par
01923 {\cf20    HEDLEY INTERNAL USE ONLY.  API subject to change without notice. */}\par
01924 {\cf21 #if defined(JSON_HEDLEY_IS_CONSTEXPR_)}\par
01925 {\cf21     #undef JSON_HEDLEY_IS_CONSTEXPR_}\par
01926 {\cf21 #endif}\par
01927 {\cf21 #if \\}\par
01928 {\cf21     JSON_HEDLEY_HAS_BUILTIN(__builtin_constant_p) || \\}\par
01929 {\cf21     JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \\}\par
01930 {\cf21     JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01931 {\cf21     JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,19) || \\}\par
01932 {\cf21     JSON_HEDLEY_ARM_VERSION_CHECK(4,1,0) || \\}\par
01933 {\cf21     JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \\}\par
01934 {\cf21     JSON_HEDLEY_TI_CL6X_VERSION_CHECK(6,1,0) || \\}\par
01935 {\cf21     (JSON_HEDLEY_SUNPRO_VERSION_CHECK(5,10,0) && !defined(__cplusplus)) || \\}\par
01936 {\cf21     JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \\}\par
01937 {\cf21     JSON_HEDLEY_MCST_LCC_VERSION_CHECK(1,25,10)}\par
01938 {\cf21     #define JSON_HEDLEY_IS_CONSTANT(expr) __builtin_constant_p(expr)}\par
01939 {\cf21 #endif}\par
01940 {\cf21 #if !defined(__cplusplus)}\par
01941 {\cf21 #  if \\}\par
01942 {\cf21        JSON_HEDLEY_HAS_BUILTIN(__builtin_types_compatible_p) || \\}\par
01943 {\cf21        JSON_HEDLEY_GCC_VERSION_CHECK(3,4,0) || \\}\par
01944 {\cf21        JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
01945 {\cf21        JSON_HEDLEY_IBM_VERSION_CHECK(13,1,0) || \\}\par
01946 {\cf21        JSON_HEDLEY_CRAY_VERSION_CHECK(8,1,0) || \\}\par
01947 {\cf21        JSON_HEDLEY_ARM_VERSION_CHECK(5,4,0) || \\}\par
01948 {\cf21        JSON_HEDLEY_TINYC_VERSION_CHECK(0,9,24)}\par
01949 {\cf21 #if defined(__INTPTR_TYPE__)}\par
01950 {\cf21     #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0)), int*)}\par
01951 {\cf21 #else}\par
01952 {\cf21     #include <stdint.h>}\par
01953 {\cf21     #define JSON_HEDLEY_IS_CONSTEXPR_(expr) __builtin_types_compatible_p(__typeof__((1 ? (void*) ((intptr_t) ((expr) * 0)) : (int*) 0)), int*)}\par
01954 {\cf21 #endif}\par
01955 {\cf21 #  elif \\}\par
01956 {\cf21        ( \\}\par
01957 {\cf21           defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L) && \\}\par
01958 {\cf21           !defined(JSON_HEDLEY_SUNPRO_VERSION) && \\}\par
01959 {\cf21           !defined(JSON_HEDLEY_PGI_VERSION) && \\}\par
01960 {\cf21           !defined(JSON_HEDLEY_IAR_VERSION)) || \\}\par
01961 {\cf21        (JSON_HEDLEY_HAS_EXTENSION(c_generic_selections) && !defined(JSON_HEDLEY_IAR_VERSION)) || \\}\par
01962 {\cf21        JSON_HEDLEY_GCC_VERSION_CHECK(4,9,0) || \\}\par
01963 {\cf21        JSON_HEDLEY_INTEL_VERSION_CHECK(17,0,0) || \\}\par
01964 {\cf21        JSON_HEDLEY_IBM_VERSION_CHECK(12,1,0) || \\}\par
01965 {\cf21        JSON_HEDLEY_ARM_VERSION_CHECK(5,3,0)}\par
01966 {\cf21 #if defined(__INTPTR_TYPE__)}\par
01967 {\cf21     #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((__INTPTR_TYPE__) ((expr) * 0)) : (int*) 0), int*: 1, void*: 0)}\par
01968 {\cf21 #else}\par
01969 {\cf21     #include <stdint.h>}\par
01970 {\cf21     #define JSON_HEDLEY_IS_CONSTEXPR_(expr) _Generic((1 ? (void*) ((intptr_t) * 0) : (int*) 0), int*: 1, void*: 0)}\par
01971 {\cf21 #endif}\par
01972 {\cf21 #  elif \\}\par
01973 {\cf21        defined(JSON_HEDLEY_GCC_VERSION) || \\}\par
01974 {\cf21        defined(JSON_HEDLEY_INTEL_VERSION) || \\}\par
01975 {\cf21        defined(JSON_HEDLEY_TINYC_VERSION) || \\}\par
01976 {\cf21        defined(JSON_HEDLEY_TI_ARMCL_VERSION) || \\}\par
01977 {\cf21        JSON_HEDLEY_TI_CL430_VERSION_CHECK(18,12,0) || \\}\par
01978 {\cf21        defined(JSON_HEDLEY_TI_CL2000_VERSION) || \\}\par
01979 {\cf21        defined(JSON_HEDLEY_TI_CL6X_VERSION) || \\}\par
01980 {\cf21        defined(JSON_HEDLEY_TI_CL7X_VERSION) || \\}\par
01981 {\cf21        defined(JSON_HEDLEY_TI_CLPRU_VERSION) || \\}\par
01982 {\cf21        defined(__clang__)}\par
01983 {\cf21 #    define JSON_HEDLEY_IS_CONSTEXPR_(expr) ( \\}\par
01984 {\cf21         sizeof(void) != \\}\par
01985 {\cf21         sizeof(*( \\}\par
01986 {\cf21                   1 ? \\}\par
01987 {\cf21                   ((void*) ((expr) * 0L) ) : \\}\par
01988 {\cf21 ((struct \{ char v[sizeof(void) * 2]; \} *) 1) \\}\par
01989 {\cf21                 ) \\}\par
01990 {\cf21               ) \\}\par
01991 {\cf21                                             )}\par
01992 {\cf21 #  endif}\par
01993 {\cf21 #endif}\par
01994 {\cf21 #if defined(JSON_HEDLEY_IS_CONSTEXPR_)}\par
01995 {\cf21     #if !defined(JSON_HEDLEY_IS_CONSTANT)}\par
01996 {\cf21         #define JSON_HEDLEY_IS_CONSTANT(expr) JSON_HEDLEY_IS_CONSTEXPR_(expr)}\par
01997 {\cf21     #endif}\par
01998 {\cf21     #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (JSON_HEDLEY_IS_CONSTEXPR_(expr) ? (expr) : (-1))}\par
01999 {\cf21 #else}\par
02000 {\cf21     #if !defined(JSON_HEDLEY_IS_CONSTANT)}\par
02001 {\cf21         #define JSON_HEDLEY_IS_CONSTANT(expr) (0)}\par
02002 {\cf21     #endif}\par
02003 {\cf21     #define JSON_HEDLEY_REQUIRE_CONSTEXPR(expr) (expr)}\par
02004 {\cf21 #endif}\par
02005 \par
02006 {\cf21 #if defined(JSON_HEDLEY_BEGIN_C_DECLS)}\par
02007 {\cf21     #undef JSON_HEDLEY_BEGIN_C_DECLS}\par
02008 {\cf21 #endif}\par
02009 {\cf21 #if defined(JSON_HEDLEY_END_C_DECLS)}\par
02010 {\cf21     #undef JSON_HEDLEY_END_C_DECLS}\par
02011 {\cf21 #endif}\par
02012 {\cf21 #if defined(JSON_HEDLEY_C_DECL)}\par
02013 {\cf21     #undef JSON_HEDLEY_C_DECL}\par
02014 {\cf21 #endif}\par
02015 {\cf21 #if defined(__cplusplus)}\par
02016 {\cf21     #define JSON_HEDLEY_BEGIN_C_DECLS extern "C"} \{\par
02017 {\cf21     #define JSON_HEDLEY_END_C_DECLS \}}\par
02018 {\cf21     #define JSON_HEDLEY_C_DECL extern "C"}\par
02019 {\cf21 #else}\par
02020 {\cf21     #define JSON_HEDLEY_BEGIN_C_DECLS}\par
02021 {\cf21     #define JSON_HEDLEY_END_C_DECLS}\par
02022 {\cf21     #define JSON_HEDLEY_C_DECL}\par
02023 {\cf21 #endif}\par
02024 \par
02025 {\cf21 #if defined(JSON_HEDLEY_STATIC_ASSERT)}\par
02026 {\cf21     #undef JSON_HEDLEY_STATIC_ASSERT}\par
02027 {\cf21 #endif}\par
02028 {\cf21 #if \\}\par
02029 {\cf21   !defined(__cplusplus) && ( \\}\par
02030 {\cf21       (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)) || \\}\par
02031 {\cf21       (JSON_HEDLEY_HAS_FEATURE(c_static_assert) && !defined(JSON_HEDLEY_INTEL_CL_VERSION)) || \\}\par
02032 {\cf21       JSON_HEDLEY_GCC_VERSION_CHECK(6,0,0) || \\}\par
02033 {\cf21       JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0) || \\}\par
02034 {\cf21       defined(_Static_assert) \\}\par
02035 {\cf21     )}\par
02036 {\cf21 #  define JSON_HEDLEY_STATIC_ASSERT(expr, message) _Static_assert(expr, message)}\par
02037 {\cf21 #elif \\}\par
02038 {\cf21   (defined(__cplusplus) && (__cplusplus >= 201103L)) || \\}\par
02039 {\cf21   JSON_HEDLEY_MSVC_VERSION_CHECK(16,0,0) || \\}\par
02040 {\cf21   JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
02041 {\cf21 #  define JSON_HEDLEY_STATIC_ASSERT(expr, message) JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(static_assert(expr, message))}\par
02042 {\cf21 #else}\par
02043 {\cf21 #  define JSON_HEDLEY_STATIC_ASSERT(expr, message)}\par
02044 {\cf21 #endif}\par
02045 \par
02046 {\cf21 #if defined(JSON_HEDLEY_NULL)}\par
02047 {\cf21     #undef JSON_HEDLEY_NULL}\par
02048 {\cf21 #endif}\par
02049 {\cf21 #if defined(__cplusplus)}\par
02050 {\cf21     #if __cplusplus >= 201103L}\par
02051 {\cf21         #define JSON_HEDLEY_NULL JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_(nullptr)}\par
02052 {\cf21     #elif defined(NULL)}\par
02053 {\cf21         #define JSON_HEDLEY_NULL NULL}\par
02054 {\cf21     #else}\par
02055 {\cf21         #define JSON_HEDLEY_NULL JSON_HEDLEY_STATIC_CAST(void*, 0)}\par
02056 {\cf21     #endif}\par
02057 {\cf21 #elif defined(NULL)}\par
02058 {\cf21     #define JSON_HEDLEY_NULL NULL}\par
02059 {\cf21 #else}\par
02060 {\cf21     #define JSON_HEDLEY_NULL ((void*) 0)}\par
02061 {\cf21 #endif}\par
02062 \par
02063 {\cf21 #if defined(JSON_HEDLEY_MESSAGE)}\par
02064 {\cf21     #undef JSON_HEDLEY_MESSAGE}\par
02065 {\cf21 #endif}\par
02066 {\cf21 #if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas"})\par
02067 {\cf21 #  define JSON_HEDLEY_MESSAGE(msg) \\}\par
02068 {\cf21     JSON_HEDLEY_DIAGNOSTIC_PUSH \\}\par
02069 {\cf21     JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \\}\par
02070 {\cf21     JSON_HEDLEY_PRAGMA(message msg) \\}\par
02071 {\cf21     JSON_HEDLEY_DIAGNOSTIC_POP}\par
02072 {\cf21 #elif \\}\par
02073 {\cf21   JSON_HEDLEY_GCC_VERSION_CHECK(4,4,0) || \\}\par
02074 {\cf21   JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)}\par
02075 {\cf21 #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message msg)}\par
02076 {\cf21 #elif JSON_HEDLEY_CRAY_VERSION_CHECK(5,0,0)}\par
02077 {\cf21 #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(_CRI message msg)}\par
02078 {\cf21 #elif JSON_HEDLEY_IAR_VERSION_CHECK(8,0,0)}\par
02079 {\cf21 #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))}\par
02080 {\cf21 #elif JSON_HEDLEY_PELLES_VERSION_CHECK(2,0,0)}\par
02081 {\cf21 #  define JSON_HEDLEY_MESSAGE(msg) JSON_HEDLEY_PRAGMA(message(msg))}\par
02082 {\cf21 #else}\par
02083 {\cf21 #  define JSON_HEDLEY_MESSAGE(msg)}\par
02084 {\cf21 #endif}\par
02085 \par
02086 {\cf21 #if defined(JSON_HEDLEY_WARNING)}\par
02087 {\cf21     #undef JSON_HEDLEY_WARNING}\par
02088 {\cf21 #endif}\par
02089 {\cf21 #if JSON_HEDLEY_HAS_WARNING("-Wunknown-pragmas"})\par
02090 {\cf21 #  define JSON_HEDLEY_WARNING(msg) \\}\par
02091 {\cf21     JSON_HEDLEY_DIAGNOSTIC_PUSH \\}\par
02092 {\cf21     JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS \\}\par
02093 {\cf21     JSON_HEDLEY_PRAGMA(clang warning msg) \\}\par
02094 {\cf21     JSON_HEDLEY_DIAGNOSTIC_POP}\par
02095 {\cf21 #elif \\}\par
02096 {\cf21   JSON_HEDLEY_GCC_VERSION_CHECK(4,8,0) || \\}\par
02097 {\cf21   JSON_HEDLEY_PGI_VERSION_CHECK(18,4,0) || \\}\par
02098 {\cf21   JSON_HEDLEY_INTEL_VERSION_CHECK(13,0,0)}\par
02099 {\cf21 #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(GCC warning msg)}\par
02100 {\cf21 #elif \\}\par
02101 {\cf21   JSON_HEDLEY_MSVC_VERSION_CHECK(15,0,0) || \\}\par
02102 {\cf21   JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
02103 {\cf21 #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_PRAGMA(message(msg))}\par
02104 {\cf21 #else}\par
02105 {\cf21 #  define JSON_HEDLEY_WARNING(msg) JSON_HEDLEY_MESSAGE(msg)}\par
02106 {\cf21 #endif}\par
02107 \par
02108 {\cf21 #if defined(JSON_HEDLEY_REQUIRE)}\par
02109 {\cf21     #undef JSON_HEDLEY_REQUIRE}\par
02110 {\cf21 #endif}\par
02111 {\cf21 #if defined(JSON_HEDLEY_REQUIRE_MSG)}\par
02112 {\cf21     #undef JSON_HEDLEY_REQUIRE_MSG}\par
02113 {\cf21 #endif}\par
02114 {\cf21 #if JSON_HEDLEY_HAS_ATTRIBUTE(diagnose_if)}\par
02115 {\cf21 #  if JSON_HEDLEY_HAS_WARNING("-Wgcc-compat"})\par
02116 {\cf21 #    define JSON_HEDLEY_REQUIRE(expr) \\}\par
02117 {\cf21     JSON_HEDLEY_DIAGNOSTIC_PUSH \\}\par
02118 {\cf21     _Pragma("clang diagnostic ignored \\"-Wgcc-compat\\""}) \\\par
02119     __attribute__((diagnose_if(!(expr), #expr, "error"))) \\\par
02120     JSON_HEDLEY_DIAGNOSTIC_POP\par
02121 {\cf21 #    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) \\}\par
02122 {\cf21     JSON_HEDLEY_DIAGNOSTIC_PUSH \\}\par
02123 {\cf21     _Pragma("clang diagnostic ignored \\"-Wgcc-compat\\""}) \\\par
02124     __attribute__((diagnose_if(!(expr), msg, "error"))) \\\par
02125     JSON_HEDLEY_DIAGNOSTIC_POP\par
02126 {\cf21 #  else}\par
02127 {\cf21 #    define JSON_HEDLEY_REQUIRE(expr) __attribute__((diagnose_if(!(expr), #expr, "error"})))\par
02128 {\cf21 #    define JSON_HEDLEY_REQUIRE_MSG(expr,msg) __attribute__((diagnose_if(!(expr), msg, "error"})))\par
02129 {\cf21 #  endif}\par
02130 {\cf21 #else}\par
02131 {\cf21 #  define JSON_HEDLEY_REQUIRE(expr)}\par
02132 {\cf21 #  define JSON_HEDLEY_REQUIRE_MSG(expr,msg)}\par
02133 {\cf21 #endif}\par
02134 \par
02135 {\cf21 #if defined(JSON_HEDLEY_FLAGS)}\par
02136 {\cf21     #undef JSON_HEDLEY_FLAGS}\par
02137 {\cf21 #endif}\par
02138 {\cf21 #if JSON_HEDLEY_HAS_ATTRIBUTE(flag_enum) && (!defined(__cplusplus) || JSON_HEDLEY_HAS_WARNING("-Wbitfield-enum-conversion"}))\par
02139 {\cf21     #define JSON_HEDLEY_FLAGS __attribute__((__flag_enum__))}\par
02140 {\cf21 #else}\par
02141 {\cf21     #define JSON_HEDLEY_FLAGS}\par
02142 {\cf21 #endif}\par
02143 \par
02144 {\cf21 #if defined(JSON_HEDLEY_FLAGS_CAST)}\par
02145 {\cf21     #undef JSON_HEDLEY_FLAGS_CAST}\par
02146 {\cf21 #endif}\par
02147 {\cf21 #if JSON_HEDLEY_INTEL_VERSION_CHECK(19,0,0)}\par
02148 {\cf21 #  define JSON_HEDLEY_FLAGS_CAST(T, expr) (__extension__ (\{ \\}\par
02149 {\cf21         JSON_HEDLEY_DIAGNOSTIC_PUSH \\}\par
02150 {\cf21         _Pragma("warning(disable:188)"}) \\\par
02151         ((T) (expr)); \\\par
02152         JSON_HEDLEY_DIAGNOSTIC_POP \\\par
02153     \}))\par
02154 {\cf21 #else}\par
02155 {\cf21 #  define JSON_HEDLEY_FLAGS_CAST(T, expr) JSON_HEDLEY_STATIC_CAST(T, expr)}\par
02156 {\cf21 #endif}\par
02157 \par
02158 {\cf21 #if defined(JSON_HEDLEY_EMPTY_BASES)}\par
02159 {\cf21     #undef JSON_HEDLEY_EMPTY_BASES}\par
02160 {\cf21 #endif}\par
02161 {\cf21 #if \\}\par
02162 {\cf21     (JSON_HEDLEY_MSVC_VERSION_CHECK(19,0,23918) && !JSON_HEDLEY_MSVC_VERSION_CHECK(20,0,0)) || \\}\par
02163 {\cf21     JSON_HEDLEY_INTEL_CL_VERSION_CHECK(2021,1,0)}\par
02164 {\cf21     #define JSON_HEDLEY_EMPTY_BASES __declspec(empty_bases)}\par
02165 {\cf21 #else}\par
02166 {\cf21     #define JSON_HEDLEY_EMPTY_BASES}\par
02167 {\cf21 #endif}\par
02168 \par
02169 {\cf20 /* Remaining macros are deprecated. */}\par
02170 \par
02171 {\cf21 #if defined(JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK)}\par
02172 {\cf21     #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK}\par
02173 {\cf21 #endif}\par
02174 {\cf21 #if defined(__clang__)}\par
02175 {\cf21     #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) (0)}\par
02176 {\cf21 #else}\par
02177 {\cf21     #define JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK(major,minor,patch) JSON_HEDLEY_GCC_VERSION_CHECK(major,minor,patch)}\par
02178 {\cf21 #endif}\par
02179 \par
02180 {\cf21 #if defined(JSON_HEDLEY_CLANG_HAS_ATTRIBUTE)}\par
02181 {\cf21     #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE}\par
02182 {\cf21 #endif}\par
02183 {\cf21 #define JSON_HEDLEY_CLANG_HAS_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_ATTRIBUTE(attribute)}\par
02184 \par
02185 {\cf21 #if defined(JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE)}\par
02186 {\cf21     #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE}\par
02187 {\cf21 #endif}\par
02188 {\cf21 #define JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_CPP_ATTRIBUTE(attribute)}\par
02189 \par
02190 {\cf21 #if defined(JSON_HEDLEY_CLANG_HAS_BUILTIN)}\par
02191 {\cf21     #undef JSON_HEDLEY_CLANG_HAS_BUILTIN}\par
02192 {\cf21 #endif}\par
02193 {\cf21 #define JSON_HEDLEY_CLANG_HAS_BUILTIN(builtin) JSON_HEDLEY_HAS_BUILTIN(builtin)}\par
02194 \par
02195 {\cf21 #if defined(JSON_HEDLEY_CLANG_HAS_FEATURE)}\par
02196 {\cf21     #undef JSON_HEDLEY_CLANG_HAS_FEATURE}\par
02197 {\cf21 #endif}\par
02198 {\cf21 #define JSON_HEDLEY_CLANG_HAS_FEATURE(feature) JSON_HEDLEY_HAS_FEATURE(feature)}\par
02199 \par
02200 {\cf21 #if defined(JSON_HEDLEY_CLANG_HAS_EXTENSION)}\par
02201 {\cf21     #undef JSON_HEDLEY_CLANG_HAS_EXTENSION}\par
02202 {\cf21 #endif}\par
02203 {\cf21 #define JSON_HEDLEY_CLANG_HAS_EXTENSION(extension) JSON_HEDLEY_HAS_EXTENSION(extension)}\par
02204 \par
02205 {\cf21 #if defined(JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE)}\par
02206 {\cf21     #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE}\par
02207 {\cf21 #endif}\par
02208 {\cf21 #define JSON_HEDLEY_CLANG_HAS_DECLSPEC_ATTRIBUTE(attribute) JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE(attribute)}\par
02209 \par
02210 {\cf21 #if defined(JSON_HEDLEY_CLANG_HAS_WARNING)}\par
02211 {\cf21     #undef JSON_HEDLEY_CLANG_HAS_WARNING}\par
02212 {\cf21 #endif}\par
02213 {\cf21 #define JSON_HEDLEY_CLANG_HAS_WARNING(warning) JSON_HEDLEY_HAS_WARNING(warning)}\par
02214 \par
02215 {\cf21 #endif }{\cf20 /* !defined(JSON_HEDLEY_VERSION) || (JSON_HEDLEY_VERSION < X) */}{\cf21 }\par
02216 \par
02217 \par
02218 {\cf20 // This file contains all internal macro definitions}\par
02219 {\cf20 // You MUST include macro_unscope.hpp at the end of json.hpp to undef all of them}\par
02220 \par
02221 {\cf20 // exclude unsupported compilers}\par
02222 {\cf21 #if !defined(JSON_SKIP_UNSUPPORTED_COMPILER_CHECK)}\par
02223 {\cf21     #if defined(__clang__)}\par
02224 {\cf21         #if (__clang_major__ * 10000 + __clang_minor__ * 100 + __clang_patchlevel__) < 30400}\par
02225 {\cf21             #error "unsupported Clang version - see https://github.com/nlohmann/json#supported-compilers"}\par
02226 {\cf21         #endif}\par
02227 {\cf21     #elif defined(__GNUC__) && !(defined(__ICC) || defined(__INTEL_COMPILER))}\par
02228 {\cf21         #if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) < 40800}\par
02229 {\cf21             #error "unsupported GCC version - see https://github.com/nlohmann/json#supported-compilers"}\par
02230 {\cf21         #endif}\par
02231 {\cf21     #endif}\par
02232 {\cf21 #endif}\par
02233 \par
02234 {\cf20 // C++ language standard detection}\par
02235 {\cf20 // if the user manually specified the used c++ version this is skipped}\par
02236 {\cf21 #if !defined(JSON_HAS_CPP_20) && !defined(JSON_HAS_CPP_17) && !defined(JSON_HAS_CPP_14) && !defined(JSON_HAS_CPP_11)}\par
02237 {\cf21     #if (defined(__cplusplus) && __cplusplus >= 202002L) || (defined(_MSVC_LANG) && _MSVC_LANG >= 202002L)}\par
02238 {\cf21         #define JSON_HAS_CPP_20}\par
02239 {\cf21         #define JSON_HAS_CPP_17}\par
02240 {\cf21         #define JSON_HAS_CPP_14}\par
02241 {\cf21     #elif (defined(__cplusplus) && __cplusplus >= 201703L) || (defined(_HAS_CXX17) && _HAS_CXX17 == 1) }{\cf20 // fix for issue #464}\par
02242 {\cf21         #define JSON_HAS_CPP_17}\par
02243 {\cf21         #define JSON_HAS_CPP_14}\par
02244 {\cf21     #elif (defined(__cplusplus) && __cplusplus >= 201402L) || (defined(_HAS_CXX14) && _HAS_CXX14 == 1)}\par
02245 {\cf21         #define JSON_HAS_CPP_14}\par
02246 {\cf21     #endif}\par
02247     {\cf20 // the cpp 11 flag is always specified because it is the minimal required version}\par
02248 {\cf21     #define JSON_HAS_CPP_11}\par
02249 {\cf21 #endif}\par
02250 \par
02251 {\cf20 // disable documentation warnings on clang}\par
02252 {\cf21 #if defined(__clang__)}\par
02253 {\cf21     #pragma clang diagnostic push}\par
02254 {\cf21     #pragma clang diagnostic ignored "-Wdocumentation"}\par
02255 {\cf21     #pragma clang diagnostic ignored "-Wdocumentation-unknown-command"}\par
02256 {\cf21 #endif}\par
02257 \par
02258 {\cf20 // allow to disable exceptions}\par
02259 {\cf21 #if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || defined(_CPPUNWIND)) && !defined(JSON_NOEXCEPTION)}\par
02260 {\cf21     #define JSON_THROW(exception) throw exception}\par
02261 {\cf21     #define JSON_TRY try}\par
02262 {\cf21     #define JSON_CATCH(exception) catch(exception)}\par
02263 {\cf21     #define JSON_INTERNAL_CATCH(exception) catch(exception)}\par
02264 {\cf21 #else}\par
02265 {\cf21     #include <cstdlib>}\par
02266 {\cf21     #define JSON_THROW(exception) std::abort()}\par
02267 {\cf21     #define JSON_TRY if(true)}\par
02268 {\cf21     #define JSON_CATCH(exception) if(false)}\par
02269 {\cf21     #define JSON_INTERNAL_CATCH(exception) if(false)}\par
02270 {\cf21 #endif}\par
02271 \par
02272 {\cf20 // override exception macros}\par
02273 {\cf21 #if defined(JSON_THROW_USER)}\par
02274 {\cf21     #undef JSON_THROW}\par
02275 {\cf21     #define JSON_THROW JSON_THROW_USER}\par
02276 {\cf21 #endif}\par
02277 {\cf21 #if defined(JSON_TRY_USER)}\par
02278 {\cf21     #undef JSON_TRY}\par
02279 {\cf21     #define JSON_TRY JSON_TRY_USER}\par
02280 {\cf21 #endif}\par
02281 {\cf21 #if defined(JSON_CATCH_USER)}\par
02282 {\cf21     #undef JSON_CATCH}\par
02283 {\cf21     #define JSON_CATCH JSON_CATCH_USER}\par
02284 {\cf21     #undef JSON_INTERNAL_CATCH}\par
02285 {\cf21     #define JSON_INTERNAL_CATCH JSON_CATCH_USER}\par
02286 {\cf21 #endif}\par
02287 {\cf21 #if defined(JSON_INTERNAL_CATCH_USER)}\par
02288 {\cf21     #undef JSON_INTERNAL_CATCH}\par
02289 {\cf21     #define JSON_INTERNAL_CATCH JSON_INTERNAL_CATCH_USER}\par
02290 {\cf21 #endif}\par
02291 \par
02292 {\cf20 // allow to override assert}\par
02293 {\cf21 #if !defined(JSON_ASSERT)}\par
02294 {\cf21     #include <cassert>} {\cf20 // assert}\par
02295 {\cf21     #define JSON_ASSERT(x) assert(x)}\par
02296 {\cf21 #endif}\par
02297 \par
02298 {\cf20 // allow to access some private functions (needed by the test suite)}\par
02299 {\cf21 #if defined(JSON_TESTS_PRIVATE)}\par
02300 {\cf21     #define JSON_PRIVATE_UNLESS_TESTED public}\par
02301 {\cf21 #else}\par
02302 {\cf21     #define JSON_PRIVATE_UNLESS_TESTED private}\par
02303 {\cf21 #endif}\par
02304 \par
02310 {\cf21 #define NLOHMANN_JSON_SERIALIZE_ENUM(ENUM_TYPE, ...)                                            \\}\par
02311 {\cf21     template<typename BasicJsonType>                                                            \\}\par
02312 {\cf21     inline void to_json(BasicJsonType& j, const ENUM_TYPE& e)                                   \\}\par
02313 {\cf21     \{                                                                                           \\}\par
02314 {\cf21         static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!"});          \\\par
02315         static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \\\par
02316         auto it = std::find_if(std::begin(m), std::end(m),                                      \\\par
02317                                [e](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool  \\\par
02318         \{                                                                                       \\\par
02319             return ej_pair.first == e;                                                          \\\par
02320         \});                                                                                     \\\par
02321         j = ((it != std::end(m)) ? it : std::begin(m))->second;                                 \\\par
02322     \}                                                                                           \\\par
02323     template<typename BasicJsonType>                                                            \\\par
02324     inline void from_json(const BasicJsonType& j, ENUM_TYPE& e)                                 \\\par
02325     \{                                                                                           \\\par
02326         static_assert(std::is_enum<ENUM_TYPE>::value, #ENUM_TYPE " must be an enum!");          \\\par
02327         static const std::pair<ENUM_TYPE, BasicJsonType> m[] = __VA_ARGS__;                     \\\par
02328         auto it = std::find_if(std::begin(m), std::end(m),                                      \\\par
02329                                [&j](const std::pair<ENUM_TYPE, BasicJsonType>& ej_pair) -> bool \\\par
02330         \{                                                                                       \\\par
02331             return ej_pair.second == j;                                                         \\\par
02332         \});                                                                                     \\\par
02333         e = ((it != std::end(m)) ? it : std::begin(m))->first;                                  \\\par
02334     \}\par
02335 \par
02336 {\cf20 // Ugly macros to avoid uglier copy-paste when specializing basic_json. They}\par
02337 {\cf20 // may be removed in the future once the class is split.}\par
02338 \par
02339 {\cf21 #define NLOHMANN_BASIC_JSON_TPL_DECLARATION                                \\}\par
02340 {\cf21     template<template<typename, typename, typename...> class ObjectType,   \\}\par
02341 {\cf21              template<typename, typename...> class ArrayType,              \\}\par
02342 {\cf21              class StringType, class BooleanType, class NumberIntegerType, \\}\par
02343 {\cf21              class NumberUnsignedType, class NumberFloatType,              \\}\par
02344 {\cf21              template<typename> class AllocatorType,                       \\}\par
02345 {\cf21              template<typename, typename = void> class JSONSerializer,     \\}\par
02346 {\cf21              class BinaryType>}\par
02347 \par
02348 {\cf21 #define NLOHMANN_BASIC_JSON_TPL                                            \\}\par
02349 {\cf21     basic_json<ObjectType, ArrayType, StringType, BooleanType,             \\}\par
02350 {\cf21     NumberIntegerType, NumberUnsignedType, NumberFloatType,                \\}\par
02351 {\cf21     AllocatorType, JSONSerializer, BinaryType>}\par
02352 \par
02353 {\cf20 // Macros to simplify conversion from/to types}\par
02354 \par
02355 {\cf21 #define NLOHMANN_JSON_EXPAND( x ) x}\par
02356 {\cf21 #define NLOHMANN_JSON_GET_MACRO(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, NAME,...) NAME}\par
02357 {\cf21 #define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \\}\par
02358 {\cf21         NLOHMANN_JSON_PASTE64, \\}\par
02359 {\cf21         NLOHMANN_JSON_PASTE63, \\}\par
02360 {\cf21         NLOHMANN_JSON_PASTE62, \\}\par
02361 {\cf21         NLOHMANN_JSON_PASTE61, \\}\par
02362 {\cf21         NLOHMANN_JSON_PASTE60, \\}\par
02363 {\cf21         NLOHMANN_JSON_PASTE59, \\}\par
02364 {\cf21         NLOHMANN_JSON_PASTE58, \\}\par
02365 {\cf21         NLOHMANN_JSON_PASTE57, \\}\par
02366 {\cf21         NLOHMANN_JSON_PASTE56, \\}\par
02367 {\cf21         NLOHMANN_JSON_PASTE55, \\}\par
02368 {\cf21         NLOHMANN_JSON_PASTE54, \\}\par
02369 {\cf21         NLOHMANN_JSON_PASTE53, \\}\par
02370 {\cf21         NLOHMANN_JSON_PASTE52, \\}\par
02371 {\cf21         NLOHMANN_JSON_PASTE51, \\}\par
02372 {\cf21         NLOHMANN_JSON_PASTE50, \\}\par
02373 {\cf21         NLOHMANN_JSON_PASTE49, \\}\par
02374 {\cf21         NLOHMANN_JSON_PASTE48, \\}\par
02375 {\cf21         NLOHMANN_JSON_PASTE47, \\}\par
02376 {\cf21         NLOHMANN_JSON_PASTE46, \\}\par
02377 {\cf21         NLOHMANN_JSON_PASTE45, \\}\par
02378 {\cf21         NLOHMANN_JSON_PASTE44, \\}\par
02379 {\cf21         NLOHMANN_JSON_PASTE43, \\}\par
02380 {\cf21         NLOHMANN_JSON_PASTE42, \\}\par
02381 {\cf21         NLOHMANN_JSON_PASTE41, \\}\par
02382 {\cf21         NLOHMANN_JSON_PASTE40, \\}\par
02383 {\cf21         NLOHMANN_JSON_PASTE39, \\}\par
02384 {\cf21         NLOHMANN_JSON_PASTE38, \\}\par
02385 {\cf21         NLOHMANN_JSON_PASTE37, \\}\par
02386 {\cf21         NLOHMANN_JSON_PASTE36, \\}\par
02387 {\cf21         NLOHMANN_JSON_PASTE35, \\}\par
02388 {\cf21         NLOHMANN_JSON_PASTE34, \\}\par
02389 {\cf21         NLOHMANN_JSON_PASTE33, \\}\par
02390 {\cf21         NLOHMANN_JSON_PASTE32, \\}\par
02391 {\cf21         NLOHMANN_JSON_PASTE31, \\}\par
02392 {\cf21         NLOHMANN_JSON_PASTE30, \\}\par
02393 {\cf21         NLOHMANN_JSON_PASTE29, \\}\par
02394 {\cf21         NLOHMANN_JSON_PASTE28, \\}\par
02395 {\cf21         NLOHMANN_JSON_PASTE27, \\}\par
02396 {\cf21         NLOHMANN_JSON_PASTE26, \\}\par
02397 {\cf21         NLOHMANN_JSON_PASTE25, \\}\par
02398 {\cf21         NLOHMANN_JSON_PASTE24, \\}\par
02399 {\cf21         NLOHMANN_JSON_PASTE23, \\}\par
02400 {\cf21         NLOHMANN_JSON_PASTE22, \\}\par
02401 {\cf21         NLOHMANN_JSON_PASTE21, \\}\par
02402 {\cf21         NLOHMANN_JSON_PASTE20, \\}\par
02403 {\cf21         NLOHMANN_JSON_PASTE19, \\}\par
02404 {\cf21         NLOHMANN_JSON_PASTE18, \\}\par
02405 {\cf21         NLOHMANN_JSON_PASTE17, \\}\par
02406 {\cf21         NLOHMANN_JSON_PASTE16, \\}\par
02407 {\cf21         NLOHMANN_JSON_PASTE15, \\}\par
02408 {\cf21         NLOHMANN_JSON_PASTE14, \\}\par
02409 {\cf21         NLOHMANN_JSON_PASTE13, \\}\par
02410 {\cf21         NLOHMANN_JSON_PASTE12, \\}\par
02411 {\cf21         NLOHMANN_JSON_PASTE11, \\}\par
02412 {\cf21         NLOHMANN_JSON_PASTE10, \\}\par
02413 {\cf21         NLOHMANN_JSON_PASTE9, \\}\par
02414 {\cf21         NLOHMANN_JSON_PASTE8, \\}\par
02415 {\cf21         NLOHMANN_JSON_PASTE7, \\}\par
02416 {\cf21         NLOHMANN_JSON_PASTE6, \\}\par
02417 {\cf21         NLOHMANN_JSON_PASTE5, \\}\par
02418 {\cf21         NLOHMANN_JSON_PASTE4, \\}\par
02419 {\cf21         NLOHMANN_JSON_PASTE3, \\}\par
02420 {\cf21         NLOHMANN_JSON_PASTE2, \\}\par
02421 {\cf21         NLOHMANN_JSON_PASTE1)(__VA_ARGS__))}\par
02422 {\cf21 #define NLOHMANN_JSON_PASTE2(func, v1) func(v1)}\par
02423 {\cf21 #define NLOHMANN_JSON_PASTE3(func, v1, v2) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE2(func, v2)}\par
02424 {\cf21 #define NLOHMANN_JSON_PASTE4(func, v1, v2, v3) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE3(func, v2, v3)}\par
02425 {\cf21 #define NLOHMANN_JSON_PASTE5(func, v1, v2, v3, v4) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE4(func, v2, v3, v4)}\par
02426 {\cf21 #define NLOHMANN_JSON_PASTE6(func, v1, v2, v3, v4, v5) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE5(func, v2, v3, v4, v5)}\par
02427 {\cf21 #define NLOHMANN_JSON_PASTE7(func, v1, v2, v3, v4, v5, v6) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE6(func, v2, v3, v4, v5, v6)}\par
02428 {\cf21 #define NLOHMANN_JSON_PASTE8(func, v1, v2, v3, v4, v5, v6, v7) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE7(func, v2, v3, v4, v5, v6, v7)}\par
02429 {\cf21 #define NLOHMANN_JSON_PASTE9(func, v1, v2, v3, v4, v5, v6, v7, v8) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE8(func, v2, v3, v4, v5, v6, v7, v8)}\par
02430 {\cf21 #define NLOHMANN_JSON_PASTE10(func, v1, v2, v3, v4, v5, v6, v7, v8, v9) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE9(func, v2, v3, v4, v5, v6, v7, v8, v9)}\par
02431 {\cf21 #define NLOHMANN_JSON_PASTE11(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE10(func, v2, v3, v4, v5, v6, v7, v8, v9, v10)}\par
02432 {\cf21 #define NLOHMANN_JSON_PASTE12(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE11(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11)}\par
02433 {\cf21 #define NLOHMANN_JSON_PASTE13(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE12(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12)}\par
02434 {\cf21 #define NLOHMANN_JSON_PASTE14(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE13(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13)}\par
02435 {\cf21 #define NLOHMANN_JSON_PASTE15(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE14(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14)}\par
02436 {\cf21 #define NLOHMANN_JSON_PASTE16(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE15(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15)}\par
02437 {\cf21 #define NLOHMANN_JSON_PASTE17(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE16(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16)}\par
02438 {\cf21 #define NLOHMANN_JSON_PASTE18(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE17(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17)}\par
02439 {\cf21 #define NLOHMANN_JSON_PASTE19(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE18(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18)}\par
02440 {\cf21 #define NLOHMANN_JSON_PASTE20(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE19(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19)}\par
02441 {\cf21 #define NLOHMANN_JSON_PASTE21(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE20(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20)}\par
02442 {\cf21 #define NLOHMANN_JSON_PASTE22(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE21(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21)}\par
02443 {\cf21 #define NLOHMANN_JSON_PASTE23(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE22(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22)}\par
02444 {\cf21 #define NLOHMANN_JSON_PASTE24(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE23(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23)}\par
02445 {\cf21 #define NLOHMANN_JSON_PASTE25(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE24(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24)}\par
02446 {\cf21 #define NLOHMANN_JSON_PASTE26(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE25(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25)}\par
02447 {\cf21 #define NLOHMANN_JSON_PASTE27(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE26(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26)}\par
02448 {\cf21 #define NLOHMANN_JSON_PASTE28(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE27(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27)}\par
02449 {\cf21 #define NLOHMANN_JSON_PASTE29(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE28(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28)}\par
02450 {\cf21 #define NLOHMANN_JSON_PASTE30(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE29(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29)}\par
02451 {\cf21 #define NLOHMANN_JSON_PASTE31(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE30(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30)}\par
02452 {\cf21 #define NLOHMANN_JSON_PASTE32(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE31(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31)}\par
02453 {\cf21 #define NLOHMANN_JSON_PASTE33(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE32(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32)}\par
02454 {\cf21 #define NLOHMANN_JSON_PASTE34(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE33(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33)}\par
02455 {\cf21 #define NLOHMANN_JSON_PASTE35(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE34(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34)}\par
02456 {\cf21 #define NLOHMANN_JSON_PASTE36(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE35(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35)}\par
02457 {\cf21 #define NLOHMANN_JSON_PASTE37(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE36(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36)}\par
02458 {\cf21 #define NLOHMANN_JSON_PASTE38(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE37(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37)}\par
02459 {\cf21 #define NLOHMANN_JSON_PASTE39(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE38(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38)}\par
02460 {\cf21 #define NLOHMANN_JSON_PASTE40(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE39(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39)}\par
02461 {\cf21 #define NLOHMANN_JSON_PASTE41(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE40(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40)}\par
02462 {\cf21 #define NLOHMANN_JSON_PASTE42(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE41(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41)}\par
02463 {\cf21 #define NLOHMANN_JSON_PASTE43(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE42(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42)}\par
02464 {\cf21 #define NLOHMANN_JSON_PASTE44(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE43(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43)}\par
02465 {\cf21 #define NLOHMANN_JSON_PASTE45(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE44(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44)}\par
02466 {\cf21 #define NLOHMANN_JSON_PASTE46(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE45(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45)}\par
02467 {\cf21 #define NLOHMANN_JSON_PASTE47(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE46(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46)}\par
02468 {\cf21 #define NLOHMANN_JSON_PASTE48(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE47(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47)}\par
02469 {\cf21 #define NLOHMANN_JSON_PASTE49(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE48(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48)}\par
02470 {\cf21 #define NLOHMANN_JSON_PASTE50(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE49(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49)}\par
02471 {\cf21 #define NLOHMANN_JSON_PASTE51(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE50(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50)}\par
02472 {\cf21 #define NLOHMANN_JSON_PASTE52(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE51(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51)}\par
02473 {\cf21 #define NLOHMANN_JSON_PASTE53(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE52(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52)}\par
02474 {\cf21 #define NLOHMANN_JSON_PASTE54(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE53(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53)}\par
02475 {\cf21 #define NLOHMANN_JSON_PASTE55(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE54(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54)}\par
02476 {\cf21 #define NLOHMANN_JSON_PASTE56(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE55(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55)}\par
02477 {\cf21 #define NLOHMANN_JSON_PASTE57(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE56(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56)}\par
02478 {\cf21 #define NLOHMANN_JSON_PASTE58(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE57(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57)}\par
02479 {\cf21 #define NLOHMANN_JSON_PASTE59(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE58(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58)}\par
02480 {\cf21 #define NLOHMANN_JSON_PASTE60(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE59(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59)}\par
02481 {\cf21 #define NLOHMANN_JSON_PASTE61(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE60(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60)}\par
02482 {\cf21 #define NLOHMANN_JSON_PASTE62(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE61(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61)}\par
02483 {\cf21 #define NLOHMANN_JSON_PASTE63(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE62(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62)}\par
02484 {\cf21 #define NLOHMANN_JSON_PASTE64(func, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63) NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE63(func, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63)}\par
02485 \par
02486 {\cf21 #define NLOHMANN_JSON_TO(v1) nlohmann_json_j[#v1] = nlohmann_json_t.v1;}\par
02487 {\cf21 #define NLOHMANN_JSON_FROM(v1) nlohmann_json_j.at(#v1).get_to(nlohmann_json_t.v1);}\par
02488 \par
02494 {\cf21 #define NLOHMANN_DEFINE_TYPE_INTRUSIVE(Type, ...)  \\}\par
02495 {\cf21     friend void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) \{ NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) \} \\}\par
02496 {\cf21     friend void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) \{ NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) \}}\par
02497 \par
02503 {\cf21 #define NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(Type, ...)  \\}\par
02504 {\cf21     inline void to_json(nlohmann::json& nlohmann_json_j, const Type& nlohmann_json_t) \{ NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_TO, __VA_ARGS__)) \} \\}\par
02505 {\cf21     inline void from_json(const nlohmann::json& nlohmann_json_j, Type& nlohmann_json_t) \{ NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_PASTE(NLOHMANN_JSON_FROM, __VA_ARGS__)) \}}\par
02506 \par
02507 {\cf21 #ifndef JSON_USE_IMPLICIT_CONVERSIONS}\par
02508 {\cf21     #define JSON_USE_IMPLICIT_CONVERSIONS 1}\par
02509 {\cf21 #endif}\par
02510 \par
02511 {\cf21 #if JSON_USE_IMPLICIT_CONVERSIONS}\par
02512 {\cf21     #define JSON_EXPLICIT}\par
02513 {\cf21 #else}\par
02514 {\cf21     #define JSON_EXPLICIT explicit}\par
02515 {\cf21 #endif}\par
02516 \par
02517 {\cf21 #ifndef JSON_DIAGNOSTICS}\par
02518 {\cf21     #define JSON_DIAGNOSTICS 0}\par
02519 {\cf21 #endif}\par
02520 \par
02521 \par
02522 {\cf17 namespace }nlohmann\par
02523 \{\par
02524 {\cf17 namespace }detail\par
02525 \{\par
02526 \par
02540 {\cf17 inline} {\cf18 void} replace_substring(std::string& s, {\cf17 const} std::string& f,\par
02541                               {\cf17 const} std::string& t)\par
02542 \{\par
02543     JSON_ASSERT(!f.empty());\par
02544     {\cf19 for} ({\cf17 auto} pos = s.find(f);                {\cf20 // find first occurrence of f}\par
02545             pos != std::string::npos;         {\cf20 // make sure f was found}\par
02546             s.replace(pos, f.size(), t),      {\cf20 // replace with t, and}\par
02547             pos = s.find(f, pos + t.size()))  {\cf20 // find next occurrence of f}\par
02548     \{\}\par
02549 \}\par
02550 \par
02558 {\cf17 inline} std::string escape(std::string s)\par
02559 \{\par
02560     replace_substring(s, {\cf22 "~"}, {\cf22 "~0"});\par
02561     replace_substring(s, {\cf22 "/"}, {\cf22 "~1"});\par
02562     {\cf19 return} s;\par
02563 \}\par
02564 \par
02572 {\cf17 static} {\cf18 void} unescape(std::string& s)\par
02573 \{\par
02574     replace_substring(s, {\cf22 "~1"}, {\cf22 "/"});\par
02575     replace_substring(s, {\cf22 "~0"}, {\cf22 "~"});\par
02576 \}\par
02577 \par
02578 \} {\cf20 // namespace detail}\par
02579 \} {\cf20 // namespace nlohmann}\par
02580 \par
02581 {\cf20 // #include <nlohmann/detail/input/position_t.hpp>}\par
02582 \par
02583 \par
02584 {\cf21 #include <cstddef>} {\cf20 // size_t}\par
02585 \par
02586 {\cf17 namespace }nlohmann\par
02587 \{\par
02588 {\cf17 namespace }detail\par
02589 \{\par
02591 {\cf17 struct }position_t\par
02592 \{\par
02594     std::size_t chars_read_total = 0;\par
02596     std::size_t chars_read_current_line = 0;\par
02598     std::size_t lines_read = 0;\par
02599 \par
02601     {\cf17 constexpr} {\cf17 operator} size_t(){\cf17  const}\par
02602 {\cf17     }\{\par
02603         {\cf19 return} chars_read_total;\par
02604     \}\par
02605 \};\par
02606 \par
02607 \} {\cf20 // namespace detail}\par
02608 \} {\cf20 // namespace nlohmann}\par
02609 \par
02610 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
02611 \par
02612 \par
02613 {\cf17 namespace }nlohmann\par
02614 \{\par
02615 {\cf17 namespace }detail\par
02616 \{\par
02618 {\cf20 // exceptions //}\par
02620 {\cf20 }\par
02649 {\cf17 class }exception : {\cf17 public} std::exception\par
02650 \{\par
02651   {\cf17 public}:\par
02653     {\cf17 const} {\cf18 char}* what() const noexcept{\cf17  override}\par
02654 {\cf17     }\{\par
02655         {\cf19 return} m.what();\par
02656     \}\par
02657 \par
02659     {\cf17 const} {\cf18 int} id; {\cf20 // NOLINT(cppcoreguidelines-non-private-member-variables-in-classes)}\par
02660 \par
02661   {\cf17 protected}:\par
02662     JSON_HEDLEY_NON_NULL(3)\par
02663     exception({\cf18 int} id_, const {\cf18 char}* what_arg) : {\cf18 id}(id_), m(what_arg) \{\}\par
02664 \par
02665     {\cf17 static} std::string name({\cf17 const} std::string& ename, {\cf18 int} id_)\par
02666     \{\par
02667         {\cf19 return} {\cf22 "[json.exception."} + ename + {\cf22 "."} + std::to_string(id_) + {\cf22 "] "};\par
02668     \}\par
02669 \par
02670     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
02671     {\cf17 static} std::string diagnostics({\cf17 const} BasicJsonType& leaf_element)\par
02672     \{\par
02673 {\cf21 #if JSON_DIAGNOSTICS}\par
02674         std::vector<std::string> tokens;\par
02675         {\cf19 for} ({\cf17 const} {\cf17 auto}* current = &leaf_element; current->m_parent != {\cf17 nullptr}; current = current->m_parent)\par
02676         \{\par
02677             {\cf19 switch} (current->m_parent->type())\par
02678             \{\par
02679                 {\cf19 case} value_t::array:\par
02680                 \{\par
02681                     {\cf19 for} (std::size_t i = 0; i < current->m_parent->m_value.array->size(); ++i)\par
02682                     \{\par
02683                         {\cf19 if} (&current->m_parent->m_value.array->operator[](i) == current)\par
02684                         \{\par
02685                             tokens.emplace_back(std::to_string(i));\par
02686                             {\cf19 break};\par
02687                         \}\par
02688                     \}\par
02689                     {\cf19 break};\par
02690                 \}\par
02691 \par
02692                 {\cf19 case} value_t::object:\par
02693                 \{\par
02694                     {\cf19 for} ({\cf17 const} {\cf17 auto}& element : *current->m_parent->m_value.object)\par
02695                     \{\par
02696                         {\cf19 if} (&element.second == current)\par
02697                         \{\par
02698                             tokens.emplace_back(element.first.c_str());\par
02699                             {\cf19 break};\par
02700                         \}\par
02701                     \}\par
02702                     {\cf19 break};\par
02703                 \}\par
02704 \par
02705                 {\cf19 case} value_t::null: {\cf20 // LCOV_EXCL_LINE}\par
02706                 {\cf19 case} value_t::string: {\cf20 // LCOV_EXCL_LINE}\par
02707                 {\cf19 case} value_t::boolean: {\cf20 // LCOV_EXCL_LINE}\par
02708                 {\cf19 case} value_t::number_integer: {\cf20 // LCOV_EXCL_LINE}\par
02709                 {\cf19 case} value_t::number_unsigned: {\cf20 // LCOV_EXCL_LINE}\par
02710                 {\cf19 case} value_t::number_float: {\cf20 // LCOV_EXCL_LINE}\par
02711                 {\cf19 case} value_t::binary: {\cf20 // LCOV_EXCL_LINE}\par
02712                 {\cf19 case} value_t::discarded: {\cf20 // LCOV_EXCL_LINE}\par
02713                 {\cf19 default}:   {\cf20 // LCOV_EXCL_LINE}\par
02714                     {\cf19 break}; {\cf20 // LCOV_EXCL_LINE}\par
02715             \}\par
02716         \}\par
02717 \par
02718         {\cf19 if} (tokens.empty())\par
02719         \{\par
02720             {\cf19 return} {\cf22 ""};\par
02721         \}\par
02722 \par
02723         {\cf19 return} {\cf22 "("} + std::accumulate(tokens.rbegin(), tokens.rend(), std::string\{\},\par
02724                                      []({\cf17 const} std::string & a, {\cf17 const} std::string & b)\par
02725         \{\par
02726             return a + {\cf22 "/"} + detail::escape(b);\par
02727         \}) + {\cf22 ") "};\par
02728 {\cf21 #else}\par
02729         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(leaf_element);\par
02730         {\cf19 return} {\cf22 ""};\par
02731 {\cf21 #endif}\par
02732     \}\par
02733 \par
02734   {\cf17 private}:\par
02736     std::runtime_error m;\par
02737 \};\par
02738 \par
02784 {\cf17 class }parse_error : {\cf17 public} exception\par
02785 \{\par
02786   {\cf17 public}:\par
02796     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
02797     {\cf17 static} parse_error create({\cf18 int} id_, {\cf17 const} position_t& pos, {\cf17 const} std::string& what_arg, {\cf17 const} BasicJsonType& context)\par
02798     \{\par
02799         std::string w = exception::name({\cf22 "parse_error"}, id_) + {\cf22 "parse error"} +\par
02800                         position_string(pos) + {\cf22 ": "} + exception::diagnostics(context) + what_arg;\par
02801         {\cf19 return} parse_error(id_, pos.chars_read_total, w.c_str());\par
02802     \}\par
02803 \par
02804     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
02805     {\cf17 static} parse_error create({\cf18 int} id_, std::size_t byte_, {\cf17 const} std::string& what_arg, {\cf17 const} BasicJsonType& context)\par
02806     \{\par
02807         std::string w = exception::name({\cf22 "parse_error"}, id_) + {\cf22 "parse error"} +\par
02808                         (byte_ != 0 ? ({\cf22 " at byte "} + std::to_string(byte_)) : {\cf22 ""}) +\par
02809                         {\cf22 ": "} + exception::diagnostics(context) + what_arg;\par
02810         {\cf19 return} parse_error(id_, byte_, w.c_str());\par
02811     \}\par
02812 \par
02822     {\cf17 const} std::size_t byte;\par
02823 \par
02824   {\cf17 private}:\par
02825     parse_error({\cf18 int} id_, std::size_t byte_, {\cf17 const} {\cf18 char}* what_arg)\par
02826         : exception(id_, what_arg), byte(byte_) \{\}\par
02827 \par
02828     {\cf17 static} std::string position_string({\cf17 const} position_t& pos)\par
02829     \{\par
02830         {\cf19 return} {\cf22 " at line "} + std::to_string(pos.lines_read + 1) +\par
02831                {\cf22 ", column "} + std::to_string(pos.chars_read_current_line);\par
02832     \}\par
02833 \};\par
02834 \par
02872 {\cf17 class }invalid_iterator : {\cf17 public} exception\par
02873 \{\par
02874   {\cf17 public}:\par
02875     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
02876     {\cf17 static} invalid_iterator create({\cf18 int} id_, {\cf17 const} std::string& what_arg, {\cf17 const} BasicJsonType& context)\par
02877     \{\par
02878         std::string w = exception::name({\cf22 "invalid_iterator"}, id_) + exception::diagnostics(context) + what_arg;\par
02879         {\cf19 return} invalid_iterator(id_, w.c_str());\par
02880     \}\par
02881 \par
02882   {\cf17 private}:\par
02883     JSON_HEDLEY_NON_NULL(3)\par
02884     invalid_iterator({\cf18 int} id_, const {\cf18 char}* what_arg)\par
02885         : exception(id_, what_arg) \{\}\par
02886 \};\par
02887 \par
02927 {\cf17 class }type_error : {\cf17 public} exception\par
02928 \{\par
02929   {\cf17 public}:\par
02930     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
02931     {\cf17 static} type_error create({\cf18 int} id_, {\cf17 const} std::string& what_arg, {\cf17 const} BasicJsonType& context)\par
02932     \{\par
02933         std::string w = exception::name({\cf22 "type_error"}, id_) + exception::diagnostics(context) + what_arg;\par
02934         {\cf19 return} type_error(id_, w.c_str());\par
02935     \}\par
02936 \par
02937   {\cf17 private}:\par
02938     JSON_HEDLEY_NON_NULL(3)\par
02939     type_error({\cf18 int} id_, const {\cf18 char}* what_arg) : exception(id_, what_arg) \{\}\par
02940 \};\par
02941 \par
02975 {\cf17 class }out_of_range : {\cf17 public} exception\par
02976 \{\par
02977   {\cf17 public}:\par
02978     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
02979     {\cf17 static} out_of_range create({\cf18 int} id_, {\cf17 const} std::string& what_arg, {\cf17 const} BasicJsonType& context)\par
02980     \{\par
02981         std::string w = exception::name({\cf22 "out_of_range"}, id_) + exception::diagnostics(context) + what_arg;\par
02982         {\cf19 return} out_of_range(id_, w.c_str());\par
02983     \}\par
02984 \par
02985   {\cf17 private}:\par
02986     JSON_HEDLEY_NON_NULL(3)\par
02987     out_of_range({\cf18 int} id_, const {\cf18 char}* what_arg) : exception(id_, what_arg) \{\}\par
02988 \};\par
02989 \par
03014 {\cf17 class }other_error : {\cf17 public} exception\par
03015 \{\par
03016   {\cf17 public}:\par
03017     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
03018     {\cf17 static} other_error create({\cf18 int} id_, {\cf17 const} std::string& what_arg, {\cf17 const} BasicJsonType& context)\par
03019     \{\par
03020         std::string w = exception::name({\cf22 "other_error"}, id_) + exception::diagnostics(context) + what_arg;\par
03021         {\cf19 return} other_error(id_, w.c_str());\par
03022     \}\par
03023 \par
03024   {\cf17 private}:\par
03025     JSON_HEDLEY_NON_NULL(3)\par
03026     other_error({\cf18 int} id_, const {\cf18 char}* what_arg) : exception(id_, what_arg) \{\}\par
03027 \};\par
03028 \}  {\cf20 // namespace detail}\par
03029 \}  {\cf20 // namespace nlohmann}\par
03030 \par
03031 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
03032 \par
03033 {\cf20 // #include <nlohmann/detail/meta/cpp_future.hpp>}\par
03034 \par
03035 \par
03036 {\cf21 #include <cstddef>} {\cf20 // size_t}\par
03037 {\cf21 #include <type_traits>} {\cf20 // conditional, enable_if, false_type, integral_constant, is_constructible, is_integral, is_same, remove_cv, remove_reference, true_type}\par
03038 {\cf21 #include <utility>} {\cf20 // index_sequence, make_index_sequence, index_sequence_for}\par
03039 \par
03040 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
03041 \par
03042 \par
03043 {\cf17 namespace }nlohmann\par
03044 \{\par
03045 {\cf17 namespace }detail\par
03046 \{\par
03047 \par
03048 {\cf17 template}<{\cf17 typename} T>\par
03049 {\cf17 using} uncvref_t = {\cf17 typename} std::remove_cv<typename std::remove_reference<T>::type>::type;\par
03050 \par
03051 {\cf21 #ifdef JSON_HAS_CPP_14}\par
03052 \par
03053 {\cf20 // the following utilities are natively available in C++14}\par
03054 {\cf17 using} std::enable_if_t;\par
03055 {\cf17 using} std::index_sequence;\par
03056 {\cf17 using} std::make_index_sequence;\par
03057 {\cf17 using} std::index_sequence_for;\par
03058 \par
03059 {\cf21 #else}\par
03060 \par
03061 {\cf20 // alias templates to reduce boilerplate}\par
03062 {\cf17 template}<{\cf18 bool} B, {\cf17 typename} T = {\cf18 void}>\par
03063 {\cf17 using} enable_if_t = {\cf17 typename} std::enable_if<B, T>::type;\par
03064 \par
03065 {\cf20 // The following code is taken from https://github.com/abseil/abseil-cpp/blob/10cb35e459f5ecca5b2ff107635da0bfa41011b4/absl/utility/utility.h}\par
03066 {\cf20 // which is part of Google Abseil (https://github.com/abseil/abseil-cpp), licensed under the Apache License 2.0.}\par
03067 \par
03069 \par
03070 {\cf20 // integer_sequence}\par
03071 {\cf20 //}\par
03072 {\cf20 // Class template representing a compile-time integer sequence. An instantiation}\par
03073 {\cf20 // of `integer_sequence<T, Ints...>` has a sequence of integers encoded in its}\par
03074 {\cf20 // type through its template arguments (which is a common need when}\par
03075 {\cf20 // working with C++11 variadic templates). `absl::integer_sequence` is designed}\par
03076 {\cf20 // to be a drop-in replacement for C++14's `std::integer_sequence`.}\par
03077 {\cf20 //}\par
03078 {\cf20 // Example:}\par
03079 {\cf20 //}\par
03080 {\cf20 //   template< class T, T... Ints >}\par
03081 {\cf20 //   void user_function(integer_sequence<T, Ints...>);}\par
03082 {\cf20 //}\par
03083 {\cf20 //   int main()}\par
03084 {\cf20 //   \{}\par
03085 {\cf20 //     // user_function's `T` will be deduced to `int` and `Ints...`}\par
03086 {\cf20 //     // will be deduced to `0, 1, 2, 3, 4`.}\par
03087 {\cf20 //     user_function(make_integer_sequence<int, 5>());}\par
03088 {\cf20 //   \}}\par
03089 {\cf17 template} <{\cf17 typename} T, T... Ints>\par
03090 {\cf17 struct }integer_sequence\par
03091 \{\par
03092     {\cf17 using} value_type = T;\par
03093     {\cf17 static} {\cf17 constexpr} std::size_t size() noexcept\par
03094     \{\par
03095         {\cf19 return} {\cf17 sizeof}...(Ints);\par
03096     \}\par
03097 \};\par
03098 \par
03099 {\cf20 // index_sequence}\par
03100 {\cf20 //}\par
03101 {\cf20 // A helper template for an `integer_sequence` of `size_t`,}\par
03102 {\cf20 // `absl::index_sequence` is designed to be a drop-in replacement for C++14's}\par
03103 {\cf20 // `std::index_sequence`.}\par
03104 {\cf17 template} <{\cf18 size_t}... Ints>\par
03105 {\cf17 using} index_sequence = integer_sequence<size_t, Ints...>;\par
03106 \par
03107 {\cf17 namespace }utility_internal\par
03108 \{\par
03109 \par
03110 {\cf17 template} <{\cf17 typename} Seq, {\cf18 size_t} SeqSize, {\cf18 size_t} Rem>\par
03111 {\cf17 struct }Extend;\par
03112 \par
03113 {\cf20 // Note that SeqSize == sizeof...(Ints). It's passed explicitly for efficiency.}\par
03114 {\cf17 template} <{\cf17 typename} T, T... Ints, {\cf18 size_t} SeqSize>\par
03115 {\cf17 struct }Extend<integer_sequence<T, Ints...>, SeqSize, 0>\par
03116 \{\par
03117     {\cf17 using} type = integer_sequence < T, Ints..., (Ints + SeqSize)... >;\par
03118 \};\par
03119 \par
03120 {\cf17 template} <{\cf17 typename} T, T... Ints, {\cf18 size_t} SeqSize>\par
03121 {\cf17 struct }Extend<integer_sequence<T, Ints...>, SeqSize, 1>\par
03122 \{\par
03123     {\cf17 using} type = integer_sequence < T, Ints..., (Ints + SeqSize)..., 2 * SeqSize >;\par
03124 \};\par
03125 \par
03126 {\cf20 // Recursion helper for 'make_integer_sequence<T, N>'.}\par
03127 {\cf20 // 'Gen<T, N>::type' is an alias for 'integer_sequence<T, 0, 1, ... N-1>'.}\par
03128 {\cf17 template} <{\cf17 typename} T, {\cf18 size_t} N>\par
03129 {\cf17 struct }Gen\par
03130 \{\par
03131     {\cf17 using} type =\par
03132         {\cf17 typename} Extend < {\cf17 typename} Gen < T, N / 2 >::type, N / 2, N % 2 >::type;\par
03133 \};\par
03134 \par
03135 {\cf17 template} <{\cf17 typename} T>\par
03136 {\cf17 struct }Gen<T, 0>\par
03137 \{\par
03138     {\cf17 using} type = integer_sequence<T>;\par
03139 \};\par
03140 \par
03141 \}  {\cf20 // namespace utility_internal}\par
03142 \par
03143 {\cf20 // Compile-time sequences of integers}\par
03144 \par
03145 {\cf20 // make_integer_sequence}\par
03146 {\cf20 //}\par
03147 {\cf20 // This template alias is equivalent to}\par
03148 {\cf20 // `integer_sequence<int, 0, 1, ..., N-1>`, and is designed to be a drop-in}\par
03149 {\cf20 // replacement for C++14's `std::make_integer_sequence`.}\par
03150 {\cf17 template} <{\cf17 typename} T, T N>\par
03151 {\cf17 using} make_integer_sequence = {\cf17 typename} utility_internal::Gen<T, N>::type;\par
03152 \par
03153 {\cf20 // make_index_sequence}\par
03154 {\cf20 //}\par
03155 {\cf20 // This template alias is equivalent to `index_sequence<0, 1, ..., N-1>`,}\par
03156 {\cf20 // and is designed to be a drop-in replacement for C++14's}\par
03157 {\cf20 // `std::make_index_sequence`.}\par
03158 {\cf17 template} <{\cf18 size_t} N>\par
03159 {\cf17 using} make_index_sequence = make_integer_sequence<size_t, N>;\par
03160 \par
03161 {\cf20 // index_sequence_for}\par
03162 {\cf20 //}\par
03163 {\cf20 // Converts a typename pack into an index sequence of the same length, and}\par
03164 {\cf20 // is designed to be a drop-in replacement for C++14's}\par
03165 {\cf20 // `std::index_sequence_for()`}\par
03166 {\cf17 template} <{\cf17 typename}... Ts>\par
03167 {\cf17 using} index_sequence_for = make_index_sequence<{\cf17 sizeof}...(Ts)>;\par
03168 \par
03170 \par
03171 {\cf21 #endif}\par
03172 \par
03173 {\cf20 // dispatch utility (taken from ranges-v3)}\par
03174 {\cf17 template}<{\cf18 unsigned} N> {\cf17 struct }priority_tag : priority_tag < N - 1 > \{\};\par
03175 {\cf17 template}<> {\cf17 struct }priority_tag<0> \{\};\par
03176 \par
03177 {\cf20 // taken from ranges-v3}\par
03178 {\cf17 template}<{\cf17 typename} T>\par
03179 {\cf17 struct }static_const\par
03180 \{\par
03181     {\cf17 static} {\cf17 constexpr} T value\{\};\par
03182 \};\par
03183 \par
03184 {\cf17 template}<{\cf17 typename} T>\par
03185 {\cf17 constexpr} T static_const<T>::value;\par
03186 \par
03187 \}  {\cf20 // namespace detail}\par
03188 \}  {\cf20 // namespace nlohmann}\par
03189 \par
03190 {\cf20 // #include <nlohmann/detail/meta/identity_tag.hpp>}\par
03191 \par
03192 \par
03193 {\cf17 namespace }nlohmann\par
03194 \{\par
03195 {\cf17 namespace }detail\par
03196 \{\par
03197 {\cf20 // dispatching helper struct}\par
03198 {\cf17 template} <{\cf17 class} T> {\cf17 struct }identity_tag \{\};\par
03199 \}  {\cf20 // namespace detail}\par
03200 \}  {\cf20 // namespace nlohmann}\par
03201 \par
03202 {\cf20 // #include <nlohmann/detail/meta/type_traits.hpp>}\par
03203 \par
03204 \par
03205 {\cf21 #include <limits>} {\cf20 // numeric_limits}\par
03206 {\cf21 #include <type_traits>} {\cf20 // false_type, is_constructible, is_integral, is_same, true_type}\par
03207 {\cf21 #include <utility>} {\cf20 // declval}\par
03208 {\cf21 #include <tuple>} {\cf20 // tuple}\par
03209 \par
03210 {\cf20 // #include <nlohmann/detail/iterators/iterator_traits.hpp>}\par
03211 \par
03212 \par
03213 {\cf21 #include <iterator>} {\cf20 // random_access_iterator_tag}\par
03214 \par
03215 {\cf20 // #include <nlohmann/detail/meta/void_t.hpp>}\par
03216 \par
03217 \par
03218 {\cf17 namespace }nlohmann\par
03219 \{\par
03220 {\cf17 namespace }detail\par
03221 \{\par
03222 {\cf17 template}<{\cf17 typename} ...Ts> {\cf17 struct }make_void\par
03223 \{\par
03224     {\cf17 using} type = void;\par
03225 \};\par
03226 {\cf17 template}<{\cf17 typename} ...Ts> {\cf17 using} void_t = {\cf17 typename} make_void<Ts...>::type;\par
03227 \} {\cf20 // namespace detail}\par
03228 \}  {\cf20 // namespace nlohmann}\par
03229 \par
03230 {\cf20 // #include <nlohmann/detail/meta/cpp_future.hpp>}\par
03231 \par
03232 \par
03233 {\cf17 namespace }nlohmann\par
03234 \{\par
03235 {\cf17 namespace }detail\par
03236 \{\par
03237 {\cf17 template}<{\cf17 typename} It, {\cf17 typename} = {\cf18 void}>\par
03238 {\cf17 struct }iterator_types \{\};\par
03239 \par
03240 {\cf17 template}<{\cf17 typename} It>\par
03241 {\cf17 struct }iterator_types <\par
03242     It,\par
03243     void_t<typename It::difference_type, typename It::value_type, typename It::pointer,\par
03244     typename It::reference, typename It::iterator_category >>\par
03245 \{\par
03246     {\cf17 using} difference_type = {\cf17 typename} It::difference_type;\par
03247     {\cf17 using} value_type = {\cf17 typename} It::value_type;\par
03248     {\cf17 using} pointer = {\cf17 typename} It::pointer;\par
03249     {\cf17 using} reference = {\cf17 typename} It::reference;\par
03250     {\cf17 using} iterator_category = {\cf17 typename} It::iterator_category;\par
03251 \};\par
03252 \par
03253 {\cf20 // This is required as some compilers implement std::iterator_traits in a way that}\par
03254 {\cf20 // doesn't work with SFINAE. See https://github.com/nlohmann/json/issues/1341.}\par
03255 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
03256 {\cf17 struct }iterator_traits\par
03257 \{\par
03258 \};\par
03259 \par
03260 {\cf17 template}<{\cf17 typename} T>\par
03261 {\cf17 struct }iterator_traits < T, enable_if_t < !std::is_pointer<T>::value >>\par
03262             : iterator_types<T>\par
03263 \{\par
03264 \};\par
03265 \par
03266 {\cf17 template}<{\cf17 typename} T>\par
03267 {\cf17 struct }iterator_traits<T*, enable_if_t<std::is_object<T>::value>>\par
03268 \{\par
03269     {\cf17 using} iterator_category = std::random_access_iterator_tag;\par
03270     {\cf17 using} value_type = T;\par
03271     {\cf17 using} difference_type = ptrdiff_t;\par
03272     {\cf17 using} pointer = T*;\par
03273     {\cf17 using} reference = T&;\par
03274 \};\par
03275 \} {\cf20 // namespace detail}\par
03276 \} {\cf20 // namespace nlohmann}\par
03277 \par
03278 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
03279 \par
03280 {\cf20 // #include <nlohmann/detail/meta/cpp_future.hpp>}\par
03281 \par
03282 {\cf20 // #include <nlohmann/detail/meta/detected.hpp>}\par
03283 \par
03284 \par
03285 {\cf21 #include <type_traits>}\par
03286 \par
03287 {\cf20 // #include <nlohmann/detail/meta/void_t.hpp>}\par
03288 \par
03289 \par
03290 {\cf20 // https://en.cppreference.com/w/cpp/experimental/is_detected}\par
03291 {\cf17 namespace }nlohmann\par
03292 \{\par
03293 {\cf17 namespace }detail\par
03294 \{\par
03295 {\cf17 struct }nonesuch\par
03296 \{\par
03297     nonesuch() = {\cf17 delete};\par
03298     ~nonesuch() = {\cf17 delete};\par
03299     nonesuch(nonesuch {\cf17 const}&) = {\cf17 delete};\par
03300     nonesuch(nonesuch {\cf17 const}&&) = {\cf17 delete};\par
03301     {\cf18 void} operator=(nonesuch {\cf17 const}&) = {\cf17 delete};\par
03302     {\cf18 void} operator=(nonesuch&&) = {\cf17 delete};\par
03303 \};\par
03304 \par
03305 {\cf17 template}<{\cf17 class }Default,\par
03306          {\cf17 class }AlwaysVoid,\par
03307          {\cf17 template}<{\cf17 class}...> {\cf17 class }Op,\par
03308          {\cf17 class}... Args>\par
03309 {\cf17 struct }detector\par
03310 \{\par
03311     {\cf17 using} value_t = std::false_type;\par
03312     {\cf17 using} type = Default;\par
03313 \};\par
03314 \par
03315 {\cf17 template}<{\cf17 class }Default, {\cf17 template}<{\cf17 class}...> {\cf17 class }Op, {\cf17 class}... Args>\par
03316 {\cf17 struct }detector<Default, void_t<Op<Args...>>, Op, Args...>\par
03317 \{\par
03318     {\cf17 using} value_t = std::true_type;\par
03319     {\cf17 using} type = Op<Args...>;\par
03320 \};\par
03321 \par
03322 {\cf17 template}<{\cf17 template}<{\cf17 class}...> {\cf17 class }Op, {\cf17 class}... Args>\par
03323 {\cf17 using} is_detected = {\cf17 typename} detector<nonesuch, void, Op, Args...>::value_t;\par
03324 \par
03325 {\cf17 template}<{\cf17 template}<{\cf17 class}...> {\cf17 class }Op, {\cf17 class}... Args>\par
03326 {\cf17 struct }is_detected_lazy : is_detected<Op, Args...> \{ \};\par
03327 \par
03328 {\cf17 template}<{\cf17 template}<{\cf17 class}...> {\cf17 class }Op, {\cf17 class}... Args>\par
03329 {\cf17 using} detected_t = {\cf17 typename} detector<nonesuch, void, Op, Args...>::type;\par
03330 \par
03331 {\cf17 template}<{\cf17 class }Default, {\cf17 template}<{\cf17 class}...> {\cf17 class }Op, {\cf17 class}... Args>\par
03332 {\cf17 using} detected_or = detector<Default, void, Op, Args...>;\par
03333 \par
03334 {\cf17 template}<{\cf17 class }Default, {\cf17 template}<{\cf17 class}...> {\cf17 class }Op, {\cf17 class}... Args>\par
03335 {\cf17 using} detected_or_t = {\cf17 typename} detected_or<Default, Op, Args...>::type;\par
03336 \par
03337 {\cf17 template}<{\cf17 class }Expected, {\cf17 template}<{\cf17 class}...> {\cf17 class }Op, {\cf17 class}... Args>\par
03338 {\cf17 using} is_detected_exact = std::is_same<Expected, detected_t<Op, Args...>>;\par
03339 \par
03340 {\cf17 template}<{\cf17 class }To, {\cf17 template}<{\cf17 class}...> {\cf17 class }Op, {\cf17 class}... Args>\par
03341 {\cf17 using} is_detected_convertible =\par
03342     std::is_convertible<detected_t<Op, Args...>, To>;\par
03343 \}  {\cf20 // namespace detail}\par
03344 \}  {\cf20 // namespace nlohmann}\par
03345 \par
03346 {\cf20 // #include <nlohmann/json_fwd.hpp>}\par
03347 {\cf21 #ifndef INCLUDE_NLOHMANN_JSON_FWD_HPP_}\par
03348 {\cf21 #define INCLUDE_NLOHMANN_JSON_FWD_HPP_}\par
03349 \par
03350 {\cf21 #include <cstdint>} {\cf20 // int64_t, uint64_t}\par
03351 {\cf21 #include <map>} {\cf20 // map}\par
03352 {\cf21 #include <memory>} {\cf20 // allocator}\par
03353 {\cf21 #include <string>} {\cf20 // string}\par
03354 {\cf21 #include <vector>} {\cf20 // vector}\par
03355 \par
03361 {\cf17 namespace }nlohmann\par
03362 \{\par
03370 {\cf17 template}<{\cf17 typename} T = {\cf18 void}, {\cf17 typename} SFINAE = {\cf18 void}>\par
03371 {\cf17 struct }adl_serializer;\par
03372 \par
03373 {\cf17 template}<{\cf17 template}<{\cf17 typename} U, {\cf17 typename} V, {\cf17 typename}... Args> {\cf17 class }ObjectType =\par
03374          std::map,\par
03375          {\cf17 template}<{\cf17 typename} U, {\cf17 typename}... Args> {\cf17 class }ArrayType = std::vector,\par
03376          {\cf17 class }StringType = std::string, {\cf17 class }BooleanType = bool,\par
03377          {\cf17 class }NumberIntegerType = std::int64_t,\par
03378          {\cf17 class }NumberUnsignedType = std::uint64_t,\par
03379          {\cf17 class }NumberFloatType = double,\par
03380          {\cf17 template}<{\cf17 typename} U> {\cf17 class }AllocatorType = std::allocator,\par
03381          {\cf17 template}<{\cf17 typename} T, {\cf17 typename} SFINAE = {\cf18 void}> {\cf17 class }JSONSerializer =\par
03382          adl_serializer,\par
03383          {\cf17 class }BinaryType = std::vector<std::uint8_t>>\par
03384 {\cf17 class }basic_json;\par
03385 \par
03397 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
03398 {\cf17 class }json_pointer;\par
03399 \par
03408 {\cf17 using} json = basic_json<>;\par
03409 \par
03410 {\cf17 template}<{\cf17 class} Key, {\cf17 class} T, {\cf17 class} IgnoredLess, {\cf17 class} Allocator>\par
03411 {\cf17 struct }ordered_map;\par
03412 \par
03420 {\cf17 using} ordered_json = basic_json<nlohmann::ordered_map>;\par
03421 \par
03422 \}  {\cf20 // namespace nlohmann}\par
03423 \par
03424 {\cf21 #endif  }{\cf20 // INCLUDE_NLOHMANN_JSON_FWD_HPP_}\par
03425 \par
03426 \par
03427 {\cf17 namespace }nlohmann\par
03428 \{\par
03437 {\cf17 namespace }detail\par
03438 \{\par
03440 {\cf20 // helpers //}\par
03442 {\cf20 }\par
03443 {\cf20 // Note to maintainers:}\par
03444 {\cf20 //}\par
03445 {\cf20 // Every trait in this file expects a non CV-qualified type.}\par
03446 {\cf20 // The only exceptions are in the 'aliases for detected' section}\par
03447 {\cf20 // (i.e. those of the form: decltype(T::member_function(std::declval<T>())))}\par
03448 {\cf20 //}\par
03449 {\cf20 // In this case, T has to be properly CV-qualified to constraint the function arguments}\par
03450 {\cf20 // (e.g. to_json(BasicJsonType&, const T&))}\par
03451 \par
03452 {\cf17 template}<{\cf17 typename}> {\cf17 struct }is_basic_json : std::false_type \{\};\par
03453 \par
03454 NLOHMANN_BASIC_JSON_TPL_DECLARATION\par
03455 {\cf17 struct }is_basic_json<NLOHMANN_BASIC_JSON_TPL> : std::true_type \{\};\par
03456 \par
03458 {\cf20 // json_ref helpers //}\par
03460 {\cf20 }\par
03461 {\cf17 template}<{\cf17 typename}>\par
03462 {\cf17 class }json_ref;\par
03463 \par
03464 {\cf17 template}<{\cf17 typename}>\par
03465 {\cf17 struct }is_json_ref : std::false_type \{\};\par
03466 \par
03467 {\cf17 template}<{\cf17 typename} T>\par
03468 {\cf17 struct }is_json_ref<json_ref<T>> : std::true_type \{\};\par
03469 \par
03471 {\cf20 // aliases for detected //}\par
03473 {\cf20 }\par
03474 {\cf17 template}<{\cf17 typename} T>\par
03475 {\cf17 using} mapped_type_t = {\cf17 typename} T::mapped_type;\par
03476 \par
03477 {\cf17 template}<{\cf17 typename} T>\par
03478 {\cf17 using} key_type_t = {\cf17 typename} T::key_type;\par
03479 \par
03480 {\cf17 template}<{\cf17 typename} T>\par
03481 {\cf17 using} value_type_t = {\cf17 typename} T::value_type;\par
03482 \par
03483 {\cf17 template}<{\cf17 typename} T>\par
03484 {\cf17 using} difference_type_t = {\cf17 typename} T::difference_type;\par
03485 \par
03486 {\cf17 template}<{\cf17 typename} T>\par
03487 {\cf17 using} pointer_t = {\cf17 typename} T::pointer;\par
03488 \par
03489 {\cf17 template}<{\cf17 typename} T>\par
03490 {\cf17 using} reference_t = {\cf17 typename} T::reference;\par
03491 \par
03492 {\cf17 template}<{\cf17 typename} T>\par
03493 {\cf17 using} iterator_category_t = {\cf17 typename} T::iterator_category;\par
03494 \par
03495 {\cf17 template}<{\cf17 typename} T>\par
03496 {\cf17 using} iterator_t = {\cf17 typename} T::iterator;\par
03497 \par
03498 {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... Args>\par
03499 {\cf17 using} to_json_function = {\cf17 decltype}(T::to_json(std::declval<Args>()...));\par
03500 \par
03501 {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... Args>\par
03502 {\cf17 using} from_json_function = {\cf17 decltype}(T::from_json(std::declval<Args>()...));\par
03503 \par
03504 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} U>\par
03505 {\cf17 using} get_template_function = {\cf17 decltype}(std::declval<T>().template get<U>());\par
03506 \par
03507 {\cf20 // trait checking if JSONSerializer<T>::from_json(json const&, udt&) exists}\par
03508 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
03509 {\cf17 struct }has_from_json : std::false_type \{\};\par
03510 \par
03511 {\cf20 // trait checking if j.get<T> is valid}\par
03512 {\cf20 // use this trait instead of std::is_constructible or std::is_convertible,}\par
03513 {\cf20 // both rely on, or make use of implicit conversions, and thus fail when T}\par
03514 {\cf20 // has several constructors/operator= (see https://github.com/nlohmann/json/issues/958)}\par
03515 {\cf17 template} <{\cf17 typename} BasicJsonType, {\cf17 typename} T>\par
03516 {\cf17 struct }is_getable\par
03517 \{\par
03518     {\cf17 static} {\cf17 constexpr} {\cf18 bool} value = is_detected<get_template_function, const BasicJsonType&, T>::value;\par
03519 \};\par
03520 \par
03521 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T>\par
03522 {\cf17 struct }has_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>\par
03523 \{\par
03524     {\cf17 using} serializer = {\cf17 typename} BasicJsonType::template json_serializer<T, void>;\par
03525 \par
03526     {\cf17 static} {\cf17 constexpr} {\cf18 bool} value =\par
03527         is_detected_exact<void, from_json_function, serializer,\par
03528         {\cf17 const} BasicJsonType&, T&>::value;\par
03529 \};\par
03530 \par
03531 {\cf20 // This trait checks if JSONSerializer<T>::from_json(json const&) exists}\par
03532 {\cf20 // this overload is used for non-default-constructible user-defined-types}\par
03533 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
03534 {\cf17 struct }has_non_default_from_json : std::false_type \{\};\par
03535 \par
03536 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T>\par
03537 {\cf17 struct }has_non_default_from_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>\par
03538 \{\par
03539     {\cf17 using} serializer = {\cf17 typename} BasicJsonType::template json_serializer<T, void>;\par
03540 \par
03541     {\cf17 static} {\cf17 constexpr} {\cf18 bool} value =\par
03542         is_detected_exact<T, from_json_function, serializer,\par
03543         {\cf17 const} BasicJsonType&>::value;\par
03544 \};\par
03545 \par
03546 {\cf20 // This trait checks if BasicJsonType::json_serializer<T>::to_json exists}\par
03547 {\cf20 // Do not evaluate the trait when T is a basic_json type, to avoid template instantiation infinite recursion.}\par
03548 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
03549 {\cf17 struct }has_to_json : std::false_type \{\};\par
03550 \par
03551 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T>\par
03552 {\cf17 struct }has_to_json < BasicJsonType, T, enable_if_t < !is_basic_json<T>::value >>\par
03553 \{\par
03554     {\cf17 using} serializer = {\cf17 typename} BasicJsonType::template json_serializer<T, void>;\par
03555 \par
03556     {\cf17 static} {\cf17 constexpr} {\cf18 bool} value =\par
03557         is_detected_exact<void, to_json_function, serializer, BasicJsonType&,\par
03558         T>::value;\par
03559 \};\par
03560 \par
03561 \par
03563 {\cf20 // is_ functions //}\par
03565 {\cf20 }\par
03566 {\cf20 // https://en.cppreference.com/w/cpp/types/conjunction}\par
03567 {\cf17 template}<{\cf17 class}...> {\cf17 struct }conjunction : std::true_type \{ \};\par
03568 {\cf17 template}<{\cf17 class} B1> {\cf17 struct }conjunction<B1> : B1 \{ \};\par
03569 {\cf17 template}<{\cf17 class }B1, {\cf17 class}... Bn>\par
03570 {\cf17 struct }conjunction<B1, Bn...>\par
03571 : std::conditional<bool(B1::value), conjunction<Bn...>, B1>::type \{\};\par
03572 \par
03573 {\cf20 // https://en.cppreference.com/w/cpp/types/negation}\par
03574 {\cf17 template}<{\cf17 class} B> {\cf17 struct }negation : std::integral_constant < bool, !B::value > \{ \};\par
03575 \par
03576 {\cf20 // Reimplementation of is_constructible and is_default_constructible, due to them being broken for}\par
03577 {\cf20 // std::pair and std::tuple until LWG 2367 fix (see https://cplusplus.github.io/LWG/lwg-defects.html#2367).}\par
03578 {\cf20 // This causes compile errors in e.g. clang 3.5 or gcc 4.9.}\par
03579 {\cf17 template} <{\cf17 typename} T>\par
03580 {\cf17 struct }is_default_constructible : std::is_default_constructible<T> \{\};\par
03581 \par
03582 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
03583 {\cf17 struct }is_default_constructible<std::pair<T1, T2>>\par
03584             : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> \{\};\par
03585 \par
03586 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
03587 {\cf17 struct }is_default_constructible<const std::pair<T1, T2>>\par
03588             : conjunction<is_default_constructible<T1>, is_default_constructible<T2>> \{\};\par
03589 \par
03590 {\cf17 template} <{\cf17 typename}... Ts>\par
03591 {\cf17 struct }is_default_constructible<std::tuple<Ts...>>\par
03592             : conjunction<is_default_constructible<Ts>...> \{\};\par
03593 \par
03594 {\cf17 template} <{\cf17 typename}... Ts>\par
03595 {\cf17 struct }is_default_constructible<const std::tuple<Ts...>>\par
03596             : conjunction<is_default_constructible<Ts>...> \{\};\par
03597 \par
03598 \par
03599 {\cf17 template} <{\cf17 typename} T, {\cf17 typename}... Args>\par
03600 {\cf17 struct }is_constructible : std::is_constructible<T, Args...> \{\};\par
03601 \par
03602 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
03603 {\cf17 struct }is_constructible<std::pair<T1, T2>> : is_default_constructible<std::pair<T1, T2>> \{\};\par
03604 \par
03605 {\cf17 template} <{\cf17 typename} T1, {\cf17 typename} T2>\par
03606 {\cf17 struct }is_constructible<const std::pair<T1, T2>> : is_default_constructible<const std::pair<T1, T2>> \{\};\par
03607 \par
03608 {\cf17 template} <{\cf17 typename}... Ts>\par
03609 {\cf17 struct }is_constructible<std::tuple<Ts...>> : is_default_constructible<std::tuple<Ts...>> \{\};\par
03610 \par
03611 {\cf17 template} <{\cf17 typename}... Ts>\par
03612 {\cf17 struct }is_constructible<const std::tuple<Ts...>> : is_default_constructible<const std::tuple<Ts...>> \{\};\par
03613 \par
03614 \par
03615 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
03616 {\cf17 struct }is_iterator_traits : std::false_type \{\};\par
03617 \par
03618 {\cf17 template}<{\cf17 typename} T>\par
03619 {\cf17 struct }is_iterator_traits<iterator_traits<T>>\par
03620 \{\par
03621   {\cf17 private}:\par
03622     {\cf17 using} traits = iterator_traits<T>;\par
03623 \par
03624   {\cf17 public}:\par
03625     {\cf17 static} {\cf17 constexpr} {\cf17 auto} value =\par
03626         is_detected<value_type_t, traits>::value &&\par
03627         is_detected<difference_type_t, traits>::value &&\par
03628         is_detected<pointer_t, traits>::value &&\par
03629         is_detected<iterator_category_t, traits>::value &&\par
03630         is_detected<reference_t, traits>::value;\par
03631 \};\par
03632 \par
03633 {\cf20 // The following implementation of is_complete_type is taken from}\par
03634 {\cf20 // https://blogs.msdn.microsoft.com/vcblog/2015/12/02/partial-support-for-expression-sfinae-in-vs-2015-update-1/}\par
03635 {\cf20 // and is written by Xiang Fan who agreed to using it in this library.}\par
03636 \par
03637 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} = {\cf18 void}>\par
03638 {\cf17 struct }is_complete_type : std::false_type \{\};\par
03639 \par
03640 {\cf17 template}<{\cf17 typename} T>\par
03641 {\cf17 struct }is_complete_type<T, decltype(void(sizeof(T)))> : std::true_type \{\};\par
03642 \par
03643 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleObjectType,\par
03644          {\cf17 typename} = {\cf18 void}>\par
03645 {\cf17 struct }is_compatible_object_type_impl : std::false_type \{\};\par
03646 \par
03647 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleObjectType>\par
03648 {\cf17 struct }is_compatible_object_type_impl <\par
03649     BasicJsonType, CompatibleObjectType,\par
03650     enable_if_t < is_detected<mapped_type_t, CompatibleObjectType>::value&&\par
03651     is_detected<key_type_t, CompatibleObjectType>::value >>\par
03652 \{\par
03653     {\cf17 using} object_t = {\cf17 typename} BasicJsonType::object_t;\par
03654 \par
03655     {\cf20 // macOS's is_constructible does not play well with nonesuch...}\par
03656     {\cf17 static} {\cf17 constexpr} {\cf18 bool} value =\par
03657         is_constructible<{\cf17 typename} object_t::key_type,\par
03658         {\cf17 typename} CompatibleObjectType::key_type>::value &&\par
03659         is_constructible<{\cf17 typename} object_t::mapped_type,\par
03660         {\cf17 typename} CompatibleObjectType::mapped_type>::value;\par
03661 \};\par
03662 \par
03663 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleObjectType>\par
03664 {\cf17 struct }is_compatible_object_type\par
03665     : is_compatible_object_type_impl<BasicJsonType, CompatibleObjectType> \{\};\par
03666 \par
03667 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleObjectType,\par
03668          {\cf17 typename} = {\cf18 void}>\par
03669 {\cf17 struct }is_constructible_object_type_impl : std::false_type \{\};\par
03670 \par
03671 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleObjectType>\par
03672 {\cf17 struct }is_constructible_object_type_impl <\par
03673     BasicJsonType, ConstructibleObjectType,\par
03674     enable_if_t < is_detected<mapped_type_t, ConstructibleObjectType>::value&&\par
03675     is_detected<key_type_t, ConstructibleObjectType>::value >>\par
03676 \{\par
03677     {\cf17 using} object_t = {\cf17 typename} BasicJsonType::object_t;\par
03678 \par
03679     {\cf17 static} {\cf17 constexpr} {\cf18 bool} value =\par
03680         (is_default_constructible<ConstructibleObjectType>::value &&\par
03681          (std::is_move_assignable<ConstructibleObjectType>::value ||\par
03682           std::is_copy_assignable<ConstructibleObjectType>::value) &&\par
03683          (is_constructible<{\cf17 typename} ConstructibleObjectType::key_type,\par
03684           {\cf17 typename} object_t::key_type>::value &&\par
03685           std::is_same <\par
03686           {\cf17 typename} object_t::mapped_type,\par
03687           {\cf17 typename} ConstructibleObjectType::mapped_type >::value)) ||\par
03688         (has_from_json<BasicJsonType,\par
03689          {\cf17 typename} ConstructibleObjectType::mapped_type>::value ||\par
03690          has_non_default_from_json <\par
03691          BasicJsonType,\par
03692          {\cf17 typename} ConstructibleObjectType::mapped_type >::value);\par
03693 \};\par
03694 \par
03695 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleObjectType>\par
03696 {\cf17 struct }is_constructible_object_type\par
03697     : is_constructible_object_type_impl<BasicJsonType,\par
03698       ConstructibleObjectType> \{\};\par
03699 \par
03700 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleStringType,\par
03701          {\cf17 typename} = {\cf18 void}>\par
03702 {\cf17 struct }is_compatible_string_type_impl : std::false_type \{\};\par
03703 \par
03704 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleStringType>\par
03705 {\cf17 struct }is_compatible_string_type_impl <\par
03706     BasicJsonType, CompatibleStringType,\par
03707     enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,\par
03708     value_type_t, CompatibleStringType>::value >>\par
03709 \{\par
03710     {\cf17 static} {\cf17 constexpr} {\cf17 auto} value =\par
03711         is_constructible<typename BasicJsonType::string_t, CompatibleStringType>::value;\par
03712 \};\par
03713 \par
03714 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleStringType>\par
03715 {\cf17 struct }is_compatible_string_type\par
03716     : is_compatible_string_type_impl<BasicJsonType, ConstructibleStringType> \{\};\par
03717 \par
03718 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleStringType,\par
03719          {\cf17 typename} = {\cf18 void}>\par
03720 {\cf17 struct }is_constructible_string_type_impl : std::false_type \{\};\par
03721 \par
03722 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleStringType>\par
03723 {\cf17 struct }is_constructible_string_type_impl <\par
03724     BasicJsonType, ConstructibleStringType,\par
03725     enable_if_t<is_detected_exact<typename BasicJsonType::string_t::value_type,\par
03726     value_type_t, ConstructibleStringType>::value >>\par
03727 \{\par
03728     {\cf17 static} {\cf17 constexpr} {\cf17 auto} value =\par
03729         is_constructible<ConstructibleStringType,\par
03730         {\cf17 typename} BasicJsonType::string_t>::value;\par
03731 \};\par
03732 \par
03733 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleStringType>\par
03734 {\cf17 struct }is_constructible_string_type\par
03735     : is_constructible_string_type_impl<BasicJsonType, ConstructibleStringType> \{\};\par
03736 \par
03737 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleArrayType, {\cf17 typename} = {\cf18 void}>\par
03738 {\cf17 struct }is_compatible_array_type_impl : std::false_type \{\};\par
03739 \par
03740 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleArrayType>\par
03741 {\cf17 struct }is_compatible_array_type_impl <\par
03742     BasicJsonType, CompatibleArrayType,\par
03743     enable_if_t < is_detected<value_type_t, CompatibleArrayType>::value&&\par
03744     is_detected<iterator_t, CompatibleArrayType>::value&&\par
03745 {\cf20 // This is needed because json_reverse_iterator has a ::iterator type...}\par
03746 {\cf20 // Therefore it is detected as a CompatibleArrayType.}\par
03747 {\cf20 // The real fix would be to have an Iterable concept.}\par
03748     !is_iterator_traits <\par
03749     iterator_traits<CompatibleArrayType >>::value >>\par
03750 \{\par
03751     {\cf17 static} {\cf17 constexpr} {\cf18 bool} value =\par
03752         is_constructible<BasicJsonType,\par
03753         {\cf17 typename} CompatibleArrayType::value_type>::value;\par
03754 \};\par
03755 \par
03756 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleArrayType>\par
03757 {\cf17 struct }is_compatible_array_type\par
03758     : is_compatible_array_type_impl<BasicJsonType, CompatibleArrayType> \{\};\par
03759 \par
03760 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleArrayType, {\cf17 typename} = {\cf18 void}>\par
03761 {\cf17 struct }is_constructible_array_type_impl : std::false_type \{\};\par
03762 \par
03763 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleArrayType>\par
03764 {\cf17 struct }is_constructible_array_type_impl <\par
03765     BasicJsonType, ConstructibleArrayType,\par
03766     enable_if_t<std::is_same<ConstructibleArrayType,\par
03767     typename BasicJsonType::value_type>::value >>\par
03768             : std::true_type \{\};\par
03769 \par
03770 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleArrayType>\par
03771 {\cf17 struct }is_constructible_array_type_impl <\par
03772     BasicJsonType, ConstructibleArrayType,\par
03773     enable_if_t < !std::is_same<ConstructibleArrayType,\par
03774     typename BasicJsonType::value_type>::value&&\par
03775     is_default_constructible<ConstructibleArrayType>::value&&\par
03776 (std::is_move_assignable<ConstructibleArrayType>::value ||\par
03777  std::is_copy_assignable<ConstructibleArrayType>::value)&&\par
03778 is_detected<value_type_t, ConstructibleArrayType>::value&&\par
03779 is_detected<iterator_t, ConstructibleArrayType>::value&&\par
03780 is_complete_type <\par
03781 detected_t<value_type_t, ConstructibleArrayType >>::value >>\par
03782 \{\par
03783     {\cf17 static} {\cf17 constexpr} {\cf18 bool} value =\par
03784         {\cf20 // This is needed because json_reverse_iterator has a ::iterator type,}\par
03785         {\cf20 // furthermore, std::back_insert_iterator (and other iterators) have a}\par
03786         {\cf20 // base class `iterator`... Therefore it is detected as a}\par
03787         {\cf20 // ConstructibleArrayType. The real fix would be to have an Iterable}\par
03788         {\cf20 // concept.}\par
03789         !is_iterator_traits<iterator_traits<ConstructibleArrayType>>::value &&\par
03790 \par
03791         (std::is_same<{\cf17 typename} ConstructibleArrayType::value_type,\par
03792          {\cf17 typename} BasicJsonType::array_t::value_type>::value ||\par
03793          has_from_json<BasicJsonType,\par
03794          {\cf17 typename} ConstructibleArrayType::value_type>::value ||\par
03795          has_non_default_from_json <\par
03796          BasicJsonType, {\cf17 typename} ConstructibleArrayType::value_type >::value);\par
03797 \};\par
03798 \par
03799 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleArrayType>\par
03800 {\cf17 struct }is_constructible_array_type\par
03801     : is_constructible_array_type_impl<BasicJsonType, ConstructibleArrayType> \{\};\par
03802 \par
03803 {\cf17 template}<{\cf17 typename} RealIntegerType, {\cf17 typename} CompatibleNumberIntegerType,\par
03804          {\cf17 typename} = {\cf18 void}>\par
03805 {\cf17 struct }is_compatible_integer_type_impl : std::false_type \{\};\par
03806 \par
03807 {\cf17 template}<{\cf17 typename} RealIntegerType, {\cf17 typename} CompatibleNumberIntegerType>\par
03808 {\cf17 struct }is_compatible_integer_type_impl <\par
03809     RealIntegerType, CompatibleNumberIntegerType,\par
03810     enable_if_t < std::is_integral<RealIntegerType>::value&&\par
03811     std::is_integral<CompatibleNumberIntegerType>::value&&\par
03812     !std::is_same<bool, CompatibleNumberIntegerType>::value >>\par
03813 \{\par
03814     {\cf20 // is there an assert somewhere on overflows?}\par
03815     {\cf17 using} RealLimits = std::numeric_limits<RealIntegerType>;\par
03816     {\cf17 using} CompatibleLimits = std::numeric_limits<CompatibleNumberIntegerType>;\par
03817 \par
03818     {\cf17 static} {\cf17 constexpr} {\cf17 auto} value =\par
03819         is_constructible<RealIntegerType,\par
03820         CompatibleNumberIntegerType>::value &&\par
03821         CompatibleLimits::is_integer &&\par
03822         RealLimits::is_signed == CompatibleLimits::is_signed;\par
03823 \};\par
03824 \par
03825 {\cf17 template}<{\cf17 typename} RealIntegerType, {\cf17 typename} CompatibleNumberIntegerType>\par
03826 {\cf17 struct }is_compatible_integer_type\par
03827     : is_compatible_integer_type_impl<RealIntegerType,\par
03828       CompatibleNumberIntegerType> \{\};\par
03829 \par
03830 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleType, {\cf17 typename} = {\cf18 void}>\par
03831 {\cf17 struct }is_compatible_type_impl: std::false_type \{\};\par
03832 \par
03833 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleType>\par
03834 {\cf17 struct }is_compatible_type_impl <\par
03835     BasicJsonType, CompatibleType,\par
03836     enable_if_t<is_complete_type<CompatibleType>::value >>\par
03837 \{\par
03838     {\cf17 static} {\cf17 constexpr} {\cf18 bool} value =\par
03839         has_to_json<BasicJsonType, CompatibleType>::value;\par
03840 \};\par
03841 \par
03842 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleType>\par
03843 {\cf17 struct }is_compatible_type\par
03844     : is_compatible_type_impl<BasicJsonType, CompatibleType> \{\};\par
03845 \par
03846 {\cf17 template}<{\cf17 typename} T1, {\cf17 typename} T2>\par
03847 {\cf17 struct }is_constructible_tuple : std::false_type \{\};\par
03848 \par
03849 {\cf17 template}<{\cf17 typename} T1, {\cf17 typename}... Args>\par
03850 {\cf17 struct }is_constructible_tuple<T1, std::tuple<Args...>> : conjunction<is_constructible<T1, Args>...> \{\};\par
03851 \par
03852 {\cf20 // a naive helper to check if a type is an ordered_map (exploits the fact that}\par
03853 {\cf20 // ordered_map inherits capacity() from std::vector)}\par
03854 {\cf17 template} <{\cf17 typename} T>\par
03855 {\cf17 struct }is_ordered_map\par
03856 \{\par
03857     {\cf17 using} one = char;\par
03858 \par
03859     {\cf17 struct }two\par
03860     \{\par
03861         {\cf18 char} x[2]; {\cf20 // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)}\par
03862     \};\par
03863 \par
03864     {\cf17 template} <{\cf17 typename} C> {\cf17 static} one test( {\cf17 decltype}(&C::capacity) ) ;\par
03865     {\cf17 template} <{\cf17 typename} C> {\cf17 static} two test(...);\par
03866 \par
03867     {\cf17 enum} \{ value = {\cf17 sizeof}(test<T>({\cf17 nullptr})) == {\cf17 sizeof}({\cf18 char}) \}; {\cf20 // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)}\par
03868 \};\par
03869 \par
03870 {\cf20 // to avoid useless casts (see https://github.com/nlohmann/json/issues/2893#issuecomment-889152324)}\par
03871 template < typename T, typename U, enable_if_t < !std::is_same<T, U>::value, {\cf18 int} > = 0 >\par
03872 T conditional_static_cast(U value)\par
03873 \{\par
03874     {\cf19 return} {\cf17 static_cast<}T{\cf17 >}(value);\par
03875 \}\par
03876 \par
03877 template<typename T, typename U, enable_if_t<std::is_same<T, U>::value, {\cf18 int}> = 0>\par
03878 T conditional_static_cast(U value)\par
03879 \{\par
03880     {\cf19 return} value;\par
03881 \}\par
03882 \par
03883 \}  {\cf20 // namespace detail}\par
03884 \}  {\cf20 // namespace nlohmann}\par
03885 \par
03886 {\cf20 // #include <nlohmann/detail/value_t.hpp>}\par
03887 \par
03888 \par
03889 {\cf17 namespace }nlohmann\par
03890 \{\par
03891 {\cf17 namespace }detail\par
03892 \{\par
03893 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
03894 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, {\cf17 typename} std::nullptr_t& n)\par
03895 \{\par
03896     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_null()))\par
03897     \{\par
03898         JSON_THROW(type_error::create(302, {\cf22 "type must be null, but is "} + std::string(j.type_name()), j));\par
03899     \}\par
03900     n = {\cf17 nullptr};\par
03901 \}\par
03902 \par
03903 {\cf20 // overloads for basic_json template parameters}\par
03904 {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} ArithmeticType,\par
03905            enable_if_t < std::is_arithmetic<ArithmeticType>::value&&\par
03906                          !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,\par
03907                          {\cf18 int} > = 0 >\par
03908 {\cf18 void} get_arithmetic_value({\cf17 const} BasicJsonType& j, ArithmeticType& val)\par
03909 \{\par
03910     {\cf19 switch} ({\cf17 static_cast<}value_t{\cf17 >}(j))\par
03911     \{\par
03912         {\cf19 case} value_t::number_unsigned:\par
03913         \{\par
03914             val = {\cf17 static_cast<}ArithmeticType{\cf17 >}(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());\par
03915             {\cf19 break};\par
03916         \}\par
03917         {\cf19 case} value_t::number_integer:\par
03918         \{\par
03919             val = {\cf17 static_cast<}ArithmeticType{\cf17 >}(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());\par
03920             {\cf19 break};\par
03921         \}\par
03922         {\cf19 case} value_t::number_float:\par
03923         \{\par
03924             val = {\cf17 static_cast<}ArithmeticType{\cf17 >}(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());\par
03925             {\cf19 break};\par
03926         \}\par
03927 \par
03928         {\cf19 case} value_t::null:\par
03929         {\cf19 case} value_t::object:\par
03930         {\cf19 case} value_t::array:\par
03931         {\cf19 case} value_t::string:\par
03932         {\cf19 case} value_t::boolean:\par
03933         {\cf19 case} value_t::binary:\par
03934         {\cf19 case} value_t::discarded:\par
03935         {\cf19 default}:\par
03936             JSON_THROW(type_error::create(302, {\cf22 "type must be number, but is "} + std::string(j.type_name()), j));\par
03937     \}\par
03938 \}\par
03939 \par
03940 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
03941 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, {\cf17 typename} BasicJsonType::boolean_t& b)\par
03942 \{\par
03943     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_boolean()))\par
03944     \{\par
03945         JSON_THROW(type_error::create(302, {\cf22 "type must be boolean, but is "} + std::string(j.type_name()), j));\par
03946     \}\par
03947     b = *j.template get_ptr<const typename BasicJsonType::boolean_t*>();\par
03948 \}\par
03949 \par
03950 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
03951 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, {\cf17 typename} BasicJsonType::string_t& s)\par
03952 \{\par
03953     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_string()))\par
03954     \{\par
03955         JSON_THROW(type_error::create(302, {\cf22 "type must be string, but is "} + std::string(j.type_name()), j));\par
03956     \}\par
03957     s = *j.template get_ptr<const typename BasicJsonType::string_t*>();\par
03958 \}\par
03959 \par
03960 {\cf17 template} <\par
03961     {\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleStringType,\par
03962     enable_if_t <\par
03963         is_constructible_string_type<BasicJsonType, ConstructibleStringType>::value&&\par
03964         !std::is_same<{\cf17 typename} BasicJsonType::string_t,\par
03965                       ConstructibleStringType>::value,\par
03966         {\cf18 int} > = 0 >\par
03967 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, ConstructibleStringType& s)\par
03968 \{\par
03969     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_string()))\par
03970     \{\par
03971         JSON_THROW(type_error::create(302, {\cf22 "type must be string, but is "} + std::string(j.type_name()), j));\par
03972     \}\par
03973 \par
03974     s = *j.template get_ptr<const typename BasicJsonType::string_t*>();\par
03975 \}\par
03976 \par
03977 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
03978 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, {\cf17 typename} BasicJsonType::number_float_t& val)\par
03979 \{\par
03980     get_arithmetic_value(j, val);\par
03981 \}\par
03982 \par
03983 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
03984 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, {\cf17 typename} BasicJsonType::number_unsigned_t& val)\par
03985 \{\par
03986     get_arithmetic_value(j, val);\par
03987 \}\par
03988 \par
03989 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
03990 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, {\cf17 typename} BasicJsonType::number_integer_t& val)\par
03991 \{\par
03992     get_arithmetic_value(j, val);\par
03993 \}\par
03994 \par
03995 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} EnumType,\par
03996          enable_if_t<std::is_enum<EnumType>::value, {\cf18 int}> = 0>\par
03997 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, EnumType& e)\par
03998 \{\par
03999     {\cf17 typename} std::underlying_type<EnumType>::type val;\par
04000     get_arithmetic_value(j, val);\par
04001     e = {\cf17 static_cast<}EnumType{\cf17 >}(val);\par
04002 \}\par
04003 \par
04004 {\cf20 // forward_list doesn't have an insert method}\par
04005 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T, {\cf17 typename} Allocator,\par
04006          enable_if_t<is_getable<BasicJsonType, T>::value, {\cf18 int}> = 0>\par
04007 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, std::forward_list<T, Allocator>& l)\par
04008 \{\par
04009     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_array()))\par
04010     \{\par
04011         JSON_THROW(type_error::create(302, {\cf22 "type must be array, but is "} + std::string(j.type_name()), j));\par
04012     \}\par
04013     l.clear();\par
04014     std::transform(j.rbegin(), j.rend(),\par
04015                    std::front_inserter(l), []({\cf17 const} BasicJsonType & i)\par
04016     \{\par
04017         return i.template get<T>();\par
04018     \});\par
04019 \}\par
04020 \par
04021 {\cf20 // valarray doesn't have an insert method}\par
04022 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T,\par
04023          enable_if_t<is_getable<BasicJsonType, T>::value, {\cf18 int}> = 0>\par
04024 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, std::valarray<T>& l)\par
04025 \{\par
04026     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_array()))\par
04027     \{\par
04028         JSON_THROW(type_error::create(302, {\cf22 "type must be array, but is "} + std::string(j.type_name()), j));\par
04029     \}\par
04030     l.resize(j.size());\par
04031     std::transform(j.begin(), j.end(), std::begin(l),\par
04032                    []({\cf17 const} BasicJsonType & elem)\par
04033     \{\par
04034         return elem.template get<T>();\par
04035     \});\par
04036 \}\par
04037 \par
04038 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T, std::{\cf18 size_t} N>\par
04039 {\cf17 auto} from_json({\cf17 const} BasicJsonType& j, T (&arr)[N]) {\cf20 // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)}\par
04040 -> {\cf17 decltype}(j.template get<T>(), void())\par
04041 \{\par
04042     {\cf19 for} (std::size_t i = 0; i < N; ++i)\par
04043     \{\par
04044         arr[i] = j.at(i).template get<T>();\par
04045     \}\par
04046 \}\par
04047 \par
04048 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04049 {\cf18 void} from_json_array_impl({\cf17 const} BasicJsonType& j, {\cf17 typename} BasicJsonType::array_t& arr, priority_tag<3> {\cf20 /*unused*/})\par
04050 \{\par
04051     arr = *j.template get_ptr<const typename BasicJsonType::array_t*>();\par
04052 \}\par
04053 \par
04054 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T, std::{\cf18 size_t} N>\par
04055 {\cf17 auto} from_json_array_impl({\cf17 const} BasicJsonType& j, std::array<T, N>& arr,\par
04056                           priority_tag<2> {\cf20 /*unused*/})\par
04057 -> {\cf17 decltype}(j.template get<T>(), void())\par
04058 \{\par
04059     {\cf19 for} (std::size_t i = 0; i < N; ++i)\par
04060     \{\par
04061         arr[i] = j.at(i).template get<T>();\par
04062     \}\par
04063 \}\par
04064 \par
04065 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleArrayType,\par
04066          enable_if_t<\par
04067              std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,\par
04068              {\cf18 int}> = 0>\par
04069 {\cf17 auto} from_json_array_impl({\cf17 const} BasicJsonType& j, ConstructibleArrayType& arr, priority_tag<1> {\cf20 /*unused*/})\par
04070 -> {\cf17 decltype}(\par
04071     arr.reserve(std::declval<typename ConstructibleArrayType::size_type>()),\par
04072     j.template get<typename ConstructibleArrayType::value_type>(),\par
04073     void())\par
04074 \{\par
04075     {\cf17 using} std::end;\par
04076 \par
04077     ConstructibleArrayType ret;\par
04078     ret.reserve(j.size());\par
04079     std::transform(j.begin(), j.end(),\par
04080                    std::inserter(ret, end(ret)), []({\cf17 const} BasicJsonType & i)\par
04081     \{\par
04082         {\cf20 // get<BasicJsonType>() returns *this, this won't call a from_json}\par
04083         {\cf20 // method when value_type is BasicJsonType}\par
04084         {\cf19 return} i.template get<typename ConstructibleArrayType::value_type>();\par
04085     \});\par
04086     arr = std::move(ret);\par
04087 \}\par
04088 \par
04089 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleArrayType,\par
04090          enable_if_t<\par
04091              std::is_assignable<ConstructibleArrayType&, ConstructibleArrayType>::value,\par
04092              {\cf18 int}> = 0>\par
04093 {\cf18 void} from_json_array_impl({\cf17 const} BasicJsonType& j, ConstructibleArrayType& arr,\par
04094                           priority_tag<0> {\cf20 /*unused*/})\par
04095 \{\par
04096     {\cf17 using} std::end;\par
04097 \par
04098     ConstructibleArrayType ret;\par
04099     std::transform(\par
04100         j.begin(), j.end(), std::inserter(ret, end(ret)),\par
04101         []({\cf17 const} BasicJsonType & i)\par
04102     \{\par
04103         {\cf20 // get<BasicJsonType>() returns *this, this won't call a from_json}\par
04104         {\cf20 // method when value_type is BasicJsonType}\par
04105         {\cf19 return} i.template get<typename ConstructibleArrayType::value_type>();\par
04106     \});\par
04107     arr = std::move(ret);\par
04108 \}\par
04109 \par
04110 {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleArrayType,\par
04111            enable_if_t <\par
04112                is_constructible_array_type<BasicJsonType, ConstructibleArrayType>::value&&\par
04113                !is_constructible_object_type<BasicJsonType, ConstructibleArrayType>::value&&\par
04114                !is_constructible_string_type<BasicJsonType, ConstructibleArrayType>::value&&\par
04115                !std::is_same<ConstructibleArrayType, typename BasicJsonType::binary_t>::value&&\par
04116                !is_basic_json<ConstructibleArrayType>::value,\par
04117                {\cf18 int} > = 0 >\par
04118 {\cf17 auto} from_json({\cf17 const} BasicJsonType& j, ConstructibleArrayType& arr)\par
04119 -> {\cf17 decltype}(from_json_array_impl(j, arr, priority_tag<3> \{\}),\par
04120 j.template get<typename ConstructibleArrayType::value_type>(),\par
04121 void())\par
04122 \{\par
04123     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_array()))\par
04124     \{\par
04125         JSON_THROW(type_error::create(302, {\cf22 "type must be array, but is "} + std::string(j.type_name()), j));\par
04126     \}\par
04127 \par
04128     from_json_array_impl(j, arr, priority_tag<3> \{\});\par
04129 \}\par
04130 \par
04131 {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} T, std::size_t... Idx >\par
04132 std::array<T, {\cf17 sizeof}...(Idx)> from_json_inplace_array_impl(BasicJsonType&& j,\par
04133         identity_tag<std::array<T, {\cf17 sizeof}...(Idx)>> {\cf20 /*unused*/}, index_sequence<Idx...> {\cf20 /*unused*/})\par
04134 \{\par
04135     {\cf19 return} \{ \{ std::forward<BasicJsonType>(j).at(Idx).template get<T>()... \} \};\par
04136 \}\par
04137 \par
04138 {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} T, std::{\cf18 size_t} N >\par
04139 {\cf17 auto} from_json(BasicJsonType&& j, identity_tag<std::array<T, N>> tag)\par
04140 -> {\cf17 decltype}(from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> \{\}))\par
04141 \{\par
04142     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_array()))\par
04143     \{\par
04144         JSON_THROW(type_error::create(302, {\cf22 "type must be array, but is "} + std::string(j.type_name()), j));\par
04145     \}\par
04146 \par
04147     {\cf19 return} from_json_inplace_array_impl(std::forward<BasicJsonType>(j), tag, make_index_sequence<N> \{\});\par
04148 \}\par
04149 \par
04150 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04151 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, {\cf17 typename} BasicJsonType::binary_t& bin)\par
04152 \{\par
04153     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_binary()))\par
04154     \{\par
04155         JSON_THROW(type_error::create(302, {\cf22 "type must be binary, but is "} + std::string(j.type_name()), j));\par
04156     \}\par
04157 \par
04158     bin = *j.template get_ptr<const typename BasicJsonType::binary_t*>();\par
04159 \}\par
04160 \par
04161 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} ConstructibleObjectType,\par
04162          enable_if_t<is_constructible_object_type<BasicJsonType, ConstructibleObjectType>::value, {\cf18 int}> = 0>\par
04163 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, ConstructibleObjectType& obj)\par
04164 \{\par
04165     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_object()))\par
04166     \{\par
04167         JSON_THROW(type_error::create(302, {\cf22 "type must be object, but is "} + std::string(j.type_name()), j));\par
04168     \}\par
04169 \par
04170     ConstructibleObjectType ret;\par
04171     {\cf17 const} {\cf17 auto}* inner_object = j.template get_ptr<const typename BasicJsonType::object_t*>();\par
04172     {\cf17 using} value_type = {\cf17 typename} ConstructibleObjectType::value_type;\par
04173     std::transform(\par
04174         inner_object->begin(), inner_object->end(),\par
04175         std::inserter(ret, ret.begin()),\par
04176         []({\cf17 typename} BasicJsonType::object_t::value_type {\cf17 const} & p)\par
04177     \{\par
04178         return value_type(p.first, p.second.template get<typename ConstructibleObjectType::mapped_type>());\par
04179     \});\par
04180     obj = std::move(ret);\par
04181 \}\par
04182 \par
04183 {\cf20 // overload for arithmetic types, not chosen for basic_json template arguments}\par
04184 {\cf20 // (BooleanType, etc..); note: Is it really necessary to provide explicit}\par
04185 {\cf20 // overloads for boolean_t etc. in case of a custom BooleanType which is not}\par
04186 {\cf20 // an arithmetic type?}\par
04187 {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} ArithmeticType,\par
04188            enable_if_t <\par
04189                std::is_arithmetic<ArithmeticType>::value&&\par
04190                !std::is_same<ArithmeticType, typename BasicJsonType::number_unsigned_t>::value&&\par
04191                !std::is_same<ArithmeticType, typename BasicJsonType::number_integer_t>::value&&\par
04192                !std::is_same<ArithmeticType, typename BasicJsonType::number_float_t>::value&&\par
04193                !std::is_same<ArithmeticType, typename BasicJsonType::boolean_t>::value,\par
04194                {\cf18 int} > = 0 >\par
04195 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, ArithmeticType& val)\par
04196 \{\par
04197     {\cf19 switch} ({\cf17 static_cast<}value_t{\cf17 >}(j))\par
04198     \{\par
04199         {\cf19 case} value_t::number_unsigned:\par
04200         \{\par
04201             val = {\cf17 static_cast<}ArithmeticType{\cf17 >}(*j.template get_ptr<const typename BasicJsonType::number_unsigned_t*>());\par
04202             {\cf19 break};\par
04203         \}\par
04204         {\cf19 case} value_t::number_integer:\par
04205         \{\par
04206             val = {\cf17 static_cast<}ArithmeticType{\cf17 >}(*j.template get_ptr<const typename BasicJsonType::number_integer_t*>());\par
04207             {\cf19 break};\par
04208         \}\par
04209         {\cf19 case} value_t::number_float:\par
04210         \{\par
04211             val = {\cf17 static_cast<}ArithmeticType{\cf17 >}(*j.template get_ptr<const typename BasicJsonType::number_float_t*>());\par
04212             {\cf19 break};\par
04213         \}\par
04214         {\cf19 case} value_t::boolean:\par
04215         \{\par
04216             val = {\cf17 static_cast<}ArithmeticType{\cf17 >}(*j.template get_ptr<const typename BasicJsonType::boolean_t*>());\par
04217             {\cf19 break};\par
04218         \}\par
04219 \par
04220         {\cf19 case} value_t::null:\par
04221         {\cf19 case} value_t::object:\par
04222         {\cf19 case} value_t::array:\par
04223         {\cf19 case} value_t::string:\par
04224         {\cf19 case} value_t::binary:\par
04225         {\cf19 case} value_t::discarded:\par
04226         {\cf19 default}:\par
04227             JSON_THROW(type_error::create(302, {\cf22 "type must be number, but is "} + std::string(j.type_name()), j));\par
04228     \}\par
04229 \}\par
04230 \par
04231 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename}... Args, std::size_t... Idx>\par
04232 std::tuple<Args...> from_json_tuple_impl_base(BasicJsonType&& j, index_sequence<Idx...> {\cf20 /*unused*/})\par
04233 \{\par
04234     {\cf19 return} std::make_tuple(std::forward<BasicJsonType>(j).at(Idx).{\cf17 template} get<Args>()...);\par
04235 \}\par
04236 \par
04237 {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 class} A1, {\cf17 class} A2 >\par
04238 std::pair<A1, A2> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::pair<A1, A2>> {\cf20 /*unused*/}, priority_tag<0> {\cf20 /*unused*/})\par
04239 \{\par
04240     {\cf19 return} \{std::forward<BasicJsonType>(j).at(0).template get<A1>(),\par
04241             std::forward<BasicJsonType>(j).at(1).template get<A2>()\};\par
04242 \}\par
04243 \par
04244 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} A1, {\cf17 typename} A2>\par
04245 {\cf18 void} from_json_tuple_impl(BasicJsonType&& j, std::pair<A1, A2>& p, priority_tag<1> {\cf20 /*unused*/})\par
04246 \{\par
04247     p = from_json_tuple_impl(std::forward<BasicJsonType>(j), identity_tag<std::pair<A1, A2>> \{\}, priority_tag<0> \{\});\par
04248 \}\par
04249 \par
04250 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename}... Args>\par
04251 std::tuple<Args...> from_json_tuple_impl(BasicJsonType&& j, identity_tag<std::tuple<Args...>> {\cf20 /*unused*/}, priority_tag<2> {\cf20 /*unused*/})\par
04252 \{\par
04253     {\cf19 return} from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> \{\});\par
04254 \}\par
04255 \par
04256 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename}... Args>\par
04257 {\cf18 void} from_json_tuple_impl(BasicJsonType&& j, std::tuple<Args...>& t, priority_tag<3> {\cf20 /*unused*/})\par
04258 \{\par
04259     t = from_json_tuple_impl_base<BasicJsonType, Args...>(std::forward<BasicJsonType>(j), index_sequence_for<Args...> \{\});\par
04260 \}\par
04261 \par
04262 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} TupleRelated>\par
04263 {\cf17 auto} from_json(BasicJsonType&& j, TupleRelated&& t)\par
04264 -> {\cf17 decltype}(from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> \{\}))\par
04265 \{\par
04266     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_array()))\par
04267     \{\par
04268         JSON_THROW(type_error::create(302, {\cf22 "type must be array, but is "} + std::string(j.type_name()), j));\par
04269     \}\par
04270 \par
04271     {\cf19 return} from_json_tuple_impl(std::forward<BasicJsonType>(j), std::forward<TupleRelated>(t), priority_tag<3> \{\});\par
04272 \}\par
04273 \par
04274 {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} Key, {\cf17 typename} Value, {\cf17 typename} Compare, {\cf17 typename} Allocator,\par
04275            {\cf17 typename} = enable_if_t < !std::is_constructible <\par
04276                                         {\cf17 typename} BasicJsonType::string_t, Key >::value >>\par
04277 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, std::map<Key, Value, Compare, Allocator>& m)\par
04278 \{\par
04279     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_array()))\par
04280     \{\par
04281         JSON_THROW(type_error::create(302, {\cf22 "type must be array, but is "} + std::string(j.type_name()), j));\par
04282     \}\par
04283     m.clear();\par
04284     {\cf19 for} ({\cf17 const} {\cf17 auto}& p : j)\par
04285     \{\par
04286         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!p.is_array()))\par
04287         \{\par
04288             JSON_THROW(type_error::create(302, {\cf22 "type must be array, but is "} + std::string(p.type_name()), j));\par
04289         \}\par
04290         m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());\par
04291     \}\par
04292 \}\par
04293 \par
04294 {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} Key, {\cf17 typename} Value, {\cf17 typename} Hash, {\cf17 typename} KeyEqual, {\cf17 typename} Allocator,\par
04295            {\cf17 typename} = enable_if_t < !std::is_constructible <\par
04296                                         {\cf17 typename} BasicJsonType::string_t, Key >::value >>\par
04297 {\cf18 void} from_json({\cf17 const} BasicJsonType& j, std::unordered_map<Key, Value, Hash, KeyEqual, Allocator>& m)\par
04298 \{\par
04299     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_array()))\par
04300     \{\par
04301         JSON_THROW(type_error::create(302, {\cf22 "type must be array, but is "} + std::string(j.type_name()), j));\par
04302     \}\par
04303     m.clear();\par
04304     {\cf19 for} ({\cf17 const} {\cf17 auto}& p : j)\par
04305     \{\par
04306         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!p.is_array()))\par
04307         \{\par
04308             JSON_THROW(type_error::create(302, {\cf22 "type must be array, but is "} + std::string(p.type_name()), j));\par
04309         \}\par
04310         m.emplace(p.at(0).template get<Key>(), p.at(1).template get<Value>());\par
04311     \}\par
04312 \}\par
04313 \par
04314 {\cf17 struct }from_json_fn\par
04315 \{\par
04316     {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T>\par
04317     {\cf17 auto} operator()({\cf17 const} BasicJsonType& j, T&& val) {\cf17 const}\par
04318     {\cf17 noexcept}({\cf17 noexcept}(from_json(j, std::forward<T>(val))))\par
04319     -> {\cf17 decltype}(from_json(j, std::forward<T>(val)))\par
04320     \{\par
04321         {\cf19 return} from_json(j, std::forward<T>(val));\par
04322     \}\par
04323 \};\par
04324 \}  {\cf20 // namespace detail}\par
04325 \par
04329 {\cf17 namespace }{\cf20 // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)}\par
04330 \{\par
04331 {\cf17 constexpr} {\cf17 const} {\cf17 auto}& from_json = detail::static_const<detail::from_json_fn>::value; {\cf20 // NOLINT(misc-definitions-in-headers)}\par
04332 \} {\cf20 // namespace}\par
04333 \} {\cf20 // namespace nlohmann}\par
04334 \par
04335 {\cf20 // #include <nlohmann/detail/conversions/to_json.hpp>}\par
04336 \par
04337 \par
04338 {\cf21 #include <algorithm>} {\cf20 // copy}\par
04339 {\cf21 #include <iterator>} {\cf20 // begin, end}\par
04340 {\cf21 #include <string>} {\cf20 // string}\par
04341 {\cf21 #include <tuple>} {\cf20 // tuple, get}\par
04342 {\cf21 #include <type_traits>} {\cf20 // is_same, is_constructible, is_floating_point, is_enum, underlying_type}\par
04343 {\cf21 #include <utility>} {\cf20 // move, forward, declval, pair}\par
04344 {\cf21 #include <valarray>} {\cf20 // valarray}\par
04345 {\cf21 #include <vector>} {\cf20 // vector}\par
04346 \par
04347 {\cf20 // #include <nlohmann/detail/iterators/iteration_proxy.hpp>}\par
04348 \par
04349 \par
04350 {\cf21 #include <cstddef>} {\cf20 // size_t}\par
04351 {\cf21 #include <iterator>} {\cf20 // input_iterator_tag}\par
04352 {\cf21 #include <string>} {\cf20 // string, to_string}\par
04353 {\cf21 #include <tuple>} {\cf20 // tuple_size, get, tuple_element}\par
04354 {\cf21 #include <utility>} {\cf20 // move}\par
04355 \par
04356 {\cf20 // #include <nlohmann/detail/meta/type_traits.hpp>}\par
04357 \par
04358 {\cf20 // #include <nlohmann/detail/value_t.hpp>}\par
04359 \par
04360 \par
04361 {\cf17 namespace }nlohmann\par
04362 \{\par
04363 {\cf17 namespace }detail\par
04364 \{\par
04365 {\cf17 template}<{\cf17 typename} {\cf18 string}_type>\par
04366 {\cf18 void} int_to_string( string_type& target, std::size_t value )\par
04367 \{\par
04368     {\cf20 // For ADL}\par
04369     {\cf17 using} std::to_string;\par
04370     target = to_string(value);\par
04371 \}\par
04372 {\cf17 template}<{\cf17 typename} IteratorType> {\cf17 class }iteration_proxy_value\par
04373 \{\par
04374   {\cf17 public}:\par
04375     {\cf17 using} difference_type = std::ptrdiff_t;\par
04376     {\cf17 using} value_type = iteration_proxy_value;\par
04377     {\cf17 using} pointer = value_type * ;\par
04378     {\cf17 using} reference = value_type & ;\par
04379     {\cf17 using} iterator_category = std::input_iterator_tag;\par
04380     {\cf17 using} string_type = {\cf17 typename} std::remove_cv< typename std::remove_reference<decltype( std::declval<IteratorType>().key() ) >::type >::type;\par
04381 \par
04382   {\cf17 private}:\par
04384     IteratorType anchor;\par
04386     std::size_t array_index = 0;\par
04388     {\cf17 mutable} std::size_t array_index_last = 0;\par
04390     {\cf17 mutable} string_type array_index_str = {\cf22 "0"};\par
04392     {\cf17 const} string_type empty_str\{\};\par
04393 \par
04394   {\cf17 public}:\par
04395     {\cf17 explicit} iteration_proxy_value(IteratorType it) noexcept\par
04396         : anchor(std::move(it))\par
04397     \{\}\par
04398 \par
04400     iteration_proxy_value& operator*()\par
04401     \{\par
04402         {\cf19 return} *{\cf17 this};\par
04403     \}\par
04404 \par
04406     iteration_proxy_value& operator++()\par
04407     \{\par
04408         ++anchor;\par
04409         ++array_index;\par
04410 \par
04411         {\cf19 return} *{\cf17 this};\par
04412     \}\par
04413 \par
04415     {\cf18 bool} operator==({\cf17 const} iteration_proxy_value& o){\cf17  const}\par
04416 {\cf17     }\{\par
04417         {\cf19 return} anchor == o.anchor;\par
04418     \}\par
04419 \par
04421     {\cf18 bool} operator!=({\cf17 const} iteration_proxy_value& o){\cf17  const}\par
04422 {\cf17     }\{\par
04423         {\cf19 return} anchor != o.anchor;\par
04424     \}\par
04425 \par
04427     {\cf17 const} string_type& key(){\cf17  const}\par
04428 {\cf17     }\{\par
04429         JSON_ASSERT(anchor.m_object != {\cf17 nullptr});\par
04430 \par
04431         {\cf19 switch} (anchor.m_object->type())\par
04432         \{\par
04433             {\cf20 // use integer array index as key}\par
04434             {\cf19 case} value_t::array:\par
04435             \{\par
04436                 {\cf19 if} (array_index != array_index_last)\par
04437                 \{\par
04438                     int_to_string( array_index_str, array_index );\par
04439                     array_index_last = array_index;\par
04440                 \}\par
04441                 {\cf19 return} array_index_str;\par
04442             \}\par
04443 \par
04444             {\cf20 // use key from the object}\par
04445             {\cf19 case} value_t::object:\par
04446                 {\cf19 return} anchor.key();\par
04447 \par
04448             {\cf20 // use an empty key for all primitive types}\par
04449             {\cf19 case} value_t::null:\par
04450             {\cf19 case} value_t::string:\par
04451             {\cf19 case} value_t::boolean:\par
04452             {\cf19 case} value_t::number_integer:\par
04453             {\cf19 case} value_t::number_unsigned:\par
04454             {\cf19 case} value_t::number_float:\par
04455             {\cf19 case} value_t::binary:\par
04456             {\cf19 case} value_t::discarded:\par
04457             {\cf19 default}:\par
04458                 {\cf19 return} empty_str;\par
04459         \}\par
04460     \}\par
04461 \par
04463     {\cf17 typename} IteratorType::reference value(){\cf17  const}\par
04464 {\cf17     }\{\par
04465         {\cf19 return} anchor.value();\par
04466     \}\par
04467 \};\par
04468 \par
04470 {\cf17 template}<{\cf17 typename} IteratorType> {\cf17 class }iteration_proxy\par
04471 \{\par
04472   {\cf17 private}:\par
04474     {\cf17 typename} IteratorType::reference container;\par
04475 \par
04476   {\cf17 public}:\par
04478     {\cf17 explicit} iteration_proxy({\cf17 typename} IteratorType::reference cont) noexcept\par
04479         : container(cont) \{\}\par
04480 \par
04482     iteration_proxy_value<IteratorType> begin() noexcept\par
04483     \{\par
04484         {\cf19 return} iteration_proxy_value<IteratorType>(container.begin());\par
04485     \}\par
04486 \par
04488     iteration_proxy_value<IteratorType> end() noexcept\par
04489     \{\par
04490         {\cf19 return} iteration_proxy_value<IteratorType>(container.end());\par
04491     \}\par
04492 \};\par
04493 {\cf20 // Structured Bindings Support}\par
04494 {\cf20 // For further reference see https://blog.tartanllama.xyz/structured-bindings/}\par
04495 {\cf20 // And see https://github.com/nlohmann/json/pull/1391}\par
04496 {\cf17 template}<std::{\cf18 size_t} N, {\cf17 typename} IteratorType, enable_if_t<N == 0, {\cf18 int}> = 0>\par
04497 {\cf17 auto} get({\cf17 const} nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> {\cf17 decltype}(i.key())\par
04498 \{\par
04499     {\cf19 return} i.key();\par
04500 \}\par
04501 {\cf20 // Structured Bindings Support}\par
04502 {\cf20 // For further reference see https://blog.tartanllama.xyz/structured-bindings/}\par
04503 {\cf20 // And see https://github.com/nlohmann/json/pull/1391}\par
04504 {\cf17 template}<std::{\cf18 size_t} N, {\cf17 typename} IteratorType, enable_if_t<N == 1, {\cf18 int}> = 0>\par
04505 {\cf17 auto} get({\cf17 const} nlohmann::detail::iteration_proxy_value<IteratorType>& i) -> {\cf17 decltype}(i.value())\par
04506 \{\par
04507     {\cf19 return} i.value();\par
04508 \}\par
04509 \}  {\cf20 // namespace detail}\par
04510 \}  {\cf20 // namespace nlohmann}\par
04511 \par
04512 {\cf20 // The Addition to the STD Namespace is required to add}\par
04513 {\cf20 // Structured Bindings Support to the iteration_proxy_value class}\par
04514 {\cf20 // For further reference see https://blog.tartanllama.xyz/structured-bindings/}\par
04515 {\cf20 // And see https://github.com/nlohmann/json/pull/1391}\par
04516 {\cf17 namespace }std\par
04517 \{\par
04518 {\cf21 #if defined(__clang__)}\par
04519     {\cf20 // Fix: https://github.com/nlohmann/json/issues/1401}\par
04520 {\cf21     #pragma clang diagnostic push}\par
04521 {\cf21     #pragma clang diagnostic ignored "-Wmismatched-tags"}\par
04522 {\cf21 #endif}\par
04523 {\cf17 template}<{\cf17 typename} IteratorType>\par
04524 {\cf17 class }tuple_size<::nlohmann::detail::iteration_proxy_value<IteratorType>>\par
04525             : {\cf17 public} std::integral_constant<std::size_t, 2> \{\};\par
04526 \par
04527 {\cf17 template}<std::{\cf18 size_t} N, {\cf17 typename} IteratorType>\par
04528 {\cf17 class }tuple_element<N, ::nlohmann::detail::iteration_proxy_value<IteratorType >>\par
04529 \{\par
04530   {\cf17 public}:\par
04531     {\cf17 using} type = {\cf17 decltype}(\par
04532                      get<N>(std::declval <\par
04533                             ::nlohmann::detail::iteration_proxy_value<IteratorType >> ()));\par
04534 \};\par
04535 {\cf21 #if defined(__clang__)}\par
04536 {\cf21     #pragma clang diagnostic pop}\par
04537 {\cf21 #endif}\par
04538 \} {\cf20 // namespace std}\par
04539 \par
04540 {\cf20 // #include <nlohmann/detail/meta/cpp_future.hpp>}\par
04541 \par
04542 {\cf20 // #include <nlohmann/detail/meta/type_traits.hpp>}\par
04543 \par
04544 {\cf20 // #include <nlohmann/detail/value_t.hpp>}\par
04545 \par
04546 \par
04547 {\cf17 namespace }nlohmann\par
04548 \{\par
04549 {\cf17 namespace }detail\par
04550 \{\par
04552 {\cf20 // constructors //}\par
04554 {\cf20 }\par
04555 {\cf20 /*}\par
04556 {\cf20  * Note all external_constructor<>::construct functions need to call}\par
04557 {\cf20  * j.m_value.destroy(j.m_type) to avoid a memory leak in case j contains an}\par
04558 {\cf20  * allocated value (e.g., a string). See bug issue}\par
04559 {\cf20  * https://github.com/nlohmann/json/issues/2865 for more information.}\par
04560 {\cf20  */}\par
04561 \par
04562 {\cf17 template}<value_t> {\cf17 struct }external_constructor;\par
04563 \par
04564 {\cf17 template}<>\par
04565 {\cf17 struct }external_constructor<value_t::boolean>\par
04566 \{\par
04567     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04568     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 typename} BasicJsonType::boolean_t b) {\cf17 noexcept}\par
04569     \{\par
04570         j.m_value.destroy(j.m_type);\par
04571         j.m_type = value_t::boolean;\par
04572         j.m_value = b;\par
04573         j.assert_invariant();\par
04574     \}\par
04575 \};\par
04576 \par
04577 {\cf17 template}<>\par
04578 {\cf17 struct }external_constructor<value_t::string>\par
04579 \{\par
04580     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04581     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 const} {\cf17 typename} BasicJsonType::string_t& s)\par
04582     \{\par
04583         j.m_value.destroy(j.m_type);\par
04584         j.m_type = value_t::string;\par
04585         j.m_value = s;\par
04586         j.assert_invariant();\par
04587     \}\par
04588 \par
04589     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04590     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 typename} BasicJsonType::string_t&& s)\par
04591     \{\par
04592         j.m_value.destroy(j.m_type);\par
04593         j.m_type = value_t::string;\par
04594         j.m_value = std::move(s);\par
04595         j.assert_invariant();\par
04596     \}\par
04597 \par
04598     {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleStringType,\par
04599                enable_if_t < !std::is_same<CompatibleStringType, typename BasicJsonType::string_t>::value,\par
04600                              {\cf18 int} > = 0 >\par
04601     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 const} CompatibleStringType& str)\par
04602     \{\par
04603         j.m_value.destroy(j.m_type);\par
04604         j.m_type = value_t::string;\par
04605         j.m_value.string = j.template create<typename BasicJsonType::string_t>(str);\par
04606         j.assert_invariant();\par
04607     \}\par
04608 \};\par
04609 \par
04610 {\cf17 template}<>\par
04611 {\cf17 struct }external_constructor<value_t::binary>\par
04612 \{\par
04613     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04614     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 const} {\cf17 typename} BasicJsonType::binary_t& b)\par
04615     \{\par
04616         j.m_value.destroy(j.m_type);\par
04617         j.m_type = value_t::binary;\par
04618         j.m_value = {\cf17 typename} BasicJsonType::binary_t(b);\par
04619         j.assert_invariant();\par
04620     \}\par
04621 \par
04622     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04623     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 typename} BasicJsonType::binary_t&& b)\par
04624     \{\par
04625         j.m_value.destroy(j.m_type);\par
04626         j.m_type = value_t::binary;\par
04627         j.m_value = {\cf17 typename} BasicJsonType::binary_t(std::move(b));\par
04628         j.assert_invariant();\par
04629     \}\par
04630 \};\par
04631 \par
04632 {\cf17 template}<>\par
04633 {\cf17 struct }external_constructor<value_t::number_float>\par
04634 \{\par
04635     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04636     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 typename} BasicJsonType::number_float_t val) {\cf17 noexcept}\par
04637     \{\par
04638         j.m_value.destroy(j.m_type);\par
04639         j.m_type = value_t::number_float;\par
04640         j.m_value = val;\par
04641         j.assert_invariant();\par
04642     \}\par
04643 \};\par
04644 \par
04645 {\cf17 template}<>\par
04646 {\cf17 struct }external_constructor<value_t::number_unsigned>\par
04647 \{\par
04648     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04649     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 typename} BasicJsonType::number_unsigned_t val) {\cf17 noexcept}\par
04650     \{\par
04651         j.m_value.destroy(j.m_type);\par
04652         j.m_type = value_t::number_unsigned;\par
04653         j.m_value = val;\par
04654         j.assert_invariant();\par
04655     \}\par
04656 \};\par
04657 \par
04658 {\cf17 template}<>\par
04659 {\cf17 struct }external_constructor<value_t::number_integer>\par
04660 \{\par
04661     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04662     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 typename} BasicJsonType::number_integer_t val) {\cf17 noexcept}\par
04663     \{\par
04664         j.m_value.destroy(j.m_type);\par
04665         j.m_type = value_t::number_integer;\par
04666         j.m_value = val;\par
04667         j.assert_invariant();\par
04668     \}\par
04669 \};\par
04670 \par
04671 {\cf17 template}<>\par
04672 {\cf17 struct }external_constructor<value_t::array>\par
04673 \{\par
04674     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04675     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 const} {\cf17 typename} BasicJsonType::array_t& arr)\par
04676     \{\par
04677         j.m_value.destroy(j.m_type);\par
04678         j.m_type = value_t::array;\par
04679         j.m_value = arr;\par
04680         j.set_parents();\par
04681         j.assert_invariant();\par
04682     \}\par
04683 \par
04684     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04685     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 typename} BasicJsonType::array_t&& arr)\par
04686     \{\par
04687         j.m_value.destroy(j.m_type);\par
04688         j.m_type = value_t::array;\par
04689         j.m_value = std::move(arr);\par
04690         j.set_parents();\par
04691         j.assert_invariant();\par
04692     \}\par
04693 \par
04694     {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleArrayType,\par
04695                enable_if_t < !std::is_same<CompatibleArrayType, typename BasicJsonType::array_t>::value,\par
04696                              {\cf18 int} > = 0 >\par
04697     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 const} CompatibleArrayType& arr)\par
04698     \{\par
04699         {\cf17 using} std::begin;\par
04700         {\cf17 using} std::end;\par
04701 \par
04702         j.m_value.destroy(j.m_type);\par
04703         j.m_type = value_t::array;\par
04704         j.m_value.array = j.template create<typename BasicJsonType::array_t>(begin(arr), end(arr));\par
04705         j.set_parents();\par
04706         j.assert_invariant();\par
04707     \}\par
04708 \par
04709     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04710     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 const} std::vector<bool>& arr)\par
04711     \{\par
04712         j.m_value.destroy(j.m_type);\par
04713         j.m_type = value_t::array;\par
04714         j.m_value = value_t::array;\par
04715         j.m_value.array->reserve(arr.size());\par
04716         {\cf19 for} ({\cf17 const} {\cf18 bool} x : arr)\par
04717         \{\par
04718             j.m_value.array->push_back(x);\par
04719             j.set_parent(j.m_value.array->back());\par
04720         \}\par
04721         j.assert_invariant();\par
04722     \}\par
04723 \par
04724     {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T,\par
04725              enable_if_t<std::is_convertible<T, BasicJsonType>::value, {\cf18 int}> = 0>\par
04726     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 const} std::valarray<T>& arr)\par
04727     \{\par
04728         j.m_value.destroy(j.m_type);\par
04729         j.m_type = value_t::array;\par
04730         j.m_value = value_t::array;\par
04731         j.m_value.array->resize(arr.size());\par
04732         {\cf19 if} (arr.size() > 0)\par
04733         \{\par
04734             std::copy(std::begin(arr), std::end(arr), j.m_value.array->begin());\par
04735         \}\par
04736         j.set_parents();\par
04737         j.assert_invariant();\par
04738     \}\par
04739 \};\par
04740 \par
04741 {\cf17 template}<>\par
04742 {\cf17 struct }external_constructor<value_t::object>\par
04743 \{\par
04744     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04745     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 const} {\cf17 typename} BasicJsonType::object_t& obj)\par
04746     \{\par
04747         j.m_value.destroy(j.m_type);\par
04748         j.m_type = value_t::object;\par
04749         j.m_value = obj;\par
04750         j.set_parents();\par
04751         j.assert_invariant();\par
04752     \}\par
04753 \par
04754     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04755     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 typename} BasicJsonType::object_t&& obj)\par
04756     \{\par
04757         j.m_value.destroy(j.m_type);\par
04758         j.m_type = value_t::object;\par
04759         j.m_value = std::move(obj);\par
04760         j.set_parents();\par
04761         j.assert_invariant();\par
04762     \}\par
04763 \par
04764     {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleObjectType,\par
04765                enable_if_t < !std::is_same<CompatibleObjectType, typename BasicJsonType::object_t>::value, {\cf18 int} > = 0 >\par
04766     {\cf17 static} {\cf18 void} construct(BasicJsonType& j, {\cf17 const} CompatibleObjectType& obj)\par
04767     \{\par
04768         {\cf17 using} std::begin;\par
04769         {\cf17 using} std::end;\par
04770 \par
04771         j.m_value.destroy(j.m_type);\par
04772         j.m_type = value_t::object;\par
04773         j.m_value.object = j.template create<typename BasicJsonType::object_t>(begin(obj), end(obj));\par
04774         j.set_parents();\par
04775         j.assert_invariant();\par
04776     \}\par
04777 \};\par
04778 \par
04780 {\cf20 // to_json //}\par
04782 {\cf20 }\par
04783 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T,\par
04784          enable_if_t<std::is_same<T, typename BasicJsonType::boolean_t>::value, {\cf18 int}> = 0>\par
04785 {\cf18 void} to_json(BasicJsonType& j, T b) {\cf17 noexcept}\par
04786 \{\par
04787     external_constructor<value_t::boolean>::construct(j, b);\par
04788 \}\par
04789 \par
04790 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleString,\par
04791          enable_if_t<std::is_constructible<typename BasicJsonType::string_t, CompatibleString>::value, {\cf18 int}> = 0>\par
04792 {\cf18 void} to_json(BasicJsonType& j, {\cf17 const} CompatibleString& s)\par
04793 \{\par
04794     external_constructor<value_t::string>::construct(j, s);\par
04795 \}\par
04796 \par
04797 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04798 {\cf18 void} to_json(BasicJsonType& j, {\cf17 typename} BasicJsonType::string_t&& s)\par
04799 \{\par
04800     external_constructor<value_t::string>::construct(j, std::move(s));\par
04801 \}\par
04802 \par
04803 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} FloatType,\par
04804          enable_if_t<std::is_floating_point<FloatType>::value, {\cf18 int}> = 0>\par
04805 {\cf18 void} to_json(BasicJsonType& j, FloatType val) {\cf17 noexcept}\par
04806 \{\par
04807     external_constructor<value_t::number_float>::construct(j, {\cf17 static_cast<}typename BasicJsonType::number_float_t{\cf17 >}(val));\par
04808 \}\par
04809 \par
04810 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleNumberUnsignedType,\par
04811          enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_unsigned_t, CompatibleNumberUnsignedType>::value, {\cf18 int}> = 0>\par
04812 {\cf18 void} to_json(BasicJsonType& j, CompatibleNumberUnsignedType val) {\cf17 noexcept}\par
04813 \{\par
04814     external_constructor<value_t::number_unsigned>::construct(j, {\cf17 static_cast<}typename BasicJsonType::number_unsigned_t{\cf17 >}(val));\par
04815 \}\par
04816 \par
04817 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleNumberIntegerType,\par
04818          enable_if_t<is_compatible_integer_type<typename BasicJsonType::number_integer_t, CompatibleNumberIntegerType>::value, {\cf18 int}> = 0>\par
04819 {\cf18 void} to_json(BasicJsonType& j, CompatibleNumberIntegerType val) {\cf17 noexcept}\par
04820 \{\par
04821     external_constructor<value_t::number_integer>::construct(j, {\cf17 static_cast<}typename BasicJsonType::number_integer_t{\cf17 >}(val));\par
04822 \}\par
04823 \par
04824 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} EnumType,\par
04825          enable_if_t<std::is_enum<EnumType>::value, {\cf18 int}> = 0>\par
04826 {\cf18 void} to_json(BasicJsonType& j, EnumType e) {\cf17 noexcept}\par
04827 \{\par
04828     {\cf17 using} underlying_type = {\cf17 typename} std::underlying_type<EnumType>::type;\par
04829     external_constructor<value_t::number_integer>::construct(j, {\cf17 static_cast<}underlying_type{\cf17 >}(e));\par
04830 \}\par
04831 \par
04832 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04833 {\cf18 void} to_json(BasicJsonType& j, {\cf17 const} std::vector<bool>& e)\par
04834 \{\par
04835     external_constructor<value_t::array>::construct(j, e);\par
04836 \}\par
04837 \par
04838 {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleArrayType,\par
04839            enable_if_t < is_compatible_array_type<BasicJsonType,\par
04840                          CompatibleArrayType>::value&&\par
04841                          !is_compatible_object_type<BasicJsonType, CompatibleArrayType>::value&&\par
04842                          !is_compatible_string_type<BasicJsonType, CompatibleArrayType>::value&&\par
04843                          !std::is_same<typename BasicJsonType::binary_t, CompatibleArrayType>::value&&\par
04844                          !is_basic_json<CompatibleArrayType>::value,\par
04845                          {\cf18 int} > = 0 >\par
04846 {\cf18 void} to_json(BasicJsonType& j, {\cf17 const} CompatibleArrayType& arr)\par
04847 \{\par
04848     external_constructor<value_t::array>::construct(j, arr);\par
04849 \}\par
04850 \par
04851 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04852 {\cf18 void} to_json(BasicJsonType& j, {\cf17 const} {\cf17 typename} BasicJsonType::binary_t& bin)\par
04853 \{\par
04854     external_constructor<value_t::binary>::construct(j, bin);\par
04855 \}\par
04856 \par
04857 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T,\par
04858          enable_if_t<std::is_convertible<T, BasicJsonType>::value, {\cf18 int}> = 0>\par
04859 {\cf18 void} to_json(BasicJsonType& j, {\cf17 const} std::valarray<T>& arr)\par
04860 \{\par
04861     external_constructor<value_t::array>::construct(j, std::move(arr));\par
04862 \}\par
04863 \par
04864 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04865 {\cf18 void} to_json(BasicJsonType& j, {\cf17 typename} BasicJsonType::array_t&& arr)\par
04866 \{\par
04867     external_constructor<value_t::array>::construct(j, std::move(arr));\par
04868 \}\par
04869 \par
04870 {\cf17 template} < {\cf17 typename} BasicJsonType, {\cf17 typename} CompatibleObjectType,\par
04871            enable_if_t < is_compatible_object_type<BasicJsonType, CompatibleObjectType>::value&& !is_basic_json<CompatibleObjectType>::value, {\cf18 int} > = 0 >\par
04872 {\cf18 void} to_json(BasicJsonType& j, {\cf17 const} CompatibleObjectType& obj)\par
04873 \{\par
04874     external_constructor<value_t::object>::construct(j, obj);\par
04875 \}\par
04876 \par
04877 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
04878 {\cf18 void} to_json(BasicJsonType& j, {\cf17 typename} BasicJsonType::object_t&& obj)\par
04879 \{\par
04880     external_constructor<value_t::object>::construct(j, std::move(obj));\par
04881 \}\par
04882 \par
04883 {\cf17 template} <\par
04884     {\cf17 typename} BasicJsonType, {\cf17 typename} T, std::size_t N,\par
04885     enable_if_t < !std::is_constructible<{\cf17 typename} BasicJsonType::string_t,\par
04886                   {\cf17 const} T(&)[N]>::value, {\cf20 // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)}\par
04887                   {\cf18 int} > = 0 >\par
04888 {\cf18 void} to_json(BasicJsonType& j, {\cf17 const} T(&arr)[N]) {\cf20 // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)}\par
04889 \{\par
04890     external_constructor<value_t::array>::construct(j, arr);\par
04891 \}\par
04892 \par
04893 template < typename BasicJsonType, typename T1, typename T2, enable_if_t < std::is_constructible<BasicJsonType, T1>::value&& std::is_constructible<BasicJsonType, T2>::value, {\cf18 int} > = 0 >\par
04894 {\cf18 void} to_json(BasicJsonType& j, {\cf17 const} std::pair<T1, T2>& p)\par
04895 \{\par
04896     j = \{ p.first, p.second \};\par
04897 \}\par
04898 \par
04899 {\cf20 // for https://github.com/nlohmann/json/pull/1134}\par
04900 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T,\par
04901          enable_if_t<std::is_same<T, iteration_proxy_value<typename BasicJsonType::iterator>>::value, {\cf18 int}> = 0>\par
04902 {\cf18 void} to_json(BasicJsonType& j, {\cf17 const} T& b)\par
04903 \{\par
04904     j = \{ \{b.key(), b.value()\} \};\par
04905 \}\par
04906 \par
04907 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} Tuple, std::size_t... Idx>\par
04908 {\cf18 void} to_json_tuple_impl(BasicJsonType& j, {\cf17 const} Tuple& t, index_sequence<Idx...> {\cf20 /*unused*/})\par
04909 \{\par
04910     j = \{ std::get<Idx>(t)... \};\par
04911 \}\par
04912 \par
04913 template<typename BasicJsonType, typename T, enable_if_t<is_constructible_tuple<BasicJsonType, T>::value, {\cf18 int} > = 0>\par
04914 {\cf18 void} to_json(BasicJsonType& j, {\cf17 const} T& t)\par
04915 \{\par
04916     to_json_tuple_impl(j, t, make_index_sequence<std::tuple_size<T>::value> \{\});\par
04917 \}\par
04918 \par
04919 {\cf17 struct }to_json_fn\par
04920 \{\par
04921     {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} T>\par
04922     {\cf17 auto} operator()(BasicJsonType& j, T&& val) {\cf17 const} {\cf17 noexcept}({\cf17 noexcept}(to_json(j, std::forward<T>(val))))\par
04923     -> {\cf17 decltype}(to_json(j, std::forward<T>(val)), void())\par
04924     \{\par
04925         {\cf19 return} to_json(j, std::forward<T>(val));\par
04926     \}\par
04927 \};\par
04928 \}  {\cf20 // namespace detail}\par
04929 \par
04933 {\cf17 namespace }{\cf20 // NOLINT(cert-dcl59-cpp,fuchsia-header-anon-namespaces,google-build-namespaces)}\par
04934 \{\par
04935 {\cf17 constexpr} {\cf17 const} {\cf17 auto}& to_json = detail::static_const<detail::to_json_fn>::value; {\cf20 // NOLINT(misc-definitions-in-headers)}\par
04936 \} {\cf20 // namespace}\par
04937 \} {\cf20 // namespace nlohmann}\par
04938 \par
04939 {\cf20 // #include <nlohmann/detail/meta/identity_tag.hpp>}\par
04940 \par
04941 {\cf20 // #include <nlohmann/detail/meta/type_traits.hpp>}\par
04942 \par
04943 \par
04944 {\cf17 namespace }nlohmann\par
04945 \{\par
04946 \par
04947 {\cf17 template}<{\cf17 typename} ValueType, {\cf17 typename}>\par
04948 {\cf17 struct }adl_serializer\par
04949 \{\par
04961     {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} TargetType = ValueType>\par
04962     {\cf17 static} {\cf17 auto} from_json(BasicJsonType && j, TargetType& val) {\cf17 noexcept}(\par
04963         {\cf17 noexcept}(::nlohmann::from_json(std::forward<BasicJsonType>(j), val)))\par
04964     -> {\cf17 decltype}(::nlohmann::from_json(std::forward<BasicJsonType>(j), val), void())\par
04965     \{\par
04966         ::nlohmann::from_json(std::forward<BasicJsonType>(j), val);\par
04967     \}\par
04968 \par
04981     {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} TargetType = ValueType>\par
04982     {\cf17 static} {\cf17 auto} from_json(BasicJsonType && j) {\cf17 noexcept}(\par
04983     {\cf17 noexcept}(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> \{\})))\par
04984     -> {\cf17 decltype}(::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> \{\}))\par
04985     \{\par
04986         return ::nlohmann::from_json(std::forward<BasicJsonType>(j), detail::identity_tag<TargetType> \{\});\par
04987     \}\par
04988 \par
04998     {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} TargetType = ValueType>\par
04999     {\cf17 static} {\cf17 auto} to_json(BasicJsonType& j, TargetType && val) {\cf17 noexcept}(\par
05000         {\cf17 noexcept}(::nlohmann::to_json(j, std::forward<TargetType>(val))))\par
05001     -> {\cf17 decltype}(::nlohmann::to_json(j, std::forward<TargetType>(val)), void())\par
05002     \{\par
05003         ::nlohmann::to_json(j, std::forward<TargetType>(val));\par
05004     \}\par
05005 \};\par
05006 \}  {\cf20 // namespace nlohmann}\par
05007 \par
05008 {\cf20 // #include <nlohmann/byte_container_with_subtype.hpp>}\par
05009 \par
05010 \par
05011 {\cf21 #include <cstdint>} {\cf20 // uint8_t, uint64_t}\par
05012 {\cf21 #include <tuple>} {\cf20 // tie}\par
05013 {\cf21 #include <utility>} {\cf20 // move}\par
05014 \par
05015 {\cf17 namespace }nlohmann\par
05016 \{\par
05017 \par
05031 {\cf17 template}<{\cf17 typename} BinaryType>\par
05032 {\cf17 class }byte_container_with_subtype : {\cf17 public} BinaryType\par
05033 \{\par
05034   {\cf17 public}:\par
05036     {\cf17 using} container_type = BinaryType;\par
05038     {\cf17 using} subtype_type = std::uint64_t;\par
05039 \par
05040     byte_container_with_subtype() noexcept(noexcept(container_type()))\par
05041         : container_type()\par
05042     \{\}\par
05043 \par
05044     byte_container_with_subtype({\cf17 const} container_type& b) {\cf17 noexcept}({\cf17 noexcept}(container_type(b)))\par
05045         : container_type(b)\par
05046     \{\}\par
05047 \par
05048     byte_container_with_subtype(container_type&& b) {\cf17 noexcept}({\cf17 noexcept}(container_type(std::move(b))))\par
05049         : container_type(std::move(b))\par
05050     \{\}\par
05051 \par
05052     byte_container_with_subtype({\cf17 const} container_type& b, subtype_type subtype_) {\cf17 noexcept}({\cf17 noexcept}(container_type(b)))\par
05053         : container_type(b)\par
05054         , m_subtype(subtype_)\par
05055         , m_has_subtype({\cf17 true})\par
05056     \{\}\par
05057 \par
05058     byte_container_with_subtype(container_type&& b, subtype_type subtype_) {\cf17 noexcept}({\cf17 noexcept}(container_type(std::move(b))))\par
05059         : container_type(std::move(b))\par
05060         , m_subtype(subtype_)\par
05061         , m_has_subtype({\cf17 true})\par
05062     \{\}\par
05063 \par
05064     {\cf18 bool} operator==({\cf17 const} byte_container_with_subtype& rhs){\cf17  const}\par
05065 {\cf17     }\{\par
05066         {\cf19 return} std::tie({\cf17 static_cast<}{\cf17 const }BinaryType&{\cf17 >}(*{\cf17 this}), m_subtype, m_has_subtype) ==\par
05067                std::tie({\cf17 static_cast<}{\cf17 const }BinaryType&{\cf17 >}(rhs), rhs.m_subtype, rhs.m_has_subtype);\par
05068     \}\par
05069 \par
05070     {\cf18 bool} operator!=({\cf17 const} byte_container_with_subtype& rhs){\cf17  const}\par
05071 {\cf17     }\{\par
05072         {\cf19 return} !(rhs == *{\cf17 this});\par
05073     \}\par
05074 \par
05093     {\cf18 void} set_subtype(subtype_type subtype_) {\cf17 noexcept}\par
05094     \{\par
05095         m_subtype = subtype_;\par
05096         m_has_subtype = {\cf17 true};\par
05097     \}\par
05098 \par
05121     {\cf17 constexpr} subtype_type subtype() const noexcept\par
05122     \{\par
05123         {\cf19 return} m_has_subtype ? m_subtype : subtype_type(-1);\par
05124     \}\par
05125 \par
05142     {\cf17 constexpr} {\cf18 bool} has_subtype() const noexcept\par
05143     \{\par
05144         {\cf19 return} m_has_subtype;\par
05145     \}\par
05146 \par
05166     {\cf18 void} clear_subtype() noexcept\par
05167     \{\par
05168         m_subtype = 0;\par
05169         m_has_subtype = {\cf17 false};\par
05170     \}\par
05171 \par
05172   {\cf17 private}:\par
05173     subtype_type m_subtype = 0;\par
05174     {\cf18 bool} m_has_subtype = {\cf17 false};\par
05175 \};\par
05176 \par
05177 \}  {\cf20 // namespace nlohmann}\par
05178 \par
05179 {\cf20 // #include <nlohmann/detail/conversions/from_json.hpp>}\par
05180 \par
05181 {\cf20 // #include <nlohmann/detail/conversions/to_json.hpp>}\par
05182 \par
05183 {\cf20 // #include <nlohmann/detail/exceptions.hpp>}\par
05184 \par
05185 {\cf20 // #include <nlohmann/detail/hash.hpp>}\par
05186 \par
05187 \par
05188 {\cf21 #include <cstdint>} {\cf20 // uint8_t}\par
05189 {\cf21 #include <cstddef>} {\cf20 // size_t}\par
05190 {\cf21 #include <functional>} {\cf20 // hash}\par
05191 \par
05192 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
05193 \par
05194 {\cf20 // #include <nlohmann/detail/value_t.hpp>}\par
05195 \par
05196 \par
05197 {\cf17 namespace }nlohmann\par
05198 \{\par
05199 {\cf17 namespace }detail\par
05200 \{\par
05201 \par
05202 {\cf20 // boost::hash_combine}\par
05203 {\cf17 inline} std::size_t combine(std::size_t seed, std::size_t h) {\cf17 noexcept}\par
05204 \{\par
05205     seed ^= h + 0x9e3779b9 + (seed << 6U) + (seed >> 2U);\par
05206     {\cf19 return} seed;\par
05207 \}\par
05208 \par
05220 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
05221 std::size_t hash({\cf17 const} BasicJsonType& j)\par
05222 \{\par
05223     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
05224     {\cf17 using} number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
05225     {\cf17 using} number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
05226     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
05227 \par
05228     {\cf17 const} {\cf17 auto} type = {\cf17 static_cast<}std::size_t{\cf17 >}(j.type());\par
05229     {\cf19 switch} (j.type())\par
05230     \{\par
05231         {\cf19 case} BasicJsonType::value_t::null:\par
05232         {\cf19 case} BasicJsonType::value_t::discarded:\par
05233         \{\par
05234             {\cf19 return} combine(type, 0);\par
05235         \}\par
05236 \par
05237         {\cf19 case} BasicJsonType::value_t::object:\par
05238         \{\par
05239             {\cf17 auto} seed = combine(type, j.size());\par
05240             {\cf19 for} ({\cf17 const} {\cf17 auto}& element : j.items())\par
05241             \{\par
05242                 {\cf17 const} {\cf17 auto} h = std::hash<string_t> \{\}(element.key());\par
05243                 seed = combine(seed, h);\par
05244                 seed = combine(seed, hash(element.value()));\par
05245             \}\par
05246             {\cf19 return} seed;\par
05247         \}\par
05248 \par
05249         {\cf19 case} BasicJsonType::value_t::array:\par
05250         \{\par
05251             {\cf17 auto} seed = combine(type, j.size());\par
05252             {\cf19 for} ({\cf17 const} {\cf17 auto}& element : j)\par
05253             \{\par
05254                 seed = combine(seed, hash(element));\par
05255             \}\par
05256             {\cf19 return} seed;\par
05257         \}\par
05258 \par
05259         {\cf19 case} BasicJsonType::value_t::string:\par
05260         \{\par
05261             {\cf17 const} {\cf17 auto} h = std::hash<string_t> \{\}(j.template get_ref<const string_t&>());\par
05262             {\cf19 return} combine(type, h);\par
05263         \}\par
05264 \par
05265         {\cf19 case} BasicJsonType::value_t::boolean:\par
05266         \{\par
05267             {\cf17 const} {\cf17 auto} h = std::hash<bool> \{\}(j.template get<bool>());\par
05268             {\cf19 return} combine(type, h);\par
05269         \}\par
05270 \par
05271         {\cf19 case} BasicJsonType::value_t::number_integer:\par
05272         \{\par
05273             {\cf17 const} {\cf17 auto} h = std::hash<number_integer_t> \{\}(j.template get<number_integer_t>());\par
05274             {\cf19 return} combine(type, h);\par
05275         \}\par
05276 \par
05277         {\cf19 case} BasicJsonType::value_t::number_unsigned:\par
05278         \{\par
05279             {\cf17 const} {\cf17 auto} h = std::hash<number_unsigned_t> \{\}(j.template get<number_unsigned_t>());\par
05280             {\cf19 return} combine(type, h);\par
05281         \}\par
05282 \par
05283         {\cf19 case} BasicJsonType::value_t::number_float:\par
05284         \{\par
05285             {\cf17 const} {\cf17 auto} h = std::hash<number_float_t> \{\}(j.template get<number_float_t>());\par
05286             {\cf19 return} combine(type, h);\par
05287         \}\par
05288 \par
05289         {\cf19 case} BasicJsonType::value_t::binary:\par
05290         \{\par
05291             {\cf17 auto} seed = combine(type, j.get_binary().size());\par
05292             {\cf17 const} {\cf17 auto} h = std::hash<bool> \{\}(j.get_binary().has_subtype());\par
05293             seed = combine(seed, h);\par
05294             seed = combine(seed, {\cf17 static_cast<}std::size_t{\cf17 >}(j.get_binary().subtype()));\par
05295             {\cf19 for} ({\cf17 const} {\cf17 auto} {\cf18 byte} : j.get_binary())\par
05296             \{\par
05297                 seed = combine(seed, std::hash<std::uint8_t> \{\}(byte));\par
05298             \}\par
05299             {\cf19 return} seed;\par
05300         \}\par
05301 \par
05302         {\cf19 default}:                   {\cf20 // LCOV_EXCL_LINE}\par
05303             JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE}\par
05304             {\cf19 return} 0;              {\cf20 // LCOV_EXCL_LINE}\par
05305     \}\par
05306 \}\par
05307 \par
05308 \}  {\cf20 // namespace detail}\par
05309 \}  {\cf20 // namespace nlohmann}\par
05310 \par
05311 {\cf20 // #include <nlohmann/detail/input/binary_reader.hpp>}\par
05312 \par
05313 \par
05314 {\cf21 #include <algorithm>} {\cf20 // generate_n}\par
05315 {\cf21 #include <array>} {\cf20 // array}\par
05316 {\cf21 #include <cmath>} {\cf20 // ldexp}\par
05317 {\cf21 #include <cstddef>} {\cf20 // size_t}\par
05318 {\cf21 #include <cstdint>} {\cf20 // uint8_t, uint16_t, uint32_t, uint64_t}\par
05319 {\cf21 #include <cstdio>} {\cf20 // snprintf}\par
05320 {\cf21 #include <cstring>} {\cf20 // memcpy}\par
05321 {\cf21 #include <iterator>} {\cf20 // back_inserter}\par
05322 {\cf21 #include <limits>} {\cf20 // numeric_limits}\par
05323 {\cf21 #include <string>} {\cf20 // char_traits, string}\par
05324 {\cf21 #include <utility>} {\cf20 // make_pair, move}\par
05325 {\cf21 #include <vector>} {\cf20 // vector}\par
05326 \par
05327 {\cf20 // #include <nlohmann/detail/exceptions.hpp>}\par
05328 \par
05329 {\cf20 // #include <nlohmann/detail/input/input_adapters.hpp>}\par
05330 \par
05331 \par
05332 {\cf21 #include <array>} {\cf20 // array}\par
05333 {\cf21 #include <cstddef>} {\cf20 // size_t}\par
05334 {\cf21 #include <cstring>} {\cf20 // strlen}\par
05335 {\cf21 #include <iterator>} {\cf20 // begin, end, iterator_traits, random_access_iterator_tag, distance, next}\par
05336 {\cf21 #include <memory>} {\cf20 // shared_ptr, make_shared, addressof}\par
05337 {\cf21 #include <numeric>} {\cf20 // accumulate}\par
05338 {\cf21 #include <string>} {\cf20 // string, char_traits}\par
05339 {\cf21 #include <type_traits>} {\cf20 // enable_if, is_base_of, is_pointer, is_integral, remove_pointer}\par
05340 {\cf21 #include <utility>} {\cf20 // pair, declval}\par
05341 \par
05342 {\cf21 #ifndef JSON_NO_IO}\par
05343 {\cf21     #include <cstdio>}   {\cf20 // FILE *}\par
05344 {\cf21     #include <istream>}  {\cf20 // istream}\par
05345 {\cf21 #endif                  }{\cf20 // JSON_NO_IO}\par
05346 \par
05347 {\cf20 // #include <nlohmann/detail/iterators/iterator_traits.hpp>}\par
05348 \par
05349 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
05350 \par
05351 \par
05352 {\cf17 namespace }nlohmann\par
05353 \{\par
05354 {\cf17 namespace }detail\par
05355 \{\par
05357 {\cf17 enum class} input_format_t \{ json, cbor, msgpack, ubjson, bson \};\par
05358 \par
05360 {\cf20 // input adapters //}\par
05362 {\cf20 }\par
05363 {\cf21 #ifndef JSON_NO_IO}\par
05368 {\cf17 class }file_input_adapter\par
05369 \{\par
05370   {\cf17 public}:\par
05371     {\cf17 using} char_type = char;\par
05372 \par
05373     JSON_HEDLEY_NON_NULL(2)\par
05374     explicit file_input_adapter(std::FILE* f) noexcept\par
05375         : m_file(f)\par
05376     \{\}\par
05377 \par
05378     {\cf20 // make class move-only}\par
05379     file_input_adapter({\cf17 const} file_input_adapter&) = {\cf17 delete};\par
05380     file_input_adapter(file_input_adapter&&) noexcept = default;\par
05381     file_input_adapter& operator=(const file_input_adapter&) = delete;\par
05382     file_input_adapter& operator=(file_input_adapter&&) = delete;\par
05383     ~file_input_adapter() = default;\par
05384 \par
05385     std::char_traits<{\cf18 char}>::int_type get_character() noexcept\par
05386     \{\par
05387         {\cf19 return} std::fgetc(m_file);\par
05388     \}\par
05389 \par
05390   {\cf17 private}:\par
05392     std::FILE* m_file;\par
05393 \};\par
05394 \par
05395 \par
05405 {\cf17 class }input_stream_adapter\par
05406 \{\par
05407   {\cf17 public}:\par
05408     {\cf17 using} char_type = char;\par
05409 \par
05410     ~input_stream_adapter()\par
05411     \{\par
05412         {\cf20 // clear stream flags; we use underlying streambuf I/O, do not}\par
05413         {\cf20 // maintain ifstream flags, except eof}\par
05414         {\cf19 if} (is != {\cf17 nullptr})\par
05415         \{\par
05416             is->clear(is->rdstate() & std::ios::eofbit);\par
05417         \}\par
05418     \}\par
05419 \par
05420     {\cf17 explicit} input_stream_adapter(std::istream& i)\par
05421         : is(&i), sb(i.rdbuf())\par
05422     \{\}\par
05423 \par
05424     {\cf20 // delete because of pointer members}\par
05425     input_stream_adapter({\cf17 const} input_stream_adapter&) = {\cf17 delete};\par
05426     input_stream_adapter& operator=(input_stream_adapter&) = {\cf17 delete};\par
05427     input_stream_adapter& operator=(input_stream_adapter&&) = {\cf17 delete};\par
05428 \par
05429     input_stream_adapter(input_stream_adapter&& rhs) noexcept\par
05430         : is(rhs.is), sb(rhs.sb)\par
05431     \{\par
05432         rhs.is = {\cf17 nullptr};\par
05433         rhs.sb = {\cf17 nullptr};\par
05434     \}\par
05435 \par
05436     {\cf20 // std::istream/std::streambuf use std::char_traits<char>::to_int_type, to}\par
05437     {\cf20 // ensure that std::char_traits<char>::eof() and the character 0xFF do not}\par
05438     {\cf20 // end up as the same value, eg. 0xFFFFFFFF.}\par
05439     std::char_traits<char>::int_type get_character()\par
05440     \{\par
05441         {\cf17 auto} res = sb->sbumpc();\par
05442         {\cf20 // set eof manually, as we don't use the istream interface.}\par
05443         {\cf19 if} (JSON_HEDLEY_UNLIKELY(res == std::char_traits<char>::eof()))\par
05444         \{\par
05445             is->clear(is->rdstate() | std::ios::eofbit);\par
05446         \}\par
05447         {\cf19 return} res;\par
05448     \}\par
05449 \par
05450   {\cf17 private}:\par
05452     std::istream* is = {\cf17 nullptr};\par
05453     std::streambuf* sb = {\cf17 nullptr};\par
05454 \};\par
05455 {\cf21 #endif  }{\cf20 // JSON_NO_IO}\par
05456 \par
05457 {\cf20 // General-purpose iterator-based adapter. It might not be as fast as}\par
05458 {\cf20 // theoretically possible for some containers, but it is extremely versatile.}\par
05459 {\cf17 template}<{\cf17 typename} IteratorType>\par
05460 {\cf17 class }iterator_input_adapter\par
05461 \{\par
05462   {\cf17 public}:\par
05463     {\cf17 using} char_type = {\cf17 typename} std::iterator_traits<IteratorType>::value_type;\par
05464 \par
05465     iterator_input_adapter(IteratorType first, IteratorType last)\par
05466         : current(std::move(first)), end(std::move(last))\par
05467     \{\}\par
05468 \par
05469     {\cf17 typename} std::char_traits<char_type>::int_type get_character()\par
05470     \{\par
05471         {\cf19 if} (JSON_HEDLEY_LIKELY(current != end))\par
05472         \{\par
05473             {\cf17 auto} result = std::char_traits<char_type>::to_int_type(*current);\par
05474             std::advance(current, 1);\par
05475             {\cf19 return} result;\par
05476         \}\par
05477 \par
05478         {\cf19 return} std::char_traits<char_type>::eof();\par
05479     \}\par
05480 \par
05481   {\cf17 private}:\par
05482     IteratorType current;\par
05483     IteratorType end;\par
05484 \par
05485     {\cf17 template}<{\cf17 typename} BaseInputAdapter, {\cf18 size_t} T>\par
05486     {\cf17 friend} {\cf17 struct }wide_string_input_helper;\par
05487 \par
05488     {\cf18 bool} empty(){\cf17  const}\par
05489 {\cf17     }\{\par
05490         {\cf19 return} current == end;\par
05491     \}\par
05492 \};\par
05493 \par
05494 \par
05495 {\cf17 template}<{\cf17 typename} BaseInputAdapter, {\cf18 size_t} T>\par
05496 {\cf17 struct }wide_string_input_helper;\par
05497 \par
05498 {\cf17 template}<{\cf17 typename} BaseInputAdapter>\par
05499 {\cf17 struct }wide_string_input_helper<BaseInputAdapter, 4>\par
05500 \{\par
05501     {\cf20 // UTF-32}\par
05502     {\cf17 static} {\cf18 void} fill_buffer(BaseInputAdapter& input,\par
05503                             std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,\par
05504                             {\cf18 size_t}& utf8_bytes_index,\par
05505                             {\cf18 size_t}& utf8_bytes_filled)\par
05506     \{\par
05507         utf8_bytes_index = 0;\par
05508 \par
05509         {\cf19 if} (JSON_HEDLEY_UNLIKELY(input.empty()))\par
05510         \{\par
05511             utf8_bytes[0] = std::char_traits<char>::eof();\par
05512             utf8_bytes_filled = 1;\par
05513         \}\par
05514         {\cf19 else}\par
05515         \{\par
05516             {\cf20 // get the current character}\par
05517             {\cf17 const} {\cf17 auto} wc = input.get_character();\par
05518 \par
05519             {\cf20 // UTF-32 to UTF-8 encoding}\par
05520             {\cf19 if} (wc < 0x80)\par
05521             \{\par
05522                 utf8_bytes[0] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(wc);\par
05523                 utf8_bytes_filled = 1;\par
05524             \}\par
05525             {\cf19 else} {\cf19 if} (wc <= 0x7FF)\par
05526             \{\par
05527                 utf8_bytes[0] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0xC0u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) >> 6u) & 0x1Fu));\par
05528                 utf8_bytes[1] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) & 0x3Fu));\par
05529                 utf8_bytes_filled = 2;\par
05530             \}\par
05531             {\cf19 else} {\cf19 if} (wc <= 0xFFFF)\par
05532             \{\par
05533                 utf8_bytes[0] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0xE0u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) >> 12u) & 0x0Fu));\par
05534                 utf8_bytes[1] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) >> 6u) & 0x3Fu));\par
05535                 utf8_bytes[2] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) & 0x3Fu));\par
05536                 utf8_bytes_filled = 3;\par
05537             \}\par
05538             {\cf19 else} {\cf19 if} (wc <= 0x10FFFF)\par
05539             \{\par
05540                 utf8_bytes[0] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0xF0u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) >> 18u) & 0x07u));\par
05541                 utf8_bytes[1] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) >> 12u) & 0x3Fu));\par
05542                 utf8_bytes[2] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) >> 6u) & 0x3Fu));\par
05543                 utf8_bytes[3] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) & 0x3Fu));\par
05544                 utf8_bytes_filled = 4;\par
05545             \}\par
05546             {\cf19 else}\par
05547             \{\par
05548                 {\cf20 // unknown character}\par
05549                 utf8_bytes[0] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(wc);\par
05550                 utf8_bytes_filled = 1;\par
05551             \}\par
05552         \}\par
05553     \}\par
05554 \};\par
05555 \par
05556 {\cf17 template}<{\cf17 typename} BaseInputAdapter>\par
05557 {\cf17 struct }wide_string_input_helper<BaseInputAdapter, 2>\par
05558 \{\par
05559     {\cf20 // UTF-16}\par
05560     {\cf17 static} {\cf18 void} fill_buffer(BaseInputAdapter& input,\par
05561                             std::array<std::char_traits<char>::int_type, 4>& utf8_bytes,\par
05562                             {\cf18 size_t}& utf8_bytes_index,\par
05563                             {\cf18 size_t}& utf8_bytes_filled)\par
05564     \{\par
05565         utf8_bytes_index = 0;\par
05566 \par
05567         {\cf19 if} (JSON_HEDLEY_UNLIKELY(input.empty()))\par
05568         \{\par
05569             utf8_bytes[0] = std::char_traits<char>::eof();\par
05570             utf8_bytes_filled = 1;\par
05571         \}\par
05572         {\cf19 else}\par
05573         \{\par
05574             {\cf20 // get the current character}\par
05575             {\cf17 const} {\cf17 auto} wc = input.get_character();\par
05576 \par
05577             {\cf20 // UTF-16 to UTF-8 encoding}\par
05578             {\cf19 if} (wc < 0x80)\par
05579             \{\par
05580                 utf8_bytes[0] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(wc);\par
05581                 utf8_bytes_filled = 1;\par
05582             \}\par
05583             {\cf19 else} {\cf19 if} (wc <= 0x7FF)\par
05584             \{\par
05585                 utf8_bytes[0] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0xC0u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) >> 6u)));\par
05586                 utf8_bytes[1] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) & 0x3Fu));\par
05587                 utf8_bytes_filled = 2;\par
05588             \}\par
05589             {\cf19 else} {\cf19 if} (0xD800 > wc || wc >= 0xE000)\par
05590             \{\par
05591                 utf8_bytes[0] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0xE0u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) >> 12u)));\par
05592                 utf8_bytes[1] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) >> 6u) & 0x3Fu));\par
05593                 utf8_bytes[2] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) & 0x3Fu));\par
05594                 utf8_bytes_filled = 3;\par
05595             \}\par
05596             {\cf19 else}\par
05597             \{\par
05598                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!input.empty()))\par
05599                 \{\par
05600                     {\cf17 const} {\cf17 auto} wc2 = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(input.get_character());\par
05601                     {\cf17 const} {\cf17 auto} charcode = 0x10000u + ((({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(wc) & 0x3FFu) << 10u) | (wc2 & 0x3FFu));\par
05602                     utf8_bytes[0] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0xF0u | (charcode >> 18u));\par
05603                     utf8_bytes[1] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | ((charcode >> 12u) & 0x3Fu));\par
05604                     utf8_bytes[2] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | ((charcode >> 6u) & 0x3Fu));\par
05605                     utf8_bytes[3] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(0x80u | (charcode & 0x3Fu));\par
05606                     utf8_bytes_filled = 4;\par
05607                 \}\par
05608                 {\cf19 else}\par
05609                 \{\par
05610                     utf8_bytes[0] = {\cf17 static_cast<}std::char_traits<char>::int_type{\cf17 >}(wc);\par
05611                     utf8_bytes_filled = 1;\par
05612                 \}\par
05613             \}\par
05614         \}\par
05615     \}\par
05616 \};\par
05617 \par
05618 {\cf20 // Wraps another input apdater to convert wide character types into individual bytes.}\par
05619 {\cf17 template}<{\cf17 typename} BaseInputAdapter, {\cf17 typename} W{\cf18 id}eCharType>\par
05620 {\cf17 class }wide_string_input_adapter\par
05621 \{\par
05622   {\cf17 public}:\par
05623     {\cf17 using} char_type = char;\par
05624 \par
05625     wide_string_input_adapter(BaseInputAdapter base)\par
05626         : base_adapter(base) \{\}\par
05627 \par
05628     {\cf17 typename} std::char_traits<char>::int_type get_character() noexcept\par
05629     \{\par
05630         {\cf20 // check if buffer needs to be filled}\par
05631         {\cf19 if} (utf8_bytes_index == utf8_bytes_filled)\par
05632         \{\par
05633             fill_buffer<sizeof(WideCharType)>();\par
05634 \par
05635             JSON_ASSERT(utf8_bytes_filled > 0);\par
05636             JSON_ASSERT(utf8_bytes_index == 0);\par
05637         \}\par
05638 \par
05639         {\cf20 // use buffer}\par
05640         JSON_ASSERT(utf8_bytes_filled > 0);\par
05641         JSON_ASSERT(utf8_bytes_index < utf8_bytes_filled);\par
05642         {\cf19 return} utf8_bytes[utf8_bytes_index++];\par
05643     \}\par
05644 \par
05645   {\cf17 private}:\par
05646     BaseInputAdapter base_adapter;\par
05647 \par
05648     {\cf17 template}<{\cf18 size_t} T>\par
05649     {\cf18 void} fill_buffer()\par
05650     \{\par
05651         wide_string_input_helper<BaseInputAdapter, T>::fill_buffer(base_adapter, utf8_bytes, utf8_bytes_index, utf8_bytes_filled);\par
05652     \}\par
05653 \par
05655     std::array<std::char_traits<char>::int_type, 4> utf8_bytes = \{\{0, 0, 0, 0\}\};\par
05656 \par
05658     std::size_t utf8_bytes_index = 0;\par
05660     std::size_t utf8_bytes_filled = 0;\par
05661 \};\par
05662 \par
05663 \par
05664 {\cf17 template}<{\cf17 typename} IteratorType, {\cf17 typename} Enable = {\cf18 void}>\par
05665 {\cf17 struct }iterator_input_adapter_factory\par
05666 \{\par
05667     {\cf17 using} iterator_type = IteratorType;\par
05668     {\cf17 using} char_type = {\cf17 typename} std::iterator_traits<iterator_type>::value_type;\par
05669     {\cf17 using} adapter_type = iterator_input_adapter<iterator_type>;\par
05670 \par
05671     {\cf17 static} adapter_type create(IteratorType first, IteratorType last)\par
05672     \{\par
05673         {\cf19 return} adapter_type(std::move(first), std::move(last));\par
05674     \}\par
05675 \};\par
05676 \par
05677 {\cf17 template}<{\cf17 typename} T>\par
05678 {\cf17 struct }is_iterator_of_multibyte\par
05679 \{\par
05680     {\cf17 using} value_type = {\cf17 typename} std::iterator_traits<T>::value_type;\par
05681     {\cf17 enum}\par
05682     \{\par
05683         value = {\cf17 sizeof}(value_type) > 1\par
05684     \};\par
05685 \};\par
05686 \par
05687 {\cf17 template}<{\cf17 typename} IteratorType>\par
05688 {\cf17 struct }iterator_input_adapter_factory<IteratorType, enable_if_t<is_iterator_of_multibyte<IteratorType>::value>>\par
05689 \{\par
05690     {\cf17 using} iterator_type = IteratorType;\par
05691     {\cf17 using} char_type = {\cf17 typename} std::iterator_traits<iterator_type>::value_type;\par
05692     {\cf17 using} base_adapter_type = iterator_input_adapter<iterator_type>;\par
05693     {\cf17 using} adapter_type = wide_string_input_adapter<base_adapter_type, char_type>;\par
05694 \par
05695     {\cf17 static} adapter_type create(IteratorType first, IteratorType last)\par
05696     \{\par
05697         {\cf19 return} adapter_type(base_adapter_type(std::move(first), std::move(last)));\par
05698     \}\par
05699 \};\par
05700 \par
05701 {\cf20 // General purpose iterator-based input}\par
05702 {\cf17 template}<{\cf17 typename} IteratorType>\par
05703 {\cf17 typename} iterator_input_adapter_factory<IteratorType>::adapter_type input_adapter(IteratorType first, IteratorType last)\par
05704 \{\par
05705     {\cf17 using} factory_type = iterator_input_adapter_factory<IteratorType>;\par
05706     {\cf19 return} factory_type::create(first, last);\par
05707 \}\par
05708 \par
05709 {\cf20 // Convenience shorthand from container to iterator}\par
05710 {\cf20 // Enables ADL on begin(container) and end(container)}\par
05711 {\cf20 // Encloses the using declarations in namespace for not to leak them to outside scope}\par
05712 \par
05713 {\cf17 namespace }container_input_adapter_factory_impl\par
05714 \{\par
05715 \par
05716 {\cf17 using} std::begin;\par
05717 {\cf17 using} std::end;\par
05718 \par
05719 {\cf17 template}<{\cf17 typename} ContainerType, {\cf17 typename} Enable = {\cf18 void}>\par
05720 {\cf17 struct }container_input_adapter_factory \{\};\par
05721 \par
05722 {\cf17 template}<{\cf17 typename} ContainerType>\par
05723 {\cf17 struct }container_input_adapter_factory< ContainerType,\par
05724        void_t<decltype(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>()))>>\par
05725        \{\par
05726            {\cf17 using} adapter_type = {\cf17 decltype}(input_adapter(begin(std::declval<ContainerType>()), end(std::declval<ContainerType>())));\par
05727 \par
05728            {\cf17 static} adapter_type create({\cf17 const} ContainerType& container)\par
05729 \{\par
05730     {\cf19 return} input_adapter(begin(container), end(container));\par
05731 \}\par
05732        \};\par
05733 \par
05734 \} {\cf20 // namespace container_input_adapter_factory_impl}\par
05735 \par
05736 {\cf17 template}<{\cf17 typename} ContainerType>\par
05737 {\cf17 typename} container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::adapter_type input_adapter({\cf17 const} ContainerType& container)\par
05738 \{\par
05739     {\cf19 return} container_input_adapter_factory_impl::container_input_adapter_factory<ContainerType>::create(container);\par
05740 \}\par
05741 \par
05742 {\cf21 #ifndef JSON_NO_IO}\par
05743 {\cf20 // Special cases with fast paths}\par
05744 {\cf17 inline} file_input_adapter input_adapter(std::FILE* file)\par
05745 \{\par
05746     {\cf19 return} file_input_adapter(file);\par
05747 \}\par
05748 \par
05749 {\cf17 inline} input_stream_adapter input_adapter(std::istream& stream)\par
05750 \{\par
05751     {\cf19 return} input_stream_adapter(stream);\par
05752 \}\par
05753 \par
05754 {\cf17 inline} input_stream_adapter input_adapter(std::istream&& stream)\par
05755 \{\par
05756     {\cf19 return} input_stream_adapter(stream);\par
05757 \}\par
05758 {\cf21 #endif  }{\cf20 // JSON_NO_IO}\par
05759 \par
05760 {\cf17 using} contiguous_bytes_input_adapter = {\cf17 decltype}(input_adapter(std::declval<const char*>(), std::declval<const char*>()));\par
05761 \par
05762 {\cf20 // Null-delimited strings, and the like.}\par
05763 {\cf17 template} < {\cf17 typename} CharT,\par
05764            {\cf17 typename} std::enable_if <\par
05765                std::is_pointer<CharT>::value&&\par
05766                !std::is_array<CharT>::value&&\par
05767                std::is_integral<typename std::remove_pointer<CharT>::type>::value&&\par
05768                {\cf17 sizeof}({\cf17 typename} std::remove_pointer<CharT>::type) == 1,\par
05769                {\cf18 int} >::type = 0 >\par
05770 contiguous_bytes_input_adapter input_adapter(CharT b)\par
05771 \{\par
05772     {\cf17 auto} length = std::strlen({\cf17 reinterpret_cast<}{\cf17 const }{\cf18 char}*{\cf17 >}(b));\par
05773     {\cf17 const} {\cf17 auto}* ptr = {\cf17 reinterpret_cast<}{\cf17 const }{\cf18 char}*{\cf17 >}(b);\par
05774     {\cf19 return} input_adapter(ptr, ptr + length);\par
05775 \}\par
05776 \par
05777 {\cf17 template}<{\cf17 typename} T, std::{\cf18 size_t} N>\par
05778 {\cf17 auto} input_adapter(T (&array)[N]) -> {\cf17 decltype}(input_adapter(array, array + N)) {\cf20 // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)}\par
05779 \{\par
05780     {\cf19 return} input_adapter(array, array + N);\par
05781 \}\par
05782 \par
05783 {\cf20 // This class only handles inputs of input_buffer_adapter type.}\par
05784 {\cf20 // It's required so that expressions like \{ptr, len\} can be implicitely casted}\par
05785 {\cf20 // to the correct adapter.}\par
05786 {\cf17 class }span_input_adapter\par
05787 \{\par
05788   {\cf17 public}:\par
05789     {\cf17 template} < {\cf17 typename} CharT,\par
05790                {\cf17 typename} std::enable_if <\par
05791                    std::is_pointer<CharT>::value&&\par
05792                    std::is_integral<typename std::remove_pointer<CharT>::type>::value&&\par
05793                    {\cf17 sizeof}({\cf17 typename} std::remove_pointer<CharT>::type) == 1,\par
05794                    {\cf18 int} >::type = 0 >\par
05795     span_input_adapter(CharT b, std::size_t l)\par
05796         : ia({\cf17 reinterpret_cast<}{\cf17 const }{\cf18 char}*{\cf17 >}(b), {\cf17 reinterpret_cast<}{\cf17 const }{\cf18 char}*{\cf17 >}(b) + l) \{\}\par
05797 \par
05798     {\cf17 template}<{\cf17 class }IteratorType,\par
05799              {\cf17 typename} std::enable_if<\par
05800                  std::is_same<typename iterator_traits<IteratorType>::iterator_category, std::random_access_iterator_tag>::value,\par
05801                  {\cf18 int}>::type = 0>\par
05802     span_input_adapter(IteratorType first, IteratorType last)\par
05803         : ia(input_adapter(first, last)) \{\}\par
05804 \par
05805     contiguous_bytes_input_adapter&& get()\par
05806     \{\par
05807         {\cf19 return} std::move(ia); {\cf20 // NOLINT(hicpp-move-const-arg,performance-move-const-arg)}\par
05808     \}\par
05809 \par
05810   {\cf17 private}:\par
05811     contiguous_bytes_input_adapter ia;\par
05812 \};\par
05813 \}  {\cf20 // namespace detail}\par
05814 \}  {\cf20 // namespace nlohmann}\par
05815 \par
05816 {\cf20 // #include <nlohmann/detail/input/json_sax.hpp>}\par
05817 \par
05818 \par
05819 {\cf21 #include <cstddef>}\par
05820 {\cf21 #include <string>} {\cf20 // string}\par
05821 {\cf21 #include <utility>} {\cf20 // move}\par
05822 {\cf21 #include <vector>} {\cf20 // vector}\par
05823 \par
05824 {\cf20 // #include <nlohmann/detail/exceptions.hpp>}\par
05825 \par
05826 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
05827 \par
05828 \par
05829 {\cf17 namespace }nlohmann\par
05830 \{\par
05831 \par
05840 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
05841 {\cf17 struct }json_sax\par
05842 \{\par
05843     {\cf17 using} number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
05844     {\cf17 using} number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
05845     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
05846     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
05847     {\cf17 using} binary_t = {\cf17 typename} BasicJsonType::binary_t;\par
05848 \par
05853     {\cf17 virtual} {\cf18 bool} {\cf17 null}() = 0;\par
05854 \par
05860     {\cf17 virtual} {\cf18 bool} boolean({\cf18 bool} val) = 0;\par
05861 \par
05867     {\cf17 virtual} {\cf18 bool} number_integer(number_integer_t val) = 0;\par
05868 \par
05874     {\cf17 virtual} {\cf18 bool} number_unsigned(number_unsigned_t val) = 0;\par
05875 \par
05882     {\cf17 virtual} {\cf18 bool} number_float(number_float_t val, {\cf17 const} string_t& s) = 0;\par
05883 \par
05890     {\cf17 virtual} {\cf18 bool} string(string_t& val) = 0;\par
05891 \par
05898     {\cf17 virtual} {\cf18 bool} binary(binary_t& val) = 0;\par
05899 \par
05906     {\cf17 virtual} {\cf18 bool} start_object(std::size_t elements) = 0;\par
05907 \par
05914     {\cf17 virtual} {\cf18 bool} key(string_t& val) = 0;\par
05915 \par
05920     {\cf17 virtual} {\cf18 bool} end_object() = 0;\par
05921 \par
05928     {\cf17 virtual} {\cf18 bool} start_array(std::size_t elements) = 0;\par
05929 \par
05934     {\cf17 virtual} {\cf18 bool} end_array() = 0;\par
05935 \par
05943     {\cf17 virtual} {\cf18 bool} parse_error(std::size_t position,\par
05944                              {\cf17 const} std::string& last_token,\par
05945                              {\cf17 const} detail::exception& ex) = 0;\par
05946 \par
05947     json_sax() = {\cf19 default};\par
05948     json_sax({\cf17 const} json_sax&) = {\cf19 default};\par
05949     json_sax(json_sax&&) noexcept = default;\par
05950     json_sax& operator=(const json_sax&) = default;\par
05951     json_sax& operator=(json_sax&&) noexcept = default;\par
05952     virtual ~json_sax() = default;\par
05953 \};\par
05954 \par
05955 \par
05956 namespace detail\par
05957 \{\par
05971 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
05972 {\cf17 class }json_sax_dom_parser\par
05973 \{\par
05974   {\cf17 public}:\par
05975     {\cf17 using} number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
05976     {\cf17 using} number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
05977     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
05978     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
05979     {\cf17 using} binary_t = {\cf17 typename} BasicJsonType::binary_t;\par
05980 \par
05986     {\cf17 explicit} json_sax_dom_parser(BasicJsonType& r, {\cf17 const} {\cf18 bool} allow_exceptions_ = {\cf17 true})\par
05987         : root(r), allow_exceptions(allow_exceptions_)\par
05988     \{\}\par
05989 \par
05990     {\cf20 // make class move-only}\par
05991     json_sax_dom_parser({\cf17 const} json_sax_dom_parser&) = {\cf17 delete};\par
05992     json_sax_dom_parser(json_sax_dom_parser&&) = {\cf19 default}; {\cf20 // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)}\par
05993     json_sax_dom_parser& operator=({\cf17 const} json_sax_dom_parser&) = {\cf17 delete};\par
05994     json_sax_dom_parser& operator=(json_sax_dom_parser&&) = {\cf19 default}; {\cf20 // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)}\par
05995     ~json_sax_dom_parser() = {\cf19 default};\par
05996 \par
05997     {\cf18 bool} {\cf17 null}()\par
05998     \{\par
05999         handle_value({\cf17 nullptr});\par
06000         {\cf19 return} {\cf17 true};\par
06001     \}\par
06002 \par
06003     {\cf18 bool} boolean({\cf18 bool} val)\par
06004     \{\par
06005         handle_value(val);\par
06006         {\cf19 return} {\cf17 true};\par
06007     \}\par
06008 \par
06009     {\cf18 bool} number_integer(number_integer_t val)\par
06010     \{\par
06011         handle_value(val);\par
06012         {\cf19 return} {\cf17 true};\par
06013     \}\par
06014 \par
06015     {\cf18 bool} number_unsigned(number_unsigned_t val)\par
06016     \{\par
06017         handle_value(val);\par
06018         {\cf19 return} {\cf17 true};\par
06019     \}\par
06020 \par
06021     {\cf18 bool} number_float(number_float_t val, {\cf17 const} string_t& {\cf20 /*unused*/})\par
06022     \{\par
06023         handle_value(val);\par
06024         {\cf19 return} {\cf17 true};\par
06025     \}\par
06026 \par
06027     {\cf18 bool} string(string_t& val)\par
06028     \{\par
06029         handle_value(val);\par
06030         {\cf19 return} {\cf17 true};\par
06031     \}\par
06032 \par
06033     {\cf18 bool} binary(binary_t& val)\par
06034     \{\par
06035         handle_value(std::move(val));\par
06036         {\cf19 return} {\cf17 true};\par
06037     \}\par
06038 \par
06039     {\cf18 bool} start_object(std::size_t len)\par
06040     \{\par
06041         ref_stack.push_back(handle_value(BasicJsonType::value_t::object));\par
06042 \par
06043         {\cf19 if} (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))\par
06044         \{\par
06045             JSON_THROW(out_of_range::create(408, {\cf22 "excessive object size: "} + std::to_string(len), *ref_stack.back()));\par
06046         \}\par
06047 \par
06048         {\cf19 return} {\cf17 true};\par
06049     \}\par
06050 \par
06051     {\cf18 bool} key(string_t& val)\par
06052     \{\par
06053         {\cf20 // add null at given key and store the reference for later}\par
06054         object_element = &(ref_stack.back()->m_value.object->operator[](val));\par
06055         {\cf19 return} {\cf17 true};\par
06056     \}\par
06057 \par
06058     {\cf18 bool} end_object()\par
06059     \{\par
06060         ref_stack.back()->set_parents();\par
06061         ref_stack.pop_back();\par
06062         {\cf19 return} {\cf17 true};\par
06063     \}\par
06064 \par
06065     {\cf18 bool} start_array(std::size_t len)\par
06066     \{\par
06067         ref_stack.push_back(handle_value(BasicJsonType::value_t::array));\par
06068 \par
06069         {\cf19 if} (JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))\par
06070         \{\par
06071             JSON_THROW(out_of_range::create(408, {\cf22 "excessive array size: "} + std::to_string(len), *ref_stack.back()));\par
06072         \}\par
06073 \par
06074         {\cf19 return} {\cf17 true};\par
06075     \}\par
06076 \par
06077     {\cf18 bool} end_array()\par
06078     \{\par
06079         ref_stack.back()->set_parents();\par
06080         ref_stack.pop_back();\par
06081         {\cf19 return} {\cf17 true};\par
06082     \}\par
06083 \par
06084     {\cf17 template}<{\cf17 class} Exception>\par
06085     {\cf18 bool} parse_error(std::size_t {\cf20 /*unused*/}, {\cf17 const} std::string& {\cf20 /*unused*/},\par
06086                      {\cf17 const} Exception& ex)\par
06087     \{\par
06088         errored = {\cf17 true};\par
06089         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(ex);\par
06090         {\cf19 if} (allow_exceptions)\par
06091         \{\par
06092             JSON_THROW(ex);\par
06093         \}\par
06094         {\cf19 return} {\cf17 false};\par
06095     \}\par
06096 \par
06097     {\cf17 constexpr} {\cf18 bool} is_errored(){\cf17  const}\par
06098 {\cf17     }\{\par
06099         {\cf19 return} errored;\par
06100     \}\par
06101 \par
06102   {\cf17 private}:\par
06109     {\cf17 template}<{\cf17 typename} Value>\par
06110     JSON_HEDLEY_RETURNS_NON_NULL\par
06111     BasicJsonType* handle_value(Value&& v)\par
06112     \{\par
06113         {\cf19 if} (ref_stack.empty())\par
06114         \{\par
06115             root = BasicJsonType(std::forward<Value>(v));\par
06116             {\cf19 return} &root;\par
06117         \}\par
06118 \par
06119         JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());\par
06120 \par
06121         {\cf19 if} (ref_stack.back()->is_array())\par
06122         \{\par
06123             ref_stack.back()->m_value.array->emplace_back(std::forward<Value>(v));\par
06124             {\cf19 return} &(ref_stack.back()->m_value.array->back());\par
06125         \}\par
06126 \par
06127         JSON_ASSERT(ref_stack.back()->is_object());\par
06128         JSON_ASSERT(object_element);\par
06129         *object_element = BasicJsonType(std::forward<Value>(v));\par
06130         {\cf19 return} object_element;\par
06131     \}\par
06132 \par
06134     BasicJsonType& root;\par
06136     std::vector<BasicJsonType*> ref_stack \{\};\par
06138     BasicJsonType* object_element = {\cf17 nullptr};\par
06140     {\cf18 bool} errored = {\cf17 false};\par
06142     {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true};\par
06143 \};\par
06144 \par
06145 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
06146 {\cf17 class }json_sax_dom_callback_parser\par
06147 \{\par
06148   {\cf17 public}:\par
06149     {\cf17 using} number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
06150     {\cf17 using} number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
06151     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
06152     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
06153     {\cf17 using} binary_t = {\cf17 typename} BasicJsonType::binary_t;\par
06154     {\cf17 using} parser_callback_t = {\cf17 typename} BasicJsonType::parser_callback_t;\par
06155     {\cf17 using} parse_event_t = {\cf17 typename} BasicJsonType::parse_event_t;\par
06156 \par
06157     json_sax_dom_callback_parser(BasicJsonType& r,\par
06158                                  {\cf17 const} parser_callback_t cb,\par
06159                                  {\cf17 const} {\cf18 bool} allow_exceptions_ = {\cf17 true})\par
06160         : root(r), callback(cb), allow_exceptions(allow_exceptions_)\par
06161     \{\par
06162         keep_stack.push_back({\cf17 true});\par
06163     \}\par
06164 \par
06165     {\cf20 // make class move-only}\par
06166     json_sax_dom_callback_parser({\cf17 const} json_sax_dom_callback_parser&) = {\cf17 delete};\par
06167     json_sax_dom_callback_parser(json_sax_dom_callback_parser&&) = {\cf19 default}; {\cf20 // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)}\par
06168     json_sax_dom_callback_parser& operator=({\cf17 const} json_sax_dom_callback_parser&) = {\cf17 delete};\par
06169     json_sax_dom_callback_parser& operator=(json_sax_dom_callback_parser&&) = {\cf19 default}; {\cf20 // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)}\par
06170     ~json_sax_dom_callback_parser() = {\cf19 default};\par
06171 \par
06172     {\cf18 bool} {\cf17 null}()\par
06173     \{\par
06174         handle_value({\cf17 nullptr});\par
06175         {\cf19 return} {\cf17 true};\par
06176     \}\par
06177 \par
06178     {\cf18 bool} boolean({\cf18 bool} val)\par
06179     \{\par
06180         handle_value(val);\par
06181         {\cf19 return} {\cf17 true};\par
06182     \}\par
06183 \par
06184     {\cf18 bool} number_integer(number_integer_t val)\par
06185     \{\par
06186         handle_value(val);\par
06187         {\cf19 return} {\cf17 true};\par
06188     \}\par
06189 \par
06190     {\cf18 bool} number_unsigned(number_unsigned_t val)\par
06191     \{\par
06192         handle_value(val);\par
06193         {\cf19 return} {\cf17 true};\par
06194     \}\par
06195 \par
06196     {\cf18 bool} number_float(number_float_t val, {\cf17 const} string_t& {\cf20 /*unused*/})\par
06197     \{\par
06198         handle_value(val);\par
06199         {\cf19 return} {\cf17 true};\par
06200     \}\par
06201 \par
06202     {\cf18 bool} string(string_t& val)\par
06203     \{\par
06204         handle_value(val);\par
06205         {\cf19 return} {\cf17 true};\par
06206     \}\par
06207 \par
06208     {\cf18 bool} binary(binary_t& val)\par
06209     \{\par
06210         handle_value(std::move(val));\par
06211         {\cf19 return} {\cf17 true};\par
06212     \}\par
06213 \par
06214     {\cf18 bool} start_object(std::size_t len)\par
06215     \{\par
06216         {\cf20 // check callback for object start}\par
06217         {\cf17 const} {\cf18 bool} keep = callback({\cf17 static_cast<}{\cf18 int}{\cf17 >}(ref_stack.size()), parse_event_t::object_start, discarded);\par
06218         keep_stack.push_back(keep);\par
06219 \par
06220         {\cf17 auto} val = handle_value(BasicJsonType::value_t::object, {\cf17 true});\par
06221         ref_stack.push_back(val.second);\par
06222 \par
06223         {\cf20 // check object limit}\par
06224         {\cf19 if} (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))\par
06225         \{\par
06226             JSON_THROW(out_of_range::create(408, {\cf22 "excessive object size: "} + std::to_string(len), *ref_stack.back()));\par
06227         \}\par
06228 \par
06229         {\cf19 return} {\cf17 true};\par
06230     \}\par
06231 \par
06232     {\cf18 bool} key(string_t& val)\par
06233     \{\par
06234         BasicJsonType k = BasicJsonType(val);\par
06235 \par
06236         {\cf20 // check callback for key}\par
06237         {\cf17 const} {\cf18 bool} keep = callback({\cf17 static_cast<}{\cf18 int}{\cf17 >}(ref_stack.size()), parse_event_t::key, k);\par
06238         key_keep_stack.push_back(keep);\par
06239 \par
06240         {\cf20 // add discarded value at given key and store the reference for later}\par
06241         {\cf19 if} (keep && ref_stack.back())\par
06242         \{\par
06243             object_element = &(ref_stack.back()->m_value.object->operator[](val) = discarded);\par
06244         \}\par
06245 \par
06246         {\cf19 return} {\cf17 true};\par
06247     \}\par
06248 \par
06249     {\cf18 bool} end_object()\par
06250     \{\par
06251         {\cf19 if} (ref_stack.back())\par
06252         \{\par
06253             {\cf19 if} (!callback({\cf17 static_cast<}{\cf18 int}{\cf17 >}(ref_stack.size()) - 1, parse_event_t::object_end, *ref_stack.back()))\par
06254             \{\par
06255                 {\cf20 // discard object}\par
06256                 *ref_stack.back() = discarded;\par
06257             \}\par
06258             {\cf19 else}\par
06259             \{\par
06260                 ref_stack.back()->set_parents();\par
06261             \}\par
06262         \}\par
06263 \par
06264         JSON_ASSERT(!ref_stack.empty());\par
06265         JSON_ASSERT(!keep_stack.empty());\par
06266         ref_stack.pop_back();\par
06267         keep_stack.pop_back();\par
06268 \par
06269         {\cf19 if} (!ref_stack.empty() && ref_stack.back() && ref_stack.back()->is_structured())\par
06270         \{\par
06271             {\cf20 // remove discarded value}\par
06272             {\cf19 for} ({\cf17 auto} it = ref_stack.back()->begin(); it != ref_stack.back()->end(); ++it)\par
06273             \{\par
06274                 {\cf19 if} (it->is_discarded())\par
06275                 \{\par
06276                     ref_stack.back()->erase(it);\par
06277                     {\cf19 break};\par
06278                 \}\par
06279             \}\par
06280         \}\par
06281 \par
06282         {\cf19 return} {\cf17 true};\par
06283     \}\par
06284 \par
06285     {\cf18 bool} start_array(std::size_t len)\par
06286     \{\par
06287         {\cf17 const} {\cf18 bool} keep = callback({\cf17 static_cast<}{\cf18 int}{\cf17 >}(ref_stack.size()), parse_event_t::array_start, discarded);\par
06288         keep_stack.push_back(keep);\par
06289 \par
06290         {\cf17 auto} val = handle_value(BasicJsonType::value_t::array, {\cf17 true});\par
06291         ref_stack.push_back(val.second);\par
06292 \par
06293         {\cf20 // check array limit}\par
06294         {\cf19 if} (ref_stack.back() && JSON_HEDLEY_UNLIKELY(len != std::size_t(-1) && len > ref_stack.back()->max_size()))\par
06295         \{\par
06296             JSON_THROW(out_of_range::create(408, {\cf22 "excessive array size: "} + std::to_string(len), *ref_stack.back()));\par
06297         \}\par
06298 \par
06299         {\cf19 return} {\cf17 true};\par
06300     \}\par
06301 \par
06302     {\cf18 bool} end_array()\par
06303     \{\par
06304         {\cf18 bool} keep = {\cf17 true};\par
06305 \par
06306         {\cf19 if} (ref_stack.back())\par
06307         \{\par
06308             keep = callback({\cf17 static_cast<}{\cf18 int}{\cf17 >}(ref_stack.size()) - 1, parse_event_t::array_end, *ref_stack.back());\par
06309             {\cf19 if} (keep)\par
06310             \{\par
06311                 ref_stack.back()->set_parents();\par
06312             \}\par
06313             {\cf19 else}\par
06314             \{\par
06315                 {\cf20 // discard array}\par
06316                 *ref_stack.back() = discarded;\par
06317             \}\par
06318         \}\par
06319 \par
06320         JSON_ASSERT(!ref_stack.empty());\par
06321         JSON_ASSERT(!keep_stack.empty());\par
06322         ref_stack.pop_back();\par
06323         keep_stack.pop_back();\par
06324 \par
06325         {\cf20 // remove discarded value}\par
06326         {\cf19 if} (!keep && !ref_stack.empty() && ref_stack.back()->is_array())\par
06327         \{\par
06328             ref_stack.back()->m_value.array->pop_back();\par
06329         \}\par
06330 \par
06331         {\cf19 return} {\cf17 true};\par
06332     \}\par
06333 \par
06334     {\cf17 template}<{\cf17 class} Exception>\par
06335     {\cf18 bool} parse_error(std::size_t {\cf20 /*unused*/}, {\cf17 const} std::string& {\cf20 /*unused*/},\par
06336                      {\cf17 const} Exception& ex)\par
06337     \{\par
06338         errored = {\cf17 true};\par
06339         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(ex);\par
06340         {\cf19 if} (allow_exceptions)\par
06341         \{\par
06342             JSON_THROW(ex);\par
06343         \}\par
06344         {\cf19 return} {\cf17 false};\par
06345     \}\par
06346 \par
06347     {\cf17 constexpr} {\cf18 bool} is_errored(){\cf17  const}\par
06348 {\cf17     }\{\par
06349         {\cf19 return} errored;\par
06350     \}\par
06351 \par
06352   {\cf17 private}:\par
06368     {\cf17 template}<{\cf17 typename} Value>\par
06369     std::pair<bool, BasicJsonType*> handle_value(Value&& v, {\cf17 const} {\cf18 bool} skip_callback = {\cf17 false})\par
06370     \{\par
06371         JSON_ASSERT(!keep_stack.empty());\par
06372 \par
06373         {\cf20 // do not handle this value if we know it would be added to a discarded}\par
06374         {\cf20 // container}\par
06375         {\cf19 if} (!keep_stack.back())\par
06376         \{\par
06377             {\cf19 return} \{{\cf17 false}, {\cf17 nullptr}\};\par
06378         \}\par
06379 \par
06380         {\cf20 // create value}\par
06381         {\cf17 auto} value = BasicJsonType(std::forward<Value>(v));\par
06382 \par
06383         {\cf20 // check callback}\par
06384         {\cf17 const} {\cf18 bool} keep = skip_callback || callback({\cf17 static_cast<}{\cf18 int}{\cf17 >}(ref_stack.size()), parse_event_t::value, value);\par
06385 \par
06386         {\cf20 // do not handle this value if we just learnt it shall be discarded}\par
06387         {\cf19 if} (!keep)\par
06388         \{\par
06389             {\cf19 return} \{{\cf17 false}, {\cf17 nullptr}\};\par
06390         \}\par
06391 \par
06392         {\cf19 if} (ref_stack.empty())\par
06393         \{\par
06394             root = std::move(value);\par
06395             {\cf19 return} \{{\cf17 true}, &root\};\par
06396         \}\par
06397 \par
06398         {\cf20 // skip this value if we already decided to skip the parent}\par
06399         {\cf20 // (https://github.com/nlohmann/json/issues/971#issuecomment-413678360)}\par
06400         {\cf19 if} (!ref_stack.back())\par
06401         \{\par
06402             {\cf19 return} \{{\cf17 false}, {\cf17 nullptr}\};\par
06403         \}\par
06404 \par
06405         {\cf20 // we now only expect arrays and objects}\par
06406         JSON_ASSERT(ref_stack.back()->is_array() || ref_stack.back()->is_object());\par
06407 \par
06408         {\cf20 // array}\par
06409         {\cf19 if} (ref_stack.back()->is_array())\par
06410         \{\par
06411             ref_stack.back()->m_value.array->emplace_back(std::move(value));\par
06412             {\cf19 return} \{{\cf17 true}, &(ref_stack.back()->m_value.array->back())\};\par
06413         \}\par
06414 \par
06415         {\cf20 // object}\par
06416         JSON_ASSERT(ref_stack.back()->is_object());\par
06417         {\cf20 // check if we should store an element for the current key}\par
06418         JSON_ASSERT(!key_keep_stack.empty());\par
06419         {\cf17 const} {\cf18 bool} store_element = key_keep_stack.back();\par
06420         key_keep_stack.pop_back();\par
06421 \par
06422         {\cf19 if} (!store_element)\par
06423         \{\par
06424             {\cf19 return} \{{\cf17 false}, {\cf17 nullptr}\};\par
06425         \}\par
06426 \par
06427         JSON_ASSERT(object_element);\par
06428         *object_element = std::move(value);\par
06429         {\cf19 return} \{{\cf17 true}, object_element\};\par
06430     \}\par
06431 \par
06433     BasicJsonType& root;\par
06435     std::vector<BasicJsonType*> ref_stack \{\};\par
06437     std::vector<bool> keep_stack \{\};\par
06439     std::vector<bool> key_keep_stack \{\};\par
06441     BasicJsonType* object_element = {\cf17 nullptr};\par
06443     {\cf18 bool} errored = {\cf17 false};\par
06445     {\cf17 const} parser_callback_t callback = {\cf17 nullptr};\par
06447     {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true};\par
06449     BasicJsonType discarded = BasicJsonType::value_t::discarded;\par
06450 \};\par
06451 \par
06452 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
06453 {\cf17 class }json_sax_acceptor\par
06454 \{\par
06455   {\cf17 public}:\par
06456     {\cf17 using} number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
06457     {\cf17 using} number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
06458     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
06459     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
06460     {\cf17 using} binary_t = {\cf17 typename} BasicJsonType::binary_t;\par
06461 \par
06462     {\cf18 bool} {\cf17 null}()\par
06463     \{\par
06464         {\cf19 return} {\cf17 true};\par
06465     \}\par
06466 \par
06467     {\cf18 bool} boolean({\cf18 bool} {\cf20 /*unused*/})\par
06468     \{\par
06469         {\cf19 return} {\cf17 true};\par
06470     \}\par
06471 \par
06472     {\cf18 bool} number_integer(number_integer_t {\cf20 /*unused*/})\par
06473     \{\par
06474         {\cf19 return} {\cf17 true};\par
06475     \}\par
06476 \par
06477     {\cf18 bool} number_unsigned(number_unsigned_t {\cf20 /*unused*/})\par
06478     \{\par
06479         {\cf19 return} {\cf17 true};\par
06480     \}\par
06481 \par
06482     {\cf18 bool} number_float(number_float_t {\cf20 /*unused*/}, {\cf17 const} string_t& {\cf20 /*unused*/})\par
06483     \{\par
06484         {\cf19 return} {\cf17 true};\par
06485     \}\par
06486 \par
06487     {\cf18 bool} string(string_t& {\cf20 /*unused*/})\par
06488     \{\par
06489         {\cf19 return} {\cf17 true};\par
06490     \}\par
06491 \par
06492     {\cf18 bool} binary(binary_t& {\cf20 /*unused*/})\par
06493     \{\par
06494         {\cf19 return} {\cf17 true};\par
06495     \}\par
06496 \par
06497     {\cf18 bool} start_object(std::size_t {\cf20 /*unused*/} = std::size_t(-1))\par
06498     \{\par
06499         {\cf19 return} {\cf17 true};\par
06500     \}\par
06501 \par
06502     {\cf18 bool} key(string_t& {\cf20 /*unused*/})\par
06503     \{\par
06504         {\cf19 return} {\cf17 true};\par
06505     \}\par
06506 \par
06507     {\cf18 bool} end_object()\par
06508     \{\par
06509         {\cf19 return} {\cf17 true};\par
06510     \}\par
06511 \par
06512     {\cf18 bool} start_array(std::size_t {\cf20 /*unused*/} = std::size_t(-1))\par
06513     \{\par
06514         {\cf19 return} {\cf17 true};\par
06515     \}\par
06516 \par
06517     {\cf18 bool} end_array()\par
06518     \{\par
06519         {\cf19 return} {\cf17 true};\par
06520     \}\par
06521 \par
06522     {\cf18 bool} parse_error(std::size_t {\cf20 /*unused*/}, {\cf17 const} std::string& {\cf20 /*unused*/}, {\cf17 const} detail::exception& {\cf20 /*unused*/})\par
06523     \{\par
06524         {\cf19 return} {\cf17 false};\par
06525     \}\par
06526 \};\par
06527 \}  {\cf20 // namespace detail}\par
06528 \par
06529 \}  {\cf20 // namespace nlohmann}\par
06530 \par
06531 {\cf20 // #include <nlohmann/detail/input/lexer.hpp>}\par
06532 \par
06533 \par
06534 {\cf21 #include <array>} {\cf20 // array}\par
06535 {\cf21 #include <clocale>} {\cf20 // localeconv}\par
06536 {\cf21 #include <cstddef>} {\cf20 // size_t}\par
06537 {\cf21 #include <cstdio>} {\cf20 // snprintf}\par
06538 {\cf21 #include <cstdlib>} {\cf20 // strtof, strtod, strtold, strtoll, strtoull}\par
06539 {\cf21 #include <initializer_list>} {\cf20 // initializer_list}\par
06540 {\cf21 #include <string>} {\cf20 // char_traits, string}\par
06541 {\cf21 #include <utility>} {\cf20 // move}\par
06542 {\cf21 #include <vector>} {\cf20 // vector}\par
06543 \par
06544 {\cf20 // #include <nlohmann/detail/input/input_adapters.hpp>}\par
06545 \par
06546 {\cf20 // #include <nlohmann/detail/input/position_t.hpp>}\par
06547 \par
06548 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
06549 \par
06550 \par
06551 {\cf17 namespace }nlohmann\par
06552 \{\par
06553 {\cf17 namespace }detail\par
06554 \{\par
06556 {\cf20 // lexer //}\par
06558 {\cf20 }\par
06559 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
06560 {\cf17 class }lexer_base\par
06561 \{\par
06562   {\cf17 public}:\par
06564     {\cf17 enum class} token_type\par
06565     \{\par
06566         uninitialized,    \par
06567         literal_true,     \par
06568         literal_false,    \par
06569         literal_null,     \par
06570         value_string,     \par
06571         value_unsigned,   \par
06572         value_integer,    \par
06573         value_float,      \par
06574         begin_array,      \par
06575         begin_object,     \par
06576         end_array,        \par
06577         end_object,       \par
06578         name_separator,   \par
06579         value_separator,  \par
06580         parse_error,      \par
06581         end_of_input,     \par
06582         literal_or_value  \par
06583     \};\par
06584 \par
06586     JSON_HEDLEY_RETURNS_NON_NULL\par
06587     JSON_HEDLEY_CONST\par
06588     {\cf17 static} {\cf17 const} {\cf18 char}* token_type_name({\cf17 const} token_type t) {\cf17 noexcept}\par
06589     \{\par
06590         {\cf19 switch} (t)\par
06591         \{\par
06592             {\cf19 case} token_type::uninitialized:\par
06593                 {\cf19 return} {\cf22 "<uninitialized>"};\par
06594             {\cf19 case} token_type::literal_true:\par
06595                 {\cf19 return} {\cf22 "true literal"};\par
06596             {\cf19 case} token_type::literal_false:\par
06597                 {\cf19 return} {\cf22 "false literal"};\par
06598             {\cf19 case} token_type::literal_null:\par
06599                 {\cf19 return} {\cf22 "null literal"};\par
06600             {\cf19 case} token_type::value_string:\par
06601                 {\cf19 return} {\cf22 "string literal"};\par
06602             {\cf19 case} token_type::value_unsigned:\par
06603             {\cf19 case} token_type::value_integer:\par
06604             {\cf19 case} token_type::value_float:\par
06605                 {\cf19 return} {\cf22 "number literal"};\par
06606             {\cf19 case} token_type::begin_array:\par
06607                 {\cf19 return} {\cf22 "'['"};\par
06608             {\cf19 case} token_type::begin_object:\par
06609                 {\cf19 return} {\cf22 "'\{'"};\par
06610             {\cf19 case} token_type::end_array:\par
06611                 {\cf19 return} {\cf22 "']'"};\par
06612             {\cf19 case} token_type::end_object:\par
06613                 {\cf19 return} {\cf22 "'\}'"};\par
06614             {\cf19 case} token_type::name_separator:\par
06615                 {\cf19 return} {\cf22 "':'"};\par
06616             {\cf19 case} token_type::value_separator:\par
06617                 {\cf19 return} {\cf22 "','"};\par
06618             {\cf19 case} token_type::parse_error:\par
06619                 {\cf19 return} {\cf22 "<parse error>"};\par
06620             {\cf19 case} token_type::end_of_input:\par
06621                 {\cf19 return} {\cf22 "end of input"};\par
06622             {\cf19 case} token_type::literal_or_value:\par
06623                 {\cf19 return} {\cf22 "'[', '\{', or a literal"};\par
06624             {\cf20 // LCOV_EXCL_START}\par
06625             {\cf19 default}: {\cf20 // catch non-enum values}\par
06626                 {\cf19 return} {\cf22 "unknown token"};\par
06627                 {\cf20 // LCOV_EXCL_STOP}\par
06628         \}\par
06629     \}\par
06630 \};\par
06636 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} InputAdapterType>\par
06637 {\cf17 class }lexer : {\cf17 public} lexer_base<BasicJsonType>\par
06638 \{\par
06639     {\cf17 using} number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
06640     {\cf17 using} number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
06641     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
06642     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
06643     {\cf17 using} char_type = {\cf17 typename} InputAdapterType::char_type;\par
06644     {\cf17 using} char_int_type = {\cf17 typename} std::char_traits<char_type>::int_type;\par
06645 \par
06646   {\cf17 public}:\par
06647     {\cf17 using} token_type = {\cf17 typename} lexer_base<BasicJsonType>::token_type;\par
06648 \par
06649     {\cf17 explicit} lexer(InputAdapterType&& adapter, {\cf18 bool} ignore_comments_ = {\cf17 false}) noexcept\par
06650         : ia(std::move(adapter))\par
06651         , ignore_comments(ignore_comments_)\par
06652         , decimal_point_char(static_cast<char_int_type>(get_decimal_point()))\par
06653     \{\}\par
06654 \par
06655     {\cf20 // delete because of pointer members}\par
06656     lexer({\cf17 const} lexer&) = {\cf17 delete};\par
06657     lexer(lexer&&) = {\cf19 default}; {\cf20 // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)}\par
06658     lexer& operator=(lexer&) = {\cf17 delete};\par
06659     lexer& operator=(lexer&&) = {\cf19 default}; {\cf20 // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)}\par
06660     ~lexer() = {\cf19 default};\par
06661 \par
06662   {\cf17 private}:\par
06664     {\cf20 // locales}\par
06666 {\cf20 }\par
06668     JSON_HEDLEY_PURE\par
06669     {\cf17 static} {\cf18 char} get_decimal_point() noexcept\par
06670     \{\par
06671         {\cf17 const} {\cf17 auto}* loc = localeconv();\par
06672         JSON_ASSERT(loc != {\cf17 nullptr});\par
06673         {\cf19 return} (loc->decimal_point == {\cf17 nullptr}) ? {\cf23 '.'} : *(loc->decimal_point);\par
06674     \}\par
06675 \par
06677     {\cf20 // scan functions}\par
06679 {\cf20 }\par
06695     {\cf18 int} get_codepoint()\par
06696     \{\par
06697         {\cf20 // this function only makes sense after reading `\\u`}\par
06698         JSON_ASSERT(current == {\cf23 'u'});\par
06699         {\cf18 int} codepoint = 0;\par
06700 \par
06701         {\cf17 const} {\cf17 auto} factors = \{ 12u, 8u, 4u, 0u \};\par
06702         {\cf19 for} ({\cf17 const} {\cf17 auto} factor : factors)\par
06703         \{\par
06704             get();\par
06705 \par
06706             {\cf19 if} (current >= {\cf23 '0'} && current <= {\cf23 '9'})\par
06707             \{\par
06708                 codepoint += {\cf17 static_cast<}{\cf18 int}{\cf17 >}(({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(current) - 0x30u) << factor);\par
06709             \}\par
06710             {\cf19 else} {\cf19 if} (current >= {\cf23 'A'} && current <= {\cf23 'F'})\par
06711             \{\par
06712                 codepoint += {\cf17 static_cast<}{\cf18 int}{\cf17 >}(({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(current) - 0x37u) << factor);\par
06713             \}\par
06714             {\cf19 else} {\cf19 if} (current >= {\cf23 'a'} && current <= {\cf23 'f'})\par
06715             \{\par
06716                 codepoint += {\cf17 static_cast<}{\cf18 int}{\cf17 >}(({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(current) - 0x57u) << factor);\par
06717             \}\par
06718             {\cf19 else}\par
06719             \{\par
06720                 {\cf19 return} -1;\par
06721             \}\par
06722         \}\par
06723 \par
06724         JSON_ASSERT(0x0000 <= codepoint && codepoint <= 0xFFFF);\par
06725         {\cf19 return} codepoint;\par
06726     \}\par
06727 \par
06743     {\cf18 bool} next_byte_in_range(std::initializer_list<char_int_type> ranges)\par
06744     \{\par
06745         JSON_ASSERT(ranges.size() == 2 || ranges.size() == 4 || ranges.size() == 6);\par
06746         add(current);\par
06747 \par
06748         {\cf19 for} ({\cf17 auto} range = ranges.begin(); range != ranges.end(); ++range)\par
06749         \{\par
06750             get();\par
06751             {\cf19 if} (JSON_HEDLEY_LIKELY(*range <= current && current <= *(++range)))\par
06752             \{\par
06753                 add(current);\par
06754             \}\par
06755             {\cf19 else}\par
06756             \{\par
06757                 error_message = {\cf22 "invalid string: ill-formed UTF-8 byte"};\par
06758                 {\cf19 return} {\cf17 false};\par
06759             \}\par
06760         \}\par
06761 \par
06762         {\cf19 return} {\cf17 true};\par
06763     \}\par
06764 \par
06780     token_type scan_string()\par
06781     \{\par
06782         {\cf20 // reset token_buffer (ignore opening quote)}\par
06783         reset();\par
06784 \par
06785         {\cf20 // we entered the function by reading an open quote}\par
06786         JSON_ASSERT(current == {\cf23 '\\"'});\par
06787 \par
06788         {\cf19 while} ({\cf17 true})\par
06789         \{\par
06790             {\cf20 // get next character}\par
06791             {\cf19 switch} (get())\par
06792             \{\par
06793                 {\cf20 // end of file while parsing string}\par
06794                 {\cf19 case} std::char_traits<char_type>::eof():\par
06795                 \{\par
06796                     error_message = {\cf22 "invalid string: missing closing quote"};\par
06797                     {\cf19 return} token_type::parse_error;\par
06798                 \}\par
06799 \par
06800                 {\cf20 // closing quote}\par
06801                 {\cf19 case} {\cf23 '\\"'}:\par
06802                 \{\par
06803                     {\cf19 return} token_type::value_string;\par
06804                 \}\par
06805 \par
06806                 {\cf20 // escapes}\par
06807                 {\cf19 case} {\cf23 '\\\\'}:\par
06808                 \{\par
06809                     {\cf19 switch} (get())\par
06810                     \{\par
06811                         {\cf20 // quotation mark}\par
06812                         {\cf19 case} {\cf23 '\\"'}:\par
06813                             add({\cf23 '\\"'});\par
06814                             {\cf19 break};\par
06815                         {\cf20 // reverse solidus}\par
06816                         {\cf19 case} {\cf23 '\\\\'}:\par
06817                             add({\cf23 '\\\\'});\par
06818                             {\cf19 break};\par
06819                         {\cf20 // solidus}\par
06820                         {\cf19 case} {\cf23 '/'}:\par
06821                             add({\cf23 '/'});\par
06822                             {\cf19 break};\par
06823                         {\cf20 // backspace}\par
06824                         {\cf19 case} {\cf23 'b'}:\par
06825                             add({\cf23 '\\b'});\par
06826                             {\cf19 break};\par
06827                         {\cf20 // form feed}\par
06828                         {\cf19 case} {\cf23 'f'}:\par
06829                             add({\cf23 '\\f'});\par
06830                             {\cf19 break};\par
06831                         {\cf20 // line feed}\par
06832                         {\cf19 case} {\cf23 'n'}:\par
06833                             add({\cf23 '\\n'});\par
06834                             {\cf19 break};\par
06835                         {\cf20 // carriage return}\par
06836                         {\cf19 case} {\cf23 'r'}:\par
06837                             add({\cf23 '\\r'});\par
06838                             {\cf19 break};\par
06839                         {\cf20 // tab}\par
06840                         {\cf19 case} {\cf23 't'}:\par
06841                             add({\cf23 '\\t'});\par
06842                             {\cf19 break};\par
06843 \par
06844                         {\cf20 // unicode escapes}\par
06845                         {\cf19 case} {\cf23 'u'}:\par
06846                         \{\par
06847                             {\cf17 const} {\cf18 int} codepoint1 = get_codepoint();\par
06848                             {\cf18 int} codepoint = codepoint1; {\cf20 // start with codepoint1}\par
06849 \par
06850                             {\cf19 if} (JSON_HEDLEY_UNLIKELY(codepoint1 == -1))\par
06851                             \{\par
06852                                 error_message = {\cf22 "invalid string: '\\\\u' must be followed by 4 hex digits"};\par
06853                                 {\cf19 return} token_type::parse_error;\par
06854                             \}\par
06855 \par
06856                             {\cf20 // check if code point is a high surrogate}\par
06857                             {\cf19 if} (0xD800 <= codepoint1 && codepoint1 <= 0xDBFF)\par
06858                             \{\par
06859                                 {\cf20 // expect next \\uxxxx entry}\par
06860                                 {\cf19 if} (JSON_HEDLEY_LIKELY(get() == {\cf23 '\\\\'} && get() == {\cf23 'u'}))\par
06861                                 \{\par
06862                                     {\cf17 const} {\cf18 int} codepoint2 = get_codepoint();\par
06863 \par
06864                                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(codepoint2 == -1))\par
06865                                     \{\par
06866                                         error_message = {\cf22 "invalid string: '\\\\u' must be followed by 4 hex digits"};\par
06867                                         {\cf19 return} token_type::parse_error;\par
06868                                     \}\par
06869 \par
06870                                     {\cf20 // check if codepoint2 is a low surrogate}\par
06871                                     {\cf19 if} (JSON_HEDLEY_LIKELY(0xDC00 <= codepoint2 && codepoint2 <= 0xDFFF))\par
06872                                     \{\par
06873                                         {\cf20 // overwrite codepoint}\par
06874                                         codepoint = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(\par
06875                                                         {\cf20 // high surrogate occupies the most significant 22 bits}\par
06876                                                         ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(codepoint1) << 10u)\par
06877                                                         {\cf20 // low surrogate occupies the least significant 15 bits}\par
06878                                                         + {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(codepoint2)\par
06879                                                         {\cf20 // there is still the 0xD800, 0xDC00 and 0x10000 noise}\par
06880                                                         {\cf20 // in the result so we have to subtract with:}\par
06881                                                         {\cf20 // (0xD800 << 10) + DC00 - 0x10000 = 0x35FDC00}\par
06882                                                         - 0x35FDC00u);\par
06883                                     \}\par
06884                                     {\cf19 else}\par
06885                                     \{\par
06886                                         error_message = {\cf22 "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF"};\par
06887                                         {\cf19 return} token_type::parse_error;\par
06888                                     \}\par
06889                                 \}\par
06890                                 {\cf19 else}\par
06891                                 \{\par
06892                                     error_message = {\cf22 "invalid string: surrogate U+D800..U+DBFF must be followed by U+DC00..U+DFFF"};\par
06893                                     {\cf19 return} token_type::parse_error;\par
06894                                 \}\par
06895                             \}\par
06896                             {\cf19 else}\par
06897                             \{\par
06898                                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(0xDC00 <= codepoint1 && codepoint1 <= 0xDFFF))\par
06899                                 \{\par
06900                                     error_message = {\cf22 "invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF"};\par
06901                                     {\cf19 return} token_type::parse_error;\par
06902                                 \}\par
06903                             \}\par
06904 \par
06905                             {\cf20 // result of the above calculation yields a proper codepoint}\par
06906                             JSON_ASSERT(0x00 <= codepoint && codepoint <= 0x10FFFF);\par
06907 \par
06908                             {\cf20 // translate codepoint into bytes}\par
06909                             {\cf19 if} (codepoint < 0x80)\par
06910                             \{\par
06911                                 {\cf20 // 1-byte characters: 0xxxxxxx (ASCII)}\par
06912                                 add({\cf17 static_cast<}char_int_type{\cf17 >}(codepoint));\par
06913                             \}\par
06914                             {\cf19 else} {\cf19 if} (codepoint <= 0x7FF)\par
06915                             \{\par
06916                                 {\cf20 // 2-byte characters: 110xxxxx 10xxxxxx}\par
06917                                 add({\cf17 static_cast<}char_int_type{\cf17 >}(0xC0u | ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(codepoint) >> 6u)));\par
06918                                 add({\cf17 static_cast<}char_int_type{\cf17 >}(0x80u | ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(codepoint) & 0x3Fu)));\par
06919                             \}\par
06920                             {\cf19 else} {\cf19 if} (codepoint <= 0xFFFF)\par
06921                             \{\par
06922                                 {\cf20 // 3-byte characters: 1110xxxx 10xxxxxx 10xxxxxx}\par
06923                                 add({\cf17 static_cast<}char_int_type{\cf17 >}(0xE0u | ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(codepoint) >> 12u)));\par
06924                                 add({\cf17 static_cast<}char_int_type{\cf17 >}(0x80u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(codepoint) >> 6u) & 0x3Fu)));\par
06925                                 add({\cf17 static_cast<}char_int_type{\cf17 >}(0x80u | ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(codepoint) & 0x3Fu)));\par
06926                             \}\par
06927                             {\cf19 else}\par
06928                             \{\par
06929                                 {\cf20 // 4-byte characters: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx}\par
06930                                 add({\cf17 static_cast<}char_int_type{\cf17 >}(0xF0u | ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(codepoint) >> 18u)));\par
06931                                 add({\cf17 static_cast<}char_int_type{\cf17 >}(0x80u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(codepoint) >> 12u) & 0x3Fu)));\par
06932                                 add({\cf17 static_cast<}char_int_type{\cf17 >}(0x80u | (({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(codepoint) >> 6u) & 0x3Fu)));\par
06933                                 add({\cf17 static_cast<}char_int_type{\cf17 >}(0x80u | ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(codepoint) & 0x3Fu)));\par
06934                             \}\par
06935 \par
06936                             {\cf19 break};\par
06937                         \}\par
06938 \par
06939                         {\cf20 // other characters after escape}\par
06940                         {\cf19 default}:\par
06941                             error_message = {\cf22 "invalid string: forbidden character after backslash"};\par
06942                             {\cf19 return} token_type::parse_error;\par
06943                     \}\par
06944 \par
06945                     {\cf19 break};\par
06946                 \}\par
06947 \par
06948                 {\cf20 // invalid control characters}\par
06949                 {\cf19 case} 0x00:\par
06950                 \{\par
06951                     error_message = {\cf22 "invalid string: control character U+0000 (NUL) must be escaped to \\\\u0000"};\par
06952                     {\cf19 return} token_type::parse_error;\par
06953                 \}\par
06954 \par
06955                 {\cf19 case} 0x01:\par
06956                 \{\par
06957                     error_message = {\cf22 "invalid string: control character U+0001 (SOH) must be escaped to \\\\u0001"};\par
06958                     {\cf19 return} token_type::parse_error;\par
06959                 \}\par
06960 \par
06961                 {\cf19 case} 0x02:\par
06962                 \{\par
06963                     error_message = {\cf22 "invalid string: control character U+0002 (STX) must be escaped to \\\\u0002"};\par
06964                     {\cf19 return} token_type::parse_error;\par
06965                 \}\par
06966 \par
06967                 {\cf19 case} 0x03:\par
06968                 \{\par
06969                     error_message = {\cf22 "invalid string: control character U+0003 (ETX) must be escaped to \\\\u0003"};\par
06970                     {\cf19 return} token_type::parse_error;\par
06971                 \}\par
06972 \par
06973                 {\cf19 case} 0x04:\par
06974                 \{\par
06975                     error_message = {\cf22 "invalid string: control character U+0004 (EOT) must be escaped to \\\\u0004"};\par
06976                     {\cf19 return} token_type::parse_error;\par
06977                 \}\par
06978 \par
06979                 {\cf19 case} 0x05:\par
06980                 \{\par
06981                     error_message = {\cf22 "invalid string: control character U+0005 (ENQ) must be escaped to \\\\u0005"};\par
06982                     {\cf19 return} token_type::parse_error;\par
06983                 \}\par
06984 \par
06985                 {\cf19 case} 0x06:\par
06986                 \{\par
06987                     error_message = {\cf22 "invalid string: control character U+0006 (ACK) must be escaped to \\\\u0006"};\par
06988                     {\cf19 return} token_type::parse_error;\par
06989                 \}\par
06990 \par
06991                 {\cf19 case} 0x07:\par
06992                 \{\par
06993                     error_message = {\cf22 "invalid string: control character U+0007 (BEL) must be escaped to \\\\u0007"};\par
06994                     {\cf19 return} token_type::parse_error;\par
06995                 \}\par
06996 \par
06997                 {\cf19 case} 0x08:\par
06998                 \{\par
06999                     error_message = {\cf22 "invalid string: control character U+0008 (BS) must be escaped to \\\\u0008 or \\\\b"};\par
07000                     {\cf19 return} token_type::parse_error;\par
07001                 \}\par
07002 \par
07003                 {\cf19 case} 0x09:\par
07004                 \{\par
07005                     error_message = {\cf22 "invalid string: control character U+0009 (HT) must be escaped to \\\\u0009 or \\\\t"};\par
07006                     {\cf19 return} token_type::parse_error;\par
07007                 \}\par
07008 \par
07009                 {\cf19 case} 0x0A:\par
07010                 \{\par
07011                     error_message = {\cf22 "invalid string: control character U+000A (LF) must be escaped to \\\\u000A or \\\\n"};\par
07012                     {\cf19 return} token_type::parse_error;\par
07013                 \}\par
07014 \par
07015                 {\cf19 case} 0x0B:\par
07016                 \{\par
07017                     error_message = {\cf22 "invalid string: control character U+000B (VT) must be escaped to \\\\u000B"};\par
07018                     {\cf19 return} token_type::parse_error;\par
07019                 \}\par
07020 \par
07021                 {\cf19 case} 0x0C:\par
07022                 \{\par
07023                     error_message = {\cf22 "invalid string: control character U+000C (FF) must be escaped to \\\\u000C or \\\\f"};\par
07024                     {\cf19 return} token_type::parse_error;\par
07025                 \}\par
07026 \par
07027                 {\cf19 case} 0x0D:\par
07028                 \{\par
07029                     error_message = {\cf22 "invalid string: control character U+000D (CR) must be escaped to \\\\u000D or \\\\r"};\par
07030                     {\cf19 return} token_type::parse_error;\par
07031                 \}\par
07032 \par
07033                 {\cf19 case} 0x0E:\par
07034                 \{\par
07035                     error_message = {\cf22 "invalid string: control character U+000E (SO) must be escaped to \\\\u000E"};\par
07036                     {\cf19 return} token_type::parse_error;\par
07037                 \}\par
07038 \par
07039                 {\cf19 case} 0x0F:\par
07040                 \{\par
07041                     error_message = {\cf22 "invalid string: control character U+000F (SI) must be escaped to \\\\u000F"};\par
07042                     {\cf19 return} token_type::parse_error;\par
07043                 \}\par
07044 \par
07045                 {\cf19 case} 0x10:\par
07046                 \{\par
07047                     error_message = {\cf22 "invalid string: control character U+0010 (DLE) must be escaped to \\\\u0010"};\par
07048                     {\cf19 return} token_type::parse_error;\par
07049                 \}\par
07050 \par
07051                 {\cf19 case} 0x11:\par
07052                 \{\par
07053                     error_message = {\cf22 "invalid string: control character U+0011 (DC1) must be escaped to \\\\u0011"};\par
07054                     {\cf19 return} token_type::parse_error;\par
07055                 \}\par
07056 \par
07057                 {\cf19 case} 0x12:\par
07058                 \{\par
07059                     error_message = {\cf22 "invalid string: control character U+0012 (DC2) must be escaped to \\\\u0012"};\par
07060                     {\cf19 return} token_type::parse_error;\par
07061                 \}\par
07062 \par
07063                 {\cf19 case} 0x13:\par
07064                 \{\par
07065                     error_message = {\cf22 "invalid string: control character U+0013 (DC3) must be escaped to \\\\u0013"};\par
07066                     {\cf19 return} token_type::parse_error;\par
07067                 \}\par
07068 \par
07069                 {\cf19 case} 0x14:\par
07070                 \{\par
07071                     error_message = {\cf22 "invalid string: control character U+0014 (DC4) must be escaped to \\\\u0014"};\par
07072                     {\cf19 return} token_type::parse_error;\par
07073                 \}\par
07074 \par
07075                 {\cf19 case} 0x15:\par
07076                 \{\par
07077                     error_message = {\cf22 "invalid string: control character U+0015 (NAK) must be escaped to \\\\u0015"};\par
07078                     {\cf19 return} token_type::parse_error;\par
07079                 \}\par
07080 \par
07081                 {\cf19 case} 0x16:\par
07082                 \{\par
07083                     error_message = {\cf22 "invalid string: control character U+0016 (SYN) must be escaped to \\\\u0016"};\par
07084                     {\cf19 return} token_type::parse_error;\par
07085                 \}\par
07086 \par
07087                 {\cf19 case} 0x17:\par
07088                 \{\par
07089                     error_message = {\cf22 "invalid string: control character U+0017 (ETB) must be escaped to \\\\u0017"};\par
07090                     {\cf19 return} token_type::parse_error;\par
07091                 \}\par
07092 \par
07093                 {\cf19 case} 0x18:\par
07094                 \{\par
07095                     error_message = {\cf22 "invalid string: control character U+0018 (CAN) must be escaped to \\\\u0018"};\par
07096                     {\cf19 return} token_type::parse_error;\par
07097                 \}\par
07098 \par
07099                 {\cf19 case} 0x19:\par
07100                 \{\par
07101                     error_message = {\cf22 "invalid string: control character U+0019 (EM) must be escaped to \\\\u0019"};\par
07102                     {\cf19 return} token_type::parse_error;\par
07103                 \}\par
07104 \par
07105                 {\cf19 case} 0x1A:\par
07106                 \{\par
07107                     error_message = {\cf22 "invalid string: control character U+001A (SUB) must be escaped to \\\\u001A"};\par
07108                     {\cf19 return} token_type::parse_error;\par
07109                 \}\par
07110 \par
07111                 {\cf19 case} 0x1B:\par
07112                 \{\par
07113                     error_message = {\cf22 "invalid string: control character U+001B (ESC) must be escaped to \\\\u001B"};\par
07114                     {\cf19 return} token_type::parse_error;\par
07115                 \}\par
07116 \par
07117                 {\cf19 case} 0x1C:\par
07118                 \{\par
07119                     error_message = {\cf22 "invalid string: control character U+001C (FS) must be escaped to \\\\u001C"};\par
07120                     {\cf19 return} token_type::parse_error;\par
07121                 \}\par
07122 \par
07123                 {\cf19 case} 0x1D:\par
07124                 \{\par
07125                     error_message = {\cf22 "invalid string: control character U+001D (GS) must be escaped to \\\\u001D"};\par
07126                     {\cf19 return} token_type::parse_error;\par
07127                 \}\par
07128 \par
07129                 {\cf19 case} 0x1E:\par
07130                 \{\par
07131                     error_message = {\cf22 "invalid string: control character U+001E (RS) must be escaped to \\\\u001E"};\par
07132                     {\cf19 return} token_type::parse_error;\par
07133                 \}\par
07134 \par
07135                 {\cf19 case} 0x1F:\par
07136                 \{\par
07137                     error_message = {\cf22 "invalid string: control character U+001F (US) must be escaped to \\\\u001F"};\par
07138                     {\cf19 return} token_type::parse_error;\par
07139                 \}\par
07140 \par
07141                 {\cf20 // U+0020..U+007F (except U+0022 (quote) and U+005C (backspace))}\par
07142                 {\cf19 case} 0x20:\par
07143                 {\cf19 case} 0x21:\par
07144                 {\cf19 case} 0x23:\par
07145                 {\cf19 case} 0x24:\par
07146                 {\cf19 case} 0x25:\par
07147                 {\cf19 case} 0x26:\par
07148                 {\cf19 case} 0x27:\par
07149                 {\cf19 case} 0x28:\par
07150                 {\cf19 case} 0x29:\par
07151                 {\cf19 case} 0x2A:\par
07152                 {\cf19 case} 0x2B:\par
07153                 {\cf19 case} 0x2C:\par
07154                 {\cf19 case} 0x2D:\par
07155                 {\cf19 case} 0x2E:\par
07156                 {\cf19 case} 0x2F:\par
07157                 {\cf19 case} 0x30:\par
07158                 {\cf19 case} 0x31:\par
07159                 {\cf19 case} 0x32:\par
07160                 {\cf19 case} 0x33:\par
07161                 {\cf19 case} 0x34:\par
07162                 {\cf19 case} 0x35:\par
07163                 {\cf19 case} 0x36:\par
07164                 {\cf19 case} 0x37:\par
07165                 {\cf19 case} 0x38:\par
07166                 {\cf19 case} 0x39:\par
07167                 {\cf19 case} 0x3A:\par
07168                 {\cf19 case} 0x3B:\par
07169                 {\cf19 case} 0x3C:\par
07170                 {\cf19 case} 0x3D:\par
07171                 {\cf19 case} 0x3E:\par
07172                 {\cf19 case} 0x3F:\par
07173                 {\cf19 case} 0x40:\par
07174                 {\cf19 case} 0x41:\par
07175                 {\cf19 case} 0x42:\par
07176                 {\cf19 case} 0x43:\par
07177                 {\cf19 case} 0x44:\par
07178                 {\cf19 case} 0x45:\par
07179                 {\cf19 case} 0x46:\par
07180                 {\cf19 case} 0x47:\par
07181                 {\cf19 case} 0x48:\par
07182                 {\cf19 case} 0x49:\par
07183                 {\cf19 case} 0x4A:\par
07184                 {\cf19 case} 0x4B:\par
07185                 {\cf19 case} 0x4C:\par
07186                 {\cf19 case} 0x4D:\par
07187                 {\cf19 case} 0x4E:\par
07188                 {\cf19 case} 0x4F:\par
07189                 {\cf19 case} 0x50:\par
07190                 {\cf19 case} 0x51:\par
07191                 {\cf19 case} 0x52:\par
07192                 {\cf19 case} 0x53:\par
07193                 {\cf19 case} 0x54:\par
07194                 {\cf19 case} 0x55:\par
07195                 {\cf19 case} 0x56:\par
07196                 {\cf19 case} 0x57:\par
07197                 {\cf19 case} 0x58:\par
07198                 {\cf19 case} 0x59:\par
07199                 {\cf19 case} 0x5A:\par
07200                 {\cf19 case} 0x5B:\par
07201                 {\cf19 case} 0x5D:\par
07202                 {\cf19 case} 0x5E:\par
07203                 {\cf19 case} 0x5F:\par
07204                 {\cf19 case} 0x60:\par
07205                 {\cf19 case} 0x61:\par
07206                 {\cf19 case} 0x62:\par
07207                 {\cf19 case} 0x63:\par
07208                 {\cf19 case} 0x64:\par
07209                 {\cf19 case} 0x65:\par
07210                 {\cf19 case} 0x66:\par
07211                 {\cf19 case} 0x67:\par
07212                 {\cf19 case} 0x68:\par
07213                 {\cf19 case} 0x69:\par
07214                 {\cf19 case} 0x6A:\par
07215                 {\cf19 case} 0x6B:\par
07216                 {\cf19 case} 0x6C:\par
07217                 {\cf19 case} 0x6D:\par
07218                 {\cf19 case} 0x6E:\par
07219                 {\cf19 case} 0x6F:\par
07220                 {\cf19 case} 0x70:\par
07221                 {\cf19 case} 0x71:\par
07222                 {\cf19 case} 0x72:\par
07223                 {\cf19 case} 0x73:\par
07224                 {\cf19 case} 0x74:\par
07225                 {\cf19 case} 0x75:\par
07226                 {\cf19 case} 0x76:\par
07227                 {\cf19 case} 0x77:\par
07228                 {\cf19 case} 0x78:\par
07229                 {\cf19 case} 0x79:\par
07230                 {\cf19 case} 0x7A:\par
07231                 {\cf19 case} 0x7B:\par
07232                 {\cf19 case} 0x7C:\par
07233                 {\cf19 case} 0x7D:\par
07234                 {\cf19 case} 0x7E:\par
07235                 {\cf19 case} 0x7F:\par
07236                 \{\par
07237                     add(current);\par
07238                     {\cf19 break};\par
07239                 \}\par
07240 \par
07241                 {\cf20 // U+0080..U+07FF: bytes C2..DF 80..BF}\par
07242                 {\cf19 case} 0xC2:\par
07243                 {\cf19 case} 0xC3:\par
07244                 {\cf19 case} 0xC4:\par
07245                 {\cf19 case} 0xC5:\par
07246                 {\cf19 case} 0xC6:\par
07247                 {\cf19 case} 0xC7:\par
07248                 {\cf19 case} 0xC8:\par
07249                 {\cf19 case} 0xC9:\par
07250                 {\cf19 case} 0xCA:\par
07251                 {\cf19 case} 0xCB:\par
07252                 {\cf19 case} 0xCC:\par
07253                 {\cf19 case} 0xCD:\par
07254                 {\cf19 case} 0xCE:\par
07255                 {\cf19 case} 0xCF:\par
07256                 {\cf19 case} 0xD0:\par
07257                 {\cf19 case} 0xD1:\par
07258                 {\cf19 case} 0xD2:\par
07259                 {\cf19 case} 0xD3:\par
07260                 {\cf19 case} 0xD4:\par
07261                 {\cf19 case} 0xD5:\par
07262                 {\cf19 case} 0xD6:\par
07263                 {\cf19 case} 0xD7:\par
07264                 {\cf19 case} 0xD8:\par
07265                 {\cf19 case} 0xD9:\par
07266                 {\cf19 case} 0xDA:\par
07267                 {\cf19 case} 0xDB:\par
07268                 {\cf19 case} 0xDC:\par
07269                 {\cf19 case} 0xDD:\par
07270                 {\cf19 case} 0xDE:\par
07271                 {\cf19 case} 0xDF:\par
07272                 \{\par
07273                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!next_byte_in_range(\{0x80, 0xBF\})))\par
07274                     \{\par
07275                         {\cf19 return} token_type::parse_error;\par
07276                     \}\par
07277                     {\cf19 break};\par
07278                 \}\par
07279 \par
07280                 {\cf20 // U+0800..U+0FFF: bytes E0 A0..BF 80..BF}\par
07281                 {\cf19 case} 0xE0:\par
07282                 \{\par
07283                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range(\{0xA0, 0xBF, 0x80, 0xBF\}))))\par
07284                     \{\par
07285                         {\cf19 return} token_type::parse_error;\par
07286                     \}\par
07287                     {\cf19 break};\par
07288                 \}\par
07289 \par
07290                 {\cf20 // U+1000..U+CFFF: bytes E1..EC 80..BF 80..BF}\par
07291                 {\cf20 // U+E000..U+FFFF: bytes EE..EF 80..BF 80..BF}\par
07292                 {\cf19 case} 0xE1:\par
07293                 {\cf19 case} 0xE2:\par
07294                 {\cf19 case} 0xE3:\par
07295                 {\cf19 case} 0xE4:\par
07296                 {\cf19 case} 0xE5:\par
07297                 {\cf19 case} 0xE6:\par
07298                 {\cf19 case} 0xE7:\par
07299                 {\cf19 case} 0xE8:\par
07300                 {\cf19 case} 0xE9:\par
07301                 {\cf19 case} 0xEA:\par
07302                 {\cf19 case} 0xEB:\par
07303                 {\cf19 case} 0xEC:\par
07304                 {\cf19 case} 0xEE:\par
07305                 {\cf19 case} 0xEF:\par
07306                 \{\par
07307                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range(\{0x80, 0xBF, 0x80, 0xBF\}))))\par
07308                     \{\par
07309                         {\cf19 return} token_type::parse_error;\par
07310                     \}\par
07311                     {\cf19 break};\par
07312                 \}\par
07313 \par
07314                 {\cf20 // U+D000..U+D7FF: bytes ED 80..9F 80..BF}\par
07315                 {\cf19 case} 0xED:\par
07316                 \{\par
07317                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range(\{0x80, 0x9F, 0x80, 0xBF\}))))\par
07318                     \{\par
07319                         {\cf19 return} token_type::parse_error;\par
07320                     \}\par
07321                     {\cf19 break};\par
07322                 \}\par
07323 \par
07324                 {\cf20 // U+10000..U+3FFFF F0 90..BF 80..BF 80..BF}\par
07325                 {\cf19 case} 0xF0:\par
07326                 \{\par
07327                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range(\{0x90, 0xBF, 0x80, 0xBF, 0x80, 0xBF\}))))\par
07328                     \{\par
07329                         {\cf19 return} token_type::parse_error;\par
07330                     \}\par
07331                     {\cf19 break};\par
07332                 \}\par
07333 \par
07334                 {\cf20 // U+40000..U+FFFFF F1..F3 80..BF 80..BF 80..BF}\par
07335                 {\cf19 case} 0xF1:\par
07336                 {\cf19 case} 0xF2:\par
07337                 {\cf19 case} 0xF3:\par
07338                 \{\par
07339                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range(\{0x80, 0xBF, 0x80, 0xBF, 0x80, 0xBF\}))))\par
07340                     \{\par
07341                         {\cf19 return} token_type::parse_error;\par
07342                     \}\par
07343                     {\cf19 break};\par
07344                 \}\par
07345 \par
07346                 {\cf20 // U+100000..U+10FFFF F4 80..8F 80..BF 80..BF}\par
07347                 {\cf19 case} 0xF4:\par
07348                 \{\par
07349                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!(next_byte_in_range(\{0x80, 0x8F, 0x80, 0xBF, 0x80, 0xBF\}))))\par
07350                     \{\par
07351                         {\cf19 return} token_type::parse_error;\par
07352                     \}\par
07353                     {\cf19 break};\par
07354                 \}\par
07355 \par
07356                 {\cf20 // remaining bytes (80..C1 and F5..FF) are ill-formed}\par
07357                 {\cf19 default}:\par
07358                 \{\par
07359                     error_message = {\cf22 "invalid string: ill-formed UTF-8 byte"};\par
07360                     {\cf19 return} token_type::parse_error;\par
07361                 \}\par
07362             \}\par
07363         \}\par
07364     \}\par
07365 \par
07370     {\cf18 bool} scan_comment()\par
07371     \{\par
07372         {\cf19 switch} (get())\par
07373         \{\par
07374             {\cf20 // single-line comments skip input until a newline or EOF is read}\par
07375             {\cf19 case} {\cf23 '/'}:\par
07376             \{\par
07377                 {\cf19 while} ({\cf17 true})\par
07378                 \{\par
07379                     {\cf19 switch} (get())\par
07380                     \{\par
07381                         {\cf19 case} {\cf23 '\\n'}:\par
07382                         {\cf19 case} {\cf23 '\\r'}:\par
07383                         {\cf19 case} std::char_traits<char_type>::eof():\par
07384                         case {\cf22 '\\0'}:\par
07385                             return true;\par
07386 \par
07387                         {\cf19 default}:\par
07388                             {\cf19 break};\par
07389                     \}\par
07390                 \}\par
07391             \}\par
07392 \par
07393             {\cf20 // multi-line comments skip input until */ is read}\par
07394             {\cf19 case} {\cf23 '*'}:\par
07395             \{\par
07396                 {\cf19 while} ({\cf17 true})\par
07397                 \{\par
07398                     {\cf19 switch} (get())\par
07399                     \{\par
07400                         {\cf19 case} std::char_traits<char_type>::eof():\par
07401                         case {\cf22 '\\0'}:\par
07402                         \{\par
07403                             error_message = {\cf22 "invalid comment; missing closing '*/'"};\par
07404                             {\cf19 return} {\cf17 false};\par
07405                         \}\par
07406 \par
07407                         {\cf19 case} {\cf23 '*'}:\par
07408                         \{\par
07409                             {\cf19 switch} (get())\par
07410                             \{\par
07411                                 {\cf19 case} {\cf23 '/'}:\par
07412                                     {\cf19 return} {\cf17 true};\par
07413 \par
07414                                 {\cf19 default}:\par
07415                                 \{\par
07416                                     unget();\par
07417                                     {\cf19 continue};\par
07418                                 \}\par
07419                             \}\par
07420                         \}\par
07421 \par
07422                         {\cf19 default}:\par
07423                             {\cf19 continue};\par
07424                     \}\par
07425                 \}\par
07426             \}\par
07427 \par
07428             {\cf20 // unexpected character after reading '/'}\par
07429             {\cf19 default}:\par
07430             \{\par
07431                 error_message = {\cf22 "invalid comment; expecting '/' or '*' after '/'"};\par
07432                 {\cf19 return} {\cf17 false};\par
07433             \}\par
07434         \}\par
07435     \}\par
07436 \par
07437     JSON_HEDLEY_NON_NULL(2)\par
07438     static {\cf18 void} strtof({\cf18 float}& f, const {\cf18 char}* str, {\cf18 char}** endptr) noexcept\par
07439     \{\par
07440         f = std::strtof(str, endptr);\par
07441     \}\par
07442 \par
07443     JSON_HEDLEY_NON_NULL(2)\par
07444     static {\cf18 void} strtof({\cf18 double}& f, const {\cf18 char}* str, {\cf18 char}** endptr) noexcept\par
07445     \{\par
07446         f = std::strtod(str, endptr);\par
07447     \}\par
07448 \par
07449     JSON_HEDLEY_NON_NULL(2)\par
07450     static {\cf18 void} strtof({\cf18 long} {\cf18 double}& f, const {\cf18 char}* str, {\cf18 char}** endptr) noexcept\par
07451     \{\par
07452         f = std::strtold(str, endptr);\par
07453     \}\par
07454 \par
07495     token_type scan_number()  {\cf20 // lgtm [cpp/use-of-goto]}\par
07496     \{\par
07497         {\cf20 // reset token_buffer to store the number's bytes}\par
07498         reset();\par
07499 \par
07500         {\cf20 // the type of the parsed number; initially set to unsigned; will be}\par
07501         {\cf20 // changed if minus sign, decimal point or exponent is read}\par
07502         token_type number_type = token_type::value_unsigned;\par
07503 \par
07504         {\cf20 // state (init): we just found out we need to scan a number}\par
07505         {\cf19 switch} (current)\par
07506         \{\par
07507             {\cf19 case} {\cf23 '-'}:\par
07508             \{\par
07509                 add(current);\par
07510                 {\cf19 goto} scan_number_minus;\par
07511             \}\par
07512 \par
07513             {\cf19 case} {\cf23 '0'}:\par
07514             \{\par
07515                 add(current);\par
07516                 {\cf19 goto} scan_number_zero;\par
07517             \}\par
07518 \par
07519             {\cf19 case} {\cf23 '1'}:\par
07520             {\cf19 case} {\cf23 '2'}:\par
07521             {\cf19 case} {\cf23 '3'}:\par
07522             {\cf19 case} {\cf23 '4'}:\par
07523             {\cf19 case} {\cf23 '5'}:\par
07524             {\cf19 case} {\cf23 '6'}:\par
07525             {\cf19 case} {\cf23 '7'}:\par
07526             {\cf19 case} {\cf23 '8'}:\par
07527             {\cf19 case} {\cf23 '9'}:\par
07528             \{\par
07529                 add(current);\par
07530                 {\cf19 goto} scan_number_any1;\par
07531             \}\par
07532 \par
07533             {\cf20 // all other characters are rejected outside scan_number()}\par
07534             {\cf19 default}:            {\cf20 // LCOV_EXCL_LINE}\par
07535                 JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE}\par
07536         \}\par
07537 \par
07538 scan_number_minus:\par
07539         {\cf20 // state: we just parsed a leading minus sign}\par
07540         number_type = token_type::value_integer;\par
07541         {\cf19 switch} (get())\par
07542         \{\par
07543             {\cf19 case} {\cf23 '0'}:\par
07544             \{\par
07545                 add(current);\par
07546                 {\cf19 goto} scan_number_zero;\par
07547             \}\par
07548 \par
07549             {\cf19 case} {\cf23 '1'}:\par
07550             {\cf19 case} {\cf23 '2'}:\par
07551             {\cf19 case} {\cf23 '3'}:\par
07552             {\cf19 case} {\cf23 '4'}:\par
07553             {\cf19 case} {\cf23 '5'}:\par
07554             {\cf19 case} {\cf23 '6'}:\par
07555             {\cf19 case} {\cf23 '7'}:\par
07556             {\cf19 case} {\cf23 '8'}:\par
07557             {\cf19 case} {\cf23 '9'}:\par
07558             \{\par
07559                 add(current);\par
07560                 {\cf19 goto} scan_number_any1;\par
07561             \}\par
07562 \par
07563             {\cf19 default}:\par
07564             \{\par
07565                 error_message = {\cf22 "invalid number; expected digit after '-'"};\par
07566                 {\cf19 return} token_type::parse_error;\par
07567             \}\par
07568         \}\par
07569 \par
07570 scan_number_zero:\par
07571         {\cf20 // state: we just parse a zero (maybe with a leading minus sign)}\par
07572         {\cf19 switch} (get())\par
07573         \{\par
07574             {\cf19 case} {\cf23 '.'}:\par
07575             \{\par
07576                 add(decimal_point_char);\par
07577                 {\cf19 goto} scan_number_decimal1;\par
07578             \}\par
07579 \par
07580             {\cf19 case} {\cf23 'e'}:\par
07581             {\cf19 case} {\cf23 'E'}:\par
07582             \{\par
07583                 add(current);\par
07584                 {\cf19 goto} scan_number_exponent;\par
07585             \}\par
07586 \par
07587             {\cf19 default}:\par
07588                 {\cf19 goto} scan_number_done;\par
07589         \}\par
07590 \par
07591 scan_number_any1:\par
07592         {\cf20 // state: we just parsed a number 0-9 (maybe with a leading minus sign)}\par
07593         {\cf19 switch} (get())\par
07594         \{\par
07595             {\cf19 case} {\cf23 '0'}:\par
07596             {\cf19 case} {\cf23 '1'}:\par
07597             {\cf19 case} {\cf23 '2'}:\par
07598             {\cf19 case} {\cf23 '3'}:\par
07599             {\cf19 case} {\cf23 '4'}:\par
07600             {\cf19 case} {\cf23 '5'}:\par
07601             {\cf19 case} {\cf23 '6'}:\par
07602             {\cf19 case} {\cf23 '7'}:\par
07603             {\cf19 case} {\cf23 '8'}:\par
07604             {\cf19 case} {\cf23 '9'}:\par
07605             \{\par
07606                 add(current);\par
07607                 {\cf19 goto} scan_number_any1;\par
07608             \}\par
07609 \par
07610             {\cf19 case} {\cf23 '.'}:\par
07611             \{\par
07612                 add(decimal_point_char);\par
07613                 {\cf19 goto} scan_number_decimal1;\par
07614             \}\par
07615 \par
07616             {\cf19 case} {\cf23 'e'}:\par
07617             {\cf19 case} {\cf23 'E'}:\par
07618             \{\par
07619                 add(current);\par
07620                 {\cf19 goto} scan_number_exponent;\par
07621             \}\par
07622 \par
07623             {\cf19 default}:\par
07624                 {\cf19 goto} scan_number_done;\par
07625         \}\par
07626 \par
07627 scan_number_decimal1:\par
07628         {\cf20 // state: we just parsed a decimal point}\par
07629         number_type = token_type::value_float;\par
07630         {\cf19 switch} (get())\par
07631         \{\par
07632             {\cf19 case} {\cf23 '0'}:\par
07633             {\cf19 case} {\cf23 '1'}:\par
07634             {\cf19 case} {\cf23 '2'}:\par
07635             {\cf19 case} {\cf23 '3'}:\par
07636             {\cf19 case} {\cf23 '4'}:\par
07637             {\cf19 case} {\cf23 '5'}:\par
07638             {\cf19 case} {\cf23 '6'}:\par
07639             {\cf19 case} {\cf23 '7'}:\par
07640             {\cf19 case} {\cf23 '8'}:\par
07641             {\cf19 case} {\cf23 '9'}:\par
07642             \{\par
07643                 add(current);\par
07644                 {\cf19 goto} scan_number_decimal2;\par
07645             \}\par
07646 \par
07647             {\cf19 default}:\par
07648             \{\par
07649                 error_message = {\cf22 "invalid number; expected digit after '.'"};\par
07650                 {\cf19 return} token_type::parse_error;\par
07651             \}\par
07652         \}\par
07653 \par
07654 scan_number_decimal2:\par
07655         {\cf20 // we just parsed at least one number after a decimal point}\par
07656         {\cf19 switch} (get())\par
07657         \{\par
07658             {\cf19 case} {\cf23 '0'}:\par
07659             {\cf19 case} {\cf23 '1'}:\par
07660             {\cf19 case} {\cf23 '2'}:\par
07661             {\cf19 case} {\cf23 '3'}:\par
07662             {\cf19 case} {\cf23 '4'}:\par
07663             {\cf19 case} {\cf23 '5'}:\par
07664             {\cf19 case} {\cf23 '6'}:\par
07665             {\cf19 case} {\cf23 '7'}:\par
07666             {\cf19 case} {\cf23 '8'}:\par
07667             {\cf19 case} {\cf23 '9'}:\par
07668             \{\par
07669                 add(current);\par
07670                 {\cf19 goto} scan_number_decimal2;\par
07671             \}\par
07672 \par
07673             {\cf19 case} {\cf23 'e'}:\par
07674             {\cf19 case} {\cf23 'E'}:\par
07675             \{\par
07676                 add(current);\par
07677                 {\cf19 goto} scan_number_exponent;\par
07678             \}\par
07679 \par
07680             {\cf19 default}:\par
07681                 {\cf19 goto} scan_number_done;\par
07682         \}\par
07683 \par
07684 scan_number_exponent:\par
07685         {\cf20 // we just parsed an exponent}\par
07686         number_type = token_type::value_float;\par
07687         {\cf19 switch} (get())\par
07688         \{\par
07689             {\cf19 case} {\cf23 '+'}:\par
07690             {\cf19 case} {\cf23 '-'}:\par
07691             \{\par
07692                 add(current);\par
07693                 {\cf19 goto} scan_number_sign;\par
07694             \}\par
07695 \par
07696             {\cf19 case} {\cf23 '0'}:\par
07697             {\cf19 case} {\cf23 '1'}:\par
07698             {\cf19 case} {\cf23 '2'}:\par
07699             {\cf19 case} {\cf23 '3'}:\par
07700             {\cf19 case} {\cf23 '4'}:\par
07701             {\cf19 case} {\cf23 '5'}:\par
07702             {\cf19 case} {\cf23 '6'}:\par
07703             {\cf19 case} {\cf23 '7'}:\par
07704             {\cf19 case} {\cf23 '8'}:\par
07705             {\cf19 case} {\cf23 '9'}:\par
07706             \{\par
07707                 add(current);\par
07708                 {\cf19 goto} scan_number_any2;\par
07709             \}\par
07710 \par
07711             {\cf19 default}:\par
07712             \{\par
07713                 error_message =\par
07714                     {\cf22 "invalid number; expected '+', '-', or digit after exponent"};\par
07715                 {\cf19 return} token_type::parse_error;\par
07716             \}\par
07717         \}\par
07718 \par
07719 scan_number_sign:\par
07720         {\cf20 // we just parsed an exponent sign}\par
07721         {\cf19 switch} (get())\par
07722         \{\par
07723             {\cf19 case} {\cf23 '0'}:\par
07724             {\cf19 case} {\cf23 '1'}:\par
07725             {\cf19 case} {\cf23 '2'}:\par
07726             {\cf19 case} {\cf23 '3'}:\par
07727             {\cf19 case} {\cf23 '4'}:\par
07728             {\cf19 case} {\cf23 '5'}:\par
07729             {\cf19 case} {\cf23 '6'}:\par
07730             {\cf19 case} {\cf23 '7'}:\par
07731             {\cf19 case} {\cf23 '8'}:\par
07732             {\cf19 case} {\cf23 '9'}:\par
07733             \{\par
07734                 add(current);\par
07735                 {\cf19 goto} scan_number_any2;\par
07736             \}\par
07737 \par
07738             {\cf19 default}:\par
07739             \{\par
07740                 error_message = {\cf22 "invalid number; expected digit after exponent sign"};\par
07741                 {\cf19 return} token_type::parse_error;\par
07742             \}\par
07743         \}\par
07744 \par
07745 scan_number_any2:\par
07746         {\cf20 // we just parsed a number after the exponent or exponent sign}\par
07747         {\cf19 switch} (get())\par
07748         \{\par
07749             {\cf19 case} {\cf23 '0'}:\par
07750             {\cf19 case} {\cf23 '1'}:\par
07751             {\cf19 case} {\cf23 '2'}:\par
07752             {\cf19 case} {\cf23 '3'}:\par
07753             {\cf19 case} {\cf23 '4'}:\par
07754             {\cf19 case} {\cf23 '5'}:\par
07755             {\cf19 case} {\cf23 '6'}:\par
07756             {\cf19 case} {\cf23 '7'}:\par
07757             {\cf19 case} {\cf23 '8'}:\par
07758             {\cf19 case} {\cf23 '9'}:\par
07759             \{\par
07760                 add(current);\par
07761                 {\cf19 goto} scan_number_any2;\par
07762             \}\par
07763 \par
07764             {\cf19 default}:\par
07765                 {\cf19 goto} scan_number_done;\par
07766         \}\par
07767 \par
07768 scan_number_done:\par
07769         {\cf20 // unget the character after the number (we only read it to know that}\par
07770         {\cf20 // we are done scanning a number)}\par
07771         unget();\par
07772 \par
07773         {\cf18 char}* endptr = {\cf17 nullptr}; {\cf20 // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)}\par
07774         errno = 0;\par
07775 \par
07776         {\cf20 // try to parse integers first and fall back to floats}\par
07777         {\cf19 if} (number_type == token_type::value_unsigned)\par
07778         \{\par
07779             {\cf17 const} {\cf17 auto} x = std::strtoull(token_buffer.data(), &endptr, 10);\par
07780 \par
07781             {\cf20 // we checked the number format before}\par
07782             JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());\par
07783 \par
07784             {\cf19 if} (errno == 0)\par
07785             \{\par
07786                 value_unsigned = {\cf17 static_cast<}number_unsigned_t{\cf17 >}(x);\par
07787                 {\cf19 if} (value_unsigned == x)\par
07788                 \{\par
07789                     {\cf19 return} token_type::value_unsigned;\par
07790                 \}\par
07791             \}\par
07792         \}\par
07793         {\cf19 else} {\cf19 if} (number_type == token_type::value_integer)\par
07794         \{\par
07795             {\cf17 const} {\cf17 auto} x = std::strtoll(token_buffer.data(), &endptr, 10);\par
07796 \par
07797             {\cf20 // we checked the number format before}\par
07798             JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());\par
07799 \par
07800             {\cf19 if} (errno == 0)\par
07801             \{\par
07802                 value_integer = {\cf17 static_cast<}number_integer_t{\cf17 >}(x);\par
07803                 {\cf19 if} (value_integer == x)\par
07804                 \{\par
07805                     {\cf19 return} token_type::value_integer;\par
07806                 \}\par
07807             \}\par
07808         \}\par
07809 \par
07810         {\cf20 // this code is reached if we parse a floating-point number or if an}\par
07811         {\cf20 // integer conversion above failed}\par
07812         strtof(value_float, token_buffer.data(), &endptr);\par
07813 \par
07814         {\cf20 // we checked the number format before}\par
07815         JSON_ASSERT(endptr == token_buffer.data() + token_buffer.size());\par
07816 \par
07817         {\cf19 return} token_type::value_float;\par
07818     \}\par
07819 \par
07825     JSON_HEDLEY_NON_NULL(2)\par
07826     token_type scan_literal(const char_type* literal_text, const std::{\cf18 size_t} length,\par
07827                             token_type return_type)\par
07828     \{\par
07829         JSON_ASSERT(std::char_traits<char_type>::to_char_type(current) == literal_text[0]);\par
07830         {\cf19 for} (std::size_t i = 1; i < length; ++i)\par
07831         \{\par
07832             {\cf19 if} (JSON_HEDLEY_UNLIKELY(std::char_traits<char_type>::to_char_type(get()) != literal_text[i]))\par
07833             \{\par
07834                 error_message = {\cf22 "invalid literal"};\par
07835                 {\cf19 return} token_type::parse_error;\par
07836             \}\par
07837         \}\par
07838         {\cf19 return} return_type;\par
07839     \}\par
07840 \par
07842     {\cf20 // input management}\par
07844 {\cf20 }\par
07846     {\cf18 void} reset() noexcept\par
07847     \{\par
07848         token_buffer.clear();\par
07849         token_string.clear();\par
07850         token_string.push_back(std::char_traits<char_type>::to_char_type(current));\par
07851     \}\par
07852 \par
07853     {\cf20 /*}\par
07854 {\cf20     @brief get next character from the input}\par
07855 {\cf20 }\par
07856 {\cf20     This function provides the interface to the used input adapter. It does}\par
07857 {\cf20     not throw in case the input reached EOF, but returns a}\par
07858 {\cf20     `std::char_traits<char>::eof()` in that case.  Stores the scanned characters}\par
07859 {\cf20     for use in error messages.}\par
07860 {\cf20 }\par
07861 {\cf20     @return character read from the input}\par
07862 {\cf20     */}\par
07863     char_int_type get()\par
07864     \{\par
07865         ++position.chars_read_total;\par
07866         ++position.chars_read_current_line;\par
07867 \par
07868         {\cf19 if} (next_unget)\par
07869         \{\par
07870             {\cf20 // just reset the next_unget variable and work with current}\par
07871             next_unget = {\cf17 false};\par
07872         \}\par
07873         {\cf19 else}\par
07874         \{\par
07875             current = ia.get_character();\par
07876         \}\par
07877 \par
07878         {\cf19 if} (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))\par
07879         \{\par
07880             token_string.push_back(std::char_traits<char_type>::to_char_type(current));\par
07881         \}\par
07882 \par
07883         {\cf19 if} (current == {\cf23 '\\n'})\par
07884         \{\par
07885             ++position.lines_read;\par
07886             position.chars_read_current_line = 0;\par
07887         \}\par
07888 \par
07889         {\cf19 return} current;\par
07890     \}\par
07891 \par
07900     {\cf18 void} unget()\par
07901     \{\par
07902         next_unget = {\cf17 true};\par
07903 \par
07904         --position.chars_read_total;\par
07905 \par
07906         {\cf20 // in case we "unget" a newline, we have to also decrement the lines_read}\par
07907         {\cf19 if} (position.chars_read_current_line == 0)\par
07908         \{\par
07909             {\cf19 if} (position.lines_read > 0)\par
07910             \{\par
07911                 --position.lines_read;\par
07912             \}\par
07913         \}\par
07914         {\cf19 else}\par
07915         \{\par
07916             --position.chars_read_current_line;\par
07917         \}\par
07918 \par
07919         {\cf19 if} (JSON_HEDLEY_LIKELY(current != std::char_traits<char_type>::eof()))\par
07920         \{\par
07921             JSON_ASSERT(!token_string.empty());\par
07922             token_string.pop_back();\par
07923         \}\par
07924     \}\par
07925 \par
07927     {\cf18 void} add(char_int_type c)\par
07928     \{\par
07929         token_buffer.push_back({\cf17 static_cast<}typename string_t::value_type{\cf17 >}(c));\par
07930     \}\par
07931 \par
07932   {\cf17 public}:\par
07934     {\cf20 // value getters}\par
07936 {\cf20 }\par
07938     {\cf17 constexpr} number_integer_t get_number_integer() const noexcept\par
07939     \{\par
07940         {\cf19 return} value_integer;\par
07941     \}\par
07942 \par
07944     {\cf17 constexpr} number_unsigned_t get_number_unsigned() const noexcept\par
07945     \{\par
07946         {\cf19 return} value_unsigned;\par
07947     \}\par
07948 \par
07950     {\cf17 constexpr} number_float_t get_number_float() const noexcept\par
07951     \{\par
07952         {\cf19 return} value_float;\par
07953     \}\par
07954 \par
07956     string_t& get_string()\par
07957     \{\par
07958         {\cf19 return} token_buffer;\par
07959     \}\par
07960 \par
07962     {\cf20 // diagnostics}\par
07964 {\cf20 }\par
07966     {\cf17 constexpr} position_t get_position() const noexcept\par
07967     \{\par
07968         {\cf19 return} position;\par
07969     \}\par
07970 \par
07974     std::string get_token_string(){\cf17  const}\par
07975 {\cf17     }\{\par
07976         {\cf20 // escape control characters}\par
07977         std::string result;\par
07978         {\cf19 for} ({\cf17 const} {\cf17 auto} c : token_string)\par
07979         \{\par
07980             {\cf19 if} ({\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(c) <= {\cf22 '\\x1F'})\par
07981             \{\par
07982                 {\cf20 // escape control characters}\par
07983                 std::array<char, 9> cs\{\{\}\};\par
07984                 (std::snprintf)(cs.data(), cs.size(), {\cf22 "<U+%.4X>"}, {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(c)); {\cf20 // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)}\par
07985                 result += cs.data();\par
07986             \}\par
07987             {\cf19 else}\par
07988             \{\par
07989                 {\cf20 // add character as is}\par
07990                 result.push_back({\cf17 static_cast<}std::string::value_type{\cf17 >}(c));\par
07991             \}\par
07992         \}\par
07993 \par
07994         {\cf19 return} result;\par
07995     \}\par
07996 \par
07998     JSON_HEDLEY_RETURNS_NON_NULL\par
07999     {\cf17 constexpr} {\cf17 const} {\cf18 char}* get_error_message() const noexcept\par
08000     \{\par
08001         {\cf19 return} error_message;\par
08002     \}\par
08003 \par
08005     {\cf20 // actual scanner}\par
08007 {\cf20 }\par
08012     {\cf18 bool} skip_bom()\par
08013     \{\par
08014         {\cf19 if} (get() == 0xEF)\par
08015         \{\par
08016             {\cf20 // check if we completely parse the BOM}\par
08017             {\cf19 return} get() == 0xBB && get() == 0xBF;\par
08018         \}\par
08019 \par
08020         {\cf20 // the first character is not the beginning of the BOM; unget it to}\par
08021         {\cf20 // process is later}\par
08022         unget();\par
08023         {\cf19 return} {\cf17 true};\par
08024     \}\par
08025 \par
08026     {\cf18 void} skip_whitespace()\par
08027     \{\par
08028         {\cf19 do}\par
08029         \{\par
08030             get();\par
08031         \}\par
08032         {\cf19 while} (current == {\cf23 ' '} || current == {\cf23 '\\t'} || current == {\cf23 '\\n'} || current == {\cf23 '\\r'});\par
08033     \}\par
08034 \par
08035     token_type scan()\par
08036     \{\par
08037         {\cf20 // initially, skip the BOM}\par
08038         {\cf19 if} (position.chars_read_total == 0 && !skip_bom())\par
08039         \{\par
08040             error_message = {\cf22 "invalid BOM; must be 0xEF 0xBB 0xBF if given"};\par
08041             {\cf19 return} token_type::parse_error;\par
08042         \}\par
08043 \par
08044         {\cf20 // read next character and ignore whitespace}\par
08045         skip_whitespace();\par
08046 \par
08047         {\cf20 // ignore comments}\par
08048         {\cf19 while} (ignore_comments && current == {\cf23 '/'})\par
08049         \{\par
08050             {\cf19 if} (!scan_comment())\par
08051             \{\par
08052                 {\cf19 return} token_type::parse_error;\par
08053             \}\par
08054 \par
08055             {\cf20 // skip following whitespace}\par
08056             skip_whitespace();\par
08057         \}\par
08058 \par
08059         {\cf19 switch} (current)\par
08060         \{\par
08061             {\cf20 // structural characters}\par
08062             {\cf19 case} {\cf23 '['}:\par
08063                 {\cf19 return} token_type::begin_array;\par
08064             {\cf19 case} {\cf23 ']'}:\par
08065                 {\cf19 return} token_type::end_array;\par
08066             {\cf19 case} {\cf23 '\{'}:\par
08067                 {\cf19 return} token_type::begin_object;\par
08068             {\cf19 case} {\cf23 '\}'}:\par
08069                 {\cf19 return} token_type::end_object;\par
08070             {\cf19 case} {\cf23 ':'}:\par
08071                 {\cf19 return} token_type::name_separator;\par
08072             {\cf19 case} {\cf23 ','}:\par
08073                 {\cf19 return} token_type::value_separator;\par
08074 \par
08075             {\cf20 // literals}\par
08076             {\cf19 case} {\cf23 't'}:\par
08077             \{\par
08078                 std::array<char_type, 4> true_literal = \{\{char_type({\cf23 't'}), char_type({\cf23 'r'}), char_type({\cf23 'u'}), char_type({\cf23 'e'})\}\};\par
08079                 {\cf19 return} scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);\par
08080             \}\par
08081             {\cf19 case} {\cf23 'f'}:\par
08082             \{\par
08083                 std::array<char_type, 5> false_literal = \{\{char_type({\cf23 'f'}), char_type({\cf23 'a'}), char_type({\cf23 'l'}), char_type({\cf23 's'}), char_type({\cf23 'e'})\}\};\par
08084                 {\cf19 return} scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);\par
08085             \}\par
08086             {\cf19 case} {\cf23 'n'}:\par
08087             \{\par
08088                 std::array<char_type, 4> null_literal = \{\{char_type({\cf23 'n'}), char_type({\cf23 'u'}), char_type({\cf23 'l'}), char_type({\cf23 'l'})\}\};\par
08089                 {\cf19 return} scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);\par
08090             \}\par
08091 \par
08092             {\cf20 // string}\par
08093             {\cf19 case} {\cf23 '\\"'}:\par
08094                 {\cf19 return} scan_string();\par
08095 \par
08096             {\cf20 // number}\par
08097             {\cf19 case} {\cf23 '-'}:\par
08098             {\cf19 case} {\cf23 '0'}:\par
08099             {\cf19 case} {\cf23 '1'}:\par
08100             {\cf19 case} {\cf23 '2'}:\par
08101             {\cf19 case} {\cf23 '3'}:\par
08102             {\cf19 case} {\cf23 '4'}:\par
08103             {\cf19 case} {\cf23 '5'}:\par
08104             {\cf19 case} {\cf23 '6'}:\par
08105             {\cf19 case} {\cf23 '7'}:\par
08106             {\cf19 case} {\cf23 '8'}:\par
08107             {\cf19 case} {\cf23 '9'}:\par
08108                 {\cf19 return} scan_number();\par
08109 \par
08110             {\cf20 // end of input (the null byte is needed when parsing from}\par
08111             {\cf20 // string literals)}\par
08112             {\cf19 case} {\cf23 '\\0'}:\par
08113             {\cf19 case} std::char_traits<char_type>::eof():\par
08114                 {\cf19 return} token_type::end_of_input;\par
08115 \par
08116             {\cf20 // error}\par
08117             {\cf19 default}:\par
08118                 error_message = {\cf22 "invalid literal"};\par
08119                 {\cf19 return} token_type::parse_error;\par
08120         \}\par
08121     \}\par
08122 \par
08123   {\cf17 private}:\par
08125     InputAdapterType ia;\par
08126 \par
08128     {\cf17 const} {\cf18 bool} ignore_comments = {\cf17 false};\par
08129 \par
08131     char_int_type current = std::char_traits<char_type>::eof();\par
08132 \par
08134     {\cf18 bool} next_unget = {\cf17 false};\par
08135 \par
08137     position_t position \{\};\par
08138 \par
08140     std::vector<char_type> token_string \{\};\par
08141 \par
08143     string_t token_buffer \{\};\par
08144 \par
08146     {\cf17 const} {\cf18 char}* error_message = {\cf22 ""};\par
08147 \par
08148     {\cf20 // number values}\par
08149     number_integer_t value_integer = 0;\par
08150     number_unsigned_t value_unsigned = 0;\par
08151     number_float_t value_float = 0;\par
08152 \par
08154     {\cf17 const} char_int_type decimal_point_char = {\cf23 '.'};\par
08155 \};\par
08156 \}  {\cf20 // namespace detail}\par
08157 \}  {\cf20 // namespace nlohmann}\par
08158 \par
08159 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
08160 \par
08161 {\cf20 // #include <nlohmann/detail/meta/is_sax.hpp>}\par
08162 \par
08163 \par
08164 {\cf21 #include <cstdint>} {\cf20 // size_t}\par
08165 {\cf21 #include <utility>} {\cf20 // declval}\par
08166 {\cf21 #include <string>} {\cf20 // string}\par
08167 \par
08168 {\cf20 // #include <nlohmann/detail/meta/detected.hpp>}\par
08169 \par
08170 {\cf20 // #include <nlohmann/detail/meta/type_traits.hpp>}\par
08171 \par
08172 \par
08173 {\cf17 namespace }nlohmann\par
08174 \{\par
08175 {\cf17 namespace }detail\par
08176 \{\par
08177 {\cf17 template}<{\cf17 typename} T>\par
08178 {\cf17 using} null_function_t = {\cf17 decltype}(std::declval<T&>().null());\par
08179 \par
08180 {\cf17 template}<{\cf17 typename} T>\par
08181 {\cf17 using} boolean_function_t =\par
08182     {\cf17 decltype}(std::declval<T&>().boolean(std::declval<bool>()));\par
08183 \par
08184 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Integer>\par
08185 {\cf17 using} number_integer_function_t =\par
08186     {\cf17 decltype}(std::declval<T&>().number_integer(std::declval<Integer>()));\par
08187 \par
08188 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Un{\cf18 signed}>\par
08189 {\cf17 using} number_unsigned_function_t =\par
08190     {\cf17 decltype}(std::declval<T&>().number_unsigned(std::declval<Unsigned>()));\par
08191 \par
08192 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Float, {\cf17 typename} String>\par
08193 {\cf17 using} number_float_function_t = {\cf17 decltype}(std::declval<T&>().number_float(\par
08194                                     std::declval<Float>(), std::declval<const String&>()));\par
08195 \par
08196 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} String>\par
08197 {\cf17 using} string_function_t =\par
08198     {\cf17 decltype}(std::declval<T&>().string(std::declval<String&>()));\par
08199 \par
08200 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Binary>\par
08201 {\cf17 using} binary_function_t =\par
08202     {\cf17 decltype}(std::declval<T&>().binary(std::declval<Binary&>()));\par
08203 \par
08204 {\cf17 template}<{\cf17 typename} T>\par
08205 {\cf17 using} start_object_function_t =\par
08206     {\cf17 decltype}(std::declval<T&>().start_object(std::declval<std::size_t>()));\par
08207 \par
08208 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} String>\par
08209 {\cf17 using} key_function_t =\par
08210     {\cf17 decltype}(std::declval<T&>().key(std::declval<String&>()));\par
08211 \par
08212 {\cf17 template}<{\cf17 typename} T>\par
08213 {\cf17 using} end_object_function_t = {\cf17 decltype}(std::declval<T&>().end_object());\par
08214 \par
08215 {\cf17 template}<{\cf17 typename} T>\par
08216 {\cf17 using} start_array_function_t =\par
08217     {\cf17 decltype}(std::declval<T&>().start_array(std::declval<std::size_t>()));\par
08218 \par
08219 {\cf17 template}<{\cf17 typename} T>\par
08220 {\cf17 using} end_array_function_t = {\cf17 decltype}(std::declval<T&>().end_array());\par
08221 \par
08222 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Exception>\par
08223 {\cf17 using} parse_error_function_t = {\cf17 decltype}(std::declval<T&>().parse_error(\par
08224         std::declval<std::size_t>(), std::declval<const std::string&>(),\par
08225         std::declval<const Exception&>()));\par
08226 \par
08227 {\cf17 template}<{\cf17 typename} SAX, {\cf17 typename} BasicJsonType>\par
08228 {\cf17 struct }is_sax\par
08229 \{\par
08230   {\cf17 private}:\par
08231     {\cf17 static_assert}(is_basic_json<BasicJsonType>::value,\par
08232                   {\cf22 "BasicJsonType must be of type basic_json<...>"});\par
08233 \par
08234     {\cf17 using} number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
08235     {\cf17 using} number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
08236     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
08237     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
08238     {\cf17 using} binary_t = {\cf17 typename} BasicJsonType::binary_t;\par
08239     {\cf17 using} exception_t = {\cf17 typename} BasicJsonType::exception;\par
08240 \par
08241   {\cf17 public}:\par
08242     {\cf17 static} {\cf17 constexpr} {\cf18 bool} value =\par
08243         is_detected_exact<bool, null_function_t, SAX>::value &&\par
08244         is_detected_exact<bool, boolean_function_t, SAX>::value &&\par
08245         is_detected_exact<bool, number_integer_function_t, SAX, number_integer_t>::value &&\par
08246         is_detected_exact<bool, number_unsigned_function_t, SAX, number_unsigned_t>::value &&\par
08247         is_detected_exact<bool, number_float_function_t, SAX, number_float_t, string_t>::value &&\par
08248         is_detected_exact<bool, string_function_t, SAX, string_t>::value &&\par
08249         is_detected_exact<bool, binary_function_t, SAX, binary_t>::value &&\par
08250         is_detected_exact<bool, start_object_function_t, SAX>::value &&\par
08251         is_detected_exact<bool, key_function_t, SAX, string_t>::value &&\par
08252         is_detected_exact<bool, end_object_function_t, SAX>::value &&\par
08253         is_detected_exact<bool, start_array_function_t, SAX>::value &&\par
08254         is_detected_exact<bool, end_array_function_t, SAX>::value &&\par
08255         is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value;\par
08256 \};\par
08257 \par
08258 {\cf17 template}<{\cf17 typename} SAX, {\cf17 typename} BasicJsonType>\par
08259 {\cf17 struct }is_sax_static_asserts\par
08260 \{\par
08261   {\cf17 private}:\par
08262     {\cf17 static_assert}(is_basic_json<BasicJsonType>::value,\par
08263                   {\cf22 "BasicJsonType must be of type basic_json<...>"});\par
08264 \par
08265     {\cf17 using} number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
08266     {\cf17 using} number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
08267     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
08268     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
08269     {\cf17 using} binary_t = {\cf17 typename} BasicJsonType::binary_t;\par
08270     {\cf17 using} exception_t = {\cf17 typename} BasicJsonType::exception;\par
08271 \par
08272   {\cf17 public}:\par
08273     {\cf17 static_assert}(is_detected_exact<bool, null_function_t, SAX>::value,\par
08274                   {\cf22 "Missing/invalid function: bool null()"});\par
08275     {\cf17 static_assert}(is_detected_exact<bool, boolean_function_t, SAX>::value,\par
08276                   {\cf22 "Missing/invalid function: bool boolean(bool)"});\par
08277     {\cf17 static_assert}(is_detected_exact<bool, boolean_function_t, SAX>::value,\par
08278                   {\cf22 "Missing/invalid function: bool boolean(bool)"});\par
08279     {\cf17 static_assert}(\par
08280         is_detected_exact<bool, number_integer_function_t, SAX,\par
08281         number_integer_t>::value,\par
08282         {\cf22 "Missing/invalid function: bool number_integer(number_integer_t)"});\par
08283     {\cf17 static_assert}(\par
08284         is_detected_exact<bool, number_unsigned_function_t, SAX,\par
08285         number_unsigned_t>::value,\par
08286         {\cf22 "Missing/invalid function: bool number_unsigned(number_unsigned_t)"});\par
08287     {\cf17 static_assert}(is_detected_exact<bool, number_float_function_t, SAX,\par
08288                   number_float_t, string_t>::value,\par
08289                   {\cf22 "Missing/invalid function: bool number_float(number_float_t, const string_t&)"});\par
08290     {\cf17 static_assert}(\par
08291         is_detected_exact<bool, string_function_t, SAX, string_t>::value,\par
08292         {\cf22 "Missing/invalid function: bool string(string_t&)"});\par
08293     {\cf17 static_assert}(\par
08294         is_detected_exact<bool, binary_function_t, SAX, binary_t>::value,\par
08295         {\cf22 "Missing/invalid function: bool binary(binary_t&)"});\par
08296     {\cf17 static_assert}(is_detected_exact<bool, start_object_function_t, SAX>::value,\par
08297                   {\cf22 "Missing/invalid function: bool start_object(std::size_t)"});\par
08298     {\cf17 static_assert}(is_detected_exact<bool, key_function_t, SAX, string_t>::value,\par
08299                   {\cf22 "Missing/invalid function: bool key(string_t&)"});\par
08300     {\cf17 static_assert}(is_detected_exact<bool, end_object_function_t, SAX>::value,\par
08301                   {\cf22 "Missing/invalid function: bool end_object()"});\par
08302     {\cf17 static_assert}(is_detected_exact<bool, start_array_function_t, SAX>::value,\par
08303                   {\cf22 "Missing/invalid function: bool start_array(std::size_t)"});\par
08304     {\cf17 static_assert}(is_detected_exact<bool, end_array_function_t, SAX>::value,\par
08305                   {\cf22 "Missing/invalid function: bool end_array()"});\par
08306     {\cf17 static_assert}(\par
08307         is_detected_exact<bool, parse_error_function_t, SAX, exception_t>::value,\par
08308         {\cf22 "Missing/invalid function: bool parse_error(std::size_t, const "}\par
08309         {\cf22 "std::string&, const exception&)"});\par
08310 \};\par
08311 \}  {\cf20 // namespace detail}\par
08312 \}  {\cf20 // namespace nlohmann}\par
08313 \par
08314 {\cf20 // #include <nlohmann/detail/meta/type_traits.hpp>}\par
08315 \par
08316 {\cf20 // #include <nlohmann/detail/value_t.hpp>}\par
08317 \par
08318 \par
08319 {\cf17 namespace }nlohmann\par
08320 \{\par
08321 {\cf17 namespace }detail\par
08322 \{\par
08323 \par
08325 {\cf17 enum class} cbor_tag_handler_t\par
08326 \{\par
08327     error,   \par
08328     ignore,  \par
08329     store    \par
08330 \};\par
08331 \par
08339 {\cf17 static} {\cf17 inline} {\cf18 bool} little_endianess({\cf18 int} num = 1) noexcept\par
08340 \{\par
08341     {\cf19 return} *{\cf17 reinterpret_cast<}{\cf18 char}*{\cf17 >}(&num) == 1;\par
08342 \}\par
08343 \par
08344 \par
08346 {\cf20 // binary reader //}\par
08348 {\cf20 }\par
08352 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} InputAdapterType, {\cf17 typename} SAX = json_sax_dom_parser<BasicJsonType>>\par
08353 {\cf17 class }binary_reader\par
08354 \{\par
08355     {\cf17 using} number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
08356     {\cf17 using} number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
08357     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
08358     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
08359     {\cf17 using} binary_t = {\cf17 typename} BasicJsonType::binary_t;\par
08360     {\cf17 using} json_sax_t = SAX;\par
08361     {\cf17 using} char_type = {\cf17 typename} InputAdapterType::char_type;\par
08362     {\cf17 using} char_int_type = {\cf17 typename} std::char_traits<char_type>::int_type;\par
08363 \par
08364   {\cf17 public}:\par
08370     {\cf17 explicit} binary_reader(InputAdapterType&& adapter) noexcept : ia(std::move(adapter))\par
08371     \{\par
08372         (void)detail::is_sax_static_asserts<SAX, BasicJsonType> \{\};\par
08373     \}\par
08374 \par
08375     {\cf20 // make class move-only}\par
08376     binary_reader({\cf17 const} binary_reader&) = {\cf17 delete};\par
08377     binary_reader(binary_reader&&) = {\cf19 default}; {\cf20 // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)}\par
08378     binary_reader& operator=({\cf17 const} binary_reader&) = {\cf17 delete};\par
08379     binary_reader& operator=(binary_reader&&) = {\cf19 default}; {\cf20 // NOLINT(hicpp-noexcept-move,performance-noexcept-move-constructor)}\par
08380     ~binary_reader() = {\cf19 default};\par
08381 \par
08390     JSON_HEDLEY_NON_NULL(3)\par
08391     bool sax_parse(const input_format_t format,\par
08392                    json_sax_t* sax_,\par
08393                    const {\cf18 bool} strict = true,\par
08394                    const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)\par
08395     \{\par
08396         sax = sax_;\par
08397         {\cf18 bool} result = {\cf17 false};\par
08398 \par
08399         {\cf19 switch} (format)\par
08400         \{\par
08401             {\cf19 case} input_format_t::bson:\par
08402                 result = parse_bson_internal();\par
08403                 {\cf19 break};\par
08404 \par
08405             {\cf19 case} input_format_t::cbor:\par
08406                 result = parse_cbor_internal({\cf17 true}, tag_handler);\par
08407                 {\cf19 break};\par
08408 \par
08409             {\cf19 case} input_format_t::msgpack:\par
08410                 result = parse_msgpack_internal();\par
08411                 {\cf19 break};\par
08412 \par
08413             {\cf19 case} input_format_t::ubjson:\par
08414                 result = parse_ubjson_internal();\par
08415                 {\cf19 break};\par
08416 \par
08417             {\cf19 case} input_format_t::json: {\cf20 // LCOV_EXCL_LINE}\par
08418             {\cf19 default}:            {\cf20 // LCOV_EXCL_LINE}\par
08419                 JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE}\par
08420         \}\par
08421 \par
08422         {\cf20 // strict mode: next byte must be EOF}\par
08423         {\cf19 if} (result && strict)\par
08424         \{\par
08425             {\cf19 if} (format == input_format_t::ubjson)\par
08426             \{\par
08427                 get_ignore_noop();\par
08428             \}\par
08429             {\cf19 else}\par
08430             \{\par
08431                 get();\par
08432             \}\par
08433 \par
08434             {\cf19 if} (JSON_HEDLEY_UNLIKELY(current != std::char_traits<char_type>::eof()))\par
08435             \{\par
08436                 {\cf19 return} sax->parse_error(chars_read, get_token_string(),\par
08437                                         parse_error::create(110, chars_read, exception_message(format, {\cf22 "expected end of input; last byte: 0x"} + get_token_string(), {\cf22 "value"}), BasicJsonType()));\par
08438             \}\par
08439         \}\par
08440 \par
08441         {\cf19 return} result;\par
08442     \}\par
08443 \par
08444   {\cf17 private}:\par
08446     {\cf20 // BSON //}\par
08448 {\cf20 }\par
08453     {\cf18 bool} parse_bson_internal()\par
08454     \{\par
08455         std::int32_t document_size\{\};\par
08456         get_number<std::int32_t, true>(input_format_t::bson, document_size);\par
08457 \par
08458         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))\par
08459         \{\par
08460             {\cf19 return} {\cf17 false};\par
08461         \}\par
08462 \par
08463         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list({\cf20 /*is_array*/}{\cf17 false})))\par
08464         \{\par
08465             {\cf19 return} {\cf17 false};\par
08466         \}\par
08467 \par
08468         {\cf19 return} sax->end_object();\par
08469     \}\par
08470 \par
08478     {\cf18 bool} get_bson_cstr(string_t& result)\par
08479     \{\par
08480         {\cf17 auto} out = std::back_inserter(result);\par
08481         {\cf19 while} ({\cf17 true})\par
08482         \{\par
08483             get();\par
08484             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, {\cf22 "cstring"})))\par
08485             \{\par
08486                 {\cf19 return} {\cf17 false};\par
08487             \}\par
08488             {\cf19 if} (current == 0x00)\par
08489             \{\par
08490                 {\cf19 return} {\cf17 true};\par
08491             \}\par
08492             *out++ = {\cf17 static_cast<}typename string_t::value_type{\cf17 >}(current);\par
08493         \}\par
08494     \}\par
08495 \par
08507     {\cf17 template}<{\cf17 typename} NumberType>\par
08508     {\cf18 bool} get_bson_string({\cf17 const} NumberType len, string_t& result)\par
08509     \{\par
08510         {\cf19 if} (JSON_HEDLEY_UNLIKELY(len < 1))\par
08511         \{\par
08512             {\cf17 auto} last_token = get_token_string();\par
08513             {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, {\cf22 "string length must be at least 1, is "} + std::to_string(len), {\cf22 "string"}), BasicJsonType()));\par
08514         \}\par
08515 \par
08516         {\cf19 return} get_string(input_format_t::bson, len - {\cf17 static_cast<}NumberType{\cf17 >}(1), result) && get() != std::char_traits<char_type>::eof();\par
08517     \}\par
08518 \par
08528     {\cf17 template}<{\cf17 typename} NumberType>\par
08529     {\cf18 bool} get_bson_binary({\cf17 const} NumberType len, binary_t& result)\par
08530     \{\par
08531         {\cf19 if} (JSON_HEDLEY_UNLIKELY(len < 0))\par
08532         \{\par
08533             {\cf17 auto} last_token = get_token_string();\par
08534             {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::bson, {\cf22 "byte array length cannot be negative, is "} + std::to_string(len), {\cf22 "binary"}), BasicJsonType()));\par
08535         \}\par
08536 \par
08537         {\cf20 // All BSON binary values have a subtype}\par
08538         std::uint8_t subtype\{\};\par
08539         get_number<std::uint8_t>(input_format_t::bson, subtype);\par
08540         result.set_subtype(subtype);\par
08541 \par
08542         {\cf19 return} get_binary(input_format_t::bson, len, result);\par
08543     \}\par
08544 \par
08555     {\cf18 bool} parse_bson_element_internal({\cf17 const} char_int_type element_type,\par
08556                                      {\cf17 const} std::size_t element_type_parse_position)\par
08557     \{\par
08558         {\cf19 switch} (element_type)\par
08559         \{\par
08560             {\cf19 case} 0x01: {\cf20 // double}\par
08561             \{\par
08562                 {\cf18 double} number\{\};\par
08563                 {\cf19 return} get_number<double, true>(input_format_t::bson, number) && sax->number_float({\cf17 static_cast<}number_float_t{\cf17 >}(number), {\cf22 ""});\par
08564             \}\par
08565 \par
08566             {\cf19 case} 0x02: {\cf20 // string}\par
08567             \{\par
08568                 std::int32_t len\{\};\par
08569                 string_t value;\par
08570                 {\cf19 return} get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_string(len, value) && sax->string(value);\par
08571             \}\par
08572 \par
08573             {\cf19 case} 0x03: {\cf20 // object}\par
08574             \{\par
08575                 {\cf19 return} parse_bson_internal();\par
08576             \}\par
08577 \par
08578             {\cf19 case} 0x04: {\cf20 // array}\par
08579             \{\par
08580                 {\cf19 return} parse_bson_array();\par
08581             \}\par
08582 \par
08583             {\cf19 case} 0x05: {\cf20 // binary}\par
08584             \{\par
08585                 std::int32_t len\{\};\par
08586                 binary_t value;\par
08587                 {\cf19 return} get_number<std::int32_t, true>(input_format_t::bson, len) && get_bson_binary(len, value) && sax->binary(value);\par
08588             \}\par
08589 \par
08590             {\cf19 case} 0x08: {\cf20 // boolean}\par
08591             \{\par
08592                 {\cf19 return} sax->boolean(get() != 0);\par
08593             \}\par
08594 \par
08595             {\cf19 case} 0x0A: {\cf20 // null}\par
08596             \{\par
08597                 {\cf19 return} sax->null();\par
08598             \}\par
08599 \par
08600             {\cf19 case} 0x10: {\cf20 // int32}\par
08601             \{\par
08602                 std::int32_t value\{\};\par
08603                 {\cf19 return} get_number<std::int32_t, true>(input_format_t::bson, value) && sax->number_integer(value);\par
08604             \}\par
08605 \par
08606             {\cf19 case} 0x12: {\cf20 // int64}\par
08607             \{\par
08608                 std::int64_t value\{\};\par
08609                 {\cf19 return} get_number<std::int64_t, true>(input_format_t::bson, value) && sax->number_integer(value);\par
08610             \}\par
08611 \par
08612             {\cf19 default}: {\cf20 // anything else not supported (yet)}\par
08613             \{\par
08614                 std::array<char, 3> cr\{\{\}\};\par
08615                 (std::snprintf)(cr.data(), cr.size(), {\cf22 "%.2hhX"}, {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(element_type)); {\cf20 // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)}\par
08616                 {\cf19 return} sax->parse_error(element_type_parse_position, std::string(cr.data()), parse_error::create(114, element_type_parse_position, {\cf22 "Unsupported BSON record type 0x"} + std::string(cr.data()), BasicJsonType()));\par
08617             \}\par
08618         \}\par
08619     \}\par
08620 \par
08633     {\cf18 bool} parse_bson_element_list({\cf17 const} {\cf18 bool} is_array)\par
08634     \{\par
08635         string_t key;\par
08636 \par
08637         {\cf19 while} ({\cf17 auto} element_type = get())\par
08638         \{\par
08639             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::bson, {\cf22 "element list"})))\par
08640             \{\par
08641                 {\cf19 return} {\cf17 false};\par
08642             \}\par
08643 \par
08644             {\cf17 const} std::size_t element_type_parse_position = chars_read;\par
08645             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_bson_cstr(key)))\par
08646             \{\par
08647                 {\cf19 return} {\cf17 false};\par
08648             \}\par
08649 \par
08650             {\cf19 if} (!is_array && !sax->key(key))\par
08651             \{\par
08652                 {\cf19 return} {\cf17 false};\par
08653             \}\par
08654 \par
08655             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_bson_element_internal(element_type, element_type_parse_position)))\par
08656             \{\par
08657                 {\cf19 return} {\cf17 false};\par
08658             \}\par
08659 \par
08660             {\cf20 // get_bson_cstr only appends}\par
08661             key.clear();\par
08662         \}\par
08663 \par
08664         {\cf19 return} {\cf17 true};\par
08665     \}\par
08666 \par
08671     {\cf18 bool} parse_bson_array()\par
08672     \{\par
08673         std::int32_t document_size\{\};\par
08674         get_number<std::int32_t, true>(input_format_t::bson, document_size);\par
08675 \par
08676         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))\par
08677         \{\par
08678             {\cf19 return} {\cf17 false};\par
08679         \}\par
08680 \par
08681         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_bson_element_list({\cf20 /*is_array*/}{\cf17 true})))\par
08682         \{\par
08683             {\cf19 return} {\cf17 false};\par
08684         \}\par
08685 \par
08686         {\cf19 return} sax->end_array();\par
08687     \}\par
08688 \par
08690     {\cf20 // CBOR //}\par
08692 {\cf20 }\par
08701     {\cf18 bool} parse_cbor_internal({\cf17 const} {\cf18 bool} get_char,\par
08702                              {\cf17 const} cbor_tag_handler_t tag_handler)\par
08703     \{\par
08704         {\cf19 switch} (get_char ? get() : current)\par
08705         \{\par
08706             {\cf20 // EOF}\par
08707             {\cf19 case} std::char_traits<char_type>::eof():\par
08708                 return unexpect_eof(input_format_t::cbor, {\cf22 "value"});\par
08709 \par
08710             {\cf20 // Integer 0x00..0x17 (0..23)}\par
08711             {\cf19 case} 0x00:\par
08712             {\cf19 case} 0x01:\par
08713             {\cf19 case} 0x02:\par
08714             {\cf19 case} 0x03:\par
08715             {\cf19 case} 0x04:\par
08716             {\cf19 case} 0x05:\par
08717             {\cf19 case} 0x06:\par
08718             {\cf19 case} 0x07:\par
08719             {\cf19 case} 0x08:\par
08720             {\cf19 case} 0x09:\par
08721             {\cf19 case} 0x0A:\par
08722             {\cf19 case} 0x0B:\par
08723             {\cf19 case} 0x0C:\par
08724             {\cf19 case} 0x0D:\par
08725             {\cf19 case} 0x0E:\par
08726             {\cf19 case} 0x0F:\par
08727             {\cf19 case} 0x10:\par
08728             {\cf19 case} 0x11:\par
08729             {\cf19 case} 0x12:\par
08730             {\cf19 case} 0x13:\par
08731             {\cf19 case} 0x14:\par
08732             {\cf19 case} 0x15:\par
08733             {\cf19 case} 0x16:\par
08734             {\cf19 case} 0x17:\par
08735                 {\cf19 return} sax->number_unsigned({\cf17 static_cast<}number_unsigned_t{\cf17 >}(current));\par
08736 \par
08737             {\cf19 case} 0x18: {\cf20 // Unsigned integer (one-byte uint8_t follows)}\par
08738             \{\par
08739                 std::uint8_t number\{\};\par
08740                 {\cf19 return} get_number(input_format_t::cbor, number) && sax->number_unsigned(number);\par
08741             \}\par
08742 \par
08743             {\cf19 case} 0x19: {\cf20 // Unsigned integer (two-byte uint16_t follows)}\par
08744             \{\par
08745                 std::uint16_t number\{\};\par
08746                 {\cf19 return} get_number(input_format_t::cbor, number) && sax->number_unsigned(number);\par
08747             \}\par
08748 \par
08749             {\cf19 case} 0x1A: {\cf20 // Unsigned integer (four-byte uint32_t follows)}\par
08750             \{\par
08751                 std::uint32_t number\{\};\par
08752                 {\cf19 return} get_number(input_format_t::cbor, number) && sax->number_unsigned(number);\par
08753             \}\par
08754 \par
08755             {\cf19 case} 0x1B: {\cf20 // Unsigned integer (eight-byte uint64_t follows)}\par
08756             \{\par
08757                 std::uint64_t number\{\};\par
08758                 {\cf19 return} get_number(input_format_t::cbor, number) && sax->number_unsigned(number);\par
08759             \}\par
08760 \par
08761             {\cf20 // Negative integer -1-0x00..-1-0x17 (-1..-24)}\par
08762             {\cf19 case} 0x20:\par
08763             {\cf19 case} 0x21:\par
08764             {\cf19 case} 0x22:\par
08765             {\cf19 case} 0x23:\par
08766             {\cf19 case} 0x24:\par
08767             {\cf19 case} 0x25:\par
08768             {\cf19 case} 0x26:\par
08769             {\cf19 case} 0x27:\par
08770             {\cf19 case} 0x28:\par
08771             {\cf19 case} 0x29:\par
08772             {\cf19 case} 0x2A:\par
08773             {\cf19 case} 0x2B:\par
08774             {\cf19 case} 0x2C:\par
08775             {\cf19 case} 0x2D:\par
08776             {\cf19 case} 0x2E:\par
08777             {\cf19 case} 0x2F:\par
08778             {\cf19 case} 0x30:\par
08779             {\cf19 case} 0x31:\par
08780             {\cf19 case} 0x32:\par
08781             {\cf19 case} 0x33:\par
08782             {\cf19 case} 0x34:\par
08783             {\cf19 case} 0x35:\par
08784             {\cf19 case} 0x36:\par
08785             {\cf19 case} 0x37:\par
08786                 {\cf19 return} sax->number_integer({\cf17 static_cast<}std::int8_t{\cf17 >}(0x20 - 1 - current));\par
08787 \par
08788             {\cf19 case} 0x38: {\cf20 // Negative integer (one-byte uint8_t follows)}\par
08789             \{\par
08790                 std::uint8_t number\{\};\par
08791                 {\cf19 return} get_number(input_format_t::cbor, number) && sax->number_integer({\cf17 static_cast<}number_integer_t{\cf17 >}(-1) - number);\par
08792             \}\par
08793 \par
08794             {\cf19 case} 0x39: {\cf20 // Negative integer -1-n (two-byte uint16_t follows)}\par
08795             \{\par
08796                 std::uint16_t number\{\};\par
08797                 {\cf19 return} get_number(input_format_t::cbor, number) && sax->number_integer({\cf17 static_cast<}number_integer_t{\cf17 >}(-1) - number);\par
08798             \}\par
08799 \par
08800             {\cf19 case} 0x3A: {\cf20 // Negative integer -1-n (four-byte uint32_t follows)}\par
08801             \{\par
08802                 std::uint32_t number\{\};\par
08803                 {\cf19 return} get_number(input_format_t::cbor, number) && sax->number_integer({\cf17 static_cast<}number_integer_t{\cf17 >}(-1) - number);\par
08804             \}\par
08805 \par
08806             {\cf19 case} 0x3B: {\cf20 // Negative integer -1-n (eight-byte uint64_t follows)}\par
08807             \{\par
08808                 std::uint64_t number\{\};\par
08809                 {\cf19 return} get_number(input_format_t::cbor, number) && sax->number_integer({\cf17 static_cast<}number_integer_t{\cf17 >}(-1)\par
08810                         - {\cf17 static_cast<}number_integer_t{\cf17 >}(number));\par
08811             \}\par
08812 \par
08813             {\cf20 // Binary data (0x00..0x17 bytes follow)}\par
08814             {\cf19 case} 0x40:\par
08815             {\cf19 case} 0x41:\par
08816             {\cf19 case} 0x42:\par
08817             {\cf19 case} 0x43:\par
08818             {\cf19 case} 0x44:\par
08819             {\cf19 case} 0x45:\par
08820             {\cf19 case} 0x46:\par
08821             {\cf19 case} 0x47:\par
08822             {\cf19 case} 0x48:\par
08823             {\cf19 case} 0x49:\par
08824             {\cf19 case} 0x4A:\par
08825             {\cf19 case} 0x4B:\par
08826             {\cf19 case} 0x4C:\par
08827             {\cf19 case} 0x4D:\par
08828             {\cf19 case} 0x4E:\par
08829             {\cf19 case} 0x4F:\par
08830             {\cf19 case} 0x50:\par
08831             {\cf19 case} 0x51:\par
08832             {\cf19 case} 0x52:\par
08833             {\cf19 case} 0x53:\par
08834             {\cf19 case} 0x54:\par
08835             {\cf19 case} 0x55:\par
08836             {\cf19 case} 0x56:\par
08837             {\cf19 case} 0x57:\par
08838             {\cf19 case} 0x58: {\cf20 // Binary data (one-byte uint8_t for n follows)}\par
08839             {\cf19 case} 0x59: {\cf20 // Binary data (two-byte uint16_t for n follow)}\par
08840             {\cf19 case} 0x5A: {\cf20 // Binary data (four-byte uint32_t for n follow)}\par
08841             {\cf19 case} 0x5B: {\cf20 // Binary data (eight-byte uint64_t for n follow)}\par
08842             {\cf19 case} 0x5F: {\cf20 // Binary data (indefinite length)}\par
08843             \{\par
08844                 binary_t b;\par
08845                 {\cf19 return} get_cbor_binary(b) && sax->binary(b);\par
08846             \}\par
08847 \par
08848             {\cf20 // UTF-8 string (0x00..0x17 bytes follow)}\par
08849             {\cf19 case} 0x60:\par
08850             {\cf19 case} 0x61:\par
08851             {\cf19 case} 0x62:\par
08852             {\cf19 case} 0x63:\par
08853             {\cf19 case} 0x64:\par
08854             {\cf19 case} 0x65:\par
08855             {\cf19 case} 0x66:\par
08856             {\cf19 case} 0x67:\par
08857             {\cf19 case} 0x68:\par
08858             {\cf19 case} 0x69:\par
08859             {\cf19 case} 0x6A:\par
08860             {\cf19 case} 0x6B:\par
08861             {\cf19 case} 0x6C:\par
08862             {\cf19 case} 0x6D:\par
08863             {\cf19 case} 0x6E:\par
08864             {\cf19 case} 0x6F:\par
08865             {\cf19 case} 0x70:\par
08866             {\cf19 case} 0x71:\par
08867             {\cf19 case} 0x72:\par
08868             {\cf19 case} 0x73:\par
08869             {\cf19 case} 0x74:\par
08870             {\cf19 case} 0x75:\par
08871             {\cf19 case} 0x76:\par
08872             {\cf19 case} 0x77:\par
08873             {\cf19 case} 0x78: {\cf20 // UTF-8 string (one-byte uint8_t for n follows)}\par
08874             {\cf19 case} 0x79: {\cf20 // UTF-8 string (two-byte uint16_t for n follow)}\par
08875             {\cf19 case} 0x7A: {\cf20 // UTF-8 string (four-byte uint32_t for n follow)}\par
08876             {\cf19 case} 0x7B: {\cf20 // UTF-8 string (eight-byte uint64_t for n follow)}\par
08877             {\cf19 case} 0x7F: {\cf20 // UTF-8 string (indefinite length)}\par
08878             \{\par
08879                 string_t s;\par
08880                 {\cf19 return} get_cbor_string(s) && sax->string(s);\par
08881             \}\par
08882 \par
08883             {\cf20 // array (0x00..0x17 data items follow)}\par
08884             {\cf19 case} 0x80:\par
08885             {\cf19 case} 0x81:\par
08886             {\cf19 case} 0x82:\par
08887             {\cf19 case} 0x83:\par
08888             {\cf19 case} 0x84:\par
08889             {\cf19 case} 0x85:\par
08890             {\cf19 case} 0x86:\par
08891             {\cf19 case} 0x87:\par
08892             {\cf19 case} 0x88:\par
08893             {\cf19 case} 0x89:\par
08894             {\cf19 case} 0x8A:\par
08895             {\cf19 case} 0x8B:\par
08896             {\cf19 case} 0x8C:\par
08897             {\cf19 case} 0x8D:\par
08898             {\cf19 case} 0x8E:\par
08899             {\cf19 case} 0x8F:\par
08900             {\cf19 case} 0x90:\par
08901             {\cf19 case} 0x91:\par
08902             {\cf19 case} 0x92:\par
08903             {\cf19 case} 0x93:\par
08904             {\cf19 case} 0x94:\par
08905             {\cf19 case} 0x95:\par
08906             {\cf19 case} 0x96:\par
08907             {\cf19 case} 0x97:\par
08908                 {\cf19 return} get_cbor_array({\cf17 static_cast<}std::size_t{\cf17 >}({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(current) & 0x1Fu), tag_handler);\par
08909 \par
08910             {\cf19 case} 0x98: {\cf20 // array (one-byte uint8_t for n follows)}\par
08911             \{\par
08912                 std::uint8_t len\{\};\par
08913                 {\cf19 return} get_number(input_format_t::cbor, len) && get_cbor_array({\cf17 static_cast<}std::size_t{\cf17 >}(len), tag_handler);\par
08914             \}\par
08915 \par
08916             {\cf19 case} 0x99: {\cf20 // array (two-byte uint16_t for n follow)}\par
08917             \{\par
08918                 std::uint16_t len\{\};\par
08919                 {\cf19 return} get_number(input_format_t::cbor, len) && get_cbor_array({\cf17 static_cast<}std::size_t{\cf17 >}(len), tag_handler);\par
08920             \}\par
08921 \par
08922             {\cf19 case} 0x9A: {\cf20 // array (four-byte uint32_t for n follow)}\par
08923             \{\par
08924                 std::uint32_t len\{\};\par
08925                 {\cf19 return} get_number(input_format_t::cbor, len) && get_cbor_array({\cf17 static_cast<}std::size_t{\cf17 >}(len), tag_handler);\par
08926             \}\par
08927 \par
08928             {\cf19 case} 0x9B: {\cf20 // array (eight-byte uint64_t for n follow)}\par
08929             \{\par
08930                 std::uint64_t len\{\};\par
08931                 {\cf19 return} get_number(input_format_t::cbor, len) && get_cbor_array(detail::conditional_static_cast<std::size_t>(len), tag_handler);\par
08932             \}\par
08933 \par
08934             {\cf19 case} 0x9F: {\cf20 // array (indefinite length)}\par
08935                 {\cf19 return} get_cbor_array(std::size_t(-1), tag_handler);\par
08936 \par
08937             {\cf20 // map (0x00..0x17 pairs of data items follow)}\par
08938             {\cf19 case} 0xA0:\par
08939             {\cf19 case} 0xA1:\par
08940             {\cf19 case} 0xA2:\par
08941             {\cf19 case} 0xA3:\par
08942             {\cf19 case} 0xA4:\par
08943             {\cf19 case} 0xA5:\par
08944             {\cf19 case} 0xA6:\par
08945             {\cf19 case} 0xA7:\par
08946             {\cf19 case} 0xA8:\par
08947             {\cf19 case} 0xA9:\par
08948             {\cf19 case} 0xAA:\par
08949             {\cf19 case} 0xAB:\par
08950             {\cf19 case} 0xAC:\par
08951             {\cf19 case} 0xAD:\par
08952             {\cf19 case} 0xAE:\par
08953             {\cf19 case} 0xAF:\par
08954             {\cf19 case} 0xB0:\par
08955             {\cf19 case} 0xB1:\par
08956             {\cf19 case} 0xB2:\par
08957             {\cf19 case} 0xB3:\par
08958             {\cf19 case} 0xB4:\par
08959             {\cf19 case} 0xB5:\par
08960             {\cf19 case} 0xB6:\par
08961             {\cf19 case} 0xB7:\par
08962                 {\cf19 return} get_cbor_object({\cf17 static_cast<}std::size_t{\cf17 >}({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(current) & 0x1Fu), tag_handler);\par
08963 \par
08964             {\cf19 case} 0xB8: {\cf20 // map (one-byte uint8_t for n follows)}\par
08965             \{\par
08966                 std::uint8_t len\{\};\par
08967                 {\cf19 return} get_number(input_format_t::cbor, len) && get_cbor_object({\cf17 static_cast<}std::size_t{\cf17 >}(len), tag_handler);\par
08968             \}\par
08969 \par
08970             {\cf19 case} 0xB9: {\cf20 // map (two-byte uint16_t for n follow)}\par
08971             \{\par
08972                 std::uint16_t len\{\};\par
08973                 {\cf19 return} get_number(input_format_t::cbor, len) && get_cbor_object({\cf17 static_cast<}std::size_t{\cf17 >}(len), tag_handler);\par
08974             \}\par
08975 \par
08976             {\cf19 case} 0xBA: {\cf20 // map (four-byte uint32_t for n follow)}\par
08977             \{\par
08978                 std::uint32_t len\{\};\par
08979                 {\cf19 return} get_number(input_format_t::cbor, len) && get_cbor_object({\cf17 static_cast<}std::size_t{\cf17 >}(len), tag_handler);\par
08980             \}\par
08981 \par
08982             {\cf19 case} 0xBB: {\cf20 // map (eight-byte uint64_t for n follow)}\par
08983             \{\par
08984                 std::uint64_t len\{\};\par
08985                 {\cf19 return} get_number(input_format_t::cbor, len) && get_cbor_object(detail::conditional_static_cast<std::size_t>(len), tag_handler);\par
08986             \}\par
08987 \par
08988             {\cf19 case} 0xBF: {\cf20 // map (indefinite length)}\par
08989                 {\cf19 return} get_cbor_object(std::size_t(-1), tag_handler);\par
08990 \par
08991             {\cf19 case} 0xC6: {\cf20 // tagged item}\par
08992             {\cf19 case} 0xC7:\par
08993             {\cf19 case} 0xC8:\par
08994             {\cf19 case} 0xC9:\par
08995             {\cf19 case} 0xCA:\par
08996             {\cf19 case} 0xCB:\par
08997             {\cf19 case} 0xCC:\par
08998             {\cf19 case} 0xCD:\par
08999             {\cf19 case} 0xCE:\par
09000             {\cf19 case} 0xCF:\par
09001             {\cf19 case} 0xD0:\par
09002             {\cf19 case} 0xD1:\par
09003             {\cf19 case} 0xD2:\par
09004             {\cf19 case} 0xD3:\par
09005             {\cf19 case} 0xD4:\par
09006             {\cf19 case} 0xD8: {\cf20 // tagged item (1 bytes follow)}\par
09007             {\cf19 case} 0xD9: {\cf20 // tagged item (2 bytes follow)}\par
09008             {\cf19 case} 0xDA: {\cf20 // tagged item (4 bytes follow)}\par
09009             {\cf19 case} 0xDB: {\cf20 // tagged item (8 bytes follow)}\par
09010             \{\par
09011                 {\cf19 switch} (tag_handler)\par
09012                 \{\par
09013                     {\cf19 case} cbor_tag_handler_t::error:\par
09014                     \{\par
09015                         {\cf17 auto} last_token = get_token_string();\par
09016                         {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, {\cf22 "invalid byte: 0x"} + last_token, {\cf22 "value"}), BasicJsonType()));\par
09017                     \}\par
09018 \par
09019                     {\cf19 case} cbor_tag_handler_t::ignore:\par
09020                     \{\par
09021                         {\cf20 // ignore binary subtype}\par
09022                         {\cf19 switch} (current)\par
09023                         \{\par
09024                             {\cf19 case} 0xD8:\par
09025                             \{\par
09026                                 std::uint8_t subtype_to_ignore\{\};\par
09027                                 get_number(input_format_t::cbor, subtype_to_ignore);\par
09028                                 {\cf19 break};\par
09029                             \}\par
09030                             {\cf19 case} 0xD9:\par
09031                             \{\par
09032                                 std::uint16_t subtype_to_ignore\{\};\par
09033                                 get_number(input_format_t::cbor, subtype_to_ignore);\par
09034                                 {\cf19 break};\par
09035                             \}\par
09036                             {\cf19 case} 0xDA:\par
09037                             \{\par
09038                                 std::uint32_t subtype_to_ignore\{\};\par
09039                                 get_number(input_format_t::cbor, subtype_to_ignore);\par
09040                                 {\cf19 break};\par
09041                             \}\par
09042                             {\cf19 case} 0xDB:\par
09043                             \{\par
09044                                 std::uint64_t subtype_to_ignore\{\};\par
09045                                 get_number(input_format_t::cbor, subtype_to_ignore);\par
09046                                 {\cf19 break};\par
09047                             \}\par
09048                             {\cf19 default}:\par
09049                                 {\cf19 break};\par
09050                         \}\par
09051                         {\cf19 return} parse_cbor_internal({\cf17 true}, tag_handler);\par
09052                     \}\par
09053 \par
09054                     {\cf19 case} cbor_tag_handler_t::store:\par
09055                     \{\par
09056                         binary_t b;\par
09057                         {\cf20 // use binary subtype and store in binary container}\par
09058                         {\cf19 switch} (current)\par
09059                         \{\par
09060                             {\cf19 case} 0xD8:\par
09061                             \{\par
09062                                 std::uint8_t subtype\{\};\par
09063                                 get_number(input_format_t::cbor, subtype);\par
09064                                 b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));\par
09065                                 {\cf19 break};\par
09066                             \}\par
09067                             {\cf19 case} 0xD9:\par
09068                             \{\par
09069                                 std::uint16_t subtype\{\};\par
09070                                 get_number(input_format_t::cbor, subtype);\par
09071                                 b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));\par
09072                                 {\cf19 break};\par
09073                             \}\par
09074                             {\cf19 case} 0xDA:\par
09075                             \{\par
09076                                 std::uint32_t subtype\{\};\par
09077                                 get_number(input_format_t::cbor, subtype);\par
09078                                 b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));\par
09079                                 {\cf19 break};\par
09080                             \}\par
09081                             {\cf19 case} 0xDB:\par
09082                             \{\par
09083                                 std::uint64_t subtype\{\};\par
09084                                 get_number(input_format_t::cbor, subtype);\par
09085                                 b.set_subtype(detail::conditional_static_cast<typename binary_t::subtype_type>(subtype));\par
09086                                 {\cf19 break};\par
09087                             \}\par
09088                             {\cf19 default}:\par
09089                                 {\cf19 return} parse_cbor_internal({\cf17 true}, tag_handler);\par
09090                         \}\par
09091                         get();\par
09092                         {\cf19 return} get_cbor_binary(b) && sax->binary(b);\par
09093                     \}\par
09094 \par
09095                     {\cf19 default}:                 {\cf20 // LCOV_EXCL_LINE}\par
09096                         JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE}\par
09097                         {\cf19 return} {\cf17 false};        {\cf20 // LCOV_EXCL_LINE}\par
09098                 \}\par
09099             \}\par
09100 \par
09101             {\cf19 case} 0xF4: {\cf20 // false}\par
09102                 {\cf19 return} sax->boolean({\cf17 false});\par
09103 \par
09104             {\cf19 case} 0xF5: {\cf20 // true}\par
09105                 {\cf19 return} sax->boolean({\cf17 true});\par
09106 \par
09107             {\cf19 case} 0xF6: {\cf20 // null}\par
09108                 {\cf19 return} sax->null();\par
09109 \par
09110             {\cf19 case} 0xF9: {\cf20 // Half-Precision Float (two-byte IEEE 754)}\par
09111             \{\par
09112                 {\cf17 const} {\cf17 auto} byte1_raw = get();\par
09113                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, {\cf22 "number"})))\par
09114                 \{\par
09115                     {\cf19 return} {\cf17 false};\par
09116                 \}\par
09117                 {\cf17 const} {\cf17 auto} byte2_raw = get();\par
09118                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, {\cf22 "number"})))\par
09119                 \{\par
09120                     {\cf19 return} {\cf17 false};\par
09121                 \}\par
09122 \par
09123                 {\cf17 const} {\cf17 auto} byte1 = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(byte1_raw);\par
09124                 {\cf17 const} {\cf17 auto} byte2 = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(byte2_raw);\par
09125 \par
09126                 {\cf20 // code from RFC 7049, Appendix D, Figure 3:}\par
09127                 {\cf20 // As half-precision floating-point numbers were only added}\par
09128                 {\cf20 // to IEEE 754 in 2008, today's programming platforms often}\par
09129                 {\cf20 // still only have limited support for them. It is very}\par
09130                 {\cf20 // easy to include at least decoding support for them even}\par
09131                 {\cf20 // without such support. An example of a small decoder for}\par
09132                 {\cf20 // half-precision floating-point numbers in the C language}\par
09133                 {\cf20 // is shown in Fig. 3.}\par
09134                 {\cf17 const} {\cf17 auto} half = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}((byte1 << 8u) + byte2);\par
09135                 {\cf17 const} {\cf18 double} val = [&half]\par
09136                 \{\par
09137                     {\cf17 const} {\cf18 int} exp = (half >> 10u) & 0x1Fu;\par
09138                     {\cf17 const} {\cf18 unsigned} {\cf18 int} mant = half & 0x3FFu;\par
09139                     JSON_ASSERT(0 <= exp&& exp <= 32);\par
09140                     JSON_ASSERT(mant <= 1024);\par
09141                     {\cf19 switch} (exp)\par
09142                     \{\par
09143                         {\cf19 case} 0:\par
09144                             {\cf19 return} std::ldexp(mant, -24);\par
09145                         {\cf19 case} 31:\par
09146                             {\cf19 return} (mant == 0)\par
09147                             ? std::numeric_limits<double>::infinity()\par
09148                             : std::numeric_limits<double>::quiet_NaN();\par
09149                         {\cf19 default}:\par
09150                             {\cf19 return} std::ldexp(mant + 1024, exp - 25);\par
09151                     \}\par
09152                 \}();\par
09153                 {\cf19 return} sax->number_float((half & 0x8000u) != 0\par
09154                                          ? {\cf17 static_cast<}number_float_t{\cf17 >}(-val)\par
09155                                          : {\cf17 static_cast<}number_float_t{\cf17 >}(val), {\cf22 ""});\par
09156             \}\par
09157 \par
09158             {\cf19 case} 0xFA: {\cf20 // Single-Precision Float (four-byte IEEE 754)}\par
09159             \{\par
09160                 {\cf18 float} number\{\};\par
09161                 {\cf19 return} get_number(input_format_t::cbor, number) && sax->number_float({\cf17 static_cast<}number_float_t{\cf17 >}(number), {\cf22 ""});\par
09162             \}\par
09163 \par
09164             {\cf19 case} 0xFB: {\cf20 // Double-Precision Float (eight-byte IEEE 754)}\par
09165             \{\par
09166                 {\cf18 double} number\{\};\par
09167                 {\cf19 return} get_number(input_format_t::cbor, number) && sax->number_float({\cf17 static_cast<}number_float_t{\cf17 >}(number), {\cf22 ""});\par
09168             \}\par
09169 \par
09170             {\cf19 default}: {\cf20 // anything else (0xFF is handled inside the other types)}\par
09171             \{\par
09172                 {\cf17 auto} last_token = get_token_string();\par
09173                 {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::cbor, {\cf22 "invalid byte: 0x"} + last_token, {\cf22 "value"}), BasicJsonType()));\par
09174             \}\par
09175         \}\par
09176     \}\par
09177 \par
09189     {\cf18 bool} get_cbor_string(string_t& result)\par
09190     \{\par
09191         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, {\cf22 "string"})))\par
09192         \{\par
09193             {\cf19 return} {\cf17 false};\par
09194         \}\par
09195 \par
09196         {\cf19 switch} (current)\par
09197         \{\par
09198             {\cf20 // UTF-8 string (0x00..0x17 bytes follow)}\par
09199             {\cf19 case} 0x60:\par
09200             {\cf19 case} 0x61:\par
09201             {\cf19 case} 0x62:\par
09202             {\cf19 case} 0x63:\par
09203             {\cf19 case} 0x64:\par
09204             {\cf19 case} 0x65:\par
09205             {\cf19 case} 0x66:\par
09206             {\cf19 case} 0x67:\par
09207             {\cf19 case} 0x68:\par
09208             {\cf19 case} 0x69:\par
09209             {\cf19 case} 0x6A:\par
09210             {\cf19 case} 0x6B:\par
09211             {\cf19 case} 0x6C:\par
09212             {\cf19 case} 0x6D:\par
09213             {\cf19 case} 0x6E:\par
09214             {\cf19 case} 0x6F:\par
09215             {\cf19 case} 0x70:\par
09216             {\cf19 case} 0x71:\par
09217             {\cf19 case} 0x72:\par
09218             {\cf19 case} 0x73:\par
09219             {\cf19 case} 0x74:\par
09220             {\cf19 case} 0x75:\par
09221             {\cf19 case} 0x76:\par
09222             {\cf19 case} 0x77:\par
09223             \{\par
09224                 {\cf19 return} get_string(input_format_t::cbor, {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(current) & 0x1Fu, result);\par
09225             \}\par
09226 \par
09227             {\cf19 case} 0x78: {\cf20 // UTF-8 string (one-byte uint8_t for n follows)}\par
09228             \{\par
09229                 std::uint8_t len\{\};\par
09230                 {\cf19 return} get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);\par
09231             \}\par
09232 \par
09233             {\cf19 case} 0x79: {\cf20 // UTF-8 string (two-byte uint16_t for n follow)}\par
09234             \{\par
09235                 std::uint16_t len\{\};\par
09236                 {\cf19 return} get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);\par
09237             \}\par
09238 \par
09239             {\cf19 case} 0x7A: {\cf20 // UTF-8 string (four-byte uint32_t for n follow)}\par
09240             \{\par
09241                 std::uint32_t len\{\};\par
09242                 {\cf19 return} get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);\par
09243             \}\par
09244 \par
09245             {\cf19 case} 0x7B: {\cf20 // UTF-8 string (eight-byte uint64_t for n follow)}\par
09246             \{\par
09247                 std::uint64_t len\{\};\par
09248                 {\cf19 return} get_number(input_format_t::cbor, len) && get_string(input_format_t::cbor, len, result);\par
09249             \}\par
09250 \par
09251             {\cf19 case} 0x7F: {\cf20 // UTF-8 string (indefinite length)}\par
09252             \{\par
09253                 {\cf19 while} (get() != 0xFF)\par
09254                 \{\par
09255                     string_t chunk;\par
09256                     {\cf19 if} (!get_cbor_string(chunk))\par
09257                     \{\par
09258                         {\cf19 return} {\cf17 false};\par
09259                     \}\par
09260                     result.append(chunk);\par
09261                 \}\par
09262                 {\cf19 return} {\cf17 true};\par
09263             \}\par
09264 \par
09265             {\cf19 default}:\par
09266             \{\par
09267                 {\cf17 auto} last_token = get_token_string();\par
09268                 {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, {\cf22 "expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0x"} + last_token, {\cf22 "string"}), BasicJsonType()));\par
09269             \}\par
09270         \}\par
09271     \}\par
09272 \par
09284     {\cf18 bool} get_cbor_binary(binary_t& result)\par
09285     \{\par
09286         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::cbor, {\cf22 "binary"})))\par
09287         \{\par
09288             {\cf19 return} {\cf17 false};\par
09289         \}\par
09290 \par
09291         {\cf19 switch} (current)\par
09292         \{\par
09293             {\cf20 // Binary data (0x00..0x17 bytes follow)}\par
09294             {\cf19 case} 0x40:\par
09295             {\cf19 case} 0x41:\par
09296             {\cf19 case} 0x42:\par
09297             {\cf19 case} 0x43:\par
09298             {\cf19 case} 0x44:\par
09299             {\cf19 case} 0x45:\par
09300             {\cf19 case} 0x46:\par
09301             {\cf19 case} 0x47:\par
09302             {\cf19 case} 0x48:\par
09303             {\cf19 case} 0x49:\par
09304             {\cf19 case} 0x4A:\par
09305             {\cf19 case} 0x4B:\par
09306             {\cf19 case} 0x4C:\par
09307             {\cf19 case} 0x4D:\par
09308             {\cf19 case} 0x4E:\par
09309             {\cf19 case} 0x4F:\par
09310             {\cf19 case} 0x50:\par
09311             {\cf19 case} 0x51:\par
09312             {\cf19 case} 0x52:\par
09313             {\cf19 case} 0x53:\par
09314             {\cf19 case} 0x54:\par
09315             {\cf19 case} 0x55:\par
09316             {\cf19 case} 0x56:\par
09317             {\cf19 case} 0x57:\par
09318             \{\par
09319                 {\cf19 return} get_binary(input_format_t::cbor, {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(current) & 0x1Fu, result);\par
09320             \}\par
09321 \par
09322             {\cf19 case} 0x58: {\cf20 // Binary data (one-byte uint8_t for n follows)}\par
09323             \{\par
09324                 std::uint8_t len\{\};\par
09325                 {\cf19 return} get_number(input_format_t::cbor, len) &&\par
09326                        get_binary(input_format_t::cbor, len, result);\par
09327             \}\par
09328 \par
09329             {\cf19 case} 0x59: {\cf20 // Binary data (two-byte uint16_t for n follow)}\par
09330             \{\par
09331                 std::uint16_t len\{\};\par
09332                 {\cf19 return} get_number(input_format_t::cbor, len) &&\par
09333                        get_binary(input_format_t::cbor, len, result);\par
09334             \}\par
09335 \par
09336             {\cf19 case} 0x5A: {\cf20 // Binary data (four-byte uint32_t for n follow)}\par
09337             \{\par
09338                 std::uint32_t len\{\};\par
09339                 {\cf19 return} get_number(input_format_t::cbor, len) &&\par
09340                        get_binary(input_format_t::cbor, len, result);\par
09341             \}\par
09342 \par
09343             {\cf19 case} 0x5B: {\cf20 // Binary data (eight-byte uint64_t for n follow)}\par
09344             \{\par
09345                 std::uint64_t len\{\};\par
09346                 {\cf19 return} get_number(input_format_t::cbor, len) &&\par
09347                        get_binary(input_format_t::cbor, len, result);\par
09348             \}\par
09349 \par
09350             {\cf19 case} 0x5F: {\cf20 // Binary data (indefinite length)}\par
09351             \{\par
09352                 {\cf19 while} (get() != 0xFF)\par
09353                 \{\par
09354                     binary_t chunk;\par
09355                     {\cf19 if} (!get_cbor_binary(chunk))\par
09356                     \{\par
09357                         {\cf19 return} {\cf17 false};\par
09358                     \}\par
09359                     result.insert(result.end(), chunk.begin(), chunk.end());\par
09360                 \}\par
09361                 {\cf19 return} {\cf17 true};\par
09362             \}\par
09363 \par
09364             {\cf19 default}:\par
09365             \{\par
09366                 {\cf17 auto} last_token = get_token_string();\par
09367                 {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::cbor, {\cf22 "expected length specification (0x40-0x5B) or indefinite binary array type (0x5F); last byte: 0x"} + last_token, {\cf22 "binary"}), BasicJsonType()));\par
09368             \}\par
09369         \}\par
09370     \}\par
09371 \par
09378     {\cf18 bool} get_cbor_array({\cf17 const} std::size_t len,\par
09379                         {\cf17 const} cbor_tag_handler_t tag_handler)\par
09380     \{\par
09381         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))\par
09382         \{\par
09383             {\cf19 return} {\cf17 false};\par
09384         \}\par
09385 \par
09386         {\cf19 if} (len != std::size_t(-1))\par
09387         \{\par
09388             {\cf19 for} (std::size_t i = 0; i < len; ++i)\par
09389             \{\par
09390                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal({\cf17 true}, tag_handler)))\par
09391                 \{\par
09392                     {\cf19 return} {\cf17 false};\par
09393                 \}\par
09394             \}\par
09395         \}\par
09396         {\cf19 else}\par
09397         \{\par
09398             {\cf19 while} (get() != 0xFF)\par
09399             \{\par
09400                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal({\cf17 false}, tag_handler)))\par
09401                 \{\par
09402                     {\cf19 return} {\cf17 false};\par
09403                 \}\par
09404             \}\par
09405         \}\par
09406 \par
09407         {\cf19 return} sax->end_array();\par
09408     \}\par
09409 \par
09416     {\cf18 bool} get_cbor_object({\cf17 const} std::size_t len,\par
09417                          {\cf17 const} cbor_tag_handler_t tag_handler)\par
09418     \{\par
09419         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))\par
09420         \{\par
09421             {\cf19 return} {\cf17 false};\par
09422         \}\par
09423 \par
09424         {\cf19 if} (len != 0)\par
09425         \{\par
09426             string_t key;\par
09427             {\cf19 if} (len != std::size_t(-1))\par
09428             \{\par
09429                 {\cf19 for} (std::size_t i = 0; i < len; ++i)\par
09430                 \{\par
09431                     get();\par
09432                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))\par
09433                     \{\par
09434                         {\cf19 return} {\cf17 false};\par
09435                     \}\par
09436 \par
09437                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal({\cf17 true}, tag_handler)))\par
09438                     \{\par
09439                         {\cf19 return} {\cf17 false};\par
09440                     \}\par
09441                     key.clear();\par
09442                 \}\par
09443             \}\par
09444             {\cf19 else}\par
09445             \{\par
09446                 {\cf19 while} (get() != 0xFF)\par
09447                 \{\par
09448                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_cbor_string(key) || !sax->key(key)))\par
09449                     \{\par
09450                         {\cf19 return} {\cf17 false};\par
09451                     \}\par
09452 \par
09453                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_cbor_internal({\cf17 true}, tag_handler)))\par
09454                     \{\par
09455                         {\cf19 return} {\cf17 false};\par
09456                     \}\par
09457                     key.clear();\par
09458                 \}\par
09459             \}\par
09460         \}\par
09461 \par
09462         {\cf19 return} sax->end_object();\par
09463     \}\par
09464 \par
09466     {\cf20 // MsgPack //}\par
09468 {\cf20 }\par
09472     {\cf18 bool} parse_msgpack_internal()\par
09473     \{\par
09474         {\cf19 switch} (get())\par
09475         \{\par
09476             {\cf20 // EOF}\par
09477             {\cf19 case} std::char_traits<char_type>::eof():\par
09478                 return unexpect_eof(input_format_t::msgpack, {\cf22 "value"});\par
09479 \par
09480             {\cf20 // positive fixint}\par
09481             {\cf19 case} 0x00:\par
09482             {\cf19 case} 0x01:\par
09483             {\cf19 case} 0x02:\par
09484             {\cf19 case} 0x03:\par
09485             {\cf19 case} 0x04:\par
09486             {\cf19 case} 0x05:\par
09487             {\cf19 case} 0x06:\par
09488             {\cf19 case} 0x07:\par
09489             {\cf19 case} 0x08:\par
09490             {\cf19 case} 0x09:\par
09491             {\cf19 case} 0x0A:\par
09492             {\cf19 case} 0x0B:\par
09493             {\cf19 case} 0x0C:\par
09494             {\cf19 case} 0x0D:\par
09495             {\cf19 case} 0x0E:\par
09496             {\cf19 case} 0x0F:\par
09497             {\cf19 case} 0x10:\par
09498             {\cf19 case} 0x11:\par
09499             {\cf19 case} 0x12:\par
09500             {\cf19 case} 0x13:\par
09501             {\cf19 case} 0x14:\par
09502             {\cf19 case} 0x15:\par
09503             {\cf19 case} 0x16:\par
09504             {\cf19 case} 0x17:\par
09505             {\cf19 case} 0x18:\par
09506             {\cf19 case} 0x19:\par
09507             {\cf19 case} 0x1A:\par
09508             {\cf19 case} 0x1B:\par
09509             {\cf19 case} 0x1C:\par
09510             {\cf19 case} 0x1D:\par
09511             {\cf19 case} 0x1E:\par
09512             {\cf19 case} 0x1F:\par
09513             {\cf19 case} 0x20:\par
09514             {\cf19 case} 0x21:\par
09515             {\cf19 case} 0x22:\par
09516             {\cf19 case} 0x23:\par
09517             {\cf19 case} 0x24:\par
09518             {\cf19 case} 0x25:\par
09519             {\cf19 case} 0x26:\par
09520             {\cf19 case} 0x27:\par
09521             {\cf19 case} 0x28:\par
09522             {\cf19 case} 0x29:\par
09523             {\cf19 case} 0x2A:\par
09524             {\cf19 case} 0x2B:\par
09525             {\cf19 case} 0x2C:\par
09526             {\cf19 case} 0x2D:\par
09527             {\cf19 case} 0x2E:\par
09528             {\cf19 case} 0x2F:\par
09529             {\cf19 case} 0x30:\par
09530             {\cf19 case} 0x31:\par
09531             {\cf19 case} 0x32:\par
09532             {\cf19 case} 0x33:\par
09533             {\cf19 case} 0x34:\par
09534             {\cf19 case} 0x35:\par
09535             {\cf19 case} 0x36:\par
09536             {\cf19 case} 0x37:\par
09537             {\cf19 case} 0x38:\par
09538             {\cf19 case} 0x39:\par
09539             {\cf19 case} 0x3A:\par
09540             {\cf19 case} 0x3B:\par
09541             {\cf19 case} 0x3C:\par
09542             {\cf19 case} 0x3D:\par
09543             {\cf19 case} 0x3E:\par
09544             {\cf19 case} 0x3F:\par
09545             {\cf19 case} 0x40:\par
09546             {\cf19 case} 0x41:\par
09547             {\cf19 case} 0x42:\par
09548             {\cf19 case} 0x43:\par
09549             {\cf19 case} 0x44:\par
09550             {\cf19 case} 0x45:\par
09551             {\cf19 case} 0x46:\par
09552             {\cf19 case} 0x47:\par
09553             {\cf19 case} 0x48:\par
09554             {\cf19 case} 0x49:\par
09555             {\cf19 case} 0x4A:\par
09556             {\cf19 case} 0x4B:\par
09557             {\cf19 case} 0x4C:\par
09558             {\cf19 case} 0x4D:\par
09559             {\cf19 case} 0x4E:\par
09560             {\cf19 case} 0x4F:\par
09561             {\cf19 case} 0x50:\par
09562             {\cf19 case} 0x51:\par
09563             {\cf19 case} 0x52:\par
09564             {\cf19 case} 0x53:\par
09565             {\cf19 case} 0x54:\par
09566             {\cf19 case} 0x55:\par
09567             {\cf19 case} 0x56:\par
09568             {\cf19 case} 0x57:\par
09569             {\cf19 case} 0x58:\par
09570             {\cf19 case} 0x59:\par
09571             {\cf19 case} 0x5A:\par
09572             {\cf19 case} 0x5B:\par
09573             {\cf19 case} 0x5C:\par
09574             {\cf19 case} 0x5D:\par
09575             {\cf19 case} 0x5E:\par
09576             {\cf19 case} 0x5F:\par
09577             {\cf19 case} 0x60:\par
09578             {\cf19 case} 0x61:\par
09579             {\cf19 case} 0x62:\par
09580             {\cf19 case} 0x63:\par
09581             {\cf19 case} 0x64:\par
09582             {\cf19 case} 0x65:\par
09583             {\cf19 case} 0x66:\par
09584             {\cf19 case} 0x67:\par
09585             {\cf19 case} 0x68:\par
09586             {\cf19 case} 0x69:\par
09587             {\cf19 case} 0x6A:\par
09588             {\cf19 case} 0x6B:\par
09589             {\cf19 case} 0x6C:\par
09590             {\cf19 case} 0x6D:\par
09591             {\cf19 case} 0x6E:\par
09592             {\cf19 case} 0x6F:\par
09593             {\cf19 case} 0x70:\par
09594             {\cf19 case} 0x71:\par
09595             {\cf19 case} 0x72:\par
09596             {\cf19 case} 0x73:\par
09597             {\cf19 case} 0x74:\par
09598             {\cf19 case} 0x75:\par
09599             {\cf19 case} 0x76:\par
09600             {\cf19 case} 0x77:\par
09601             {\cf19 case} 0x78:\par
09602             {\cf19 case} 0x79:\par
09603             {\cf19 case} 0x7A:\par
09604             {\cf19 case} 0x7B:\par
09605             {\cf19 case} 0x7C:\par
09606             {\cf19 case} 0x7D:\par
09607             {\cf19 case} 0x7E:\par
09608             {\cf19 case} 0x7F:\par
09609                 {\cf19 return} sax->number_unsigned({\cf17 static_cast<}number_unsigned_t{\cf17 >}(current));\par
09610 \par
09611             {\cf20 // fixmap}\par
09612             {\cf19 case} 0x80:\par
09613             {\cf19 case} 0x81:\par
09614             {\cf19 case} 0x82:\par
09615             {\cf19 case} 0x83:\par
09616             {\cf19 case} 0x84:\par
09617             {\cf19 case} 0x85:\par
09618             {\cf19 case} 0x86:\par
09619             {\cf19 case} 0x87:\par
09620             {\cf19 case} 0x88:\par
09621             {\cf19 case} 0x89:\par
09622             {\cf19 case} 0x8A:\par
09623             {\cf19 case} 0x8B:\par
09624             {\cf19 case} 0x8C:\par
09625             {\cf19 case} 0x8D:\par
09626             {\cf19 case} 0x8E:\par
09627             {\cf19 case} 0x8F:\par
09628                 {\cf19 return} get_msgpack_object({\cf17 static_cast<}std::size_t{\cf17 >}({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(current) & 0x0Fu));\par
09629 \par
09630             {\cf20 // fixarray}\par
09631             {\cf19 case} 0x90:\par
09632             {\cf19 case} 0x91:\par
09633             {\cf19 case} 0x92:\par
09634             {\cf19 case} 0x93:\par
09635             {\cf19 case} 0x94:\par
09636             {\cf19 case} 0x95:\par
09637             {\cf19 case} 0x96:\par
09638             {\cf19 case} 0x97:\par
09639             {\cf19 case} 0x98:\par
09640             {\cf19 case} 0x99:\par
09641             {\cf19 case} 0x9A:\par
09642             {\cf19 case} 0x9B:\par
09643             {\cf19 case} 0x9C:\par
09644             {\cf19 case} 0x9D:\par
09645             {\cf19 case} 0x9E:\par
09646             {\cf19 case} 0x9F:\par
09647                 {\cf19 return} get_msgpack_array({\cf17 static_cast<}std::size_t{\cf17 >}({\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(current) & 0x0Fu));\par
09648 \par
09649             {\cf20 // fixstr}\par
09650             {\cf19 case} 0xA0:\par
09651             {\cf19 case} 0xA1:\par
09652             {\cf19 case} 0xA2:\par
09653             {\cf19 case} 0xA3:\par
09654             {\cf19 case} 0xA4:\par
09655             {\cf19 case} 0xA5:\par
09656             {\cf19 case} 0xA6:\par
09657             {\cf19 case} 0xA7:\par
09658             {\cf19 case} 0xA8:\par
09659             {\cf19 case} 0xA9:\par
09660             {\cf19 case} 0xAA:\par
09661             {\cf19 case} 0xAB:\par
09662             {\cf19 case} 0xAC:\par
09663             {\cf19 case} 0xAD:\par
09664             {\cf19 case} 0xAE:\par
09665             {\cf19 case} 0xAF:\par
09666             {\cf19 case} 0xB0:\par
09667             {\cf19 case} 0xB1:\par
09668             {\cf19 case} 0xB2:\par
09669             {\cf19 case} 0xB3:\par
09670             {\cf19 case} 0xB4:\par
09671             {\cf19 case} 0xB5:\par
09672             {\cf19 case} 0xB6:\par
09673             {\cf19 case} 0xB7:\par
09674             {\cf19 case} 0xB8:\par
09675             {\cf19 case} 0xB9:\par
09676             {\cf19 case} 0xBA:\par
09677             {\cf19 case} 0xBB:\par
09678             {\cf19 case} 0xBC:\par
09679             {\cf19 case} 0xBD:\par
09680             {\cf19 case} 0xBE:\par
09681             {\cf19 case} 0xBF:\par
09682             {\cf19 case} 0xD9: {\cf20 // str 8}\par
09683             {\cf19 case} 0xDA: {\cf20 // str 16}\par
09684             {\cf19 case} 0xDB: {\cf20 // str 32}\par
09685             \{\par
09686                 string_t s;\par
09687                 {\cf19 return} get_msgpack_string(s) && sax->string(s);\par
09688             \}\par
09689 \par
09690             {\cf19 case} 0xC0: {\cf20 // nil}\par
09691                 {\cf19 return} sax->null();\par
09692 \par
09693             {\cf19 case} 0xC2: {\cf20 // false}\par
09694                 {\cf19 return} sax->boolean({\cf17 false});\par
09695 \par
09696             {\cf19 case} 0xC3: {\cf20 // true}\par
09697                 {\cf19 return} sax->boolean({\cf17 true});\par
09698 \par
09699             {\cf19 case} 0xC4: {\cf20 // bin 8}\par
09700             {\cf19 case} 0xC5: {\cf20 // bin 16}\par
09701             {\cf19 case} 0xC6: {\cf20 // bin 32}\par
09702             {\cf19 case} 0xC7: {\cf20 // ext 8}\par
09703             {\cf19 case} 0xC8: {\cf20 // ext 16}\par
09704             {\cf19 case} 0xC9: {\cf20 // ext 32}\par
09705             {\cf19 case} 0xD4: {\cf20 // fixext 1}\par
09706             {\cf19 case} 0xD5: {\cf20 // fixext 2}\par
09707             {\cf19 case} 0xD6: {\cf20 // fixext 4}\par
09708             {\cf19 case} 0xD7: {\cf20 // fixext 8}\par
09709             {\cf19 case} 0xD8: {\cf20 // fixext 16}\par
09710             \{\par
09711                 binary_t b;\par
09712                 {\cf19 return} get_msgpack_binary(b) && sax->binary(b);\par
09713             \}\par
09714 \par
09715             {\cf19 case} 0xCA: {\cf20 // float 32}\par
09716             \{\par
09717                 {\cf18 float} number\{\};\par
09718                 {\cf19 return} get_number(input_format_t::msgpack, number) && sax->number_float({\cf17 static_cast<}number_float_t{\cf17 >}(number), {\cf22 ""});\par
09719             \}\par
09720 \par
09721             {\cf19 case} 0xCB: {\cf20 // float 64}\par
09722             \{\par
09723                 {\cf18 double} number\{\};\par
09724                 {\cf19 return} get_number(input_format_t::msgpack, number) && sax->number_float({\cf17 static_cast<}number_float_t{\cf17 >}(number), {\cf22 ""});\par
09725             \}\par
09726 \par
09727             {\cf19 case} 0xCC: {\cf20 // uint 8}\par
09728             \{\par
09729                 std::uint8_t number\{\};\par
09730                 {\cf19 return} get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);\par
09731             \}\par
09732 \par
09733             {\cf19 case} 0xCD: {\cf20 // uint 16}\par
09734             \{\par
09735                 std::uint16_t number\{\};\par
09736                 {\cf19 return} get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);\par
09737             \}\par
09738 \par
09739             {\cf19 case} 0xCE: {\cf20 // uint 32}\par
09740             \{\par
09741                 std::uint32_t number\{\};\par
09742                 {\cf19 return} get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);\par
09743             \}\par
09744 \par
09745             {\cf19 case} 0xCF: {\cf20 // uint 64}\par
09746             \{\par
09747                 std::uint64_t number\{\};\par
09748                 {\cf19 return} get_number(input_format_t::msgpack, number) && sax->number_unsigned(number);\par
09749             \}\par
09750 \par
09751             {\cf19 case} 0xD0: {\cf20 // int 8}\par
09752             \{\par
09753                 std::int8_t number\{\};\par
09754                 {\cf19 return} get_number(input_format_t::msgpack, number) && sax->number_integer(number);\par
09755             \}\par
09756 \par
09757             {\cf19 case} 0xD1: {\cf20 // int 16}\par
09758             \{\par
09759                 std::int16_t number\{\};\par
09760                 {\cf19 return} get_number(input_format_t::msgpack, number) && sax->number_integer(number);\par
09761             \}\par
09762 \par
09763             {\cf19 case} 0xD2: {\cf20 // int 32}\par
09764             \{\par
09765                 std::int32_t number\{\};\par
09766                 {\cf19 return} get_number(input_format_t::msgpack, number) && sax->number_integer(number);\par
09767             \}\par
09768 \par
09769             {\cf19 case} 0xD3: {\cf20 // int 64}\par
09770             \{\par
09771                 std::int64_t number\{\};\par
09772                 {\cf19 return} get_number(input_format_t::msgpack, number) && sax->number_integer(number);\par
09773             \}\par
09774 \par
09775             {\cf19 case} 0xDC: {\cf20 // array 16}\par
09776             \{\par
09777                 std::uint16_t len\{\};\par
09778                 {\cf19 return} get_number(input_format_t::msgpack, len) && get_msgpack_array({\cf17 static_cast<}std::size_t{\cf17 >}(len));\par
09779             \}\par
09780 \par
09781             {\cf19 case} 0xDD: {\cf20 // array 32}\par
09782             \{\par
09783                 std::uint32_t len\{\};\par
09784                 {\cf19 return} get_number(input_format_t::msgpack, len) && get_msgpack_array({\cf17 static_cast<}std::size_t{\cf17 >}(len));\par
09785             \}\par
09786 \par
09787             {\cf19 case} 0xDE: {\cf20 // map 16}\par
09788             \{\par
09789                 std::uint16_t len\{\};\par
09790                 {\cf19 return} get_number(input_format_t::msgpack, len) && get_msgpack_object({\cf17 static_cast<}std::size_t{\cf17 >}(len));\par
09791             \}\par
09792 \par
09793             {\cf19 case} 0xDF: {\cf20 // map 32}\par
09794             \{\par
09795                 std::uint32_t len\{\};\par
09796                 {\cf19 return} get_number(input_format_t::msgpack, len) && get_msgpack_object({\cf17 static_cast<}std::size_t{\cf17 >}(len));\par
09797             \}\par
09798 \par
09799             {\cf20 // negative fixint}\par
09800             {\cf19 case} 0xE0:\par
09801             {\cf19 case} 0xE1:\par
09802             {\cf19 case} 0xE2:\par
09803             {\cf19 case} 0xE3:\par
09804             {\cf19 case} 0xE4:\par
09805             {\cf19 case} 0xE5:\par
09806             {\cf19 case} 0xE6:\par
09807             {\cf19 case} 0xE7:\par
09808             {\cf19 case} 0xE8:\par
09809             {\cf19 case} 0xE9:\par
09810             {\cf19 case} 0xEA:\par
09811             {\cf19 case} 0xEB:\par
09812             {\cf19 case} 0xEC:\par
09813             {\cf19 case} 0xED:\par
09814             {\cf19 case} 0xEE:\par
09815             {\cf19 case} 0xEF:\par
09816             {\cf19 case} 0xF0:\par
09817             {\cf19 case} 0xF1:\par
09818             {\cf19 case} 0xF2:\par
09819             {\cf19 case} 0xF3:\par
09820             {\cf19 case} 0xF4:\par
09821             {\cf19 case} 0xF5:\par
09822             {\cf19 case} 0xF6:\par
09823             {\cf19 case} 0xF7:\par
09824             {\cf19 case} 0xF8:\par
09825             {\cf19 case} 0xF9:\par
09826             {\cf19 case} 0xFA:\par
09827             {\cf19 case} 0xFB:\par
09828             {\cf19 case} 0xFC:\par
09829             {\cf19 case} 0xFD:\par
09830             {\cf19 case} 0xFE:\par
09831             {\cf19 case} 0xFF:\par
09832                 {\cf19 return} sax->number_integer({\cf17 static_cast<}std::int8_t{\cf17 >}(current));\par
09833 \par
09834             {\cf19 default}: {\cf20 // anything else}\par
09835             \{\par
09836                 {\cf17 auto} last_token = get_token_string();\par
09837                 {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::msgpack, {\cf22 "invalid byte: 0x"} + last_token, {\cf22 "value"}), BasicJsonType()));\par
09838             \}\par
09839         \}\par
09840     \}\par
09841 \par
09852     {\cf18 bool} get_msgpack_string(string_t& result)\par
09853     \{\par
09854         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::msgpack, {\cf22 "string"})))\par
09855         \{\par
09856             {\cf19 return} {\cf17 false};\par
09857         \}\par
09858 \par
09859         {\cf19 switch} (current)\par
09860         \{\par
09861             {\cf20 // fixstr}\par
09862             {\cf19 case} 0xA0:\par
09863             {\cf19 case} 0xA1:\par
09864             {\cf19 case} 0xA2:\par
09865             {\cf19 case} 0xA3:\par
09866             {\cf19 case} 0xA4:\par
09867             {\cf19 case} 0xA5:\par
09868             {\cf19 case} 0xA6:\par
09869             {\cf19 case} 0xA7:\par
09870             {\cf19 case} 0xA8:\par
09871             {\cf19 case} 0xA9:\par
09872             {\cf19 case} 0xAA:\par
09873             {\cf19 case} 0xAB:\par
09874             {\cf19 case} 0xAC:\par
09875             {\cf19 case} 0xAD:\par
09876             {\cf19 case} 0xAE:\par
09877             {\cf19 case} 0xAF:\par
09878             {\cf19 case} 0xB0:\par
09879             {\cf19 case} 0xB1:\par
09880             {\cf19 case} 0xB2:\par
09881             {\cf19 case} 0xB3:\par
09882             {\cf19 case} 0xB4:\par
09883             {\cf19 case} 0xB5:\par
09884             {\cf19 case} 0xB6:\par
09885             {\cf19 case} 0xB7:\par
09886             {\cf19 case} 0xB8:\par
09887             {\cf19 case} 0xB9:\par
09888             {\cf19 case} 0xBA:\par
09889             {\cf19 case} 0xBB:\par
09890             {\cf19 case} 0xBC:\par
09891             {\cf19 case} 0xBD:\par
09892             {\cf19 case} 0xBE:\par
09893             {\cf19 case} 0xBF:\par
09894             \{\par
09895                 {\cf19 return} get_string(input_format_t::msgpack, {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(current) & 0x1Fu, result);\par
09896             \}\par
09897 \par
09898             {\cf19 case} 0xD9: {\cf20 // str 8}\par
09899             \{\par
09900                 std::uint8_t len\{\};\par
09901                 {\cf19 return} get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);\par
09902             \}\par
09903 \par
09904             {\cf19 case} 0xDA: {\cf20 // str 16}\par
09905             \{\par
09906                 std::uint16_t len\{\};\par
09907                 {\cf19 return} get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);\par
09908             \}\par
09909 \par
09910             {\cf19 case} 0xDB: {\cf20 // str 32}\par
09911             \{\par
09912                 std::uint32_t len\{\};\par
09913                 {\cf19 return} get_number(input_format_t::msgpack, len) && get_string(input_format_t::msgpack, len, result);\par
09914             \}\par
09915 \par
09916             {\cf19 default}:\par
09917             \{\par
09918                 {\cf17 auto} last_token = get_token_string();\par
09919                 {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::msgpack, {\cf22 "expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0x"} + last_token, {\cf22 "string"}), BasicJsonType()));\par
09920             \}\par
09921         \}\par
09922     \}\par
09923 \par
09934     {\cf18 bool} get_msgpack_binary(binary_t& result)\par
09935     \{\par
09936         {\cf20 // helper function to set the subtype}\par
09937         {\cf17 auto} assign_and_return_true = [&result](std::int8_t subtype)\par
09938         \{\par
09939             result.set_subtype({\cf17 static_cast<}std::uint8_t{\cf17 >}(subtype));\par
09940             {\cf19 return} {\cf17 true};\par
09941         \};\par
09942 \par
09943         {\cf19 switch} (current)\par
09944         \{\par
09945             {\cf19 case} 0xC4: {\cf20 // bin 8}\par
09946             \{\par
09947                 std::uint8_t len\{\};\par
09948                 {\cf19 return} get_number(input_format_t::msgpack, len) &&\par
09949                        get_binary(input_format_t::msgpack, len, result);\par
09950             \}\par
09951 \par
09952             {\cf19 case} 0xC5: {\cf20 // bin 16}\par
09953             \{\par
09954                 std::uint16_t len\{\};\par
09955                 {\cf19 return} get_number(input_format_t::msgpack, len) &&\par
09956                        get_binary(input_format_t::msgpack, len, result);\par
09957             \}\par
09958 \par
09959             {\cf19 case} 0xC6: {\cf20 // bin 32}\par
09960             \{\par
09961                 std::uint32_t len\{\};\par
09962                 {\cf19 return} get_number(input_format_t::msgpack, len) &&\par
09963                        get_binary(input_format_t::msgpack, len, result);\par
09964             \}\par
09965 \par
09966             {\cf19 case} 0xC7: {\cf20 // ext 8}\par
09967             \{\par
09968                 std::uint8_t len\{\};\par
09969                 std::int8_t subtype\{\};\par
09970                 {\cf19 return} get_number(input_format_t::msgpack, len) &&\par
09971                        get_number(input_format_t::msgpack, subtype) &&\par
09972                        get_binary(input_format_t::msgpack, len, result) &&\par
09973                        assign_and_return_true(subtype);\par
09974             \}\par
09975 \par
09976             {\cf19 case} 0xC8: {\cf20 // ext 16}\par
09977             \{\par
09978                 std::uint16_t len\{\};\par
09979                 std::int8_t subtype\{\};\par
09980                 {\cf19 return} get_number(input_format_t::msgpack, len) &&\par
09981                        get_number(input_format_t::msgpack, subtype) &&\par
09982                        get_binary(input_format_t::msgpack, len, result) &&\par
09983                        assign_and_return_true(subtype);\par
09984             \}\par
09985 \par
09986             {\cf19 case} 0xC9: {\cf20 // ext 32}\par
09987             \{\par
09988                 std::uint32_t len\{\};\par
09989                 std::int8_t subtype\{\};\par
09990                 {\cf19 return} get_number(input_format_t::msgpack, len) &&\par
09991                        get_number(input_format_t::msgpack, subtype) &&\par
09992                        get_binary(input_format_t::msgpack, len, result) &&\par
09993                        assign_and_return_true(subtype);\par
09994             \}\par
09995 \par
09996             {\cf19 case} 0xD4: {\cf20 // fixext 1}\par
09997             \{\par
09998                 std::int8_t subtype\{\};\par
09999                 {\cf19 return} get_number(input_format_t::msgpack, subtype) &&\par
10000                        get_binary(input_format_t::msgpack, 1, result) &&\par
10001                        assign_and_return_true(subtype);\par
10002             \}\par
10003 \par
10004             {\cf19 case} 0xD5: {\cf20 // fixext 2}\par
10005             \{\par
10006                 std::int8_t subtype\{\};\par
10007                 {\cf19 return} get_number(input_format_t::msgpack, subtype) &&\par
10008                        get_binary(input_format_t::msgpack, 2, result) &&\par
10009                        assign_and_return_true(subtype);\par
10010             \}\par
10011 \par
10012             {\cf19 case} 0xD6: {\cf20 // fixext 4}\par
10013             \{\par
10014                 std::int8_t subtype\{\};\par
10015                 {\cf19 return} get_number(input_format_t::msgpack, subtype) &&\par
10016                        get_binary(input_format_t::msgpack, 4, result) &&\par
10017                        assign_and_return_true(subtype);\par
10018             \}\par
10019 \par
10020             {\cf19 case} 0xD7: {\cf20 // fixext 8}\par
10021             \{\par
10022                 std::int8_t subtype\{\};\par
10023                 {\cf19 return} get_number(input_format_t::msgpack, subtype) &&\par
10024                        get_binary(input_format_t::msgpack, 8, result) &&\par
10025                        assign_and_return_true(subtype);\par
10026             \}\par
10027 \par
10028             {\cf19 case} 0xD8: {\cf20 // fixext 16}\par
10029             \{\par
10030                 std::int8_t subtype\{\};\par
10031                 {\cf19 return} get_number(input_format_t::msgpack, subtype) &&\par
10032                        get_binary(input_format_t::msgpack, 16, result) &&\par
10033                        assign_and_return_true(subtype);\par
10034             \}\par
10035 \par
10036             {\cf19 default}:           {\cf20 // LCOV_EXCL_LINE}\par
10037                 {\cf19 return} {\cf17 false};  {\cf20 // LCOV_EXCL_LINE}\par
10038         \}\par
10039     \}\par
10040 \par
10045     {\cf18 bool} get_msgpack_array({\cf17 const} std::size_t len)\par
10046     \{\par
10047         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_array(len)))\par
10048         \{\par
10049             {\cf19 return} {\cf17 false};\par
10050         \}\par
10051 \par
10052         {\cf19 for} (std::size_t i = 0; i < len; ++i)\par
10053         \{\par
10054             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))\par
10055             \{\par
10056                 {\cf19 return} {\cf17 false};\par
10057             \}\par
10058         \}\par
10059 \par
10060         {\cf19 return} sax->end_array();\par
10061     \}\par
10062 \par
10067     {\cf18 bool} get_msgpack_object({\cf17 const} std::size_t len)\par
10068     \{\par
10069         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_object(len)))\par
10070         \{\par
10071             {\cf19 return} {\cf17 false};\par
10072         \}\par
10073 \par
10074         string_t key;\par
10075         {\cf19 for} (std::size_t i = 0; i < len; ++i)\par
10076         \{\par
10077             get();\par
10078             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_msgpack_string(key) || !sax->key(key)))\par
10079             \{\par
10080                 {\cf19 return} {\cf17 false};\par
10081             \}\par
10082 \par
10083             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_msgpack_internal()))\par
10084             \{\par
10085                 {\cf19 return} {\cf17 false};\par
10086             \}\par
10087             key.clear();\par
10088         \}\par
10089 \par
10090         {\cf19 return} sax->end_object();\par
10091     \}\par
10092 \par
10094     {\cf20 // UBJSON //}\par
10096 {\cf20 }\par
10104     {\cf18 bool} parse_ubjson_internal({\cf17 const} {\cf18 bool} get_char = {\cf17 true})\par
10105     \{\par
10106         {\cf19 return} get_ubjson_value(get_char ? get_ignore_noop() : current);\par
10107     \}\par
10108 \par
10123     {\cf18 bool} get_ubjson_string(string_t& result, {\cf17 const} {\cf18 bool} get_char = {\cf17 true})\par
10124     \{\par
10125         {\cf19 if} (get_char)\par
10126         \{\par
10127             get();  {\cf20 // TODO(niels): may we ignore N here?}\par
10128         \}\par
10129 \par
10130         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, {\cf22 "value"})))\par
10131         \{\par
10132             {\cf19 return} {\cf17 false};\par
10133         \}\par
10134 \par
10135         {\cf19 switch} (current)\par
10136         \{\par
10137             {\cf19 case} {\cf23 'U'}:\par
10138             \{\par
10139                 std::uint8_t len\{\};\par
10140                 {\cf19 return} get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);\par
10141             \}\par
10142 \par
10143             {\cf19 case} {\cf23 'i'}:\par
10144             \{\par
10145                 std::int8_t len\{\};\par
10146                 {\cf19 return} get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);\par
10147             \}\par
10148 \par
10149             {\cf19 case} {\cf23 'I'}:\par
10150             \{\par
10151                 std::int16_t len\{\};\par
10152                 {\cf19 return} get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);\par
10153             \}\par
10154 \par
10155             {\cf19 case} {\cf23 'l'}:\par
10156             \{\par
10157                 std::int32_t len\{\};\par
10158                 {\cf19 return} get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);\par
10159             \}\par
10160 \par
10161             {\cf19 case} {\cf23 'L'}:\par
10162             \{\par
10163                 std::int64_t len\{\};\par
10164                 {\cf19 return} get_number(input_format_t::ubjson, len) && get_string(input_format_t::ubjson, len, result);\par
10165             \}\par
10166 \par
10167             {\cf19 default}:\par
10168                 {\cf17 auto} last_token = get_token_string();\par
10169                 {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, {\cf22 "expected length type specification (U, i, I, l, L); last byte: 0x"} + last_token, {\cf22 "string"}), BasicJsonType()));\par
10170         \}\par
10171     \}\par
10172 \par
10177     {\cf18 bool} get_ubjson_size_value(std::size_t& result)\par
10178     \{\par
10179         {\cf19 switch} (get_ignore_noop())\par
10180         \{\par
10181             {\cf19 case} {\cf23 'U'}:\par
10182             \{\par
10183                 std::uint8_t number\{\};\par
10184                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))\par
10185                 \{\par
10186                     {\cf19 return} {\cf17 false};\par
10187                 \}\par
10188                 result = {\cf17 static_cast<}std::size_t{\cf17 >}(number);\par
10189                 {\cf19 return} {\cf17 true};\par
10190             \}\par
10191 \par
10192             {\cf19 case} {\cf23 'i'}:\par
10193             \{\par
10194                 std::int8_t number\{\};\par
10195                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))\par
10196                 \{\par
10197                     {\cf19 return} {\cf17 false};\par
10198                 \}\par
10199                 result = {\cf17 static_cast<}std::size_t{\cf17 >}(number); {\cf20 // NOLINT(bugprone-signed-char-misuse,cert-str34-c): number is not a char}\par
10200                 {\cf19 return} {\cf17 true};\par
10201             \}\par
10202 \par
10203             {\cf19 case} {\cf23 'I'}:\par
10204             \{\par
10205                 std::int16_t number\{\};\par
10206                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))\par
10207                 \{\par
10208                     {\cf19 return} {\cf17 false};\par
10209                 \}\par
10210                 result = {\cf17 static_cast<}std::size_t{\cf17 >}(number);\par
10211                 {\cf19 return} {\cf17 true};\par
10212             \}\par
10213 \par
10214             {\cf19 case} {\cf23 'l'}:\par
10215             \{\par
10216                 std::int32_t number\{\};\par
10217                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))\par
10218                 \{\par
10219                     {\cf19 return} {\cf17 false};\par
10220                 \}\par
10221                 result = {\cf17 static_cast<}std::size_t{\cf17 >}(number);\par
10222                 {\cf19 return} {\cf17 true};\par
10223             \}\par
10224 \par
10225             {\cf19 case} {\cf23 'L'}:\par
10226             \{\par
10227                 std::int64_t number\{\};\par
10228                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_number(input_format_t::ubjson, number)))\par
10229                 \{\par
10230                     {\cf19 return} {\cf17 false};\par
10231                 \}\par
10232                 result = {\cf17 static_cast<}std::size_t{\cf17 >}(number);\par
10233                 {\cf19 return} {\cf17 true};\par
10234             \}\par
10235 \par
10236             {\cf19 default}:\par
10237             \{\par
10238                 {\cf17 auto} last_token = get_token_string();\par
10239                 {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, {\cf22 "expected length type specification (U, i, I, l, L) after '#'; last byte: 0x"} + last_token, {\cf22 "size"}), BasicJsonType()));\par
10240             \}\par
10241         \}\par
10242     \}\par
10243 \par
10254     {\cf18 bool} get_ubjson_size_type(std::pair<std::size_t, char_int_type>& result)\par
10255     \{\par
10256         result.first = string_t::npos; {\cf20 // size}\par
10257         result.second = 0; {\cf20 // type}\par
10258 \par
10259         get_ignore_noop();\par
10260 \par
10261         {\cf19 if} (current == {\cf23 '$'})\par
10262         \{\par
10263             result.second = get();  {\cf20 // must not ignore 'N', because 'N' maybe the type}\par
10264             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, {\cf22 "type"})))\par
10265             \{\par
10266                 {\cf19 return} {\cf17 false};\par
10267             \}\par
10268 \par
10269             get_ignore_noop();\par
10270             {\cf19 if} (JSON_HEDLEY_UNLIKELY(current != {\cf23 '#'}))\par
10271             \{\par
10272                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, {\cf22 "value"})))\par
10273                 \{\par
10274                     {\cf19 return} {\cf17 false};\par
10275                 \}\par
10276                 {\cf17 auto} last_token = get_token_string();\par
10277                 {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, {\cf22 "expected '#' after type information; last byte: 0x"} + last_token, {\cf22 "size"}), BasicJsonType()));\par
10278             \}\par
10279 \par
10280             {\cf19 return} get_ubjson_size_value(result.first);\par
10281         \}\par
10282 \par
10283         {\cf19 if} (current == {\cf23 '#'})\par
10284         \{\par
10285             {\cf19 return} get_ubjson_size_value(result.first);\par
10286         \}\par
10287 \par
10288         {\cf19 return} {\cf17 true};\par
10289     \}\par
10290 \par
10295     {\cf18 bool} get_ubjson_value({\cf17 const} char_int_type prefix)\par
10296     \{\par
10297         {\cf19 switch} (prefix)\par
10298         \{\par
10299             {\cf19 case} std::char_traits<char_type>::eof():  {\cf20 // EOF}\par
10300                 return unexpect_eof(input_format_t::ubjson, {\cf22 "value"});\par
10301 \par
10302             {\cf19 case} {\cf23 'T'}:  {\cf20 // true}\par
10303                 {\cf19 return} sax->boolean({\cf17 true});\par
10304             {\cf19 case} {\cf23 'F'}:  {\cf20 // false}\par
10305                 {\cf19 return} sax->boolean({\cf17 false});\par
10306 \par
10307             {\cf19 case} {\cf23 'Z'}:  {\cf20 // null}\par
10308                 {\cf19 return} sax->null();\par
10309 \par
10310             {\cf19 case} {\cf23 'U'}:\par
10311             \{\par
10312                 std::uint8_t number\{\};\par
10313                 {\cf19 return} get_number(input_format_t::ubjson, number) && sax->number_unsigned(number);\par
10314             \}\par
10315 \par
10316             {\cf19 case} {\cf23 'i'}:\par
10317             \{\par
10318                 std::int8_t number\{\};\par
10319                 {\cf19 return} get_number(input_format_t::ubjson, number) && sax->number_integer(number);\par
10320             \}\par
10321 \par
10322             {\cf19 case} {\cf23 'I'}:\par
10323             \{\par
10324                 std::int16_t number\{\};\par
10325                 {\cf19 return} get_number(input_format_t::ubjson, number) && sax->number_integer(number);\par
10326             \}\par
10327 \par
10328             {\cf19 case} {\cf23 'l'}:\par
10329             \{\par
10330                 std::int32_t number\{\};\par
10331                 {\cf19 return} get_number(input_format_t::ubjson, number) && sax->number_integer(number);\par
10332             \}\par
10333 \par
10334             {\cf19 case} {\cf23 'L'}:\par
10335             \{\par
10336                 std::int64_t number\{\};\par
10337                 {\cf19 return} get_number(input_format_t::ubjson, number) && sax->number_integer(number);\par
10338             \}\par
10339 \par
10340             {\cf19 case} {\cf23 'd'}:\par
10341             \{\par
10342                 {\cf18 float} number\{\};\par
10343                 {\cf19 return} get_number(input_format_t::ubjson, number) && sax->number_float({\cf17 static_cast<}number_float_t{\cf17 >}(number), {\cf22 ""});\par
10344             \}\par
10345 \par
10346             {\cf19 case} {\cf23 'D'}:\par
10347             \{\par
10348                 {\cf18 double} number\{\};\par
10349                 {\cf19 return} get_number(input_format_t::ubjson, number) && sax->number_float({\cf17 static_cast<}number_float_t{\cf17 >}(number), {\cf22 ""});\par
10350             \}\par
10351 \par
10352             {\cf19 case} {\cf23 'H'}:\par
10353             \{\par
10354                 {\cf19 return} get_ubjson_high_precision_number();\par
10355             \}\par
10356 \par
10357             {\cf19 case} {\cf23 'C'}:  {\cf20 // char}\par
10358             \{\par
10359                 get();\par
10360                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, {\cf22 "char"})))\par
10361                 \{\par
10362                     {\cf19 return} {\cf17 false};\par
10363                 \}\par
10364                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(current > 127))\par
10365                 \{\par
10366                     {\cf17 auto} last_token = get_token_string();\par
10367                     {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(113, chars_read, exception_message(input_format_t::ubjson, {\cf22 "byte after 'C' must be in range 0x00..0x7F; last byte: 0x"} + last_token, {\cf22 "char"}), BasicJsonType()));\par
10368                 \}\par
10369                 string_t s(1, {\cf17 static_cast<}typename string_t::value_type{\cf17 >}(current));\par
10370                 {\cf19 return} sax->string(s);\par
10371             \}\par
10372 \par
10373             {\cf19 case} {\cf23 'S'}:  {\cf20 // string}\par
10374             \{\par
10375                 string_t s;\par
10376                 {\cf19 return} get_ubjson_string(s) && sax->string(s);\par
10377             \}\par
10378 \par
10379             {\cf19 case} {\cf23 '['}:  {\cf20 // array}\par
10380                 {\cf19 return} get_ubjson_array();\par
10381 \par
10382             {\cf19 case} {\cf23 '\{'}:  {\cf20 // object}\par
10383                 {\cf19 return} get_ubjson_object();\par
10384 \par
10385             {\cf19 default}: {\cf20 // anything else}\par
10386             \{\par
10387                 {\cf17 auto} last_token = get_token_string();\par
10388                 {\cf19 return} sax->parse_error(chars_read, last_token, parse_error::create(112, chars_read, exception_message(input_format_t::ubjson, {\cf22 "invalid byte: 0x"} + last_token, {\cf22 "value"}), BasicJsonType()));\par
10389             \}\par
10390         \}\par
10391     \}\par
10392 \par
10396     {\cf18 bool} get_ubjson_array()\par
10397     \{\par
10398         std::pair<std::size_t, char_int_type> size_and_type;\par
10399         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))\par
10400         \{\par
10401             {\cf19 return} {\cf17 false};\par
10402         \}\par
10403 \par
10404         {\cf19 if} (size_and_type.first != string_t::npos)\par
10405         \{\par
10406             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_array(size_and_type.first)))\par
10407             \{\par
10408                 {\cf19 return} {\cf17 false};\par
10409             \}\par
10410 \par
10411             {\cf19 if} (size_and_type.second != 0)\par
10412             \{\par
10413                 {\cf19 if} (size_and_type.second != {\cf23 'N'})\par
10414                 \{\par
10415                     {\cf19 for} (std::size_t i = 0; i < size_and_type.first; ++i)\par
10416                     \{\par
10417                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))\par
10418                         \{\par
10419                             {\cf19 return} {\cf17 false};\par
10420                         \}\par
10421                     \}\par
10422                 \}\par
10423             \}\par
10424             {\cf19 else}\par
10425             \{\par
10426                 {\cf19 for} (std::size_t i = 0; i < size_and_type.first; ++i)\par
10427                 \{\par
10428                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))\par
10429                     \{\par
10430                         {\cf19 return} {\cf17 false};\par
10431                     \}\par
10432                 \}\par
10433             \}\par
10434         \}\par
10435         {\cf19 else}\par
10436         \{\par
10437             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))\par
10438             \{\par
10439                 {\cf19 return} {\cf17 false};\par
10440             \}\par
10441 \par
10442             {\cf19 while} (current != {\cf23 ']'})\par
10443             \{\par
10444                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal({\cf17 false})))\par
10445                 \{\par
10446                     {\cf19 return} {\cf17 false};\par
10447                 \}\par
10448                 get_ignore_noop();\par
10449             \}\par
10450         \}\par
10451 \par
10452         {\cf19 return} sax->end_array();\par
10453     \}\par
10454 \par
10458     {\cf18 bool} get_ubjson_object()\par
10459     \{\par
10460         std::pair<std::size_t, char_int_type> size_and_type;\par
10461         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_ubjson_size_type(size_and_type)))\par
10462         \{\par
10463             {\cf19 return} {\cf17 false};\par
10464         \}\par
10465 \par
10466         string_t key;\par
10467         {\cf19 if} (size_and_type.first != string_t::npos)\par
10468         \{\par
10469             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_object(size_and_type.first)))\par
10470             \{\par
10471                 {\cf19 return} {\cf17 false};\par
10472             \}\par
10473 \par
10474             {\cf19 if} (size_and_type.second != 0)\par
10475             \{\par
10476                 {\cf19 for} (std::size_t i = 0; i < size_and_type.first; ++i)\par
10477                 \{\par
10478                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))\par
10479                     \{\par
10480                         {\cf19 return} {\cf17 false};\par
10481                     \}\par
10482                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_ubjson_value(size_and_type.second)))\par
10483                     \{\par
10484                         {\cf19 return} {\cf17 false};\par
10485                     \}\par
10486                     key.clear();\par
10487                 \}\par
10488             \}\par
10489             {\cf19 else}\par
10490             \{\par
10491                 {\cf19 for} (std::size_t i = 0; i < size_and_type.first; ++i)\par
10492                 \{\par
10493                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key) || !sax->key(key)))\par
10494                     \{\par
10495                         {\cf19 return} {\cf17 false};\par
10496                     \}\par
10497                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))\par
10498                     \{\par
10499                         {\cf19 return} {\cf17 false};\par
10500                     \}\par
10501                     key.clear();\par
10502                 \}\par
10503             \}\par
10504         \}\par
10505         {\cf19 else}\par
10506         \{\par
10507             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))\par
10508             \{\par
10509                 {\cf19 return} {\cf17 false};\par
10510             \}\par
10511 \par
10512             {\cf19 while} (current != {\cf23 '\}'})\par
10513             \{\par
10514                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!get_ubjson_string(key, {\cf17 false}) || !sax->key(key)))\par
10515                 \{\par
10516                     {\cf19 return} {\cf17 false};\par
10517                 \}\par
10518                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!parse_ubjson_internal()))\par
10519                 \{\par
10520                     {\cf19 return} {\cf17 false};\par
10521                 \}\par
10522                 get_ignore_noop();\par
10523                 key.clear();\par
10524             \}\par
10525         \}\par
10526 \par
10527         {\cf19 return} sax->end_object();\par
10528     \}\par
10529 \par
10530     {\cf20 // Note, no reader for UBJSON binary types is implemented because they do}\par
10531     {\cf20 // not exist}\par
10532 \par
10533     {\cf18 bool} get_ubjson_high_precision_number()\par
10534     \{\par
10535         {\cf20 // get size of following number string}\par
10536         std::size_t size\{\};\par
10537         {\cf17 auto} res = get_ubjson_size_value(size);\par
10538         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!res))\par
10539         \{\par
10540             {\cf19 return} res;\par
10541         \}\par
10542 \par
10543         {\cf20 // get number string}\par
10544         std::vector<char> number_vector;\par
10545         {\cf19 for} (std::size_t i = 0; i < size; ++i)\par
10546         \{\par
10547             get();\par
10548             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(input_format_t::ubjson, {\cf22 "number"})))\par
10549             \{\par
10550                 {\cf19 return} {\cf17 false};\par
10551             \}\par
10552             number_vector.push_back({\cf17 static_cast<}{\cf18 char}{\cf17 >}(current));\par
10553         \}\par
10554 \par
10555         {\cf20 // parse number string}\par
10556         {\cf17 using} ia_type = {\cf17 decltype}(detail::input_adapter(number_vector));\par
10557         {\cf17 auto} number_lexer = detail::lexer<BasicJsonType, ia_type>(detail::input_adapter(number_vector), {\cf17 false});\par
10558         {\cf17 const} {\cf17 auto} result_number = number_lexer.scan();\par
10559         {\cf17 const} {\cf17 auto} number_string = number_lexer.get_token_string();\par
10560         {\cf17 const} {\cf17 auto} result_remainder = number_lexer.scan();\par
10561 \par
10562         {\cf17 using} token_type = {\cf17 typename} detail::lexer_base<BasicJsonType>::token_type;\par
10563 \par
10564         {\cf19 if} (JSON_HEDLEY_UNLIKELY(result_remainder != token_type::end_of_input))\par
10565         \{\par
10566             {\cf19 return} sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, {\cf22 "invalid number text: "} + number_lexer.get_token_string(), {\cf22 "high-precision number"}), BasicJsonType()));\par
10567         \}\par
10568 \par
10569         {\cf19 switch} (result_number)\par
10570         \{\par
10571             {\cf19 case} token_type::value_integer:\par
10572                 {\cf19 return} sax->number_integer(number_lexer.get_number_integer());\par
10573             {\cf19 case} token_type::value_unsigned:\par
10574                 {\cf19 return} sax->number_unsigned(number_lexer.get_number_unsigned());\par
10575             {\cf19 case} token_type::value_float:\par
10576                 {\cf19 return} sax->number_float(number_lexer.get_number_float(), std::move(number_string));\par
10577             {\cf19 case} token_type::uninitialized:\par
10578             {\cf19 case} token_type::literal_true:\par
10579             {\cf19 case} token_type::literal_false:\par
10580             {\cf19 case} token_type::literal_null:\par
10581             {\cf19 case} token_type::value_string:\par
10582             {\cf19 case} token_type::begin_array:\par
10583             {\cf19 case} token_type::begin_object:\par
10584             {\cf19 case} token_type::end_array:\par
10585             {\cf19 case} token_type::end_object:\par
10586             {\cf19 case} token_type::name_separator:\par
10587             {\cf19 case} token_type::value_separator:\par
10588             {\cf19 case} token_type::parse_error:\par
10589             {\cf19 case} token_type::end_of_input:\par
10590             {\cf19 case} token_type::literal_or_value:\par
10591             {\cf19 default}:\par
10592                 {\cf19 return} sax->parse_error(chars_read, number_string, parse_error::create(115, chars_read, exception_message(input_format_t::ubjson, {\cf22 "invalid number text: "} + number_lexer.get_token_string(), {\cf22 "high-precision number"}), BasicJsonType()));\par
10593         \}\par
10594     \}\par
10595 \par
10597     {\cf20 // Utility functions //}\par
10599 {\cf20 }\par
10609     char_int_type get()\par
10610     \{\par
10611         ++chars_read;\par
10612         {\cf19 return} current = ia.get_character();\par
10613     \}\par
10614 \par
10618     char_int_type get_ignore_noop()\par
10619     \{\par
10620         {\cf19 do}\par
10621         \{\par
10622             get();\par
10623         \}\par
10624         {\cf19 while} (current == {\cf23 'N'});\par
10625 \par
10626         {\cf19 return} current;\par
10627     \}\par
10628 \par
10629     {\cf20 /*}\par
10630 {\cf20     @brief read a number from the input}\par
10631 {\cf20 }\par
10632 {\cf20     @tparam NumberType the type of the number}\par
10633 {\cf20     @param[in] format   the current format (for diagnostics)}\par
10634 {\cf20     @param[out] result  number of type @a NumberType}\par
10635 {\cf20 }\par
10636 {\cf20     @return whether conversion completed}\par
10637 {\cf20 }\par
10638 {\cf20     @note This function needs to respect the system's endianess, because}\par
10639 {\cf20           bytes in CBOR, MessagePack, and UBJSON are stored in network order}\par
10640 {\cf20           (big endian) and therefore need reordering on little endian systems.}\par
10641 {\cf20     */}\par
10642     {\cf17 template}<{\cf17 typename} NumberType, {\cf18 bool} InputIsLittleEndian = false>\par
10643     {\cf18 bool} get_number({\cf17 const} input_format_t format, NumberType& result)\par
10644     \{\par
10645         {\cf20 // step 1: read input into array with system's byte order}\par
10646         std::array<std::uint8_t, {\cf17 sizeof}(NumberType)> vec\{\};\par
10647         {\cf19 for} (std::size_t i = 0; i < {\cf17 sizeof}(NumberType); ++i)\par
10648         \{\par
10649             get();\par
10650             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, {\cf22 "number"})))\par
10651             \{\par
10652                 {\cf19 return} {\cf17 false};\par
10653             \}\par
10654 \par
10655             {\cf20 // reverse byte order prior to conversion if necessary}\par
10656             {\cf19 if} (is_little_endian != InputIsLittleEndian)\par
10657             \{\par
10658                 vec[{\cf17 sizeof}(NumberType) - i - 1] = {\cf17 static_cast<}std::uint8_t{\cf17 >}(current);\par
10659             \}\par
10660             {\cf19 else}\par
10661             \{\par
10662                 vec[i] = {\cf17 static_cast<}std::uint8_t{\cf17 >}(current); {\cf20 // LCOV_EXCL_LINE}\par
10663             \}\par
10664         \}\par
10665 \par
10666         {\cf20 // step 2: convert array into number of type T and return}\par
10667         std::memcpy(&result, vec.data(), {\cf17 sizeof}(NumberType));\par
10668         {\cf19 return} {\cf17 true};\par
10669     \}\par
10670 \par
10685     {\cf17 template}<{\cf17 typename} NumberType>\par
10686     {\cf18 bool} get_string({\cf17 const} input_format_t format,\par
10687                     {\cf17 const} NumberType len,\par
10688                     string_t& result)\par
10689     \{\par
10690         {\cf18 bool} success = {\cf17 true};\par
10691         {\cf19 for} (NumberType i = 0; i < len; i++)\par
10692         \{\par
10693             get();\par
10694             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, {\cf22 "string"})))\par
10695             \{\par
10696                 success = {\cf17 false};\par
10697                 {\cf19 break};\par
10698             \}\par
10699             result.push_back({\cf17 static_cast<}typename string_t::value_type{\cf17 >}(current));\par
10700         \}\par
10701         {\cf19 return} success;\par
10702     \}\par
10703 \par
10718     {\cf17 template}<{\cf17 typename} NumberType>\par
10719     {\cf18 bool} get_binary({\cf17 const} input_format_t format,\par
10720                     {\cf17 const} NumberType len,\par
10721                     binary_t& result)\par
10722     \{\par
10723         {\cf18 bool} success = {\cf17 true};\par
10724         {\cf19 for} (NumberType i = 0; i < len; i++)\par
10725         \{\par
10726             get();\par
10727             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!unexpect_eof(format, {\cf22 "binary"})))\par
10728             \{\par
10729                 success = {\cf17 false};\par
10730                 {\cf19 break};\par
10731             \}\par
10732             result.push_back({\cf17 static_cast<}std::uint8_t{\cf17 >}(current));\par
10733         \}\par
10734         {\cf19 return} success;\par
10735     \}\par
10736 \par
10742     JSON_HEDLEY_NON_NULL(3)\par
10743     bool unexpect_eof(const input_format_t format, const {\cf18 char}* context){\cf17  const}\par
10744 {\cf17     }\{\par
10745         {\cf19 if} (JSON_HEDLEY_UNLIKELY(current == std::char_traits<char_type>::eof()))\par
10746         \{\par
10747             {\cf19 return} sax->parse_error(chars_read, {\cf22 "<end of file>"},\par
10748                                     parse_error::create(110, chars_read, exception_message(format, {\cf22 "unexpected end of input"}, context), BasicJsonType()));\par
10749         \}\par
10750         {\cf19 return} {\cf17 true};\par
10751     \}\par
10752 \par
10756     std::string get_token_string(){\cf17  const}\par
10757 {\cf17     }\{\par
10758         std::array<char, 3> cr\{\{\}\};\par
10759         (std::snprintf)(cr.data(), cr.size(), {\cf22 "%.2hhX"}, {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(current)); {\cf20 // NOLINT(cppcoreguidelines-pro-type-vararg,hicpp-vararg)}\par
10760         {\cf19 return} std::string\{cr.data()\};\par
10761     \}\par
10762 \par
10769     std::string exception_message({\cf17 const} input_format_t format,\par
10770                                   {\cf17 const} std::string& detail,\par
10771                                   {\cf17 const} std::string& context){\cf17  const}\par
10772 {\cf17     }\{\par
10773         std::string error_msg = {\cf22 "syntax error while parsing "};\par
10774 \par
10775         {\cf19 switch} (format)\par
10776         \{\par
10777             {\cf19 case} input_format_t::cbor:\par
10778                 error_msg += {\cf22 "CBOR"};\par
10779                 {\cf19 break};\par
10780 \par
10781             {\cf19 case} input_format_t::msgpack:\par
10782                 error_msg += {\cf22 "MessagePack"};\par
10783                 {\cf19 break};\par
10784 \par
10785             {\cf19 case} input_format_t::ubjson:\par
10786                 error_msg += {\cf22 "UBJSON"};\par
10787                 {\cf19 break};\par
10788 \par
10789             {\cf19 case} input_format_t::bson:\par
10790                 error_msg += {\cf22 "BSON"};\par
10791                 {\cf19 break};\par
10792 \par
10793             {\cf19 case} input_format_t::json: {\cf20 // LCOV_EXCL_LINE}\par
10794             {\cf19 default}:            {\cf20 // LCOV_EXCL_LINE}\par
10795                 JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE}\par
10796         \}\par
10797 \par
10798         {\cf19 return} error_msg + {\cf22 " "} + context + {\cf22 ": "} + detail;\par
10799     \}\par
10800 \par
10801   {\cf17 private}:\par
10803     InputAdapterType ia;\par
10804 \par
10806     char_int_type current = std::char_traits<char_type>::eof();\par
10807 \par
10809     std::size_t chars_read = 0;\par
10810 \par
10812     {\cf17 const} {\cf18 bool} is_little_endian = little_endianess();\par
10813 \par
10815     json_sax_t* sax = {\cf17 nullptr};\par
10816 \};\par
10817 \}  {\cf20 // namespace detail}\par
10818 \}  {\cf20 // namespace nlohmann}\par
10819 \par
10820 {\cf20 // #include <nlohmann/detail/input/input_adapters.hpp>}\par
10821 \par
10822 {\cf20 // #include <nlohmann/detail/input/lexer.hpp>}\par
10823 \par
10824 {\cf20 // #include <nlohmann/detail/input/parser.hpp>}\par
10825 \par
10826 \par
10827 {\cf21 #include <cmath>} {\cf20 // isfinite}\par
10828 {\cf21 #include <cstdint>} {\cf20 // uint8_t}\par
10829 {\cf21 #include <functional>} {\cf20 // function}\par
10830 {\cf21 #include <string>} {\cf20 // string}\par
10831 {\cf21 #include <utility>} {\cf20 // move}\par
10832 {\cf21 #include <vector>} {\cf20 // vector}\par
10833 \par
10834 {\cf20 // #include <nlohmann/detail/exceptions.hpp>}\par
10835 \par
10836 {\cf20 // #include <nlohmann/detail/input/input_adapters.hpp>}\par
10837 \par
10838 {\cf20 // #include <nlohmann/detail/input/json_sax.hpp>}\par
10839 \par
10840 {\cf20 // #include <nlohmann/detail/input/lexer.hpp>}\par
10841 \par
10842 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
10843 \par
10844 {\cf20 // #include <nlohmann/detail/meta/is_sax.hpp>}\par
10845 \par
10846 {\cf20 // #include <nlohmann/detail/value_t.hpp>}\par
10847 \par
10848 \par
10849 {\cf17 namespace }nlohmann\par
10850 \{\par
10851 {\cf17 namespace }detail\par
10852 \{\par
10854 {\cf20 // parser //}\par
10856 {\cf20 }\par
10857 {\cf17 enum class} parse_event_t : std::uint8_t\par
10858 \{\par
10860     object_start,\par
10862     object_end,\par
10864     array_start,\par
10866     array_end,\par
10868     key,\par
10870     value\par
10871 \};\par
10872 \par
10873 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
10874 {\cf17 using} parser_callback_t =\par
10875     std::function<bool({\cf18 int} {\cf20 /*depth*/}, parse_event_t {\cf20 /*event*/}, BasicJsonType& {\cf20 /*parsed*/})>;\par
10876 \par
10882 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} InputAdapterType>\par
10883 {\cf17 class }parser\par
10884 \{\par
10885     {\cf17 using} number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
10886     {\cf17 using} number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
10887     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
10888     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
10889     {\cf17 using} lexer_t = lexer<BasicJsonType, InputAdapterType>;\par
10890     {\cf17 using} token_type = {\cf17 typename} lexer_t::token_type;\par
10891 \par
10892   {\cf17 public}:\par
10894     {\cf17 explicit} parser(InputAdapterType&& adapter,\par
10895                     {\cf17 const} parser_callback_t<BasicJsonType> cb = {\cf17 nullptr},\par
10896                     {\cf17 const} {\cf18 bool} allow_exceptions_ = {\cf17 true},\par
10897                     {\cf17 const} {\cf18 bool} skip_comments = {\cf17 false})\par
10898         : callback(cb)\par
10899         , m_lexer(std::move(adapter), skip_comments)\par
10900         , allow_exceptions(allow_exceptions_)\par
10901     \{\par
10902         {\cf20 // read first token}\par
10903         get_token();\par
10904     \}\par
10905 \par
10916     {\cf18 void} parse({\cf17 const} {\cf18 bool} strict, BasicJsonType& result)\par
10917     \{\par
10918         {\cf19 if} (callback)\par
10919         \{\par
10920             json_sax_dom_callback_parser<BasicJsonType> sdp(result, callback, allow_exceptions);\par
10921             sax_parse_internal(&sdp);\par
10922 \par
10923             {\cf20 // in strict mode, input must be completely read}\par
10924             {\cf19 if} (strict && (get_token() != token_type::end_of_input))\par
10925             \{\par
10926                 sdp.parse_error(m_lexer.get_position(),\par
10927                                 m_lexer.get_token_string(),\par
10928                                 parse_error::create(101, m_lexer.get_position(),\par
10929                                                     exception_message(token_type::end_of_input, {\cf22 "value"}), BasicJsonType()));\par
10930             \}\par
10931 \par
10932             {\cf20 // in case of an error, return discarded value}\par
10933             {\cf19 if} (sdp.is_errored())\par
10934             \{\par
10935                 result = value_t::discarded;\par
10936                 {\cf19 return};\par
10937             \}\par
10938 \par
10939             {\cf20 // set top-level value to null if it was discarded by the callback}\par
10940             {\cf20 // function}\par
10941             {\cf19 if} (result.is_discarded())\par
10942             \{\par
10943                 result = {\cf17 nullptr};\par
10944             \}\par
10945         \}\par
10946         {\cf19 else}\par
10947         \{\par
10948             json_sax_dom_parser<BasicJsonType> sdp(result, allow_exceptions);\par
10949             sax_parse_internal(&sdp);\par
10950 \par
10951             {\cf20 // in strict mode, input must be completely read}\par
10952             {\cf19 if} (strict && (get_token() != token_type::end_of_input))\par
10953             \{\par
10954                 sdp.parse_error(m_lexer.get_position(),\par
10955                                 m_lexer.get_token_string(),\par
10956                                 parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, {\cf22 "value"}), BasicJsonType()));\par
10957             \}\par
10958 \par
10959             {\cf20 // in case of an error, return discarded value}\par
10960             {\cf19 if} (sdp.is_errored())\par
10961             \{\par
10962                 result = value_t::discarded;\par
10963                 {\cf19 return};\par
10964             \}\par
10965         \}\par
10966 \par
10967         result.assert_invariant();\par
10968     \}\par
10969 \par
10976     {\cf18 bool} accept({\cf17 const} {\cf18 bool} strict = {\cf17 true})\par
10977     \{\par
10978         json_sax_acceptor<BasicJsonType> sax_acceptor;\par
10979         {\cf19 return} sax_parse(&sax_acceptor, strict);\par
10980     \}\par
10981 \par
10982     {\cf17 template}<{\cf17 typename} SAX>\par
10983     JSON_HEDLEY_NON_NULL(2)\par
10984     bool sax_parse(SAX* sax, const {\cf18 bool} strict = true)\par
10985     \{\par
10986         (void)detail::is_sax_static_asserts<SAX, BasicJsonType> \{\};\par
10987         {\cf17 const} {\cf18 bool} result = sax_parse_internal(sax);\par
10988 \par
10989         {\cf20 // strict mode: next byte must be EOF}\par
10990         {\cf19 if} (result && strict && (get_token() != token_type::end_of_input))\par
10991         \{\par
10992             {\cf19 return} sax->parse_error(m_lexer.get_position(),\par
10993                                     m_lexer.get_token_string(),\par
10994                                     parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, {\cf22 "value"}), BasicJsonType()));\par
10995         \}\par
10996 \par
10997         {\cf19 return} result;\par
10998     \}\par
10999 \par
11000   {\cf17 private}:\par
11001     {\cf17 template}<{\cf17 typename} SAX>\par
11002     JSON_HEDLEY_NON_NULL(2)\par
11003     bool sax_parse_internal(SAX* sax)\par
11004     \{\par
11005         {\cf20 // stack to remember the hierarchy of structured values we are parsing}\par
11006         {\cf20 // true = array; false = object}\par
11007         std::vector<bool> states;\par
11008         {\cf20 // value to avoid a goto (see comment where set to true)}\par
11009         {\cf18 bool} skip_to_state_evaluation = {\cf17 false};\par
11010 \par
11011         {\cf19 while} ({\cf17 true})\par
11012         \{\par
11013             {\cf19 if} (!skip_to_state_evaluation)\par
11014             \{\par
11015                 {\cf20 // invariant: get_token() was called before each iteration}\par
11016                 {\cf19 switch} (last_token)\par
11017                 \{\par
11018                     {\cf19 case} token_type::begin_object:\par
11019                     \{\par
11020                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_object(std::size_t(-1))))\par
11021                         \{\par
11022                             {\cf19 return} {\cf17 false};\par
11023                         \}\par
11024 \par
11025                         {\cf20 // closing \} -> we are done}\par
11026                         {\cf19 if} (get_token() == token_type::end_object)\par
11027                         \{\par
11028                             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->end_object()))\par
11029                             \{\par
11030                                 {\cf19 return} {\cf17 false};\par
11031                             \}\par
11032                             {\cf19 break};\par
11033                         \}\par
11034 \par
11035                         {\cf20 // parse key}\par
11036                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))\par
11037                         \{\par
11038                             {\cf19 return} sax->parse_error(m_lexer.get_position(),\par
11039                                                     m_lexer.get_token_string(),\par
11040                                                     parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, {\cf22 "object key"}), BasicJsonType()));\par
11041                         \}\par
11042                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))\par
11043                         \{\par
11044                             {\cf19 return} {\cf17 false};\par
11045                         \}\par
11046 \par
11047                         {\cf20 // parse separator (:)}\par
11048                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))\par
11049                         \{\par
11050                             {\cf19 return} sax->parse_error(m_lexer.get_position(),\par
11051                                                     m_lexer.get_token_string(),\par
11052                                                     parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, {\cf22 "object separator"}), BasicJsonType()));\par
11053                         \}\par
11054 \par
11055                         {\cf20 // remember we are now inside an object}\par
11056                         states.push_back({\cf17 false});\par
11057 \par
11058                         {\cf20 // parse values}\par
11059                         get_token();\par
11060                         {\cf19 continue};\par
11061                     \}\par
11062 \par
11063                     {\cf19 case} token_type::begin_array:\par
11064                     \{\par
11065                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->start_array(std::size_t(-1))))\par
11066                         \{\par
11067                             {\cf19 return} {\cf17 false};\par
11068                         \}\par
11069 \par
11070                         {\cf20 // closing ] -> we are done}\par
11071                         {\cf19 if} (get_token() == token_type::end_array)\par
11072                         \{\par
11073                             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->end_array()))\par
11074                             \{\par
11075                                 {\cf19 return} {\cf17 false};\par
11076                             \}\par
11077                             {\cf19 break};\par
11078                         \}\par
11079 \par
11080                         {\cf20 // remember we are now inside an array}\par
11081                         states.push_back({\cf17 true});\par
11082 \par
11083                         {\cf20 // parse values (no need to call get_token)}\par
11084                         {\cf19 continue};\par
11085                     \}\par
11086 \par
11087                     {\cf19 case} token_type::value_float:\par
11088                     \{\par
11089                         {\cf17 const} {\cf17 auto} res = m_lexer.get_number_float();\par
11090 \par
11091                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))\par
11092                         \{\par
11093                             {\cf19 return} sax->parse_error(m_lexer.get_position(),\par
11094                                                     m_lexer.get_token_string(),\par
11095                                                     out_of_range::create(406, {\cf22 "number overflow parsing '"} + m_lexer.get_token_string() + {\cf22 "'"}, BasicJsonType()));\par
11096                         \}\par
11097 \par
11098                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->number_float(res, m_lexer.get_string())))\par
11099                         \{\par
11100                             {\cf19 return} {\cf17 false};\par
11101                         \}\par
11102 \par
11103                         {\cf19 break};\par
11104                     \}\par
11105 \par
11106                     {\cf19 case} token_type::literal_false:\par
11107                     \{\par
11108                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->boolean({\cf17 false})))\par
11109                         \{\par
11110                             {\cf19 return} {\cf17 false};\par
11111                         \}\par
11112                         {\cf19 break};\par
11113                     \}\par
11114 \par
11115                     {\cf19 case} token_type::literal_null:\par
11116                     \{\par
11117                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->null()))\par
11118                         \{\par
11119                             {\cf19 return} {\cf17 false};\par
11120                         \}\par
11121                         {\cf19 break};\par
11122                     \}\par
11123 \par
11124                     {\cf19 case} token_type::literal_true:\par
11125                     \{\par
11126                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->boolean({\cf17 true})))\par
11127                         \{\par
11128                             {\cf19 return} {\cf17 false};\par
11129                         \}\par
11130                         {\cf19 break};\par
11131                     \}\par
11132 \par
11133                     {\cf19 case} token_type::value_integer:\par
11134                     \{\par
11135                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->number_integer(m_lexer.get_number_integer())))\par
11136                         \{\par
11137                             {\cf19 return} {\cf17 false};\par
11138                         \}\par
11139                         {\cf19 break};\par
11140                     \}\par
11141 \par
11142                     {\cf19 case} token_type::value_string:\par
11143                     \{\par
11144                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->string(m_lexer.get_string())))\par
11145                         \{\par
11146                             {\cf19 return} {\cf17 false};\par
11147                         \}\par
11148                         {\cf19 break};\par
11149                     \}\par
11150 \par
11151                     {\cf19 case} token_type::value_unsigned:\par
11152                     \{\par
11153                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->number_unsigned(m_lexer.get_number_unsigned())))\par
11154                         \{\par
11155                             {\cf19 return} {\cf17 false};\par
11156                         \}\par
11157                         {\cf19 break};\par
11158                     \}\par
11159 \par
11160                     {\cf19 case} token_type::parse_error:\par
11161                     \{\par
11162                         {\cf20 // using "uninitialized" to avoid "expected" message}\par
11163                         {\cf19 return} sax->parse_error(m_lexer.get_position(),\par
11164                                                 m_lexer.get_token_string(),\par
11165                                                 parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized, {\cf22 "value"}), BasicJsonType()));\par
11166                     \}\par
11167 \par
11168                     {\cf19 case} token_type::uninitialized:\par
11169                     {\cf19 case} token_type::end_array:\par
11170                     {\cf19 case} token_type::end_object:\par
11171                     {\cf19 case} token_type::name_separator:\par
11172                     {\cf19 case} token_type::value_separator:\par
11173                     {\cf19 case} token_type::end_of_input:\par
11174                     {\cf19 case} token_type::literal_or_value:\par
11175                     {\cf19 default}: {\cf20 // the last token was unexpected}\par
11176                     \{\par
11177                         {\cf19 return} sax->parse_error(m_lexer.get_position(),\par
11178                                                 m_lexer.get_token_string(),\par
11179                                                 parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, {\cf22 "value"}), BasicJsonType()));\par
11180                     \}\par
11181                 \}\par
11182             \}\par
11183             {\cf19 else}\par
11184             \{\par
11185                 skip_to_state_evaluation = {\cf17 false};\par
11186             \}\par
11187 \par
11188             {\cf20 // we reached this line after we successfully parsed a value}\par
11189             {\cf19 if} (states.empty())\par
11190             \{\par
11191                 {\cf20 // empty stack: we reached the end of the hierarchy: done}\par
11192                 {\cf19 return} {\cf17 true};\par
11193             \}\par
11194 \par
11195             {\cf19 if} (states.back())  {\cf20 // array}\par
11196             \{\par
11197                 {\cf20 // comma -> next value}\par
11198                 {\cf19 if} (get_token() == token_type::value_separator)\par
11199                 \{\par
11200                     {\cf20 // parse a new value}\par
11201                     get_token();\par
11202                     {\cf19 continue};\par
11203                 \}\par
11204 \par
11205                 {\cf20 // closing ]}\par
11206                 {\cf19 if} (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))\par
11207                 \{\par
11208                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->end_array()))\par
11209                     \{\par
11210                         {\cf19 return} {\cf17 false};\par
11211                     \}\par
11212 \par
11213                     {\cf20 // We are done with this array. Before we can parse a}\par
11214                     {\cf20 // new value, we need to evaluate the new state first.}\par
11215                     {\cf20 // By setting skip_to_state_evaluation to false, we}\par
11216                     {\cf20 // are effectively jumping to the beginning of this if.}\par
11217                     JSON_ASSERT(!states.empty());\par
11218                     states.pop_back();\par
11219                     skip_to_state_evaluation = {\cf17 true};\par
11220                     {\cf19 continue};\par
11221                 \}\par
11222 \par
11223                 {\cf19 return} sax->parse_error(m_lexer.get_position(),\par
11224                                         m_lexer.get_token_string(),\par
11225                                         parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array, {\cf22 "array"}), BasicJsonType()));\par
11226             \}\par
11227 \par
11228             {\cf20 // states.back() is false -> object}\par
11229 \par
11230             {\cf20 // comma -> next value}\par
11231             {\cf19 if} (get_token() == token_type::value_separator)\par
11232             \{\par
11233                 {\cf20 // parse key}\par
11234                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))\par
11235                 \{\par
11236                     {\cf19 return} sax->parse_error(m_lexer.get_position(),\par
11237                                             m_lexer.get_token_string(),\par
11238                                             parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, {\cf22 "object key"}), BasicJsonType()));\par
11239                 \}\par
11240 \par
11241                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->key(m_lexer.get_string())))\par
11242                 \{\par
11243                     {\cf19 return} {\cf17 false};\par
11244                 \}\par
11245 \par
11246                 {\cf20 // parse separator (:)}\par
11247                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))\par
11248                 \{\par
11249                     {\cf19 return} sax->parse_error(m_lexer.get_position(),\par
11250                                             m_lexer.get_token_string(),\par
11251                                             parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, {\cf22 "object separator"}), BasicJsonType()));\par
11252                 \}\par
11253 \par
11254                 {\cf20 // parse values}\par
11255                 get_token();\par
11256                 {\cf19 continue};\par
11257             \}\par
11258 \par
11259             {\cf20 // closing \}}\par
11260             {\cf19 if} (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))\par
11261             \{\par
11262                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!sax->end_object()))\par
11263                 \{\par
11264                     {\cf19 return} {\cf17 false};\par
11265                 \}\par
11266 \par
11267                 {\cf20 // We are done with this object. Before we can parse a}\par
11268                 {\cf20 // new value, we need to evaluate the new state first.}\par
11269                 {\cf20 // By setting skip_to_state_evaluation to false, we}\par
11270                 {\cf20 // are effectively jumping to the beginning of this if.}\par
11271                 JSON_ASSERT(!states.empty());\par
11272                 states.pop_back();\par
11273                 skip_to_state_evaluation = {\cf17 true};\par
11274                 {\cf19 continue};\par
11275             \}\par
11276 \par
11277             {\cf19 return} sax->parse_error(m_lexer.get_position(),\par
11278                                     m_lexer.get_token_string(),\par
11279                                     parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object, {\cf22 "object"}), BasicJsonType()));\par
11280         \}\par
11281     \}\par
11282 \par
11284     token_type get_token()\par
11285     \{\par
11286         {\cf19 return} last_token = m_lexer.scan();\par
11287     \}\par
11288 \par
11289     std::string exception_message({\cf17 const} token_type expected, {\cf17 const} std::string& context)\par
11290     \{\par
11291         std::string error_msg = {\cf22 "syntax error "};\par
11292 \par
11293         {\cf19 if} (!context.empty())\par
11294         \{\par
11295             error_msg += {\cf22 "while parsing "} + context + {\cf22 " "};\par
11296         \}\par
11297 \par
11298         error_msg += {\cf22 "- "};\par
11299 \par
11300         {\cf19 if} (last_token == token_type::parse_error)\par
11301         \{\par
11302             error_msg += std::string(m_lexer.get_error_message()) + {\cf22 "; last read: '"} +\par
11303                          m_lexer.get_token_string() + {\cf22 "'"};\par
11304         \}\par
11305         {\cf19 else}\par
11306         \{\par
11307             error_msg += {\cf22 "unexpected "} + std::string(lexer_t::token_type_name(last_token));\par
11308         \}\par
11309 \par
11310         {\cf19 if} (expected != token_type::uninitialized)\par
11311         \{\par
11312             error_msg += {\cf22 "; expected "} + std::string(lexer_t::token_type_name(expected));\par
11313         \}\par
11314 \par
11315         {\cf19 return} error_msg;\par
11316     \}\par
11317 \par
11318   {\cf17 private}:\par
11320     {\cf17 const} parser_callback_t<BasicJsonType> callback = {\cf17 nullptr};\par
11322     token_type last_token = token_type::uninitialized;\par
11324     lexer_t m_lexer;\par
11326     {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true};\par
11327 \};\par
11328 \par
11329 \}  {\cf20 // namespace detail}\par
11330 \}  {\cf20 // namespace nlohmann}\par
11331 \par
11332 {\cf20 // #include <nlohmann/detail/iterators/internal_iterator.hpp>}\par
11333 \par
11334 \par
11335 {\cf20 // #include <nlohmann/detail/iterators/primitive_iterator.hpp>}\par
11336 \par
11337 \par
11338 {\cf21 #include <cstddef>} {\cf20 // ptrdiff_t}\par
11339 {\cf21 #include <limits>}  {\cf20 // numeric_limits}\par
11340 \par
11341 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
11342 \par
11343 \par
11344 {\cf17 namespace }nlohmann\par
11345 \{\par
11346 {\cf17 namespace }detail\par
11347 \{\par
11348 {\cf20 /*}\par
11349 {\cf20 @brief an iterator for primitive JSON types}\par
11350 {\cf20 }\par
11351 {\cf20 This class models an iterator for primitive JSON types (boolean, number,}\par
11352 {\cf20 string). It's only purpose is to allow the iterator/const_iterator classes}\par
11353 {\cf20 to "iterate" over primitive values. Internally, the iterator is modeled by}\par
11354 {\cf20 a `difference_type` variable. Value begin_value (`0`) models the begin,}\par
11355 {\cf20 end_value (`1`) models past the end.}\par
11356 {\cf20 */}\par
11357 {\cf17 class }primitive_iterator_t\par
11358 \{\par
11359   {\cf17 private}:\par
11360     {\cf17 using} difference_type = std::ptrdiff_t;\par
11361     {\cf17 static} {\cf17 constexpr} difference_type begin_value = 0;\par
11362     {\cf17 static} {\cf17 constexpr} difference_type end_value = begin_value + 1;\par
11363 \par
11364   JSON_PRIVATE_UNLESS_TESTED:\par
11366     difference_type m_it = (std::numeric_limits<std::ptrdiff_t>::min)();\par
11367 \par
11368   {\cf17 public}:\par
11369     {\cf17 constexpr} difference_type get_value() const noexcept\par
11370     \{\par
11371         {\cf19 return} m_it;\par
11372     \}\par
11373 \par
11375     {\cf18 void} set_begin() noexcept\par
11376     \{\par
11377         m_it = begin_value;\par
11378     \}\par
11379 \par
11381     {\cf18 void} set_end() noexcept\par
11382     \{\par
11383         m_it = end_value;\par
11384     \}\par
11385 \par
11387     {\cf17 constexpr} {\cf18 bool} is_begin() const noexcept\par
11388     \{\par
11389         {\cf19 return} m_it == begin_value;\par
11390     \}\par
11391 \par
11393     {\cf17 constexpr} {\cf18 bool} is_end() const noexcept\par
11394     \{\par
11395         {\cf19 return} m_it == end_value;\par
11396     \}\par
11397 \par
11398     {\cf17 friend} {\cf17 constexpr} {\cf18 bool} operator==(primitive_iterator_t lhs, primitive_iterator_t rhs) {\cf17 noexcept}\par
11399     \{\par
11400         {\cf19 return} lhs.m_it == rhs.m_it;\par
11401     \}\par
11402 \par
11403     {\cf17 friend} {\cf17 constexpr} {\cf18 bool} operator<(primitive_iterator_t lhs, primitive_iterator_t rhs) {\cf17 noexcept}\par
11404     \{\par
11405         {\cf19 return} lhs.m_it < rhs.m_it;\par
11406     \}\par
11407 \par
11408     primitive_iterator_t operator+(difference_type n) {\cf17 noexcept}\par
11409     \{\par
11410         {\cf17 auto} result = *{\cf17 this};\par
11411         result += n;\par
11412         {\cf19 return} result;\par
11413     \}\par
11414 \par
11415     {\cf17 friend} {\cf17 constexpr} difference_type operator-(primitive_iterator_t lhs, primitive_iterator_t rhs) {\cf17 noexcept}\par
11416     \{\par
11417         {\cf19 return} lhs.m_it - rhs.m_it;\par
11418     \}\par
11419 \par
11420     primitive_iterator_t& operator++() noexcept\par
11421     \{\par
11422         ++m_it;\par
11423         {\cf19 return} *{\cf17 this};\par
11424     \}\par
11425 \par
11426     primitive_iterator_t {\cf17 const} operator++({\cf18 int}) {\cf17 noexcept} {\cf20 // NOLINT(readability-const-return-type)}\par
11427     \{\par
11428         {\cf17 auto} result = *{\cf17 this};\par
11429         ++m_it;\par
11430         {\cf19 return} result;\par
11431     \}\par
11432 \par
11433     primitive_iterator_t& operator--() noexcept\par
11434     \{\par
11435         --m_it;\par
11436         {\cf19 return} *{\cf17 this};\par
11437     \}\par
11438 \par
11439     primitive_iterator_t {\cf17 const} operator--({\cf18 int}) {\cf17 noexcept} {\cf20 // NOLINT(readability-const-return-type)}\par
11440     \{\par
11441         {\cf17 auto} result = *{\cf17 this};\par
11442         --m_it;\par
11443         {\cf19 return} result;\par
11444     \}\par
11445 \par
11446     primitive_iterator_t& operator+=(difference_type n) {\cf17 noexcept}\par
11447     \{\par
11448         m_it += n;\par
11449         {\cf19 return} *{\cf17 this};\par
11450     \}\par
11451 \par
11452     primitive_iterator_t& operator-=(difference_type n) {\cf17 noexcept}\par
11453     \{\par
11454         m_it -= n;\par
11455         {\cf19 return} *{\cf17 this};\par
11456     \}\par
11457 \};\par
11458 \}  {\cf20 // namespace detail}\par
11459 \}  {\cf20 // namespace nlohmann}\par
11460 \par
11461 \par
11462 {\cf17 namespace }nlohmann\par
11463 \{\par
11464 {\cf17 namespace }detail\par
11465 \{\par
11472 {\cf17 template}<{\cf17 typename} BasicJsonType> {\cf17 struct }internal_iterator\par
11473 \{\par
11475     {\cf17 typename} BasicJsonType::object_t::iterator object_iterator \{\};\par
11477     {\cf17 typename} BasicJsonType::array_t::iterator array_iterator \{\};\par
11479     primitive_iterator_t primitive_iterator \{\};\par
11480 \};\par
11481 \}  {\cf20 // namespace detail}\par
11482 \}  {\cf20 // namespace nlohmann}\par
11483 \par
11484 {\cf20 // #include <nlohmann/detail/iterators/iter_impl.hpp>}\par
11485 \par
11486 \par
11487 {\cf21 #include <iterator>} {\cf20 // iterator, random_access_iterator_tag, bidirectional_iterator_tag, advance, next}\par
11488 {\cf21 #include <type_traits>} {\cf20 // conditional, is_const, remove_const}\par
11489 \par
11490 {\cf20 // #include <nlohmann/detail/exceptions.hpp>}\par
11491 \par
11492 {\cf20 // #include <nlohmann/detail/iterators/internal_iterator.hpp>}\par
11493 \par
11494 {\cf20 // #include <nlohmann/detail/iterators/primitive_iterator.hpp>}\par
11495 \par
11496 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
11497 \par
11498 {\cf20 // #include <nlohmann/detail/meta/cpp_future.hpp>}\par
11499 \par
11500 {\cf20 // #include <nlohmann/detail/meta/type_traits.hpp>}\par
11501 \par
11502 {\cf20 // #include <nlohmann/detail/value_t.hpp>}\par
11503 \par
11504 \par
11505 {\cf17 namespace }nlohmann\par
11506 \{\par
11507 {\cf17 namespace }detail\par
11508 \{\par
11509 {\cf20 // forward declare, to be able to friend it later on}\par
11510 {\cf17 template}<{\cf17 typename} IteratorType> {\cf17 class }iteration_proxy;\par
11511 {\cf17 template}<{\cf17 typename} IteratorType> {\cf17 class }iteration_proxy_value;\par
11512 \par
11529 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
11530 {\cf17 class }iter_impl\par
11531 \{\par
11533     {\cf17 using} other_iter_impl = iter_impl<typename std::conditional<std::is_const<BasicJsonType>::value, {\cf17 typename} std::remove_const<BasicJsonType>::type, {\cf17 const} BasicJsonType>::type>;\par
11535     {\cf17 friend} other_iter_impl;\par
11536     {\cf17 friend} BasicJsonType;\par
11537     {\cf17 friend} iteration_proxy<iter_impl>;\par
11538     {\cf17 friend} iteration_proxy_value<iter_impl>;\par
11539 \par
11540     {\cf17 using} object_t = {\cf17 typename} BasicJsonType::object_t;\par
11541     {\cf17 using} array_t = {\cf17 typename} BasicJsonType::array_t;\par
11542     {\cf20 // make sure BasicJsonType is basic_json or const basic_json}\par
11543     {\cf17 static_assert}(is_basic_json<typename std::remove_const<BasicJsonType>::type>::value,\par
11544                   {\cf22 "iter_impl only accepts (const) basic_json"});\par
11545 \par
11546   {\cf17 public}:\par
11547 \par
11553     {\cf17 using} iterator_category = std::bidirectional_iterator_tag;\par
11554 \par
11556     {\cf17 using} value_type = {\cf17 typename} BasicJsonType::value_type;\par
11558     {\cf17 using} difference_type = {\cf17 typename} BasicJsonType::difference_type;\par
11560     {\cf17 using} pointer = {\cf17 typename} std::conditional<std::is_const<BasicJsonType>::value,\par
11561           {\cf17 typename} BasicJsonType::const_pointer,\par
11562           {\cf17 typename} BasicJsonType::pointer>::type;\par
11564     {\cf17 using} reference =\par
11565         {\cf17 typename} std::conditional<std::is_const<BasicJsonType>::value,\par
11566         {\cf17 typename} BasicJsonType::const_reference,\par
11567         {\cf17 typename} BasicJsonType::reference>::type;\par
11568 \par
11569     iter_impl() = {\cf19 default};\par
11570     ~iter_impl() = {\cf19 default};\par
11571     iter_impl(iter_impl&&) noexcept = default;\par
11572     iter_impl& operator=(iter_impl&&) noexcept = default;\par
11573 \par
11580     explicit iter_impl(pointer {\cf18 object}) noexcept : m_object({\cf18 object})\par
11581     \{\par
11582         JSON_ASSERT(m_object != {\cf17 nullptr});\par
11583 \par
11584         {\cf19 switch} (m_object->m_type)\par
11585         \{\par
11586             {\cf19 case} value_t::object:\par
11587             \{\par
11588                 m_it.object_iterator = {\cf17 typename} object_t::iterator();\par
11589                 {\cf19 break};\par
11590             \}\par
11591 \par
11592             {\cf19 case} value_t::array:\par
11593             \{\par
11594                 m_it.array_iterator = {\cf17 typename} array_t::iterator();\par
11595                 {\cf19 break};\par
11596             \}\par
11597 \par
11598             {\cf19 case} value_t::null:\par
11599             {\cf19 case} value_t::string:\par
11600             {\cf19 case} value_t::boolean:\par
11601             {\cf19 case} value_t::number_integer:\par
11602             {\cf19 case} value_t::number_unsigned:\par
11603             {\cf19 case} value_t::number_float:\par
11604             {\cf19 case} value_t::binary:\par
11605             {\cf19 case} value_t::discarded:\par
11606             {\cf19 default}:\par
11607             \{\par
11608                 m_it.primitive_iterator = primitive_iterator_t();\par
11609                 {\cf19 break};\par
11610             \}\par
11611         \}\par
11612     \}\par
11613 \par
11630     iter_impl({\cf17 const} iter_impl<const BasicJsonType>& other) noexcept\par
11631         : m_object(other.m_object), m_it(other.m_it)\par
11632     \{\}\par
11633 \par
11640     iter_impl& operator=({\cf17 const} iter_impl<const BasicJsonType>& other) {\cf17 noexcept}\par
11641     \{\par
11642         {\cf19 if} (&other != {\cf17 this})\par
11643         \{\par
11644             m_object = other.m_object;\par
11645             m_it = other.m_it;\par
11646         \}\par
11647         {\cf19 return} *{\cf17 this};\par
11648     \}\par
11649 \par
11655     iter_impl({\cf17 const} iter_impl<{\cf17 typename} std::remove_const<BasicJsonType>::type>& other) noexcept\par
11656         : m_object(other.m_object), m_it(other.m_it)\par
11657     \{\}\par
11658 \par
11665     iter_impl& operator=({\cf17 const} iter_impl<{\cf17 typename} std::remove_const<BasicJsonType>::type>& other) {\cf17 noexcept} {\cf20 // NOLINT(cert-oop54-cpp)}\par
11666     \{\par
11667         m_object = other.m_object;\par
11668         m_it = other.m_it;\par
11669         {\cf19 return} *{\cf17 this};\par
11670     \}\par
11671 \par
11672   JSON_PRIVATE_UNLESS_TESTED:\par
11677     {\cf18 void} set_begin() noexcept\par
11678     \{\par
11679         JSON_ASSERT(m_object != {\cf17 nullptr});\par
11680 \par
11681         {\cf19 switch} (m_object->m_type)\par
11682         \{\par
11683             {\cf19 case} value_t::object:\par
11684             \{\par
11685                 m_it.object_iterator = m_object->m_value.object->begin();\par
11686                 {\cf19 break};\par
11687             \}\par
11688 \par
11689             {\cf19 case} value_t::array:\par
11690             \{\par
11691                 m_it.array_iterator = m_object->m_value.array->begin();\par
11692                 {\cf19 break};\par
11693             \}\par
11694 \par
11695             {\cf19 case} value_t::null:\par
11696             \{\par
11697                 {\cf20 // set to end so begin()==end() is true: null is empty}\par
11698                 m_it.primitive_iterator.set_end();\par
11699                 {\cf19 break};\par
11700             \}\par
11701 \par
11702             {\cf19 case} value_t::string:\par
11703             {\cf19 case} value_t::boolean:\par
11704             {\cf19 case} value_t::number_integer:\par
11705             {\cf19 case} value_t::number_unsigned:\par
11706             {\cf19 case} value_t::number_float:\par
11707             {\cf19 case} value_t::binary:\par
11708             {\cf19 case} value_t::discarded:\par
11709             {\cf19 default}:\par
11710             \{\par
11711                 m_it.primitive_iterator.set_begin();\par
11712                 {\cf19 break};\par
11713             \}\par
11714         \}\par
11715     \}\par
11716 \par
11721     {\cf18 void} set_end() noexcept\par
11722     \{\par
11723         JSON_ASSERT(m_object != {\cf17 nullptr});\par
11724 \par
11725         {\cf19 switch} (m_object->m_type)\par
11726         \{\par
11727             {\cf19 case} value_t::object:\par
11728             \{\par
11729                 m_it.object_iterator = m_object->m_value.object->end();\par
11730                 {\cf19 break};\par
11731             \}\par
11732 \par
11733             {\cf19 case} value_t::array:\par
11734             \{\par
11735                 m_it.array_iterator = m_object->m_value.array->end();\par
11736                 {\cf19 break};\par
11737             \}\par
11738 \par
11739             {\cf19 case} value_t::null:\par
11740             {\cf19 case} value_t::string:\par
11741             {\cf19 case} value_t::boolean:\par
11742             {\cf19 case} value_t::number_integer:\par
11743             {\cf19 case} value_t::number_unsigned:\par
11744             {\cf19 case} value_t::number_float:\par
11745             {\cf19 case} value_t::binary:\par
11746             {\cf19 case} value_t::discarded:\par
11747             {\cf19 default}:\par
11748             \{\par
11749                 m_it.primitive_iterator.set_end();\par
11750                 {\cf19 break};\par
11751             \}\par
11752         \}\par
11753     \}\par
11754 \par
11755   {\cf17 public}:\par
11760     reference operator*(){\cf17  const}\par
11761 {\cf17     }\{\par
11762         JSON_ASSERT(m_object != {\cf17 nullptr});\par
11763 \par
11764         {\cf19 switch} (m_object->m_type)\par
11765         \{\par
11766             {\cf19 case} value_t::object:\par
11767             \{\par
11768                 JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());\par
11769                 {\cf19 return} m_it.object_iterator->second;\par
11770             \}\par
11771 \par
11772             {\cf19 case} value_t::array:\par
11773             \{\par
11774                 JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());\par
11775                 {\cf19 return} *m_it.array_iterator;\par
11776             \}\par
11777 \par
11778             {\cf19 case} value_t::null:\par
11779                 JSON_THROW(invalid_iterator::create(214, {\cf22 "cannot get value"}, *m_object));\par
11780 \par
11781             {\cf19 case} value_t::string:\par
11782             {\cf19 case} value_t::boolean:\par
11783             {\cf19 case} value_t::number_integer:\par
11784             {\cf19 case} value_t::number_unsigned:\par
11785             {\cf19 case} value_t::number_float:\par
11786             {\cf19 case} value_t::binary:\par
11787             {\cf19 case} value_t::discarded:\par
11788             {\cf19 default}:\par
11789             \{\par
11790                 {\cf19 if} (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))\par
11791                 \{\par
11792                     {\cf19 return} *m_object;\par
11793                 \}\par
11794 \par
11795                 JSON_THROW(invalid_iterator::create(214, {\cf22 "cannot get value"}, *m_object));\par
11796             \}\par
11797         \}\par
11798     \}\par
11799 \par
11804     pointer operator->(){\cf17  const}\par
11805 {\cf17     }\{\par
11806         JSON_ASSERT(m_object != {\cf17 nullptr});\par
11807 \par
11808         {\cf19 switch} (m_object->m_type)\par
11809         \{\par
11810             {\cf19 case} value_t::object:\par
11811             \{\par
11812                 JSON_ASSERT(m_it.object_iterator != m_object->m_value.object->end());\par
11813                 {\cf19 return} &(m_it.object_iterator->second);\par
11814             \}\par
11815 \par
11816             {\cf19 case} value_t::array:\par
11817             \{\par
11818                 JSON_ASSERT(m_it.array_iterator != m_object->m_value.array->end());\par
11819                 {\cf19 return} &*m_it.array_iterator;\par
11820             \}\par
11821 \par
11822             {\cf19 case} value_t::null:\par
11823             {\cf19 case} value_t::string:\par
11824             {\cf19 case} value_t::boolean:\par
11825             {\cf19 case} value_t::number_integer:\par
11826             {\cf19 case} value_t::number_unsigned:\par
11827             {\cf19 case} value_t::number_float:\par
11828             {\cf19 case} value_t::binary:\par
11829             {\cf19 case} value_t::discarded:\par
11830             {\cf19 default}:\par
11831             \{\par
11832                 {\cf19 if} (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.is_begin()))\par
11833                 \{\par
11834                     {\cf19 return} m_object;\par
11835                 \}\par
11836 \par
11837                 JSON_THROW(invalid_iterator::create(214, {\cf22 "cannot get value"}, *m_object));\par
11838             \}\par
11839         \}\par
11840     \}\par
11841 \par
11846     iter_impl {\cf17 const} operator++({\cf18 int}) {\cf20 // NOLINT(readability-const-return-type)}\par
11847     \{\par
11848         {\cf17 auto} result = *{\cf17 this};\par
11849         ++(*this);\par
11850         {\cf19 return} result;\par
11851     \}\par
11852 \par
11857     iter_impl& operator++()\par
11858     \{\par
11859         JSON_ASSERT(m_object != {\cf17 nullptr});\par
11860 \par
11861         {\cf19 switch} (m_object->m_type)\par
11862         \{\par
11863             {\cf19 case} value_t::object:\par
11864             \{\par
11865                 std::advance(m_it.object_iterator, 1);\par
11866                 {\cf19 break};\par
11867             \}\par
11868 \par
11869             {\cf19 case} value_t::array:\par
11870             \{\par
11871                 std::advance(m_it.array_iterator, 1);\par
11872                 {\cf19 break};\par
11873             \}\par
11874 \par
11875             {\cf19 case} value_t::null:\par
11876             {\cf19 case} value_t::string:\par
11877             {\cf19 case} value_t::boolean:\par
11878             {\cf19 case} value_t::number_integer:\par
11879             {\cf19 case} value_t::number_unsigned:\par
11880             {\cf19 case} value_t::number_float:\par
11881             {\cf19 case} value_t::binary:\par
11882             {\cf19 case} value_t::discarded:\par
11883             {\cf19 default}:\par
11884             \{\par
11885                 ++m_it.primitive_iterator;\par
11886                 {\cf19 break};\par
11887             \}\par
11888         \}\par
11889 \par
11890         {\cf19 return} *{\cf17 this};\par
11891     \}\par
11892 \par
11897     iter_impl {\cf17 const} operator--({\cf18 int}) {\cf20 // NOLINT(readability-const-return-type)}\par
11898     \{\par
11899         {\cf17 auto} result = *{\cf17 this};\par
11900         --(*this);\par
11901         {\cf19 return} result;\par
11902     \}\par
11903 \par
11908     iter_impl& operator--()\par
11909     \{\par
11910         JSON_ASSERT(m_object != {\cf17 nullptr});\par
11911 \par
11912         {\cf19 switch} (m_object->m_type)\par
11913         \{\par
11914             {\cf19 case} value_t::object:\par
11915             \{\par
11916                 std::advance(m_it.object_iterator, -1);\par
11917                 {\cf19 break};\par
11918             \}\par
11919 \par
11920             {\cf19 case} value_t::array:\par
11921             \{\par
11922                 std::advance(m_it.array_iterator, -1);\par
11923                 {\cf19 break};\par
11924             \}\par
11925 \par
11926             {\cf19 case} value_t::null:\par
11927             {\cf19 case} value_t::string:\par
11928             {\cf19 case} value_t::boolean:\par
11929             {\cf19 case} value_t::number_integer:\par
11930             {\cf19 case} value_t::number_unsigned:\par
11931             {\cf19 case} value_t::number_float:\par
11932             {\cf19 case} value_t::binary:\par
11933             {\cf19 case} value_t::discarded:\par
11934             {\cf19 default}:\par
11935             \{\par
11936                 --m_it.primitive_iterator;\par
11937                 {\cf19 break};\par
11938             \}\par
11939         \}\par
11940 \par
11941         {\cf19 return} *{\cf17 this};\par
11942     \}\par
11943 \par
11948     {\cf17 template} < {\cf17 typename} IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::{\cf18 nullptr}_t > = {\cf18 nullptr} >\par
11949     {\cf18 bool} operator==({\cf17 const} IterImpl& other){\cf17  const}\par
11950 {\cf17     }\{\par
11951         {\cf20 // if objects are not the same, the comparison is undefined}\par
11952         {\cf19 if} (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))\par
11953         \{\par
11954             JSON_THROW(invalid_iterator::create(212, {\cf22 "cannot compare iterators of different containers"}, *m_object));\par
11955         \}\par
11956 \par
11957         JSON_ASSERT(m_object != {\cf17 nullptr});\par
11958 \par
11959         {\cf19 switch} (m_object->m_type)\par
11960         \{\par
11961             {\cf19 case} value_t::object:\par
11962                 {\cf19 return} (m_it.object_iterator == other.m_it.object_iterator);\par
11963 \par
11964             {\cf19 case} value_t::array:\par
11965                 {\cf19 return} (m_it.array_iterator == other.m_it.array_iterator);\par
11966 \par
11967             {\cf19 case} value_t::null:\par
11968             {\cf19 case} value_t::string:\par
11969             {\cf19 case} value_t::boolean:\par
11970             {\cf19 case} value_t::number_integer:\par
11971             {\cf19 case} value_t::number_unsigned:\par
11972             {\cf19 case} value_t::number_float:\par
11973             {\cf19 case} value_t::binary:\par
11974             {\cf19 case} value_t::discarded:\par
11975             {\cf19 default}:\par
11976                 {\cf19 return} (m_it.primitive_iterator == other.m_it.primitive_iterator);\par
11977         \}\par
11978     \}\par
11979 \par
11984     {\cf17 template} < {\cf17 typename} IterImpl, detail::enable_if_t < (std::is_same<IterImpl, iter_impl>::value || std::is_same<IterImpl, other_iter_impl>::value), std::{\cf18 nullptr}_t > = {\cf18 nullptr} >\par
11985     {\cf18 bool} operator!=({\cf17 const} IterImpl& other){\cf17  const}\par
11986 {\cf17     }\{\par
11987         {\cf19 return} !operator==(other);\par
11988     \}\par
11989 \par
11994     {\cf18 bool} operator<({\cf17 const} iter_impl& other){\cf17  const}\par
11995 {\cf17     }\{\par
11996         {\cf20 // if objects are not the same, the comparison is undefined}\par
11997         {\cf19 if} (JSON_HEDLEY_UNLIKELY(m_object != other.m_object))\par
11998         \{\par
11999             JSON_THROW(invalid_iterator::create(212, {\cf22 "cannot compare iterators of different containers"}, *m_object));\par
12000         \}\par
12001 \par
12002         JSON_ASSERT(m_object != {\cf17 nullptr});\par
12003 \par
12004         {\cf19 switch} (m_object->m_type)\par
12005         \{\par
12006             {\cf19 case} value_t::object:\par
12007                 JSON_THROW(invalid_iterator::create(213, {\cf22 "cannot compare order of object iterators"}, *m_object));\par
12008 \par
12009             {\cf19 case} value_t::array:\par
12010                 {\cf19 return} (m_it.array_iterator < other.m_it.array_iterator);\par
12011 \par
12012             {\cf19 case} value_t::null:\par
12013             {\cf19 case} value_t::string:\par
12014             {\cf19 case} value_t::boolean:\par
12015             {\cf19 case} value_t::number_integer:\par
12016             {\cf19 case} value_t::number_unsigned:\par
12017             {\cf19 case} value_t::number_float:\par
12018             {\cf19 case} value_t::binary:\par
12019             {\cf19 case} value_t::discarded:\par
12020             {\cf19 default}:\par
12021                 {\cf19 return} (m_it.primitive_iterator < other.m_it.primitive_iterator);\par
12022         \}\par
12023     \}\par
12024 \par
12029     {\cf18 bool} operator<=({\cf17 const} iter_impl& other){\cf17  const}\par
12030 {\cf17     }\{\par
12031         {\cf19 return} !other.operator < (*this);\par
12032     \}\par
12033 \par
12038     {\cf18 bool} operator>({\cf17 const} iter_impl& other){\cf17  const}\par
12039 {\cf17     }\{\par
12040         {\cf19 return} !operator<=(other);\par
12041     \}\par
12042 \par
12047     {\cf18 bool} operator>=({\cf17 const} iter_impl& other){\cf17  const}\par
12048 {\cf17     }\{\par
12049         {\cf19 return} !operator<(other);\par
12050     \}\par
12051 \par
12056     iter_impl& operator+=(difference_type i)\par
12057     \{\par
12058         JSON_ASSERT(m_object != {\cf17 nullptr});\par
12059 \par
12060         {\cf19 switch} (m_object->m_type)\par
12061         \{\par
12062             {\cf19 case} value_t::object:\par
12063                 JSON_THROW(invalid_iterator::create(209, {\cf22 "cannot use offsets with object iterators"}, *m_object));\par
12064 \par
12065             {\cf19 case} value_t::array:\par
12066             \{\par
12067                 std::advance(m_it.array_iterator, i);\par
12068                 {\cf19 break};\par
12069             \}\par
12070 \par
12071             {\cf19 case} value_t::null:\par
12072             {\cf19 case} value_t::string:\par
12073             {\cf19 case} value_t::boolean:\par
12074             {\cf19 case} value_t::number_integer:\par
12075             {\cf19 case} value_t::number_unsigned:\par
12076             {\cf19 case} value_t::number_float:\par
12077             {\cf19 case} value_t::binary:\par
12078             {\cf19 case} value_t::discarded:\par
12079             {\cf19 default}:\par
12080             \{\par
12081                 m_it.primitive_iterator += i;\par
12082                 {\cf19 break};\par
12083             \}\par
12084         \}\par
12085 \par
12086         {\cf19 return} *{\cf17 this};\par
12087     \}\par
12088 \par
12093     iter_impl& operator-=(difference_type i)\par
12094     \{\par
12095         {\cf19 return} operator+=(-i);\par
12096     \}\par
12097 \par
12102     iter_impl operator+(difference_type i){\cf17  const}\par
12103 {\cf17     }\{\par
12104         {\cf17 auto} result = *{\cf17 this};\par
12105         result += i;\par
12106         {\cf19 return} result;\par
12107     \}\par
12108 \par
12113     {\cf17 friend} iter_impl operator+(difference_type i, {\cf17 const} iter_impl& it)\par
12114     \{\par
12115         {\cf17 auto} result = it;\par
12116         result += i;\par
12117         {\cf19 return} result;\par
12118     \}\par
12119 \par
12124     iter_impl operator-(difference_type i){\cf17  const}\par
12125 {\cf17     }\{\par
12126         {\cf17 auto} result = *{\cf17 this};\par
12127         result -= i;\par
12128         {\cf19 return} result;\par
12129     \}\par
12130 \par
12135     difference_type operator-({\cf17 const} iter_impl& other){\cf17  const}\par
12136 {\cf17     }\{\par
12137         JSON_ASSERT(m_object != {\cf17 nullptr});\par
12138 \par
12139         {\cf19 switch} (m_object->m_type)\par
12140         \{\par
12141             {\cf19 case} value_t::object:\par
12142                 JSON_THROW(invalid_iterator::create(209, {\cf22 "cannot use offsets with object iterators"}, *m_object));\par
12143 \par
12144             {\cf19 case} value_t::array:\par
12145                 {\cf19 return} m_it.array_iterator - other.m_it.array_iterator;\par
12146 \par
12147             {\cf19 case} value_t::null:\par
12148             {\cf19 case} value_t::string:\par
12149             {\cf19 case} value_t::boolean:\par
12150             {\cf19 case} value_t::number_integer:\par
12151             {\cf19 case} value_t::number_unsigned:\par
12152             {\cf19 case} value_t::number_float:\par
12153             {\cf19 case} value_t::binary:\par
12154             {\cf19 case} value_t::discarded:\par
12155             {\cf19 default}:\par
12156                 {\cf19 return} m_it.primitive_iterator - other.m_it.primitive_iterator;\par
12157         \}\par
12158     \}\par
12159 \par
12164     reference operator[](difference_type n){\cf17  const}\par
12165 {\cf17     }\{\par
12166         JSON_ASSERT(m_object != {\cf17 nullptr});\par
12167 \par
12168         {\cf19 switch} (m_object->m_type)\par
12169         \{\par
12170             {\cf19 case} value_t::object:\par
12171                 JSON_THROW(invalid_iterator::create(208, {\cf22 "cannot use operator[] for object iterators"}, *m_object));\par
12172 \par
12173             {\cf19 case} value_t::array:\par
12174                 {\cf19 return} *std::next(m_it.array_iterator, n);\par
12175 \par
12176             {\cf19 case} value_t::null:\par
12177                 JSON_THROW(invalid_iterator::create(214, {\cf22 "cannot get value"}, *m_object));\par
12178 \par
12179             {\cf19 case} value_t::string:\par
12180             {\cf19 case} value_t::boolean:\par
12181             {\cf19 case} value_t::number_integer:\par
12182             {\cf19 case} value_t::number_unsigned:\par
12183             {\cf19 case} value_t::number_float:\par
12184             {\cf19 case} value_t::binary:\par
12185             {\cf19 case} value_t::discarded:\par
12186             {\cf19 default}:\par
12187             \{\par
12188                 {\cf19 if} (JSON_HEDLEY_LIKELY(m_it.primitive_iterator.get_value() == -n))\par
12189                 \{\par
12190                     {\cf19 return} *m_object;\par
12191                 \}\par
12192 \par
12193                 JSON_THROW(invalid_iterator::create(214, {\cf22 "cannot get value"}, *m_object));\par
12194             \}\par
12195         \}\par
12196     \}\par
12197 \par
12202     {\cf17 const} {\cf17 typename} object_t::key_type& key(){\cf17  const}\par
12203 {\cf17     }\{\par
12204         JSON_ASSERT(m_object != {\cf17 nullptr});\par
12205 \par
12206         {\cf19 if} (JSON_HEDLEY_LIKELY(m_object->is_object()))\par
12207         \{\par
12208             {\cf19 return} m_it.object_iterator->first;\par
12209         \}\par
12210 \par
12211         JSON_THROW(invalid_iterator::create(207, {\cf22 "cannot use key() for non-object iterators"}, *m_object));\par
12212     \}\par
12213 \par
12218     reference value(){\cf17  const}\par
12219 {\cf17     }\{\par
12220         {\cf19 return} operator*();\par
12221     \}\par
12222 \par
12223   JSON_PRIVATE_UNLESS_TESTED:\par
12225     pointer m_object = {\cf17 nullptr};\par
12227     internal_iterator<typename std::remove_const<BasicJsonType>::type> m_it \{\};\par
12228 \};\par
12229 \} {\cf20 // namespace detail}\par
12230 \} {\cf20 // namespace nlohmann}\par
12231 \par
12232 {\cf20 // #include <nlohmann/detail/iterators/iteration_proxy.hpp>}\par
12233 \par
12234 {\cf20 // #include <nlohmann/detail/iterators/json_reverse_iterator.hpp>}\par
12235 \par
12236 \par
12237 {\cf21 #include <cstddef>} {\cf20 // ptrdiff_t}\par
12238 {\cf21 #include <iterator>} {\cf20 // reverse_iterator}\par
12239 {\cf21 #include <utility>} {\cf20 // declval}\par
12240 \par
12241 {\cf17 namespace }nlohmann\par
12242 \{\par
12243 {\cf17 namespace }detail\par
12244 \{\par
12246 {\cf20 // reverse_iterator //}\par
12248 {\cf20 }\par
12267 {\cf17 template}<{\cf17 typename} Base>\par
12268 {\cf17 class }json_reverse_iterator : {\cf17 public} std::reverse_iterator<Base>\par
12269 \{\par
12270   {\cf17 public}:\par
12271     {\cf17 using} difference_type = std::ptrdiff_t;\par
12273     {\cf17 using} base_iterator = std::reverse_iterator<Base>;\par
12275     {\cf17 using} reference = {\cf17 typename} Base::reference;\par
12276 \par
12278     {\cf17 explicit} json_reverse_iterator({\cf17 const} {\cf17 typename} base_iterator::iterator_type& it) noexcept\par
12279         : base_iterator(it) \{\}\par
12280 \par
12282     {\cf17 explicit} json_reverse_iterator({\cf17 const} base_iterator& it) noexcept : base_iterator(it) \{\}\par
12283 \par
12285     json_reverse_iterator {\cf17 const} operator++({\cf18 int}) {\cf20 // NOLINT(readability-const-return-type)}\par
12286     \{\par
12287         {\cf19 return} {\cf17 static_cast<}json_reverse_iterator{\cf17 >}(base_iterator::operator++(1));\par
12288     \}\par
12289 \par
12291     json_reverse_iterator& operator++()\par
12292     \{\par
12293         {\cf19 return} {\cf17 static_cast<}json_reverse_iterator&{\cf17 >}(base_iterator::operator++());\par
12294     \}\par
12295 \par
12297     json_reverse_iterator {\cf17 const} operator--({\cf18 int}) {\cf20 // NOLINT(readability-const-return-type)}\par
12298     \{\par
12299         {\cf19 return} {\cf17 static_cast<}json_reverse_iterator{\cf17 >}(base_iterator::operator--(1));\par
12300     \}\par
12301 \par
12303     json_reverse_iterator& operator--()\par
12304     \{\par
12305         {\cf19 return} {\cf17 static_cast<}json_reverse_iterator&{\cf17 >}(base_iterator::operator--());\par
12306     \}\par
12307 \par
12309     json_reverse_iterator& operator+=(difference_type i)\par
12310     \{\par
12311         {\cf19 return} {\cf17 static_cast<}json_reverse_iterator&{\cf17 >}(base_iterator::operator+=(i));\par
12312     \}\par
12313 \par
12315     json_reverse_iterator operator+(difference_type i){\cf17  const}\par
12316 {\cf17     }\{\par
12317         {\cf19 return} {\cf17 static_cast<}json_reverse_iterator{\cf17 >}(base_iterator::operator+(i));\par
12318     \}\par
12319 \par
12321     json_reverse_iterator operator-(difference_type i){\cf17  const}\par
12322 {\cf17     }\{\par
12323         {\cf19 return} {\cf17 static_cast<}json_reverse_iterator{\cf17 >}(base_iterator::operator-(i));\par
12324     \}\par
12325 \par
12327     difference_type operator-({\cf17 const} json_reverse_iterator& other){\cf17  const}\par
12328 {\cf17     }\{\par
12329         {\cf19 return} base_iterator(*{\cf17 this}) - base_iterator(other);\par
12330     \}\par
12331 \par
12333     reference operator[](difference_type n){\cf17  const}\par
12334 {\cf17     }\{\par
12335         {\cf19 return} *(this->operator+(n));\par
12336     \}\par
12337 \par
12339     {\cf17 auto} key() const -> decltype(std::declval<Base>().key())\par
12340     \{\par
12341         {\cf17 auto} it = --this->base();\par
12342         {\cf19 return} it.key();\par
12343     \}\par
12344 \par
12346     reference value(){\cf17  const}\par
12347 {\cf17     }\{\par
12348         {\cf17 auto} it = --this->base();\par
12349         {\cf19 return} it.operator * ();\par
12350     \}\par
12351 \};\par
12352 \}  {\cf20 // namespace detail}\par
12353 \}  {\cf20 // namespace nlohmann}\par
12354 \par
12355 {\cf20 // #include <nlohmann/detail/iterators/primitive_iterator.hpp>}\par
12356 \par
12357 {\cf20 // #include <nlohmann/detail/json_pointer.hpp>}\par
12358 \par
12359 \par
12360 {\cf21 #include <algorithm>} {\cf20 // all_of}\par
12361 {\cf21 #include <cctype>} {\cf20 // isdigit}\par
12362 {\cf21 #include <limits>} {\cf20 // max}\par
12363 {\cf21 #include <numeric>} {\cf20 // accumulate}\par
12364 {\cf21 #include <string>} {\cf20 // string}\par
12365 {\cf21 #include <utility>} {\cf20 // move}\par
12366 {\cf21 #include <vector>} {\cf20 // vector}\par
12367 \par
12368 {\cf20 // #include <nlohmann/detail/exceptions.hpp>}\par
12369 \par
12370 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
12371 \par
12372 {\cf20 // #include <nlohmann/detail/string_escape.hpp>}\par
12373 \par
12374 {\cf20 // #include <nlohmann/detail/value_t.hpp>}\par
12375 \par
12376 \par
12377 {\cf17 namespace }nlohmann\par
12378 \{\par
12379 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
12380 {\cf17 class }json_pointer\par
12381 \{\par
12382     {\cf20 // allow basic_json to access private members}\par
12383     NLOHMANN_BASIC_JSON_TPL_DECLARATION\par
12384     {\cf17 friend} {\cf17 class }basic_json;\par
12385 \par
12386   {\cf17 public}:\par
12408     {\cf17 explicit} json_pointer({\cf17 const} std::string& s = {\cf22 ""})\par
12409         : reference_tokens(split(s))\par
12410     \{\}\par
12411 \par
12426     std::string to_string(){\cf17  const}\par
12427 {\cf17     }\{\par
12428         {\cf19 return} std::accumulate(reference_tokens.begin(), reference_tokens.end(),\par
12429                                std::string\{\},\par
12430                                []({\cf17 const} std::string & a, {\cf17 const} std::string & b)\par
12431         \{\par
12432             return a + {\cf22 "/"} + detail::escape(b);\par
12433         \});\par
12434     \}\par
12435 \par
12437     {\cf17 operator} std::string(){\cf17  const}\par
12438 {\cf17     }\{\par
12439         {\cf19 return} to_string();\par
12440     \}\par
12441 \par
12458     json_pointer& operator/=({\cf17 const} json_pointer& ptr)\par
12459     \{\par
12460         reference_tokens.insert(reference_tokens.end(),\par
12461                                 ptr.reference_tokens.begin(),\par
12462                                 ptr.reference_tokens.end());\par
12463         {\cf19 return} *{\cf17 this};\par
12464     \}\par
12465 \par
12482     json_pointer& operator/=(std::string token)\par
12483     \{\par
12484         push_back(std::move(token));\par
12485         {\cf19 return} *{\cf17 this};\par
12486     \}\par
12487 \par
12504     json_pointer& operator/=(std::size_t array_idx)\par
12505     \{\par
12506         {\cf19 return} *{\cf17 this} /= std::to_string(array_idx);\par
12507     \}\par
12508 \par
12524     {\cf17 friend} json_pointer operator/({\cf17 const} json_pointer& lhs,\par
12525                                   {\cf17 const} json_pointer& rhs)\par
12526     \{\par
12527         {\cf19 return} json_pointer(lhs) /= rhs;\par
12528     \}\par
12529 \par
12545     {\cf17 friend} json_pointer operator/({\cf17 const} json_pointer& ptr, std::string token) {\cf20 // NOLINT(performance-unnecessary-value-param)}\par
12546     \{\par
12547         {\cf19 return} json_pointer(ptr) /= std::move(token);\par
12548     \}\par
12549 \par
12565     {\cf17 friend} json_pointer operator/({\cf17 const} json_pointer& ptr, std::size_t array_idx)\par
12566     \{\par
12567         {\cf19 return} json_pointer(ptr) /= array_idx;\par
12568     \}\par
12569 \par
12583     json_pointer parent_pointer(){\cf17  const}\par
12584 {\cf17     }\{\par
12585         {\cf19 if} (empty())\par
12586         \{\par
12587             {\cf19 return} *{\cf17 this};\par
12588         \}\par
12589 \par
12590         json_pointer res = *{\cf17 this};\par
12591         res.pop_back();\par
12592         {\cf19 return} res;\par
12593     \}\par
12594 \par
12608     {\cf18 void} pop_back()\par
12609     \{\par
12610         {\cf19 if} (JSON_HEDLEY_UNLIKELY(empty()))\par
12611         \{\par
12612             JSON_THROW(detail::out_of_range::create(405, {\cf22 "JSON pointer has no parent"}, BasicJsonType()));\par
12613         \}\par
12614 \par
12615         reference_tokens.pop_back();\par
12616     \}\par
12617 \par
12632     {\cf17 const} std::string& back(){\cf17  const}\par
12633 {\cf17     }\{\par
12634         {\cf19 if} (JSON_HEDLEY_UNLIKELY(empty()))\par
12635         \{\par
12636             JSON_THROW(detail::out_of_range::create(405, {\cf22 "JSON pointer has no parent"}, BasicJsonType()));\par
12637         \}\par
12638 \par
12639         {\cf19 return} reference_tokens.back();\par
12640     \}\par
12641 \par
12654     {\cf18 void} push_back({\cf17 const} std::string& token)\par
12655     \{\par
12656         reference_tokens.push_back(token);\par
12657     \}\par
12658 \par
12660     {\cf18 void} push_back(std::string&& token)\par
12661     \{\par
12662         reference_tokens.push_back(std::move(token));\par
12663     \}\par
12664 \par
12679     {\cf18 bool} empty() const noexcept\par
12680     \{\par
12681         {\cf19 return} reference_tokens.empty();\par
12682     \}\par
12683 \par
12684   {\cf17 private}:\par
12695     {\cf17 static} {\cf17 typename} BasicJsonType::size_type array_index({\cf17 const} std::string& s)\par
12696     \{\par
12697         {\cf17 using} size_type = {\cf17 typename} BasicJsonType::size_type;\par
12698 \par
12699         {\cf20 // error condition (cf. RFC 6901, Sect. 4)}\par
12700         {\cf19 if} (JSON_HEDLEY_UNLIKELY(s.size() > 1 && s[0] == {\cf23 '0'}))\par
12701         \{\par
12702             JSON_THROW(detail::parse_error::create(106, 0, {\cf22 "array index '"} + s + {\cf22 "' must not begin with '0'"}, BasicJsonType()));\par
12703         \}\par
12704 \par
12705         {\cf20 // error condition (cf. RFC 6901, Sect. 4)}\par
12706         {\cf19 if} (JSON_HEDLEY_UNLIKELY(s.size() > 1 && !(s[0] >= {\cf23 '1'} && s[0] <= {\cf23 '9'})))\par
12707         \{\par
12708             JSON_THROW(detail::parse_error::create(109, 0, {\cf22 "array index '"} + s + {\cf22 "' is not a number"}, BasicJsonType()));\par
12709         \}\par
12710 \par
12711         std::size_t processed_chars = 0;\par
12712         {\cf18 unsigned} {\cf18 long} {\cf18 long} res = 0;  {\cf20 // NOLINT(runtime/int)}\par
12713         JSON_TRY\par
12714         \{\par
12715             res = std::stoull(s, &processed_chars);\par
12716         \}\par
12717         JSON_CATCH(std::out_of_range&)\par
12718         \{\par
12719             JSON_THROW(detail::out_of_range::create(404, {\cf22 "unresolved reference token '"} + s + {\cf22 "'"}, BasicJsonType()));\par
12720         \}\par
12721 \par
12722         {\cf20 // check if the string was completely read}\par
12723         {\cf19 if} (JSON_HEDLEY_UNLIKELY(processed_chars != s.size()))\par
12724         \{\par
12725             JSON_THROW(detail::out_of_range::create(404, {\cf22 "unresolved reference token '"} + s + {\cf22 "'"}, BasicJsonType()));\par
12726         \}\par
12727 \par
12728         {\cf20 // only triggered on special platforms (like 32bit), see also}\par
12729         {\cf20 // https://github.com/nlohmann/json/pull/2203}\par
12730         {\cf19 if} (res >= {\cf17 static_cast<}{\cf18 unsigned} {\cf18 long} {\cf18 long}{\cf17 >}((std::numeric_limits<size_type>::max)()))  {\cf20 // NOLINT(runtime/int)}\par
12731         \{\par
12732             JSON_THROW(detail::out_of_range::create(410, {\cf22 "array index "} + s + {\cf22 " exceeds size_type"}, BasicJsonType())); {\cf20 // LCOV_EXCL_LINE}\par
12733         \}\par
12734 \par
12735         {\cf19 return} {\cf17 static_cast<}size_type{\cf17 >}(res);\par
12736     \}\par
12737 \par
12738   JSON_PRIVATE_UNLESS_TESTED:\par
12739     json_pointer top(){\cf17  const}\par
12740 {\cf17     }\{\par
12741         {\cf19 if} (JSON_HEDLEY_UNLIKELY(empty()))\par
12742         \{\par
12743             JSON_THROW(detail::out_of_range::create(405, {\cf22 "JSON pointer has no parent"}, BasicJsonType()));\par
12744         \}\par
12745 \par
12746         json_pointer result = *{\cf17 this};\par
12747         result.reference_tokens = \{reference_tokens[0]\};\par
12748         {\cf19 return} result;\par
12749     \}\par
12750 \par
12751   {\cf17 private}:\par
12760     BasicJsonType& get_and_create(BasicJsonType& j){\cf17  const}\par
12761 {\cf17     }\{\par
12762         {\cf17 auto}* result = &j;\par
12763 \par
12764         {\cf20 // in case no reference tokens exist, return a reference to the JSON value}\par
12765         {\cf20 // j which will be overwritten by a primitive value}\par
12766         {\cf19 for} ({\cf17 const} {\cf17 auto}& reference_token : reference_tokens)\par
12767         \{\par
12768             {\cf19 switch} (result->type())\par
12769             \{\par
12770                 {\cf19 case} detail::value_t::null:\par
12771                 \{\par
12772                     {\cf19 if} (reference_token == {\cf22 "0"})\par
12773                     \{\par
12774                         {\cf20 // start a new array if reference token is 0}\par
12775                         result = &result->operator[](0);\par
12776                     \}\par
12777                     {\cf19 else}\par
12778                     \{\par
12779                         {\cf20 // start a new object otherwise}\par
12780                         result = &result->operator[](reference_token);\par
12781                     \}\par
12782                     {\cf19 break};\par
12783                 \}\par
12784 \par
12785                 {\cf19 case} detail::value_t::object:\par
12786                 \{\par
12787                     {\cf20 // create an entry in the object}\par
12788                     result = &result->operator[](reference_token);\par
12789                     {\cf19 break};\par
12790                 \}\par
12791 \par
12792                 {\cf19 case} detail::value_t::array:\par
12793                 \{\par
12794                     {\cf20 // create an entry in the array}\par
12795                     result = &result->operator[](array_index(reference_token));\par
12796                     {\cf19 break};\par
12797                 \}\par
12798 \par
12799                 {\cf20 /*}\par
12800 {\cf20                 The following code is only reached if there exists a reference}\par
12801 {\cf20                 token _and_ the current value is primitive. In this case, we have}\par
12802 {\cf20                 an error situation, because primitive values may only occur as}\par
12803 {\cf20                 single value; that is, with an empty list of reference tokens.}\par
12804 {\cf20                 */}\par
12805                 {\cf19 case} detail::value_t::string:\par
12806                 {\cf19 case} detail::value_t::boolean:\par
12807                 {\cf19 case} detail::value_t::number_integer:\par
12808                 {\cf19 case} detail::value_t::number_unsigned:\par
12809                 {\cf19 case} detail::value_t::number_float:\par
12810                 {\cf19 case} detail::value_t::binary:\par
12811                 {\cf19 case} detail::value_t::discarded:\par
12812                 {\cf19 default}:\par
12813                     JSON_THROW(detail::type_error::create(313, {\cf22 "invalid value to unflatten"}, j));\par
12814             \}\par
12815         \}\par
12816 \par
12817         {\cf19 return} *result;\par
12818     \}\par
12819 \par
12839     BasicJsonType& get_unchecked(BasicJsonType* ptr){\cf17  const}\par
12840 {\cf17     }\{\par
12841         {\cf19 for} ({\cf17 const} {\cf17 auto}& reference_token : reference_tokens)\par
12842         \{\par
12843             {\cf20 // convert null values to arrays or objects before continuing}\par
12844             {\cf19 if} (ptr->is_null())\par
12845             \{\par
12846                 {\cf20 // check if reference token is a number}\par
12847                 {\cf17 const} {\cf18 bool} nums =\par
12848                     std::all_of(reference_token.begin(), reference_token.end(),\par
12849                                 []({\cf17 const} {\cf18 unsigned} {\cf18 char} x)\par
12850                 \{\par
12851                     return std::isdigit(x);\par
12852                 \});\par
12853 \par
12854                 {\cf20 // change value to array for numbers or "-" or to object otherwise}\par
12855                 *ptr = (nums || reference_token == {\cf22 "-"})\par
12856                        ? detail::value_t::array\par
12857                        : detail::value_t::object;\par
12858             \}\par
12859 \par
12860             {\cf19 switch} (ptr->type())\par
12861             \{\par
12862                 {\cf19 case} detail::value_t::object:\par
12863                 \{\par
12864                     {\cf20 // use unchecked object access}\par
12865                     ptr = &ptr->operator[](reference_token);\par
12866                     {\cf19 break};\par
12867                 \}\par
12868 \par
12869                 {\cf19 case} detail::value_t::array:\par
12870                 \{\par
12871                     {\cf19 if} (reference_token == {\cf22 "-"})\par
12872                     \{\par
12873                         {\cf20 // explicitly treat "-" as index beyond the end}\par
12874                         ptr = &ptr->operator[](ptr->m_value.array->size());\par
12875                     \}\par
12876                     {\cf19 else}\par
12877                     \{\par
12878                         {\cf20 // convert array index to number; unchecked access}\par
12879                         ptr = &ptr->operator[](array_index(reference_token));\par
12880                     \}\par
12881                     {\cf19 break};\par
12882                 \}\par
12883 \par
12884                 {\cf19 case} detail::value_t::null:\par
12885                 {\cf19 case} detail::value_t::string:\par
12886                 {\cf19 case} detail::value_t::boolean:\par
12887                 {\cf19 case} detail::value_t::number_integer:\par
12888                 {\cf19 case} detail::value_t::number_unsigned:\par
12889                 {\cf19 case} detail::value_t::number_float:\par
12890                 {\cf19 case} detail::value_t::binary:\par
12891                 {\cf19 case} detail::value_t::discarded:\par
12892                 {\cf19 default}:\par
12893                     JSON_THROW(detail::out_of_range::create(404, {\cf22 "unresolved reference token '"} + reference_token + {\cf22 "'"}, *ptr));\par
12894             \}\par
12895         \}\par
12896 \par
12897         {\cf19 return} *ptr;\par
12898     \}\par
12899 \par
12906     BasicJsonType& get_checked(BasicJsonType* ptr){\cf17  const}\par
12907 {\cf17     }\{\par
12908         {\cf19 for} ({\cf17 const} {\cf17 auto}& reference_token : reference_tokens)\par
12909         \{\par
12910             {\cf19 switch} (ptr->type())\par
12911             \{\par
12912                 {\cf19 case} detail::value_t::object:\par
12913                 \{\par
12914                     {\cf20 // note: at performs range check}\par
12915                     ptr = &ptr->at(reference_token);\par
12916                     {\cf19 break};\par
12917                 \}\par
12918 \par
12919                 {\cf19 case} detail::value_t::array:\par
12920                 \{\par
12921                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(reference_token == {\cf22 "-"}))\par
12922                     \{\par
12923                         {\cf20 // "-" always fails the range check}\par
12924                         JSON_THROW(detail::out_of_range::create(402,\par
12925                                                                 {\cf22 "array index '-' ("} + std::to_string(ptr->m_value.array->size()) +\par
12926                                                                 {\cf22 ") is out of range"}, *ptr));\par
12927                     \}\par
12928 \par
12929                     {\cf20 // note: at performs range check}\par
12930                     ptr = &ptr->at(array_index(reference_token));\par
12931                     {\cf19 break};\par
12932                 \}\par
12933 \par
12934                 {\cf19 case} detail::value_t::null:\par
12935                 {\cf19 case} detail::value_t::string:\par
12936                 {\cf19 case} detail::value_t::boolean:\par
12937                 {\cf19 case} detail::value_t::number_integer:\par
12938                 {\cf19 case} detail::value_t::number_unsigned:\par
12939                 {\cf19 case} detail::value_t::number_float:\par
12940                 {\cf19 case} detail::value_t::binary:\par
12941                 {\cf19 case} detail::value_t::discarded:\par
12942                 {\cf19 default}:\par
12943                     JSON_THROW(detail::out_of_range::create(404, {\cf22 "unresolved reference token '"} + reference_token + {\cf22 "'"}, *ptr));\par
12944             \}\par
12945         \}\par
12946 \par
12947         {\cf19 return} *ptr;\par
12948     \}\par
12949 \par
12963     {\cf17 const} BasicJsonType& get_unchecked({\cf17 const} BasicJsonType* ptr){\cf17  const}\par
12964 {\cf17     }\{\par
12965         {\cf19 for} ({\cf17 const} {\cf17 auto}& reference_token : reference_tokens)\par
12966         \{\par
12967             {\cf19 switch} (ptr->type())\par
12968             \{\par
12969                 {\cf19 case} detail::value_t::object:\par
12970                 \{\par
12971                     {\cf20 // use unchecked object access}\par
12972                     ptr = &ptr->operator[](reference_token);\par
12973                     {\cf19 break};\par
12974                 \}\par
12975 \par
12976                 {\cf19 case} detail::value_t::array:\par
12977                 \{\par
12978                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(reference_token == {\cf22 "-"}))\par
12979                     \{\par
12980                         {\cf20 // "-" cannot be used for const access}\par
12981                         JSON_THROW(detail::out_of_range::create(402, {\cf22 "array index '-' ("} + std::to_string(ptr->m_value.array->size()) + {\cf22 ") is out of range"}, *ptr));\par
12982                     \}\par
12983 \par
12984                     {\cf20 // use unchecked array access}\par
12985                     ptr = &ptr->operator[](array_index(reference_token));\par
12986                     {\cf19 break};\par
12987                 \}\par
12988 \par
12989                 {\cf19 case} detail::value_t::null:\par
12990                 {\cf19 case} detail::value_t::string:\par
12991                 {\cf19 case} detail::value_t::boolean:\par
12992                 {\cf19 case} detail::value_t::number_integer:\par
12993                 {\cf19 case} detail::value_t::number_unsigned:\par
12994                 {\cf19 case} detail::value_t::number_float:\par
12995                 {\cf19 case} detail::value_t::binary:\par
12996                 {\cf19 case} detail::value_t::discarded:\par
12997                 {\cf19 default}:\par
12998                     JSON_THROW(detail::out_of_range::create(404, {\cf22 "unresolved reference token '"} + reference_token + {\cf22 "'"}, *ptr));\par
12999             \}\par
13000         \}\par
13001 \par
13002         {\cf19 return} *ptr;\par
13003     \}\par
13004 \par
13011     {\cf17 const} BasicJsonType& get_checked({\cf17 const} BasicJsonType* ptr){\cf17  const}\par
13012 {\cf17     }\{\par
13013         {\cf19 for} ({\cf17 const} {\cf17 auto}& reference_token : reference_tokens)\par
13014         \{\par
13015             {\cf19 switch} (ptr->type())\par
13016             \{\par
13017                 {\cf19 case} detail::value_t::object:\par
13018                 \{\par
13019                     {\cf20 // note: at performs range check}\par
13020                     ptr = &ptr->at(reference_token);\par
13021                     {\cf19 break};\par
13022                 \}\par
13023 \par
13024                 {\cf19 case} detail::value_t::array:\par
13025                 \{\par
13026                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(reference_token == {\cf22 "-"}))\par
13027                     \{\par
13028                         {\cf20 // "-" always fails the range check}\par
13029                         JSON_THROW(detail::out_of_range::create(402,\par
13030                                                                 {\cf22 "array index '-' ("} + std::to_string(ptr->m_value.array->size()) +\par
13031                                                                 {\cf22 ") is out of range"}, *ptr));\par
13032                     \}\par
13033 \par
13034                     {\cf20 // note: at performs range check}\par
13035                     ptr = &ptr->at(array_index(reference_token));\par
13036                     {\cf19 break};\par
13037                 \}\par
13038 \par
13039                 {\cf19 case} detail::value_t::null:\par
13040                 {\cf19 case} detail::value_t::string:\par
13041                 {\cf19 case} detail::value_t::boolean:\par
13042                 {\cf19 case} detail::value_t::number_integer:\par
13043                 {\cf19 case} detail::value_t::number_unsigned:\par
13044                 {\cf19 case} detail::value_t::number_float:\par
13045                 {\cf19 case} detail::value_t::binary:\par
13046                 {\cf19 case} detail::value_t::discarded:\par
13047                 {\cf19 default}:\par
13048                     JSON_THROW(detail::out_of_range::create(404, {\cf22 "unresolved reference token '"} + reference_token + {\cf22 "'"}, *ptr));\par
13049             \}\par
13050         \}\par
13051 \par
13052         {\cf19 return} *ptr;\par
13053     \}\par
13054 \par
13059     {\cf18 bool} contains({\cf17 const} BasicJsonType* ptr){\cf17  const}\par
13060 {\cf17     }\{\par
13061         {\cf19 for} ({\cf17 const} {\cf17 auto}& reference_token : reference_tokens)\par
13062         \{\par
13063             {\cf19 switch} (ptr->type())\par
13064             \{\par
13065                 {\cf19 case} detail::value_t::object:\par
13066                 \{\par
13067                     {\cf19 if} (!ptr->contains(reference_token))\par
13068                     \{\par
13069                         {\cf20 // we did not find the key in the object}\par
13070                         {\cf19 return} {\cf17 false};\par
13071                     \}\par
13072 \par
13073                     ptr = &ptr->operator[](reference_token);\par
13074                     {\cf19 break};\par
13075                 \}\par
13076 \par
13077                 {\cf19 case} detail::value_t::array:\par
13078                 \{\par
13079                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(reference_token == {\cf22 "-"}))\par
13080                     \{\par
13081                         {\cf20 // "-" always fails the range check}\par
13082                         {\cf19 return} {\cf17 false};\par
13083                     \}\par
13084                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(reference_token.size() == 1 && !({\cf22 "0"} <= reference_token && reference_token <= {\cf22 "9"})))\par
13085                     \{\par
13086                         {\cf20 // invalid char}\par
13087                         {\cf19 return} {\cf17 false};\par
13088                     \}\par
13089                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(reference_token.size() > 1))\par
13090                     \{\par
13091                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!({\cf23 '1'} <= reference_token[0] && reference_token[0] <= {\cf23 '9'})))\par
13092                         \{\par
13093                             {\cf20 // first char should be between '1' and '9'}\par
13094                             {\cf19 return} {\cf17 false};\par
13095                         \}\par
13096                         {\cf19 for} (std::size_t i = 1; i < reference_token.size(); i++)\par
13097                         \{\par
13098                             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!({\cf23 '0'} <= reference_token[i] && reference_token[i] <= {\cf23 '9'})))\par
13099                             \{\par
13100                                 {\cf20 // other char should be between '0' and '9'}\par
13101                                 {\cf19 return} {\cf17 false};\par
13102                             \}\par
13103                         \}\par
13104                     \}\par
13105 \par
13106                     {\cf17 const} {\cf17 auto} idx = array_index(reference_token);\par
13107                     {\cf19 if} (idx >= ptr->size())\par
13108                     \{\par
13109                         {\cf20 // index out of range}\par
13110                         {\cf19 return} {\cf17 false};\par
13111                     \}\par
13112 \par
13113                     ptr = &ptr->operator[](idx);\par
13114                     {\cf19 break};\par
13115                 \}\par
13116 \par
13117                 {\cf19 case} detail::value_t::null:\par
13118                 {\cf19 case} detail::value_t::string:\par
13119                 {\cf19 case} detail::value_t::boolean:\par
13120                 {\cf19 case} detail::value_t::number_integer:\par
13121                 {\cf19 case} detail::value_t::number_unsigned:\par
13122                 {\cf19 case} detail::value_t::number_float:\par
13123                 {\cf19 case} detail::value_t::binary:\par
13124                 {\cf19 case} detail::value_t::discarded:\par
13125                 {\cf19 default}:\par
13126                 \{\par
13127                     {\cf20 // we do not expect primitive values if there is still a}\par
13128                     {\cf20 // reference token to process}\par
13129                     {\cf19 return} {\cf17 false};\par
13130                 \}\par
13131             \}\par
13132         \}\par
13133 \par
13134         {\cf20 // no reference token left means we found a primitive value}\par
13135         {\cf19 return} {\cf17 true};\par
13136     \}\par
13137 \par
13147     {\cf17 static} std::vector<std::string> split({\cf17 const} std::string& reference_string)\par
13148     \{\par
13149         std::vector<std::string> result;\par
13150 \par
13151         {\cf20 // special case: empty reference string -> no reference tokens}\par
13152         {\cf19 if} (reference_string.empty())\par
13153         \{\par
13154             {\cf19 return} result;\par
13155         \}\par
13156 \par
13157         {\cf20 // check if nonempty reference string begins with slash}\par
13158         {\cf19 if} (JSON_HEDLEY_UNLIKELY(reference_string[0] != {\cf23 '/'}))\par
13159         \{\par
13160             JSON_THROW(detail::parse_error::create(107, 1, {\cf22 "JSON pointer must be empty or begin with '/' - was: '"} + reference_string + {\cf22 "'"}, BasicJsonType()));\par
13161         \}\par
13162 \par
13163         {\cf20 // extract the reference tokens:}\par
13164         {\cf20 // - slash: position of the last read slash (or end of string)}\par
13165         {\cf20 // - start: position after the previous slash}\par
13166         {\cf19 for} (\par
13167             {\cf20 // search for the first slash after the first character}\par
13168             std::size_t slash = reference_string.find_first_of({\cf23 '/'}, 1),\par
13169             {\cf20 // set the beginning of the first reference token}\par
13170             start = 1;\par
13171             {\cf20 // we can stop if start == 0 (if slash == std::string::npos)}\par
13172             start != 0;\par
13173             {\cf20 // set the beginning of the next reference token}\par
13174             {\cf20 // (will eventually be 0 if slash == std::string::npos)}\par
13175             start = (slash == std::string::npos) ? 0 : slash + 1,\par
13176             {\cf20 // find next slash}\par
13177             slash = reference_string.find_first_of({\cf23 '/'}, start))\par
13178         \{\par
13179             {\cf20 // use the text between the beginning of the reference token}\par
13180             {\cf20 // (start) and the last slash (slash).}\par
13181             {\cf17 auto} reference_token = reference_string.substr(start, slash - start);\par
13182 \par
13183             {\cf20 // check reference tokens are properly escaped}\par
13184             {\cf19 for} (std::size_t pos = reference_token.find_first_of({\cf23 '~'});\par
13185                     pos != std::string::npos;\par
13186                     pos = reference_token.find_first_of({\cf23 '~'}, pos + 1))\par
13187             \{\par
13188                 JSON_ASSERT(reference_token[pos] == {\cf23 '~'});\par
13189 \par
13190                 {\cf20 // ~ must be followed by 0 or 1}\par
13191                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(pos == reference_token.size() - 1 ||\par
13192                                          (reference_token[pos + 1] != {\cf23 '0'} &&\par
13193                                           reference_token[pos + 1] != {\cf23 '1'})))\par
13194                 \{\par
13195                     JSON_THROW(detail::parse_error::create(108, 0, {\cf22 "escape character '~' must be followed with '0' or '1'"}, BasicJsonType()));\par
13196                 \}\par
13197             \}\par
13198 \par
13199             {\cf20 // finally, store the reference token}\par
13200             detail::unescape(reference_token);\par
13201             result.push_back(reference_token);\par
13202         \}\par
13203 \par
13204         {\cf19 return} result;\par
13205     \}\par
13206 \par
13207   {\cf17 private}:\par
13215     {\cf17 static} {\cf18 void} flatten({\cf17 const} std::string& reference_string,\par
13216                         {\cf17 const} BasicJsonType& value,\par
13217                         BasicJsonType& result)\par
13218     \{\par
13219         {\cf19 switch} (value.type())\par
13220         \{\par
13221             {\cf19 case} detail::value_t::array:\par
13222             \{\par
13223                 {\cf19 if} (value.m_value.array->empty())\par
13224                 \{\par
13225                     {\cf20 // flatten empty array as null}\par
13226                     result[reference_string] = {\cf17 nullptr};\par
13227                 \}\par
13228                 {\cf19 else}\par
13229                 \{\par
13230                     {\cf20 // iterate array and use index as reference string}\par
13231                     {\cf19 for} (std::size_t i = 0; i < value.m_value.array->size(); ++i)\par
13232                     \{\par
13233                         flatten(reference_string + {\cf22 "/"} + std::to_string(i),\par
13234                                 value.m_value.array->operator[](i), result);\par
13235                     \}\par
13236                 \}\par
13237                 {\cf19 break};\par
13238             \}\par
13239 \par
13240             {\cf19 case} detail::value_t::object:\par
13241             \{\par
13242                 {\cf19 if} (value.m_value.object->empty())\par
13243                 \{\par
13244                     {\cf20 // flatten empty object as null}\par
13245                     result[reference_string] = {\cf17 nullptr};\par
13246                 \}\par
13247                 {\cf19 else}\par
13248                 \{\par
13249                     {\cf20 // iterate object and use keys as reference string}\par
13250                     {\cf19 for} ({\cf17 const} {\cf17 auto}& element : *value.m_value.object)\par
13251                     \{\par
13252                         flatten(reference_string + {\cf22 "/"} + detail::escape(element.first), element.second, result);\par
13253                     \}\par
13254                 \}\par
13255                 {\cf19 break};\par
13256             \}\par
13257 \par
13258             {\cf19 case} detail::value_t::null:\par
13259             {\cf19 case} detail::value_t::string:\par
13260             {\cf19 case} detail::value_t::boolean:\par
13261             {\cf19 case} detail::value_t::number_integer:\par
13262             {\cf19 case} detail::value_t::number_unsigned:\par
13263             {\cf19 case} detail::value_t::number_float:\par
13264             {\cf19 case} detail::value_t::binary:\par
13265             {\cf19 case} detail::value_t::discarded:\par
13266             {\cf19 default}:\par
13267             \{\par
13268                 {\cf20 // add primitive value with its reference string}\par
13269                 result[reference_string] = value;\par
13270                 {\cf19 break};\par
13271             \}\par
13272         \}\par
13273     \}\par
13274 \par
13285     {\cf17 static} BasicJsonType\par
13286     unflatten({\cf17 const} BasicJsonType& value)\par
13287     \{\par
13288         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!value.is_object()))\par
13289         \{\par
13290             JSON_THROW(detail::type_error::create(314, {\cf22 "only objects can be unflattened"}, value));\par
13291         \}\par
13292 \par
13293         BasicJsonType result;\par
13294 \par
13295         {\cf20 // iterate the JSON object values}\par
13296         {\cf19 for} ({\cf17 const} {\cf17 auto}& element : *value.m_value.object)\par
13297         \{\par
13298             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!element.second.is_primitive()))\par
13299             \{\par
13300                 JSON_THROW(detail::type_error::create(315, {\cf22 "values in object must be primitive"}, element.second));\par
13301             \}\par
13302 \par
13303             {\cf20 // assign value to reference pointed to by JSON pointer; Note that if}\par
13304             {\cf20 // the JSON pointer is "" (i.e., points to the whole value), function}\par
13305             {\cf20 // get_and_create returns a reference to result itself. An assignment}\par
13306             {\cf20 // will then create a primitive value.}\par
13307             json_pointer(element.first).get_and_create(result) = element.second;\par
13308         \}\par
13309 \par
13310         {\cf19 return} result;\par
13311     \}\par
13312 \par
13324     {\cf17 friend} {\cf18 bool} operator==(json_pointer {\cf17 const}& lhs,\par
13325                            json_pointer {\cf17 const}& rhs) {\cf17 noexcept}\par
13326     \{\par
13327         {\cf19 return} lhs.reference_tokens == rhs.reference_tokens;\par
13328     \}\par
13329 \par
13341     {\cf17 friend} {\cf18 bool} operator!=(json_pointer {\cf17 const}& lhs,\par
13342                            json_pointer {\cf17 const}& rhs) {\cf17 noexcept}\par
13343     \{\par
13344         {\cf19 return} !(lhs == rhs);\par
13345     \}\par
13346 \par
13348     std::vector<std::string> reference_tokens;\par
13349 \};\par
13350 \}  {\cf20 // namespace nlohmann}\par
13351 \par
13352 {\cf20 // #include <nlohmann/detail/json_ref.hpp>}\par
13353 \par
13354 \par
13355 {\cf21 #include <initializer_list>}\par
13356 {\cf21 #include <utility>}\par
13357 \par
13358 {\cf20 // #include <nlohmann/detail/meta/type_traits.hpp>}\par
13359 \par
13360 \par
13361 {\cf17 namespace }nlohmann\par
13362 \{\par
13363 {\cf17 namespace }detail\par
13364 \{\par
13365 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
13366 {\cf17 class }json_ref\par
13367 \{\par
13368   {\cf17 public}:\par
13369     {\cf17 using} value_type = BasicJsonType;\par
13370 \par
13371     json_ref(value_type&& value)\par
13372         : owned_value(std::move(value))\par
13373     \{\}\par
13374 \par
13375     json_ref({\cf17 const} value_type& value)\par
13376         : value_ref(&value)\par
13377     \{\}\par
13378 \par
13379     json_ref(std::initializer_list<json_ref> init)\par
13380         : owned_value(init)\par
13381     \{\}\par
13382 \par
13383     {\cf17 template} <\par
13384         {\cf17 class}... Args,\par
13385         enable_if_t<std::is_constructible<value_type, Args...>::value, {\cf18 int}> = 0 >\par
13386     json_ref(Args && ... args)\par
13387         : owned_value(std::forward<Args>(args)...)\par
13388     \{\}\par
13389 \par
13390     {\cf20 // class should be movable only}\par
13391     json_ref(json_ref&&) noexcept = default;\par
13392     json_ref(const json_ref&) = delete;\par
13393     json_ref& operator=(const json_ref&) = delete;\par
13394     json_ref& operator=(json_ref&&) = delete;\par
13395     ~json_ref() = default;\par
13396 \par
13397     value_type moved_or_copied(){\cf17  const}\par
13398 {\cf17     }\{\par
13399         {\cf19 if} (value_ref == {\cf17 nullptr})\par
13400         \{\par
13401             {\cf19 return} std::move(owned_value);\par
13402         \}\par
13403         {\cf19 return} *value_ref;\par
13404     \}\par
13405 \par
13406     value_type {\cf17 const}& operator*(){\cf17  const}\par
13407 {\cf17     }\{\par
13408         {\cf19 return} value_ref ? *value_ref : owned_value;\par
13409     \}\par
13410 \par
13411     value_type {\cf17 const}* operator->(){\cf17  const}\par
13412 {\cf17     }\{\par
13413         {\cf19 return} &** {\cf17 this};\par
13414     \}\par
13415 \par
13416   {\cf17 private}:\par
13417     {\cf17 mutable} value_type owned_value = {\cf17 nullptr};\par
13418     value_type {\cf17 const}* value_ref = {\cf17 nullptr};\par
13419 \};\par
13420 \}  {\cf20 // namespace detail}\par
13421 \}  {\cf20 // namespace nlohmann}\par
13422 \par
13423 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
13424 \par
13425 {\cf20 // #include <nlohmann/detail/string_escape.hpp>}\par
13426 \par
13427 {\cf20 // #include <nlohmann/detail/meta/cpp_future.hpp>}\par
13428 \par
13429 {\cf20 // #include <nlohmann/detail/meta/type_traits.hpp>}\par
13430 \par
13431 {\cf20 // #include <nlohmann/detail/output/binary_writer.hpp>}\par
13432 \par
13433 \par
13434 {\cf21 #include <algorithm>} {\cf20 // reverse}\par
13435 {\cf21 #include <array>} {\cf20 // array}\par
13436 {\cf21 #include <cmath>} {\cf20 // isnan, isinf}\par
13437 {\cf21 #include <cstdint>} {\cf20 // uint8_t, uint16_t, uint32_t, uint64_t}\par
13438 {\cf21 #include <cstring>} {\cf20 // memcpy}\par
13439 {\cf21 #include <limits>} {\cf20 // numeric_limits}\par
13440 {\cf21 #include <string>} {\cf20 // string}\par
13441 {\cf21 #include <utility>} {\cf20 // move}\par
13442 \par
13443 {\cf20 // #include <nlohmann/detail/input/binary_reader.hpp>}\par
13444 \par
13445 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
13446 \par
13447 {\cf20 // #include <nlohmann/detail/output/output_adapters.hpp>}\par
13448 \par
13449 \par
13450 {\cf21 #include <algorithm>} {\cf20 // copy}\par
13451 {\cf21 #include <cstddef>} {\cf20 // size_t}\par
13452 {\cf21 #include <iterator>} {\cf20 // back_inserter}\par
13453 {\cf21 #include <memory>} {\cf20 // shared_ptr, make_shared}\par
13454 {\cf21 #include <string>} {\cf20 // basic_string}\par
13455 {\cf21 #include <vector>} {\cf20 // vector}\par
13456 \par
13457 {\cf21 #ifndef JSON_NO_IO}\par
13458 {\cf21     #include <ios>}      {\cf20 // streamsize}\par
13459 {\cf21     #include <ostream>}  {\cf20 // basic_ostream}\par
13460 {\cf21 #endif  }{\cf20 // JSON_NO_IO}\par
13461 \par
13462 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
13463 \par
13464 \par
13465 {\cf17 namespace }nlohmann\par
13466 \{\par
13467 {\cf17 namespace }detail\par
13468 \{\par
13470 {\cf17 template}<{\cf17 typename} CharType> {\cf17 struct }output_adapter_protocol\par
13471 \{\par
13472     {\cf17 virtual} {\cf18 void} write_character(CharType c) = 0;\par
13473     {\cf17 virtual} {\cf18 void} write_characters({\cf17 const} CharType* s, std::size_t length) = 0;\par
13474     {\cf17 virtual} ~output_adapter_protocol() = {\cf19 default};\par
13475 \par
13476     output_adapter_protocol() = {\cf19 default};\par
13477     output_adapter_protocol({\cf17 const} output_adapter_protocol&) = {\cf19 default};\par
13478     output_adapter_protocol(output_adapter_protocol&&) noexcept = default;\par
13479     output_adapter_protocol& operator=(const output_adapter_protocol&) = default;\par
13480     output_adapter_protocol& operator=(output_adapter_protocol&&) noexcept = default;\par
13481 \};\par
13482 \par
13484 template<typename CharType>\par
13485 using output_adapter_t = std::shared_ptr<output_adapter_protocol<CharType>>;\par
13486 \par
13488 template<typename CharType>\par
13489 class output_vector_adapter : public output_adapter_protocol<CharType>\par
13490 \{\par
13491   {\cf17 public}:\par
13492     {\cf17 explicit} output_vector_adapter(std::vector<CharType>& vec) noexcept\par
13493         : v(vec)\par
13494     \{\}\par
13495 \par
13496     {\cf18 void} write_character(CharType c){\cf17  override}\par
13497 {\cf17     }\{\par
13498         v.push_back(c);\par
13499     \}\par
13500 \par
13501     JSON_HEDLEY_NON_NULL(2)\par
13502     void write_characters(const CharType* s, std::{\cf18 size_t} length){\cf17  override}\par
13503 {\cf17     }\{\par
13504         std::copy(s, s + length, std::back_inserter(v));\par
13505     \}\par
13506 \par
13507   {\cf17 private}:\par
13508     std::vector<CharType>& v;\par
13509 \};\par
13510 \par
13511 {\cf21 #ifndef JSON_NO_IO}\par
13513 {\cf17 template}<{\cf17 typename} CharType>\par
13514 {\cf17 class }output_stream_adapter : {\cf17 public} output_adapter_protocol<CharType>\par
13515 \{\par
13516   {\cf17 public}:\par
13517     {\cf17 explicit} output_stream_adapter(std::basic_ostream<CharType>& s) noexcept\par
13518         : stream(s)\par
13519     \{\}\par
13520 \par
13521     {\cf18 void} write_character(CharType c){\cf17  override}\par
13522 {\cf17     }\{\par
13523         stream.put(c);\par
13524     \}\par
13525 \par
13526     JSON_HEDLEY_NON_NULL(2)\par
13527     void write_characters(const CharType* s, std::{\cf18 size_t} length){\cf17  override}\par
13528 {\cf17     }\{\par
13529         stream.write(s, {\cf17 static_cast<}std::streamsize{\cf17 >}(length));\par
13530     \}\par
13531 \par
13532   {\cf17 private}:\par
13533     std::basic_ostream<CharType>& stream;\par
13534 \};\par
13535 {\cf21 #endif  }{\cf20 // JSON_NO_IO}\par
13536 \par
13538 {\cf17 template}<{\cf17 typename} CharType, {\cf17 typename} StringType = std::basic_{\cf18 string}<CharType>>\par
13539 {\cf17 class }output_string_adapter : {\cf17 public} output_adapter_protocol<CharType>\par
13540 \{\par
13541   {\cf17 public}:\par
13542     {\cf17 explicit} output_string_adapter(StringType& s) noexcept\par
13543         : str(s)\par
13544     \{\}\par
13545 \par
13546     {\cf18 void} write_character(CharType c){\cf17  override}\par
13547 {\cf17     }\{\par
13548         str.push_back(c);\par
13549     \}\par
13550 \par
13551     JSON_HEDLEY_NON_NULL(2)\par
13552     void write_characters(const CharType* s, std::{\cf18 size_t} length){\cf17  override}\par
13553 {\cf17     }\{\par
13554         str.append(s, length);\par
13555     \}\par
13556 \par
13557   {\cf17 private}:\par
13558     StringType& str;\par
13559 \};\par
13560 \par
13561 {\cf17 template}<{\cf17 typename} CharType, {\cf17 typename} StringType = std::basic_{\cf18 string}<CharType>>\par
13562 {\cf17 class }output_adapter\par
13563 \{\par
13564   {\cf17 public}:\par
13565     output_adapter(std::vector<CharType>& vec)\par
13566         : oa(std::make_shared<output_vector_adapter<CharType>>(vec)) \{\}\par
13567 \par
13568 {\cf21 #ifndef JSON_NO_IO}\par
13569     output_adapter(std::basic_ostream<CharType>& s)\par
13570         : oa(std::make_shared<output_stream_adapter<CharType>>(s)) \{\}\par
13571 {\cf21 #endif  }{\cf20 // JSON_NO_IO}\par
13572 \par
13573     output_adapter(StringType& s)\par
13574         : oa(std::make_shared<output_string_adapter<CharType, StringType>>(s)) \{\}\par
13575 \par
13576     {\cf17 operator} output_adapter_t<CharType>()\par
13577     \{\par
13578         {\cf19 return} oa;\par
13579     \}\par
13580 \par
13581   {\cf17 private}:\par
13582     output_adapter_t<CharType> oa = {\cf17 nullptr};\par
13583 \};\par
13584 \}  {\cf20 // namespace detail}\par
13585 \}  {\cf20 // namespace nlohmann}\par
13586 \par
13587 \par
13588 {\cf17 namespace }nlohmann\par
13589 \{\par
13590 {\cf17 namespace }detail\par
13591 \{\par
13593 {\cf20 // binary writer //}\par
13595 {\cf20 }\par
13599 {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CharType>\par
13600 {\cf17 class }binary_writer\par
13601 \{\par
13602     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
13603     {\cf17 using} binary_t = {\cf17 typename} BasicJsonType::binary_t;\par
13604     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
13605 \par
13606   {\cf17 public}:\par
13612     {\cf17 explicit} binary_writer(output_adapter_t<CharType> adapter) : oa(std::move(adapter))\par
13613     \{\par
13614         JSON_ASSERT(oa);\par
13615     \}\par
13616 \par
13621     {\cf18 void} write_bson({\cf17 const} BasicJsonType& j)\par
13622     \{\par
13623         {\cf19 switch} (j.type())\par
13624         \{\par
13625             {\cf19 case} value_t::object:\par
13626             \{\par
13627                 write_bson_object(*j.m_value.object);\par
13628                 {\cf19 break};\par
13629             \}\par
13630 \par
13631             {\cf19 case} value_t::null:\par
13632             {\cf19 case} value_t::array:\par
13633             {\cf19 case} value_t::string:\par
13634             {\cf19 case} value_t::boolean:\par
13635             {\cf19 case} value_t::number_integer:\par
13636             {\cf19 case} value_t::number_unsigned:\par
13637             {\cf19 case} value_t::number_float:\par
13638             {\cf19 case} value_t::binary:\par
13639             {\cf19 case} value_t::discarded:\par
13640             {\cf19 default}:\par
13641             \{\par
13642                 JSON_THROW(type_error::create(317, {\cf22 "to serialize to BSON, top-level type must be object, but is "} + std::string(j.type_name()), j));\par
13643             \}\par
13644         \}\par
13645     \}\par
13646 \par
13650     {\cf18 void} write_cbor({\cf17 const} BasicJsonType& j)\par
13651     \{\par
13652         {\cf19 switch} (j.type())\par
13653         \{\par
13654             {\cf19 case} value_t::null:\par
13655             \{\par
13656                 oa->write_character(to_char_type(0xF6));\par
13657                 {\cf19 break};\par
13658             \}\par
13659 \par
13660             {\cf19 case} value_t::boolean:\par
13661             \{\par
13662                 oa->write_character(j.m_value.boolean\par
13663                                     ? to_char_type(0xF5)\par
13664                                     : to_char_type(0xF4));\par
13665                 {\cf19 break};\par
13666             \}\par
13667 \par
13668             {\cf19 case} value_t::number_integer:\par
13669             \{\par
13670                 {\cf19 if} (j.m_value.number_integer >= 0)\par
13671                 \{\par
13672                     {\cf20 // CBOR does not differentiate between positive signed}\par
13673                     {\cf20 // integers and unsigned integers. Therefore, we used the}\par
13674                     {\cf20 // code from the value_t::number_unsigned case here.}\par
13675                     {\cf19 if} (j.m_value.number_integer <= 0x17)\par
13676                     \{\par
13677                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(j.m_value.number_integer));\par
13678                     \}\par
13679                     {\cf19 else} {\cf19 if} (j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())\par
13680                     \{\par
13681                         oa->write_character(to_char_type(0x18));\par
13682                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(j.m_value.number_integer));\par
13683                     \}\par
13684                     {\cf19 else} {\cf19 if} (j.m_value.number_integer <= (std::numeric_limits<std::uint16_t>::max)())\par
13685                     \{\par
13686                         oa->write_character(to_char_type(0x19));\par
13687                         write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(j.m_value.number_integer));\par
13688                     \}\par
13689                     {\cf19 else} {\cf19 if} (j.m_value.number_integer <= (std::numeric_limits<std::uint32_t>::max)())\par
13690                     \{\par
13691                         oa->write_character(to_char_type(0x1A));\par
13692                         write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(j.m_value.number_integer));\par
13693                     \}\par
13694                     {\cf19 else}\par
13695                     \{\par
13696                         oa->write_character(to_char_type(0x1B));\par
13697                         write_number({\cf17 static_cast<}std::uint64_t{\cf17 >}(j.m_value.number_integer));\par
13698                     \}\par
13699                 \}\par
13700                 {\cf19 else}\par
13701                 \{\par
13702                     {\cf20 // The conversions below encode the sign in the first}\par
13703                     {\cf20 // byte, and the value is converted to a positive number.}\par
13704                     {\cf17 const} {\cf17 auto} positive_number = -1 - j.m_value.number_integer;\par
13705                     {\cf19 if} (j.m_value.number_integer >= -24)\par
13706                     \{\par
13707                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0x20 + positive_number));\par
13708                     \}\par
13709                     {\cf19 else} {\cf19 if} (positive_number <= (std::numeric_limits<std::uint8_t>::max)())\par
13710                     \{\par
13711                         oa->write_character(to_char_type(0x38));\par
13712                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(positive_number));\par
13713                     \}\par
13714                     {\cf19 else} {\cf19 if} (positive_number <= (std::numeric_limits<std::uint16_t>::max)())\par
13715                     \{\par
13716                         oa->write_character(to_char_type(0x39));\par
13717                         write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(positive_number));\par
13718                     \}\par
13719                     {\cf19 else} {\cf19 if} (positive_number <= (std::numeric_limits<std::uint32_t>::max)())\par
13720                     \{\par
13721                         oa->write_character(to_char_type(0x3A));\par
13722                         write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(positive_number));\par
13723                     \}\par
13724                     {\cf19 else}\par
13725                     \{\par
13726                         oa->write_character(to_char_type(0x3B));\par
13727                         write_number({\cf17 static_cast<}std::uint64_t{\cf17 >}(positive_number));\par
13728                     \}\par
13729                 \}\par
13730                 {\cf19 break};\par
13731             \}\par
13732 \par
13733             {\cf19 case} value_t::number_unsigned:\par
13734             \{\par
13735                 {\cf19 if} (j.m_value.number_unsigned <= 0x17)\par
13736                 \{\par
13737                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(j.m_value.number_unsigned));\par
13738                 \}\par
13739                 {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())\par
13740                 \{\par
13741                     oa->write_character(to_char_type(0x18));\par
13742                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(j.m_value.number_unsigned));\par
13743                 \}\par
13744                 {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())\par
13745                 \{\par
13746                     oa->write_character(to_char_type(0x19));\par
13747                     write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(j.m_value.number_unsigned));\par
13748                 \}\par
13749                 {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())\par
13750                 \{\par
13751                     oa->write_character(to_char_type(0x1A));\par
13752                     write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(j.m_value.number_unsigned));\par
13753                 \}\par
13754                 {\cf19 else}\par
13755                 \{\par
13756                     oa->write_character(to_char_type(0x1B));\par
13757                     write_number({\cf17 static_cast<}std::uint64_t{\cf17 >}(j.m_value.number_unsigned));\par
13758                 \}\par
13759                 {\cf19 break};\par
13760             \}\par
13761 \par
13762             {\cf19 case} value_t::number_float:\par
13763             \{\par
13764                 {\cf19 if} (std::isnan(j.m_value.number_float))\par
13765                 \{\par
13766                     {\cf20 // NaN is 0xf97e00 in CBOR}\par
13767                     oa->write_character(to_char_type(0xF9));\par
13768                     oa->write_character(to_char_type(0x7E));\par
13769                     oa->write_character(to_char_type(0x00));\par
13770                 \}\par
13771                 {\cf19 else} {\cf19 if} (std::isinf(j.m_value.number_float))\par
13772                 \{\par
13773                     {\cf20 // Infinity is 0xf97c00, -Infinity is 0xf9fc00}\par
13774                     oa->write_character(to_char_type(0xf9));\par
13775                     oa->write_character(j.m_value.number_float > 0 ? to_char_type(0x7C) : to_char_type(0xFC));\par
13776                     oa->write_character(to_char_type(0x00));\par
13777                 \}\par
13778                 {\cf19 else}\par
13779                 \{\par
13780                     write_compact_float(j.m_value.number_float, detail::input_format_t::cbor);\par
13781                 \}\par
13782                 {\cf19 break};\par
13783             \}\par
13784 \par
13785             {\cf19 case} value_t::string:\par
13786             \{\par
13787                 {\cf20 // step 1: write control byte and the string length}\par
13788                 {\cf17 const} {\cf17 auto} N = j.m_value.string->size();\par
13789                 {\cf19 if} (N <= 0x17)\par
13790                 \{\par
13791                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0x60 + N));\par
13792                 \}\par
13793                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint8_t>::max)())\par
13794                 \{\par
13795                     oa->write_character(to_char_type(0x78));\par
13796                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(N));\par
13797                 \}\par
13798                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint16_t>::max)())\par
13799                 \{\par
13800                     oa->write_character(to_char_type(0x79));\par
13801                     write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(N));\par
13802                 \}\par
13803                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint32_t>::max)())\par
13804                 \{\par
13805                     oa->write_character(to_char_type(0x7A));\par
13806                     write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(N));\par
13807                 \}\par
13808                 {\cf20 // LCOV_EXCL_START}\par
13809                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint64_t>::max)())\par
13810                 \{\par
13811                     oa->write_character(to_char_type(0x7B));\par
13812                     write_number({\cf17 static_cast<}std::uint64_t{\cf17 >}(N));\par
13813                 \}\par
13814                 {\cf20 // LCOV_EXCL_STOP}\par
13815 \par
13816                 {\cf20 // step 2: write the string}\par
13817                 oa->write_characters(\par
13818                     {\cf17 reinterpret_cast<}{\cf17 const }CharType*{\cf17 >}(j.m_value.string->c_str()),\par
13819                     j.m_value.string->size());\par
13820                 {\cf19 break};\par
13821             \}\par
13822 \par
13823             {\cf19 case} value_t::array:\par
13824             \{\par
13825                 {\cf20 // step 1: write control byte and the array size}\par
13826                 {\cf17 const} {\cf17 auto} N = j.m_value.array->size();\par
13827                 {\cf19 if} (N <= 0x17)\par
13828                 \{\par
13829                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0x80 + N));\par
13830                 \}\par
13831                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint8_t>::max)())\par
13832                 \{\par
13833                     oa->write_character(to_char_type(0x98));\par
13834                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(N));\par
13835                 \}\par
13836                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint16_t>::max)())\par
13837                 \{\par
13838                     oa->write_character(to_char_type(0x99));\par
13839                     write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(N));\par
13840                 \}\par
13841                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint32_t>::max)())\par
13842                 \{\par
13843                     oa->write_character(to_char_type(0x9A));\par
13844                     write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(N));\par
13845                 \}\par
13846                 {\cf20 // LCOV_EXCL_START}\par
13847                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint64_t>::max)())\par
13848                 \{\par
13849                     oa->write_character(to_char_type(0x9B));\par
13850                     write_number({\cf17 static_cast<}std::uint64_t{\cf17 >}(N));\par
13851                 \}\par
13852                 {\cf20 // LCOV_EXCL_STOP}\par
13853 \par
13854                 {\cf20 // step 2: write each element}\par
13855                 {\cf19 for} ({\cf17 const} {\cf17 auto}& el : *j.m_value.array)\par
13856                 \{\par
13857                     write_cbor(el);\par
13858                 \}\par
13859                 {\cf19 break};\par
13860             \}\par
13861 \par
13862             {\cf19 case} value_t::binary:\par
13863             \{\par
13864                 {\cf19 if} (j.m_value.binary->has_subtype())\par
13865                 \{\par
13866                     {\cf19 if} (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint8_t>::max)())\par
13867                     \{\par
13868                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0xd8));\par
13869                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(j.m_value.binary->subtype()));\par
13870                     \}\par
13871                     {\cf19 else} {\cf19 if} (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint16_t>::max)())\par
13872                     \{\par
13873                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0xd9));\par
13874                         write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(j.m_value.binary->subtype()));\par
13875                     \}\par
13876                     {\cf19 else} {\cf19 if} (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint32_t>::max)())\par
13877                     \{\par
13878                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0xda));\par
13879                         write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(j.m_value.binary->subtype()));\par
13880                     \}\par
13881                     {\cf19 else} {\cf19 if} (j.m_value.binary->subtype() <= (std::numeric_limits<std::uint64_t>::max)())\par
13882                     \{\par
13883                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0xdb));\par
13884                         write_number({\cf17 static_cast<}std::uint64_t{\cf17 >}(j.m_value.binary->subtype()));\par
13885                     \}\par
13886                 \}\par
13887 \par
13888                 {\cf20 // step 1: write control byte and the binary array size}\par
13889                 {\cf17 const} {\cf17 auto} N = j.m_value.binary->size();\par
13890                 {\cf19 if} (N <= 0x17)\par
13891                 \{\par
13892                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0x40 + N));\par
13893                 \}\par
13894                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint8_t>::max)())\par
13895                 \{\par
13896                     oa->write_character(to_char_type(0x58));\par
13897                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(N));\par
13898                 \}\par
13899                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint16_t>::max)())\par
13900                 \{\par
13901                     oa->write_character(to_char_type(0x59));\par
13902                     write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(N));\par
13903                 \}\par
13904                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint32_t>::max)())\par
13905                 \{\par
13906                     oa->write_character(to_char_type(0x5A));\par
13907                     write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(N));\par
13908                 \}\par
13909                 {\cf20 // LCOV_EXCL_START}\par
13910                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint64_t>::max)())\par
13911                 \{\par
13912                     oa->write_character(to_char_type(0x5B));\par
13913                     write_number({\cf17 static_cast<}std::uint64_t{\cf17 >}(N));\par
13914                 \}\par
13915                 {\cf20 // LCOV_EXCL_STOP}\par
13916 \par
13917                 {\cf20 // step 2: write each element}\par
13918                 oa->write_characters(\par
13919                     {\cf17 reinterpret_cast<}{\cf17 const }CharType*{\cf17 >}(j.m_value.binary->data()),\par
13920                     N);\par
13921 \par
13922                 {\cf19 break};\par
13923             \}\par
13924 \par
13925             {\cf19 case} value_t::object:\par
13926             \{\par
13927                 {\cf20 // step 1: write control byte and the object size}\par
13928                 {\cf17 const} {\cf17 auto} N = j.m_value.object->size();\par
13929                 {\cf19 if} (N <= 0x17)\par
13930                 \{\par
13931                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0xA0 + N));\par
13932                 \}\par
13933                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint8_t>::max)())\par
13934                 \{\par
13935                     oa->write_character(to_char_type(0xB8));\par
13936                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(N));\par
13937                 \}\par
13938                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint16_t>::max)())\par
13939                 \{\par
13940                     oa->write_character(to_char_type(0xB9));\par
13941                     write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(N));\par
13942                 \}\par
13943                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint32_t>::max)())\par
13944                 \{\par
13945                     oa->write_character(to_char_type(0xBA));\par
13946                     write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(N));\par
13947                 \}\par
13948                 {\cf20 // LCOV_EXCL_START}\par
13949                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint64_t>::max)())\par
13950                 \{\par
13951                     oa->write_character(to_char_type(0xBB));\par
13952                     write_number({\cf17 static_cast<}std::uint64_t{\cf17 >}(N));\par
13953                 \}\par
13954                 {\cf20 // LCOV_EXCL_STOP}\par
13955 \par
13956                 {\cf20 // step 2: write each element}\par
13957                 {\cf19 for} ({\cf17 const} {\cf17 auto}& el : *j.m_value.object)\par
13958                 \{\par
13959                     write_cbor(el.first);\par
13960                     write_cbor(el.second);\par
13961                 \}\par
13962                 {\cf19 break};\par
13963             \}\par
13964 \par
13965             {\cf19 case} value_t::discarded:\par
13966             {\cf19 default}:\par
13967                 {\cf19 break};\par
13968         \}\par
13969     \}\par
13970 \par
13974     {\cf18 void} write_msgpack({\cf17 const} BasicJsonType& j)\par
13975     \{\par
13976         {\cf19 switch} (j.type())\par
13977         \{\par
13978             {\cf19 case} value_t::null: {\cf20 // nil}\par
13979             \{\par
13980                 oa->write_character(to_char_type(0xC0));\par
13981                 {\cf19 break};\par
13982             \}\par
13983 \par
13984             {\cf19 case} value_t::boolean: {\cf20 // true and false}\par
13985             \{\par
13986                 oa->write_character(j.m_value.boolean\par
13987                                     ? to_char_type(0xC3)\par
13988                                     : to_char_type(0xC2));\par
13989                 {\cf19 break};\par
13990             \}\par
13991 \par
13992             {\cf19 case} value_t::number_integer:\par
13993             \{\par
13994                 {\cf19 if} (j.m_value.number_integer >= 0)\par
13995                 \{\par
13996                     {\cf20 // MessagePack does not differentiate between positive}\par
13997                     {\cf20 // signed integers and unsigned integers. Therefore, we used}\par
13998                     {\cf20 // the code from the value_t::number_unsigned case here.}\par
13999                     {\cf19 if} (j.m_value.number_unsigned < 128)\par
14000                     \{\par
14001                         {\cf20 // positive fixnum}\par
14002                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(j.m_value.number_integer));\par
14003                     \}\par
14004                     {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())\par
14005                     \{\par
14006                         {\cf20 // uint 8}\par
14007                         oa->write_character(to_char_type(0xCC));\par
14008                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(j.m_value.number_integer));\par
14009                     \}\par
14010                     {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())\par
14011                     \{\par
14012                         {\cf20 // uint 16}\par
14013                         oa->write_character(to_char_type(0xCD));\par
14014                         write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(j.m_value.number_integer));\par
14015                     \}\par
14016                     {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())\par
14017                     \{\par
14018                         {\cf20 // uint 32}\par
14019                         oa->write_character(to_char_type(0xCE));\par
14020                         write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(j.m_value.number_integer));\par
14021                     \}\par
14022                     {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())\par
14023                     \{\par
14024                         {\cf20 // uint 64}\par
14025                         oa->write_character(to_char_type(0xCF));\par
14026                         write_number({\cf17 static_cast<}std::uint64_t{\cf17 >}(j.m_value.number_integer));\par
14027                     \}\par
14028                 \}\par
14029                 {\cf19 else}\par
14030                 \{\par
14031                     {\cf19 if} (j.m_value.number_integer >= -32)\par
14032                     \{\par
14033                         {\cf20 // negative fixnum}\par
14034                         write_number({\cf17 static_cast<}std::int8_t{\cf17 >}(j.m_value.number_integer));\par
14035                     \}\par
14036                     {\cf19 else} {\cf19 if} (j.m_value.number_integer >= (std::numeric_limits<std::int8_t>::min)() &&\par
14037                              j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())\par
14038                     \{\par
14039                         {\cf20 // int 8}\par
14040                         oa->write_character(to_char_type(0xD0));\par
14041                         write_number({\cf17 static_cast<}std::int8_t{\cf17 >}(j.m_value.number_integer));\par
14042                     \}\par
14043                     {\cf19 else} {\cf19 if} (j.m_value.number_integer >= (std::numeric_limits<std::int16_t>::min)() &&\par
14044                              j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())\par
14045                     \{\par
14046                         {\cf20 // int 16}\par
14047                         oa->write_character(to_char_type(0xD1));\par
14048                         write_number({\cf17 static_cast<}std::int16_t{\cf17 >}(j.m_value.number_integer));\par
14049                     \}\par
14050                     {\cf19 else} {\cf19 if} (j.m_value.number_integer >= (std::numeric_limits<std::int32_t>::min)() &&\par
14051                              j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())\par
14052                     \{\par
14053                         {\cf20 // int 32}\par
14054                         oa->write_character(to_char_type(0xD2));\par
14055                         write_number({\cf17 static_cast<}std::int32_t{\cf17 >}(j.m_value.number_integer));\par
14056                     \}\par
14057                     {\cf19 else} {\cf19 if} (j.m_value.number_integer >= (std::numeric_limits<std::int64_t>::min)() &&\par
14058                              j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())\par
14059                     \{\par
14060                         {\cf20 // int 64}\par
14061                         oa->write_character(to_char_type(0xD3));\par
14062                         write_number({\cf17 static_cast<}std::int64_t{\cf17 >}(j.m_value.number_integer));\par
14063                     \}\par
14064                 \}\par
14065                 {\cf19 break};\par
14066             \}\par
14067 \par
14068             {\cf19 case} value_t::number_unsigned:\par
14069             \{\par
14070                 {\cf19 if} (j.m_value.number_unsigned < 128)\par
14071                 \{\par
14072                     {\cf20 // positive fixnum}\par
14073                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(j.m_value.number_integer));\par
14074                 \}\par
14075                 {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= (std::numeric_limits<std::uint8_t>::max)())\par
14076                 \{\par
14077                     {\cf20 // uint 8}\par
14078                     oa->write_character(to_char_type(0xCC));\par
14079                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(j.m_value.number_integer));\par
14080                 \}\par
14081                 {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= (std::numeric_limits<std::uint16_t>::max)())\par
14082                 \{\par
14083                     {\cf20 // uint 16}\par
14084                     oa->write_character(to_char_type(0xCD));\par
14085                     write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(j.m_value.number_integer));\par
14086                 \}\par
14087                 {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= (std::numeric_limits<std::uint32_t>::max)())\par
14088                 \{\par
14089                     {\cf20 // uint 32}\par
14090                     oa->write_character(to_char_type(0xCE));\par
14091                     write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(j.m_value.number_integer));\par
14092                 \}\par
14093                 {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= (std::numeric_limits<std::uint64_t>::max)())\par
14094                 \{\par
14095                     {\cf20 // uint 64}\par
14096                     oa->write_character(to_char_type(0xCF));\par
14097                     write_number({\cf17 static_cast<}std::uint64_t{\cf17 >}(j.m_value.number_integer));\par
14098                 \}\par
14099                 {\cf19 break};\par
14100             \}\par
14101 \par
14102             {\cf19 case} value_t::number_float:\par
14103             \{\par
14104                 write_compact_float(j.m_value.number_float, detail::input_format_t::msgpack);\par
14105                 {\cf19 break};\par
14106             \}\par
14107 \par
14108             {\cf19 case} value_t::string:\par
14109             \{\par
14110                 {\cf20 // step 1: write control byte and the string length}\par
14111                 {\cf17 const} {\cf17 auto} N = j.m_value.string->size();\par
14112                 {\cf19 if} (N <= 31)\par
14113                 \{\par
14114                     {\cf20 // fixstr}\par
14115                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0xA0 | N));\par
14116                 \}\par
14117                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint8_t>::max)())\par
14118                 \{\par
14119                     {\cf20 // str 8}\par
14120                     oa->write_character(to_char_type(0xD9));\par
14121                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(N));\par
14122                 \}\par
14123                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint16_t>::max)())\par
14124                 \{\par
14125                     {\cf20 // str 16}\par
14126                     oa->write_character(to_char_type(0xDA));\par
14127                     write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(N));\par
14128                 \}\par
14129                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint32_t>::max)())\par
14130                 \{\par
14131                     {\cf20 // str 32}\par
14132                     oa->write_character(to_char_type(0xDB));\par
14133                     write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(N));\par
14134                 \}\par
14135 \par
14136                 {\cf20 // step 2: write the string}\par
14137                 oa->write_characters(\par
14138                     {\cf17 reinterpret_cast<}{\cf17 const }CharType*{\cf17 >}(j.m_value.string->c_str()),\par
14139                     j.m_value.string->size());\par
14140                 {\cf19 break};\par
14141             \}\par
14142 \par
14143             {\cf19 case} value_t::array:\par
14144             \{\par
14145                 {\cf20 // step 1: write control byte and the array size}\par
14146                 {\cf17 const} {\cf17 auto} N = j.m_value.array->size();\par
14147                 {\cf19 if} (N <= 15)\par
14148                 \{\par
14149                     {\cf20 // fixarray}\par
14150                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0x90 | N));\par
14151                 \}\par
14152                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint16_t>::max)())\par
14153                 \{\par
14154                     {\cf20 // array 16}\par
14155                     oa->write_character(to_char_type(0xDC));\par
14156                     write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(N));\par
14157                 \}\par
14158                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint32_t>::max)())\par
14159                 \{\par
14160                     {\cf20 // array 32}\par
14161                     oa->write_character(to_char_type(0xDD));\par
14162                     write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(N));\par
14163                 \}\par
14164 \par
14165                 {\cf20 // step 2: write each element}\par
14166                 {\cf19 for} ({\cf17 const} {\cf17 auto}& el : *j.m_value.array)\par
14167                 \{\par
14168                     write_msgpack(el);\par
14169                 \}\par
14170                 {\cf19 break};\par
14171             \}\par
14172 \par
14173             {\cf19 case} value_t::binary:\par
14174             \{\par
14175                 {\cf20 // step 0: determine if the binary type has a set subtype to}\par
14176                 {\cf20 // determine whether or not to use the ext or fixext types}\par
14177                 {\cf17 const} {\cf18 bool} use_ext = j.m_value.binary->has_subtype();\par
14178 \par
14179                 {\cf20 // step 1: write control byte and the byte string length}\par
14180                 {\cf17 const} {\cf17 auto} N = j.m_value.binary->size();\par
14181                 {\cf19 if} (N <= (std::numeric_limits<std::uint8_t>::max)())\par
14182                 \{\par
14183                     std::uint8_t output_type\{\};\par
14184                     {\cf18 bool} fixed = {\cf17 true};\par
14185                     {\cf19 if} (use_ext)\par
14186                     \{\par
14187                         {\cf19 switch} (N)\par
14188                         \{\par
14189                             {\cf19 case} 1:\par
14190                                 output_type = 0xD4; {\cf20 // fixext 1}\par
14191                                 {\cf19 break};\par
14192                             {\cf19 case} 2:\par
14193                                 output_type = 0xD5; {\cf20 // fixext 2}\par
14194                                 {\cf19 break};\par
14195                             {\cf19 case} 4:\par
14196                                 output_type = 0xD6; {\cf20 // fixext 4}\par
14197                                 {\cf19 break};\par
14198                             {\cf19 case} 8:\par
14199                                 output_type = 0xD7; {\cf20 // fixext 8}\par
14200                                 {\cf19 break};\par
14201                             {\cf19 case} 16:\par
14202                                 output_type = 0xD8; {\cf20 // fixext 16}\par
14203                                 {\cf19 break};\par
14204                             {\cf19 default}:\par
14205                                 output_type = 0xC7; {\cf20 // ext 8}\par
14206                                 fixed = {\cf17 false};\par
14207                                 {\cf19 break};\par
14208                         \}\par
14209 \par
14210                     \}\par
14211                     {\cf19 else}\par
14212                     \{\par
14213                         output_type = 0xC4; {\cf20 // bin 8}\par
14214                         fixed = {\cf17 false};\par
14215                     \}\par
14216 \par
14217                     oa->write_character(to_char_type(output_type));\par
14218                     {\cf19 if} (!fixed)\par
14219                     \{\par
14220                         write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(N));\par
14221                     \}\par
14222                 \}\par
14223                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint16_t>::max)())\par
14224                 \{\par
14225                     std::uint8_t output_type = use_ext\par
14226                                                ? 0xC8 {\cf20 // ext 16}\par
14227                                                : 0xC5; {\cf20 // bin 16}\par
14228 \par
14229                     oa->write_character(to_char_type(output_type));\par
14230                     write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(N));\par
14231                 \}\par
14232                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint32_t>::max)())\par
14233                 \{\par
14234                     std::uint8_t output_type = use_ext\par
14235                                                ? 0xC9 {\cf20 // ext 32}\par
14236                                                : 0xC6; {\cf20 // bin 32}\par
14237 \par
14238                     oa->write_character(to_char_type(output_type));\par
14239                     write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(N));\par
14240                 \}\par
14241 \par
14242                 {\cf20 // step 1.5: if this is an ext type, write the subtype}\par
14243                 {\cf19 if} (use_ext)\par
14244                 \{\par
14245                     write_number({\cf17 static_cast<}std::int8_t{\cf17 >}(j.m_value.binary->subtype()));\par
14246                 \}\par
14247 \par
14248                 {\cf20 // step 2: write the byte string}\par
14249                 oa->write_characters(\par
14250                     {\cf17 reinterpret_cast<}{\cf17 const }CharType*{\cf17 >}(j.m_value.binary->data()),\par
14251                     N);\par
14252 \par
14253                 {\cf19 break};\par
14254             \}\par
14255 \par
14256             {\cf19 case} value_t::object:\par
14257             \{\par
14258                 {\cf20 // step 1: write control byte and the object size}\par
14259                 {\cf17 const} {\cf17 auto} N = j.m_value.object->size();\par
14260                 {\cf19 if} (N <= 15)\par
14261                 \{\par
14262                     {\cf20 // fixmap}\par
14263                     write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(0x80 | (N & 0xF)));\par
14264                 \}\par
14265                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint16_t>::max)())\par
14266                 \{\par
14267                     {\cf20 // map 16}\par
14268                     oa->write_character(to_char_type(0xDE));\par
14269                     write_number({\cf17 static_cast<}std::uint16_t{\cf17 >}(N));\par
14270                 \}\par
14271                 {\cf19 else} {\cf19 if} (N <= (std::numeric_limits<std::uint32_t>::max)())\par
14272                 \{\par
14273                     {\cf20 // map 32}\par
14274                     oa->write_character(to_char_type(0xDF));\par
14275                     write_number({\cf17 static_cast<}std::uint32_t{\cf17 >}(N));\par
14276                 \}\par
14277 \par
14278                 {\cf20 // step 2: write each element}\par
14279                 {\cf19 for} ({\cf17 const} {\cf17 auto}& el : *j.m_value.object)\par
14280                 \{\par
14281                     write_msgpack(el.first);\par
14282                     write_msgpack(el.second);\par
14283                 \}\par
14284                 {\cf19 break};\par
14285             \}\par
14286 \par
14287             {\cf19 case} value_t::discarded:\par
14288             {\cf19 default}:\par
14289                 {\cf19 break};\par
14290         \}\par
14291     \}\par
14292 \par
14299     {\cf18 void} write_ubjson({\cf17 const} BasicJsonType& j, {\cf17 const} {\cf18 bool} use_count,\par
14300                       {\cf17 const} {\cf18 bool} use_type, {\cf17 const} {\cf18 bool} add_prefix = {\cf17 true})\par
14301     \{\par
14302         {\cf19 switch} (j.type())\par
14303         \{\par
14304             {\cf19 case} value_t::null:\par
14305             \{\par
14306                 {\cf19 if} (add_prefix)\par
14307                 \{\par
14308                     oa->write_character(to_char_type({\cf23 'Z'}));\par
14309                 \}\par
14310                 {\cf19 break};\par
14311             \}\par
14312 \par
14313             {\cf19 case} value_t::boolean:\par
14314             \{\par
14315                 {\cf19 if} (add_prefix)\par
14316                 \{\par
14317                     oa->write_character(j.m_value.boolean\par
14318                                         ? to_char_type({\cf23 'T'})\par
14319                                         : to_char_type({\cf23 'F'}));\par
14320                 \}\par
14321                 {\cf19 break};\par
14322             \}\par
14323 \par
14324             {\cf19 case} value_t::number_integer:\par
14325             \{\par
14326                 write_number_with_ubjson_prefix(j.m_value.number_integer, add_prefix);\par
14327                 {\cf19 break};\par
14328             \}\par
14329 \par
14330             {\cf19 case} value_t::number_unsigned:\par
14331             \{\par
14332                 write_number_with_ubjson_prefix(j.m_value.number_unsigned, add_prefix);\par
14333                 {\cf19 break};\par
14334             \}\par
14335 \par
14336             {\cf19 case} value_t::number_float:\par
14337             \{\par
14338                 write_number_with_ubjson_prefix(j.m_value.number_float, add_prefix);\par
14339                 {\cf19 break};\par
14340             \}\par
14341 \par
14342             {\cf19 case} value_t::string:\par
14343             \{\par
14344                 {\cf19 if} (add_prefix)\par
14345                 \{\par
14346                     oa->write_character(to_char_type({\cf23 'S'}));\par
14347                 \}\par
14348                 write_number_with_ubjson_prefix(j.m_value.string->size(), {\cf17 true});\par
14349                 oa->write_characters(\par
14350                     {\cf17 reinterpret_cast<}{\cf17 const }CharType*{\cf17 >}(j.m_value.string->c_str()),\par
14351                     j.m_value.string->size());\par
14352                 {\cf19 break};\par
14353             \}\par
14354 \par
14355             {\cf19 case} value_t::array:\par
14356             \{\par
14357                 {\cf19 if} (add_prefix)\par
14358                 \{\par
14359                     oa->write_character(to_char_type({\cf23 '['}));\par
14360                 \}\par
14361 \par
14362                 {\cf18 bool} prefix_required = {\cf17 true};\par
14363                 {\cf19 if} (use_type && !j.m_value.array->empty())\par
14364                 \{\par
14365                     JSON_ASSERT(use_count);\par
14366                     {\cf17 const} CharType first_prefix = ubjson_prefix(j.front());\par
14367                     {\cf17 const} {\cf18 bool} same_prefix = std::all_of(j.begin() + 1, j.end(),\par
14368                                                          [{\cf17 this}, first_prefix]({\cf17 const} BasicJsonType & v)\par
14369                     \{\par
14370                         return ubjson_prefix(v) == first_prefix;\par
14371                     \});\par
14372 \par
14373                     {\cf19 if} (same_prefix)\par
14374                     \{\par
14375                         prefix_required = {\cf17 false};\par
14376                         oa->write_character(to_char_type({\cf23 '$'}));\par
14377                         oa->write_character(first_prefix);\par
14378                     \}\par
14379                 \}\par
14380 \par
14381                 {\cf19 if} (use_count)\par
14382                 \{\par
14383                     oa->write_character(to_char_type({\cf23 '#'}));\par
14384                     write_number_with_ubjson_prefix(j.m_value.array->size(), {\cf17 true});\par
14385                 \}\par
14386 \par
14387                 {\cf19 for} ({\cf17 const} {\cf17 auto}& el : *j.m_value.array)\par
14388                 \{\par
14389                     write_ubjson(el, use_count, use_type, prefix_required);\par
14390                 \}\par
14391 \par
14392                 {\cf19 if} (!use_count)\par
14393                 \{\par
14394                     oa->write_character(to_char_type({\cf23 ']'}));\par
14395                 \}\par
14396 \par
14397                 {\cf19 break};\par
14398             \}\par
14399 \par
14400             {\cf19 case} value_t::binary:\par
14401             \{\par
14402                 {\cf19 if} (add_prefix)\par
14403                 \{\par
14404                     oa->write_character(to_char_type({\cf23 '['}));\par
14405                 \}\par
14406 \par
14407                 {\cf19 if} (use_type && !j.m_value.binary->empty())\par
14408                 \{\par
14409                     JSON_ASSERT(use_count);\par
14410                     oa->write_character(to_char_type({\cf23 '$'}));\par
14411                     oa->write_character({\cf23 'U'});\par
14412                 \}\par
14413 \par
14414                 {\cf19 if} (use_count)\par
14415                 \{\par
14416                     oa->write_character(to_char_type({\cf23 '#'}));\par
14417                     write_number_with_ubjson_prefix(j.m_value.binary->size(), {\cf17 true});\par
14418                 \}\par
14419 \par
14420                 {\cf19 if} (use_type)\par
14421                 \{\par
14422                     oa->write_characters(\par
14423                         {\cf17 reinterpret_cast<}{\cf17 const }CharType*{\cf17 >}(j.m_value.binary->data()),\par
14424                         j.m_value.binary->size());\par
14425                 \}\par
14426                 {\cf19 else}\par
14427                 \{\par
14428                     {\cf19 for} ({\cf18 size_t} i = 0; i < j.m_value.binary->size(); ++i)\par
14429                     \{\par
14430                         oa->write_character(to_char_type({\cf23 'U'}));\par
14431                         oa->write_character(j.m_value.binary->data()[i]);\par
14432                     \}\par
14433                 \}\par
14434 \par
14435                 {\cf19 if} (!use_count)\par
14436                 \{\par
14437                     oa->write_character(to_char_type({\cf23 ']'}));\par
14438                 \}\par
14439 \par
14440                 {\cf19 break};\par
14441             \}\par
14442 \par
14443             {\cf19 case} value_t::object:\par
14444             \{\par
14445                 {\cf19 if} (add_prefix)\par
14446                 \{\par
14447                     oa->write_character(to_char_type({\cf23 '\{'}));\par
14448                 \}\par
14449 \par
14450                 {\cf18 bool} prefix_required = {\cf17 true};\par
14451                 {\cf19 if} (use_type && !j.m_value.object->empty())\par
14452                 \{\par
14453                     JSON_ASSERT(use_count);\par
14454                     {\cf17 const} CharType first_prefix = ubjson_prefix(j.front());\par
14455                     {\cf17 const} {\cf18 bool} same_prefix = std::all_of(j.begin(), j.end(),\par
14456                                                          [{\cf17 this}, first_prefix]({\cf17 const} BasicJsonType & v)\par
14457                     \{\par
14458                         return ubjson_prefix(v) == first_prefix;\par
14459                     \});\par
14460 \par
14461                     {\cf19 if} (same_prefix)\par
14462                     \{\par
14463                         prefix_required = {\cf17 false};\par
14464                         oa->write_character(to_char_type({\cf23 '$'}));\par
14465                         oa->write_character(first_prefix);\par
14466                     \}\par
14467                 \}\par
14468 \par
14469                 {\cf19 if} (use_count)\par
14470                 \{\par
14471                     oa->write_character(to_char_type({\cf23 '#'}));\par
14472                     write_number_with_ubjson_prefix(j.m_value.object->size(), {\cf17 true});\par
14473                 \}\par
14474 \par
14475                 {\cf19 for} ({\cf17 const} {\cf17 auto}& el : *j.m_value.object)\par
14476                 \{\par
14477                     write_number_with_ubjson_prefix(el.first.size(), {\cf17 true});\par
14478                     oa->write_characters(\par
14479                         {\cf17 reinterpret_cast<}{\cf17 const }CharType*{\cf17 >}(el.first.c_str()),\par
14480                         el.first.size());\par
14481                     write_ubjson(el.second, use_count, use_type, prefix_required);\par
14482                 \}\par
14483 \par
14484                 {\cf19 if} (!use_count)\par
14485                 \{\par
14486                     oa->write_character(to_char_type({\cf23 '\}'}));\par
14487                 \}\par
14488 \par
14489                 {\cf19 break};\par
14490             \}\par
14491 \par
14492             {\cf19 case} value_t::discarded:\par
14493             {\cf19 default}:\par
14494                 {\cf19 break};\par
14495         \}\par
14496     \}\par
14497 \par
14498   {\cf17 private}:\par
14500     {\cf20 // BSON //}\par
14502 {\cf20 }\par
14507     {\cf17 static} std::size_t calc_bson_entry_header_size({\cf17 const} string_t& name, {\cf17 const} BasicJsonType& j)\par
14508     \{\par
14509         {\cf17 const} {\cf17 auto} it = name.find({\cf17 static_cast<}typename string_t::value_type{\cf17 >}(0));\par
14510         {\cf19 if} (JSON_HEDLEY_UNLIKELY(it != BasicJsonType::string_t::npos))\par
14511         \{\par
14512             JSON_THROW(out_of_range::create(409, {\cf22 "BSON key cannot contain code point U+0000 (at byte "} + std::to_string(it) + {\cf22 ")"}, j));\par
14513             {\cf17 static_cast<}{\cf18 void}{\cf17 >}(j);\par
14514         \}\par
14515 \par
14516         {\cf19 return} {\cf20 /*id*/} 1ul + name.size() + {\cf20 /*zero-terminator*/}1u;\par
14517     \}\par
14518 \par
14522     {\cf18 void} write_bson_entry_header({\cf17 const} string_t& name,\par
14523                                  {\cf17 const} std::uint8_t element_type)\par
14524     \{\par
14525         oa->write_character(to_char_type(element_type)); {\cf20 // boolean}\par
14526         oa->write_characters(\par
14527             {\cf17 reinterpret_cast<}{\cf17 const }CharType*{\cf17 >}(name.c_str()),\par
14528             name.size() + 1u);\par
14529     \}\par
14530 \par
14534     {\cf18 void} write_bson_boolean({\cf17 const} string_t& name,\par
14535                             {\cf17 const} {\cf18 bool} value)\par
14536     \{\par
14537         write_bson_entry_header(name, 0x08);\par
14538         oa->write_character(value ? to_char_type(0x01) : to_char_type(0x00));\par
14539     \}\par
14540 \par
14544     {\cf18 void} write_bson_double({\cf17 const} string_t& name,\par
14545                            {\cf17 const} {\cf18 double} value)\par
14546     \{\par
14547         write_bson_entry_header(name, 0x01);\par
14548         write_number<double, true>(value);\par
14549     \}\par
14550 \par
14554     {\cf17 static} std::size_t calc_bson_string_size({\cf17 const} string_t& value)\par
14555     \{\par
14556         {\cf19 return} {\cf17 sizeof}(std::int32_t) + value.size() + 1ul;\par
14557     \}\par
14558 \par
14562     {\cf18 void} write_bson_string({\cf17 const} string_t& name,\par
14563                            {\cf17 const} string_t& value)\par
14564     \{\par
14565         write_bson_entry_header(name, 0x02);\par
14566 \par
14567         write_number<std::int32_t, true>({\cf17 static_cast<}std::int32_t{\cf17 >}(value.size() + 1ul));\par
14568         oa->write_characters(\par
14569             {\cf17 reinterpret_cast<}{\cf17 const }CharType*{\cf17 >}(value.c_str()),\par
14570             value.size() + 1);\par
14571     \}\par
14572 \par
14576     {\cf18 void} write_bson_null({\cf17 const} string_t& name)\par
14577     \{\par
14578         write_bson_entry_header(name, 0x0A);\par
14579     \}\par
14580 \par
14584     {\cf17 static} std::size_t calc_bson_integer_size({\cf17 const} std::int64_t value)\par
14585     \{\par
14586         {\cf19 return} (std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)()\par
14587                ? {\cf17 sizeof}(std::int32_t)\par
14588                : {\cf17 sizeof}(std::int64_t);\par
14589     \}\par
14590 \par
14594     {\cf18 void} write_bson_integer({\cf17 const} string_t& name,\par
14595                             {\cf17 const} std::int64_t value)\par
14596     \{\par
14597         {\cf19 if} ((std::numeric_limits<std::int32_t>::min)() <= value && value <= (std::numeric_limits<std::int32_t>::max)())\par
14598         \{\par
14599             write_bson_entry_header(name, 0x10); {\cf20 // int32}\par
14600             write_number<std::int32_t, true>({\cf17 static_cast<}std::int32_t{\cf17 >}(value));\par
14601         \}\par
14602         {\cf19 else}\par
14603         \{\par
14604             write_bson_entry_header(name, 0x12); {\cf20 // int64}\par
14605             write_number<std::int64_t, true>({\cf17 static_cast<}std::int64_t{\cf17 >}(value));\par
14606         \}\par
14607     \}\par
14608 \par
14612     {\cf17 static} {\cf17 constexpr} std::size_t calc_bson_unsigned_size({\cf17 const} std::uint64_t value) {\cf17 noexcept}\par
14613     \{\par
14614         {\cf19 return} (value <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::int32_t>::max)()))\par
14615                ? {\cf17 sizeof}(std::int32_t)\par
14616                : {\cf17 sizeof}(std::int64_t);\par
14617     \}\par
14618 \par
14622     {\cf18 void} write_bson_unsigned({\cf17 const} string_t& name,\par
14623                              {\cf17 const} BasicJsonType& j)\par
14624     \{\par
14625         {\cf19 if} (j.m_value.number_unsigned <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::int32_t>::max)()))\par
14626         \{\par
14627             write_bson_entry_header(name, 0x10 {\cf20 /* int32 */});\par
14628             write_number<std::int32_t, true>({\cf17 static_cast<}std::int32_t{\cf17 >}(j.m_value.number_unsigned));\par
14629         \}\par
14630         {\cf19 else} {\cf19 if} (j.m_value.number_unsigned <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::int64_t>::max)()))\par
14631         \{\par
14632             write_bson_entry_header(name, 0x12 {\cf20 /* int64 */});\par
14633             write_number<std::int64_t, true>({\cf17 static_cast<}std::int64_t{\cf17 >}(j.m_value.number_unsigned));\par
14634         \}\par
14635         {\cf19 else}\par
14636         \{\par
14637             JSON_THROW(out_of_range::create(407, {\cf22 "integer number "} + std::to_string(j.m_value.number_unsigned) + {\cf22 " cannot be represented by BSON as it does not fit int64"}, j));\par
14638         \}\par
14639     \}\par
14640 \par
14644     {\cf18 void} write_bson_object_entry({\cf17 const} string_t& name,\par
14645                                  {\cf17 const} {\cf17 typename} BasicJsonType::object_t& value)\par
14646     \{\par
14647         write_bson_entry_header(name, 0x03); {\cf20 // object}\par
14648         write_bson_object(value);\par
14649     \}\par
14650 \par
14654     {\cf17 static} std::size_t calc_bson_array_size({\cf17 const} {\cf17 typename} BasicJsonType::array_t& value)\par
14655     \{\par
14656         std::size_t array_index = 0ul;\par
14657 \par
14658         {\cf17 const} std::size_t embedded_document_size = std::accumulate(std::begin(value), std::end(value), std::size_t(0), [&array_index](std::size_t result, {\cf17 const} {\cf17 typename} BasicJsonType::array_t::value_type & el)\par
14659         \{\par
14660             {\cf19 return} result + calc_bson_element_size(std::to_string(array_index++), el);\par
14661         \});\par
14662 \par
14663         {\cf19 return} {\cf17 sizeof}(std::int32_t) + embedded_document_size + 1ul;\par
14664     \}\par
14665 \par
14669     {\cf17 static} std::size_t calc_bson_binary_size({\cf17 const} {\cf17 typename} BasicJsonType::binary_t& value)\par
14670     \{\par
14671         {\cf19 return} {\cf17 sizeof}(std::int32_t) + value.size() + 1ul;\par
14672     \}\par
14673 \par
14677     {\cf18 void} write_bson_array({\cf17 const} string_t& name,\par
14678                           {\cf17 const} {\cf17 typename} BasicJsonType::array_t& value)\par
14679     \{\par
14680         write_bson_entry_header(name, 0x04); {\cf20 // array}\par
14681         write_number<std::int32_t, true>({\cf17 static_cast<}std::int32_t{\cf17 >}(calc_bson_array_size(value)));\par
14682 \par
14683         std::size_t array_index = 0ul;\par
14684 \par
14685         {\cf19 for} ({\cf17 const} {\cf17 auto}& el : value)\par
14686         \{\par
14687             write_bson_element(std::to_string(array_index++), el);\par
14688         \}\par
14689 \par
14690         oa->write_character(to_char_type(0x00));\par
14691     \}\par
14692 \par
14696     {\cf18 void} write_bson_binary({\cf17 const} string_t& name,\par
14697                            {\cf17 const} binary_t& value)\par
14698     \{\par
14699         write_bson_entry_header(name, 0x05);\par
14700 \par
14701         write_number<std::int32_t, true>({\cf17 static_cast<}std::int32_t{\cf17 >}(value.size()));\par
14702         write_number(value.has_subtype() ? {\cf17 static_cast<}std::uint8_t{\cf17 >}(value.subtype()) : std::uint8_t(0x00));\par
14703 \par
14704         oa->write_characters({\cf17 reinterpret_cast<}{\cf17 const }CharType*{\cf17 >}(value.data()), value.size());\par
14705     \}\par
14706 \par
14711     {\cf17 static} std::size_t calc_bson_element_size({\cf17 const} string_t& name,\par
14712             {\cf17 const} BasicJsonType& j)\par
14713     \{\par
14714         {\cf17 const} {\cf17 auto} header_size = calc_bson_entry_header_size(name, j);\par
14715         {\cf19 switch} (j.type())\par
14716         \{\par
14717             {\cf19 case} value_t::object:\par
14718                 {\cf19 return} header_size + calc_bson_object_size(*j.m_value.object);\par
14719 \par
14720             {\cf19 case} value_t::array:\par
14721                 {\cf19 return} header_size + calc_bson_array_size(*j.m_value.array);\par
14722 \par
14723             {\cf19 case} value_t::binary:\par
14724                 {\cf19 return} header_size + calc_bson_binary_size(*j.m_value.binary);\par
14725 \par
14726             {\cf19 case} value_t::boolean:\par
14727                 {\cf19 return} header_size + 1ul;\par
14728 \par
14729             {\cf19 case} value_t::number_float:\par
14730                 {\cf19 return} header_size + 8ul;\par
14731 \par
14732             {\cf19 case} value_t::number_integer:\par
14733                 {\cf19 return} header_size + calc_bson_integer_size(j.m_value.number_integer);\par
14734 \par
14735             {\cf19 case} value_t::number_unsigned:\par
14736                 {\cf19 return} header_size + calc_bson_unsigned_size(j.m_value.number_unsigned);\par
14737 \par
14738             {\cf19 case} value_t::string:\par
14739                 {\cf19 return} header_size + calc_bson_string_size(*j.m_value.string);\par
14740 \par
14741             {\cf19 case} value_t::null:\par
14742                 {\cf19 return} header_size + 0ul;\par
14743 \par
14744             {\cf20 // LCOV_EXCL_START}\par
14745             {\cf19 case} value_t::discarded:\par
14746             {\cf19 default}:\par
14747                 JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert)}\par
14748                 {\cf19 return} 0ul;\par
14749                 {\cf20 // LCOV_EXCL_STOP}\par
14750         \}\par
14751     \}\par
14752 \par
14759     {\cf18 void} write_bson_element({\cf17 const} string_t& name,\par
14760                             {\cf17 const} BasicJsonType& j)\par
14761     \{\par
14762         {\cf19 switch} (j.type())\par
14763         \{\par
14764             {\cf19 case} value_t::object:\par
14765                 {\cf19 return} write_bson_object_entry(name, *j.m_value.object);\par
14766 \par
14767             {\cf19 case} value_t::array:\par
14768                 {\cf19 return} write_bson_array(name, *j.m_value.array);\par
14769 \par
14770             {\cf19 case} value_t::binary:\par
14771                 {\cf19 return} write_bson_binary(name, *j.m_value.binary);\par
14772 \par
14773             {\cf19 case} value_t::boolean:\par
14774                 {\cf19 return} write_bson_boolean(name, j.m_value.boolean);\par
14775 \par
14776             {\cf19 case} value_t::number_float:\par
14777                 {\cf19 return} write_bson_double(name, j.m_value.number_float);\par
14778 \par
14779             {\cf19 case} value_t::number_integer:\par
14780                 {\cf19 return} write_bson_integer(name, j.m_value.number_integer);\par
14781 \par
14782             {\cf19 case} value_t::number_unsigned:\par
14783                 {\cf19 return} write_bson_unsigned(name, j);\par
14784 \par
14785             {\cf19 case} value_t::string:\par
14786                 {\cf19 return} write_bson_string(name, *j.m_value.string);\par
14787 \par
14788             {\cf19 case} value_t::null:\par
14789                 {\cf19 return} write_bson_null(name);\par
14790 \par
14791             {\cf20 // LCOV_EXCL_START}\par
14792             {\cf19 case} value_t::discarded:\par
14793             {\cf19 default}:\par
14794                 JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert)}\par
14795                 {\cf19 return};\par
14796                 {\cf20 // LCOV_EXCL_STOP}\par
14797         \}\par
14798     \}\par
14799 \par
14806     {\cf17 static} std::size_t calc_bson_object_size({\cf17 const} {\cf17 typename} BasicJsonType::object_t& value)\par
14807     \{\par
14808         std::size_t document_size = std::accumulate(value.begin(), value.end(), std::size_t(0),\par
14809                                     []({\cf18 size_t} result, {\cf17 const} {\cf17 typename} BasicJsonType::object_t::value_type & el)\par
14810         \{\par
14811             return result += calc_bson_element_size(el.first, el.second);\par
14812         \});\par
14813 \par
14814         {\cf19 return} {\cf17 sizeof}(std::int32_t) + document_size + 1ul;\par
14815     \}\par
14816 \par
14821     {\cf18 void} write_bson_object({\cf17 const} {\cf17 typename} BasicJsonType::object_t& value)\par
14822     \{\par
14823         write_number<std::int32_t, true>({\cf17 static_cast<}std::int32_t{\cf17 >}(calc_bson_object_size(value)));\par
14824 \par
14825         {\cf19 for} ({\cf17 const} {\cf17 auto}& el : value)\par
14826         \{\par
14827             write_bson_element(el.first, el.second);\par
14828         \}\par
14829 \par
14830         oa->write_character(to_char_type(0x00));\par
14831     \}\par
14832 \par
14834     {\cf20 // CBOR //}\par
14836 {\cf20 }\par
14837     {\cf17 static} {\cf17 constexpr} CharType get_cbor_float_prefix({\cf18 float} {\cf20 /*unused*/})\par
14838     \{\par
14839         {\cf19 return} to_char_type(0xFA);  {\cf20 // Single-Precision Float}\par
14840     \}\par
14841 \par
14842     {\cf17 static} {\cf17 constexpr} CharType get_cbor_float_prefix({\cf18 double} {\cf20 /*unused*/})\par
14843     \{\par
14844         {\cf19 return} to_char_type(0xFB);  {\cf20 // Double-Precision Float}\par
14845     \}\par
14846 \par
14848     {\cf20 // MsgPack //}\par
14850 {\cf20 }\par
14851     {\cf17 static} {\cf17 constexpr} CharType get_msgpack_float_prefix({\cf18 float} {\cf20 /*unused*/})\par
14852     \{\par
14853         {\cf19 return} to_char_type(0xCA);  {\cf20 // float 32}\par
14854     \}\par
14855 \par
14856     {\cf17 static} {\cf17 constexpr} CharType get_msgpack_float_prefix({\cf18 double} {\cf20 /*unused*/})\par
14857     \{\par
14858         {\cf19 return} to_char_type(0xCB);  {\cf20 // float 64}\par
14859     \}\par
14860 \par
14862     {\cf20 // UBJSON //}\par
14864 {\cf20 }\par
14865     {\cf20 // UBJSON: write number (floating point)}\par
14866     {\cf17 template}<{\cf17 typename} NumberType, {\cf17 typename} std::enable_if<\par
14867                  std::is_floating_point<NumberType>::value, {\cf18 int}>::type = 0>\par
14868     {\cf18 void} write_number_with_ubjson_prefix({\cf17 const} NumberType n,\par
14869                                          {\cf17 const} {\cf18 bool} add_prefix)\par
14870     \{\par
14871         {\cf19 if} (add_prefix)\par
14872         \{\par
14873             oa->write_character(get_ubjson_float_prefix(n));\par
14874         \}\par
14875         write_number(n);\par
14876     \}\par
14877 \par
14878     {\cf20 // UBJSON: write number (unsigned integer)}\par
14879     {\cf17 template}<{\cf17 typename} NumberType, {\cf17 typename} std::enable_if<\par
14880                  std::is_unsigned<NumberType>::value, {\cf18 int}>::type = 0>\par
14881     {\cf18 void} write_number_with_ubjson_prefix({\cf17 const} NumberType n,\par
14882                                          {\cf17 const} {\cf18 bool} add_prefix)\par
14883     \{\par
14884         {\cf19 if} (n <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::int8_t>::max)()))\par
14885         \{\par
14886             {\cf19 if} (add_prefix)\par
14887             \{\par
14888                 oa->write_character(to_char_type({\cf23 'i'}));  {\cf20 // int8}\par
14889             \}\par
14890             write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(n));\par
14891         \}\par
14892         {\cf19 else} {\cf19 if} (n <= (std::numeric_limits<std::uint8_t>::max)())\par
14893         \{\par
14894             {\cf19 if} (add_prefix)\par
14895             \{\par
14896                 oa->write_character(to_char_type({\cf23 'U'}));  {\cf20 // uint8}\par
14897             \}\par
14898             write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(n));\par
14899         \}\par
14900         {\cf19 else} {\cf19 if} (n <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::int16_t>::max)()))\par
14901         \{\par
14902             {\cf19 if} (add_prefix)\par
14903             \{\par
14904                 oa->write_character(to_char_type({\cf23 'I'}));  {\cf20 // int16}\par
14905             \}\par
14906             write_number({\cf17 static_cast<}std::int16_t{\cf17 >}(n));\par
14907         \}\par
14908         {\cf19 else} {\cf19 if} (n <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::int32_t>::max)()))\par
14909         \{\par
14910             {\cf19 if} (add_prefix)\par
14911             \{\par
14912                 oa->write_character(to_char_type({\cf23 'l'}));  {\cf20 // int32}\par
14913             \}\par
14914             write_number({\cf17 static_cast<}std::int32_t{\cf17 >}(n));\par
14915         \}\par
14916         {\cf19 else} {\cf19 if} (n <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::int64_t>::max)()))\par
14917         \{\par
14918             {\cf19 if} (add_prefix)\par
14919             \{\par
14920                 oa->write_character(to_char_type({\cf23 'L'}));  {\cf20 // int64}\par
14921             \}\par
14922             write_number({\cf17 static_cast<}std::int64_t{\cf17 >}(n));\par
14923         \}\par
14924         {\cf19 else}\par
14925         \{\par
14926             {\cf19 if} (add_prefix)\par
14927             \{\par
14928                 oa->write_character(to_char_type({\cf23 'H'}));  {\cf20 // high-precision number}\par
14929             \}\par
14930 \par
14931             {\cf17 const} {\cf17 auto} number = BasicJsonType(n).dump();\par
14932             write_number_with_ubjson_prefix(number.size(), {\cf17 true});\par
14933             {\cf19 for} (std::size_t i = 0; i < number.size(); ++i)\par
14934             \{\par
14935                 oa->write_character(to_char_type({\cf17 static_cast<}std::uint8_t{\cf17 >}(number[i])));\par
14936             \}\par
14937         \}\par
14938     \}\par
14939 \par
14940     {\cf20 // UBJSON: write number (signed integer)}\par
14941     {\cf17 template} < {\cf17 typename} NumberType, {\cf17 typename} std::enable_if <\par
14942                    std::is_signed<NumberType>::value&&\par
14943                    !std::is_floating_point<NumberType>::value, {\cf18 int} >::type = 0 >\par
14944     {\cf18 void} write_number_with_ubjson_prefix({\cf17 const} NumberType n,\par
14945                                          {\cf17 const} {\cf18 bool} add_prefix)\par
14946     \{\par
14947         {\cf19 if} ((std::numeric_limits<std::int8_t>::min)() <= n && n <= (std::numeric_limits<std::int8_t>::max)())\par
14948         \{\par
14949             {\cf19 if} (add_prefix)\par
14950             \{\par
14951                 oa->write_character(to_char_type({\cf23 'i'}));  {\cf20 // int8}\par
14952             \}\par
14953             write_number({\cf17 static_cast<}std::int8_t{\cf17 >}(n));\par
14954         \}\par
14955         {\cf19 else} {\cf19 if} ({\cf17 static_cast<}std::int64_t{\cf17 >}((std::numeric_limits<std::uint8_t>::min)()) <= n && n <= {\cf17 static_cast<}std::int64_t{\cf17 >}((std::numeric_limits<std::uint8_t>::max)()))\par
14956         \{\par
14957             {\cf19 if} (add_prefix)\par
14958             \{\par
14959                 oa->write_character(to_char_type({\cf23 'U'}));  {\cf20 // uint8}\par
14960             \}\par
14961             write_number({\cf17 static_cast<}std::uint8_t{\cf17 >}(n));\par
14962         \}\par
14963         {\cf19 else} {\cf19 if} ((std::numeric_limits<std::int16_t>::min)() <= n && n <= (std::numeric_limits<std::int16_t>::max)())\par
14964         \{\par
14965             {\cf19 if} (add_prefix)\par
14966             \{\par
14967                 oa->write_character(to_char_type({\cf23 'I'}));  {\cf20 // int16}\par
14968             \}\par
14969             write_number({\cf17 static_cast<}std::int16_t{\cf17 >}(n));\par
14970         \}\par
14971         {\cf19 else} {\cf19 if} ((std::numeric_limits<std::int32_t>::min)() <= n && n <= (std::numeric_limits<std::int32_t>::max)())\par
14972         \{\par
14973             {\cf19 if} (add_prefix)\par
14974             \{\par
14975                 oa->write_character(to_char_type({\cf23 'l'}));  {\cf20 // int32}\par
14976             \}\par
14977             write_number({\cf17 static_cast<}std::int32_t{\cf17 >}(n));\par
14978         \}\par
14979         {\cf19 else} {\cf19 if} ((std::numeric_limits<std::int64_t>::min)() <= n && n <= (std::numeric_limits<std::int64_t>::max)())\par
14980         \{\par
14981             {\cf19 if} (add_prefix)\par
14982             \{\par
14983                 oa->write_character(to_char_type({\cf23 'L'}));  {\cf20 // int64}\par
14984             \}\par
14985             write_number({\cf17 static_cast<}std::int64_t{\cf17 >}(n));\par
14986         \}\par
14987         {\cf20 // LCOV_EXCL_START}\par
14988         {\cf19 else}\par
14989         \{\par
14990             {\cf19 if} (add_prefix)\par
14991             \{\par
14992                 oa->write_character(to_char_type({\cf23 'H'}));  {\cf20 // high-precision number}\par
14993             \}\par
14994 \par
14995             {\cf17 const} {\cf17 auto} number = BasicJsonType(n).dump();\par
14996             write_number_with_ubjson_prefix(number.size(), {\cf17 true});\par
14997             {\cf19 for} (std::size_t i = 0; i < number.size(); ++i)\par
14998             \{\par
14999                 oa->write_character(to_char_type({\cf17 static_cast<}std::uint8_t{\cf17 >}(number[i])));\par
15000             \}\par
15001         \}\par
15002         {\cf20 // LCOV_EXCL_STOP}\par
15003     \}\par
15004 \par
15008     CharType ubjson_prefix({\cf17 const} BasicJsonType& j) {\cf17 const} {\cf17 noexcept}\par
15009     \{\par
15010         {\cf19 switch} (j.type())\par
15011         \{\par
15012             {\cf19 case} value_t::null:\par
15013                 {\cf19 return} {\cf23 'Z'};\par
15014 \par
15015             {\cf19 case} value_t::boolean:\par
15016                 {\cf19 return} j.m_value.boolean ? {\cf23 'T'} : {\cf23 'F'};\par
15017 \par
15018             {\cf19 case} value_t::number_integer:\par
15019             \{\par
15020                 {\cf19 if} ((std::numeric_limits<std::int8_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int8_t>::max)())\par
15021                 \{\par
15022                     {\cf19 return} {\cf23 'i'};\par
15023                 \}\par
15024                 {\cf19 if} ((std::numeric_limits<std::uint8_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::uint8_t>::max)())\par
15025                 \{\par
15026                     {\cf19 return} {\cf23 'U'};\par
15027                 \}\par
15028                 {\cf19 if} ((std::numeric_limits<std::int16_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int16_t>::max)())\par
15029                 \{\par
15030                     {\cf19 return} {\cf23 'I'};\par
15031                 \}\par
15032                 {\cf19 if} ((std::numeric_limits<std::int32_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int32_t>::max)())\par
15033                 \{\par
15034                     {\cf19 return} {\cf23 'l'};\par
15035                 \}\par
15036                 {\cf19 if} ((std::numeric_limits<std::int64_t>::min)() <= j.m_value.number_integer && j.m_value.number_integer <= (std::numeric_limits<std::int64_t>::max)())\par
15037                 \{\par
15038                     {\cf19 return} {\cf23 'L'};\par
15039                 \}\par
15040                 {\cf20 // anything else is treated as high-precision number}\par
15041                 {\cf19 return} {\cf23 'H'}; {\cf20 // LCOV_EXCL_LINE}\par
15042             \}\par
15043 \par
15044             {\cf19 case} value_t::number_unsigned:\par
15045             \{\par
15046                 {\cf19 if} (j.m_value.number_unsigned <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::int8_t>::max)()))\par
15047                 \{\par
15048                     {\cf19 return} {\cf23 'i'};\par
15049                 \}\par
15050                 {\cf19 if} (j.m_value.number_unsigned <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::uint8_t>::max)()))\par
15051                 \{\par
15052                     {\cf19 return} {\cf23 'U'};\par
15053                 \}\par
15054                 {\cf19 if} (j.m_value.number_unsigned <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::int16_t>::max)()))\par
15055                 \{\par
15056                     {\cf19 return} {\cf23 'I'};\par
15057                 \}\par
15058                 {\cf19 if} (j.m_value.number_unsigned <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::int32_t>::max)()))\par
15059                 \{\par
15060                     {\cf19 return} {\cf23 'l'};\par
15061                 \}\par
15062                 {\cf19 if} (j.m_value.number_unsigned <= {\cf17 static_cast<}std::uint64_t{\cf17 >}((std::numeric_limits<std::int64_t>::max)()))\par
15063                 \{\par
15064                     {\cf19 return} {\cf23 'L'};\par
15065                 \}\par
15066                 {\cf20 // anything else is treated as high-precision number}\par
15067                 {\cf19 return} {\cf23 'H'}; {\cf20 // LCOV_EXCL_LINE}\par
15068             \}\par
15069 \par
15070             {\cf19 case} value_t::number_float:\par
15071                 {\cf19 return} get_ubjson_float_prefix(j.m_value.number_float);\par
15072 \par
15073             {\cf19 case} value_t::string:\par
15074                 {\cf19 return} {\cf23 'S'};\par
15075 \par
15076             {\cf19 case} value_t::array: {\cf20 // fallthrough}\par
15077             {\cf19 case} value_t::binary:\par
15078                 {\cf19 return} {\cf23 '['};\par
15079 \par
15080             {\cf19 case} value_t::object:\par
15081                 {\cf19 return} {\cf23 '\{'};\par
15082 \par
15083             {\cf19 case} value_t::discarded:\par
15084             {\cf19 default}:  {\cf20 // discarded values}\par
15085                 {\cf19 return} {\cf23 'N'};\par
15086         \}\par
15087     \}\par
15088 \par
15089     {\cf17 static} {\cf17 constexpr} CharType get_ubjson_float_prefix({\cf18 float} {\cf20 /*unused*/})\par
15090     \{\par
15091         {\cf19 return} {\cf23 'd'};  {\cf20 // float 32}\par
15092     \}\par
15093 \par
15094     {\cf17 static} {\cf17 constexpr} CharType get_ubjson_float_prefix({\cf18 double} {\cf20 /*unused*/})\par
15095     \{\par
15096         {\cf19 return} {\cf23 'D'};  {\cf20 // float 64}\par
15097     \}\par
15098 \par
15100     {\cf20 // Utility functions //}\par
15102 {\cf20 }\par
15103     {\cf20 /*}\par
15104 {\cf20     @brief write a number to output input}\par
15105 {\cf20     @param[in] n number of type @a NumberType}\par
15106 {\cf20     @tparam NumberType the type of the number}\par
15107 {\cf20     @tparam OutputIsLittleEndian Set to true if output data is}\par
15108 {\cf20                                  required to be little endian}\par
15109 {\cf20 }\par
15110 {\cf20     @note This function needs to respect the system's endianess, because bytes}\par
15111 {\cf20           in CBOR, MessagePack, and UBJSON are stored in network order (big}\par
15112 {\cf20           endian) and therefore need reordering on little endian systems.}\par
15113 {\cf20     */}\par
15114     {\cf17 template}<{\cf17 typename} NumberType, {\cf18 bool} OutputIsLittleEndian = false>\par
15115     {\cf18 void} write_number({\cf17 const} NumberType n)\par
15116     \{\par
15117         {\cf20 // step 1: write number to array of length NumberType}\par
15118         std::array<CharType, {\cf17 sizeof}(NumberType)> vec\{\};\par
15119         std::memcpy(vec.data(), &n, {\cf17 sizeof}(NumberType));\par
15120 \par
15121         {\cf20 // step 2: write array to output (with possible reordering)}\par
15122         {\cf19 if} (is_little_endian != OutputIsLittleEndian)\par
15123         \{\par
15124             {\cf20 // reverse byte order prior to conversion if necessary}\par
15125             std::reverse(vec.begin(), vec.end());\par
15126         \}\par
15127 \par
15128         oa->write_characters(vec.data(), {\cf17 sizeof}(NumberType));\par
15129     \}\par
15130 \par
15131     {\cf18 void} write_compact_float({\cf17 const} number_float_t n, detail::input_format_t format)\par
15132     \{\par
15133 {\cf21 #ifdef __GNUC__}\par
15134 {\cf21 #pragma GCC diagnostic push}\par
15135 {\cf21 #pragma GCC diagnostic ignored "-Wfloat-equal"}\par
15136 {\cf21 #endif}\par
15137         {\cf19 if} ({\cf17 static_cast<}{\cf18 double}{\cf17 >}(n) >= {\cf17 static_cast<}{\cf18 double}{\cf17 >}(std::numeric_limits<float>::lowest()) &&\par
15138                 {\cf17 static_cast<}{\cf18 double}{\cf17 >}(n) <= {\cf17 static_cast<}{\cf18 double}{\cf17 >}((std::numeric_limits<float>::max)()) &&\par
15139                 {\cf17 static_cast<}{\cf18 double}{\cf17 >}({\cf17 static_cast<}{\cf18 float}{\cf17 >}(n)) == {\cf17 static_cast<}{\cf18 double}{\cf17 >}(n))\par
15140         \{\par
15141             oa->write_character(format == detail::input_format_t::cbor\par
15142                                 ? get_cbor_float_prefix({\cf17 static_cast<}{\cf18 float}{\cf17 >}(n))\par
15143                                 : get_msgpack_float_prefix({\cf17 static_cast<}{\cf18 float}{\cf17 >}(n)));\par
15144             write_number({\cf17 static_cast<}{\cf18 float}{\cf17 >}(n));\par
15145         \}\par
15146         {\cf19 else}\par
15147         \{\par
15148             oa->write_character(format == detail::input_format_t::cbor\par
15149                                 ? get_cbor_float_prefix(n)\par
15150                                 : get_msgpack_float_prefix(n));\par
15151             write_number(n);\par
15152         \}\par
15153 {\cf21 #ifdef __GNUC__}\par
15154 {\cf21 #pragma GCC diagnostic pop}\par
15155 {\cf21 #endif}\par
15156     \}\par
15157 \par
15158   {\cf17 public}:\par
15159     {\cf20 // The following to_char_type functions are implement the conversion}\par
15160     {\cf20 // between uint8_t and CharType. In case CharType is not unsigned,}\par
15161     {\cf20 // such a conversion is required to allow values greater than 128.}\par
15162     {\cf20 // See <https://github.com/nlohmann/json/issues/1286> for a discussion.}\par
15163     {\cf17 template} < {\cf17 typename} C = CharType,\par
15164                enable_if_t < std::is_signed<C>::value && std::is_signed<char>::value > * = {\cf17 nullptr} >\par
15165     {\cf17 static} {\cf17 constexpr} CharType to_char_type(std::uint8_t x) {\cf17 noexcept}\par
15166     \{\par
15167         {\cf19 return} *{\cf17 reinterpret_cast<}{\cf18 char}*{\cf17 >}(&x);\par
15168     \}\par
15169 \par
15170     {\cf17 template} < {\cf17 typename} C = CharType,\par
15171                enable_if_t < std::is_signed<C>::value && std::is_unsigned<char>::value > * = {\cf17 nullptr} >\par
15172     {\cf17 static} CharType to_char_type(std::uint8_t x) {\cf17 noexcept}\par
15173     \{\par
15174         {\cf17 static_assert}({\cf17 sizeof}(std::uint8_t) == {\cf17 sizeof}(CharType), {\cf22 "size of CharType must be equal to std::uint8_t"});\par
15175         {\cf17 static_assert}(std::is_trivial<CharType>::value, {\cf22 "CharType must be trivial"});\par
15176         CharType result;\par
15177         std::memcpy(&result, &x, {\cf17 sizeof}(x));\par
15178         {\cf19 return} result;\par
15179     \}\par
15180 \par
15181     {\cf17 template}<{\cf17 typename} C = CharType,\par
15182              enable_if_t<std::is_unsigned<C>::value>* = {\cf17 nullptr}>\par
15183     {\cf17 static} {\cf17 constexpr} CharType to_char_type(std::uint8_t x) {\cf17 noexcept}\par
15184     \{\par
15185         {\cf19 return} x;\par
15186     \}\par
15187 \par
15188     {\cf17 template} < {\cf17 typename} InputCharType, {\cf17 typename} C = CharType,\par
15189                enable_if_t <\par
15190                    std::is_signed<C>::value &&\par
15191                    std::is_signed<char>::value &&\par
15192                    std::is_same<char, typename std::remove_cv<InputCharType>::type>::value\par
15193                    > * = {\cf17 nullptr} >\par
15194     {\cf17 static} {\cf17 constexpr} CharType to_char_type(InputCharType x) {\cf17 noexcept}\par
15195     \{\par
15196         {\cf19 return} x;\par
15197     \}\par
15198 \par
15199   {\cf17 private}:\par
15201     {\cf17 const} {\cf18 bool} is_little_endian = little_endianess();\par
15202 \par
15204     output_adapter_t<CharType> oa = {\cf17 nullptr};\par
15205 \};\par
15206 \}  {\cf20 // namespace detail}\par
15207 \}  {\cf20 // namespace nlohmann}\par
15208 \par
15209 {\cf20 // #include <nlohmann/detail/output/output_adapters.hpp>}\par
15210 \par
15211 {\cf20 // #include <nlohmann/detail/output/serializer.hpp>}\par
15212 \par
15213 \par
15214 {\cf21 #include <algorithm>} {\cf20 // reverse, remove, fill, find, none_of}\par
15215 {\cf21 #include <array>} {\cf20 // array}\par
15216 {\cf21 #include <clocale>} {\cf20 // localeconv, lconv}\par
15217 {\cf21 #include <cmath>} {\cf20 // labs, isfinite, isnan, signbit}\par
15218 {\cf21 #include <cstddef>} {\cf20 // size_t, ptrdiff_t}\par
15219 {\cf21 #include <cstdint>} {\cf20 // uint8_t}\par
15220 {\cf21 #include <cstdio>} {\cf20 // snprintf}\par
15221 {\cf21 #include <limits>} {\cf20 // numeric_limits}\par
15222 {\cf21 #include <string>} {\cf20 // string, char_traits}\par
15223 {\cf21 #include <type_traits>} {\cf20 // is_same}\par
15224 {\cf21 #include <utility>} {\cf20 // move}\par
15225 \par
15226 {\cf20 // #include <nlohmann/detail/conversions/to_chars.hpp>}\par
15227 \par
15228 \par
15229 {\cf21 #include <array>} {\cf20 // array}\par
15230 {\cf21 #include <cmath>}   {\cf20 // signbit, isfinite}\par
15231 {\cf21 #include <cstdint>} {\cf20 // intN_t, uintN_t}\par
15232 {\cf21 #include <cstring>} {\cf20 // memcpy, memmove}\par
15233 {\cf21 #include <limits>} {\cf20 // numeric_limits}\par
15234 {\cf21 #include <type_traits>} {\cf20 // conditional}\par
15235 \par
15236 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
15237 \par
15238 \par
15239 {\cf17 namespace }nlohmann\par
15240 \{\par
15241 {\cf17 namespace }detail\par
15242 \{\par
15243 \par
15263 {\cf17 namespace }dtoa_impl\par
15264 \{\par
15265 \par
15266 {\cf17 template}<{\cf17 typename} Target, {\cf17 typename} Source>\par
15267 Target reinterpret_bits({\cf17 const} Source source)\par
15268 \{\par
15269     {\cf17 static_assert}({\cf17 sizeof}(Target) == {\cf17 sizeof}(Source), {\cf22 "size mismatch"});\par
15270 \par
15271     Target target;\par
15272     std::memcpy(&target, &source, {\cf17 sizeof}(Source));\par
15273     {\cf19 return} target;\par
15274 \}\par
15275 \par
15276 {\cf17 struct }diyfp {\cf20 // f * 2^e}\par
15277 \{\par
15278     {\cf17 static} {\cf17 constexpr} {\cf18 int} kPrecision = 64; {\cf20 // = q}\par
15279 \par
15280     std::uint64_t f = 0;\par
15281     {\cf18 int} e = 0;\par
15282 \par
15283     {\cf17 constexpr} diyfp(std::uint64_t f_, {\cf18 int} e_) noexcept : f(f_), e(e_) \{\}\par
15284 \par
15289     {\cf17 static} diyfp sub({\cf17 const} diyfp& x, {\cf17 const} diyfp& y) {\cf17 noexcept}\par
15290     \{\par
15291         JSON_ASSERT(x.e == y.e);\par
15292         JSON_ASSERT(x.f >= y.f);\par
15293 \par
15294         {\cf19 return} \{x.f - y.f, x.e\};\par
15295     \}\par
15296 \par
15301     {\cf17 static} diyfp mul({\cf17 const} diyfp& x, {\cf17 const} diyfp& y) {\cf17 noexcept}\par
15302     \{\par
15303         {\cf17 static_assert}(kPrecision == 64, {\cf22 "internal error"});\par
15304 \par
15305         {\cf20 // Computes:}\par
15306         {\cf20 //  f = round((x.f * y.f) / 2^q)}\par
15307         {\cf20 //  e = x.e + y.e + q}\par
15308 \par
15309         {\cf20 // Emulate the 64-bit * 64-bit multiplication:}\par
15310         {\cf20 //}\par
15311         {\cf20 // p = u * v}\par
15312         {\cf20 //   = (u_lo + 2^32 u_hi) (v_lo + 2^32 v_hi)}\par
15313         {\cf20 //   = (u_lo v_lo         ) + 2^32 ((u_lo v_hi         ) + (u_hi v_lo         )) + 2^64 (u_hi v_hi         )}\par
15314         {\cf20 //   = (p0                ) + 2^32 ((p1                ) + (p2                )) + 2^64 (p3                )}\par
15315         {\cf20 //   = (p0_lo + 2^32 p0_hi) + 2^32 ((p1_lo + 2^32 p1_hi) + (p2_lo + 2^32 p2_hi)) + 2^64 (p3                )}\par
15316         {\cf20 //   = (p0_lo             ) + 2^32 (p0_hi + p1_lo + p2_lo                      ) + 2^64 (p1_hi + p2_hi + p3)}\par
15317         {\cf20 //   = (p0_lo             ) + 2^32 (Q                                          ) + 2^64 (H                 )}\par
15318         {\cf20 //   = (p0_lo             ) + 2^32 (Q_lo + 2^32 Q_hi                           ) + 2^64 (H                 )}\par
15319         {\cf20 //}\par
15320         {\cf20 // (Since Q might be larger than 2^32 - 1)}\par
15321         {\cf20 //}\par
15322         {\cf20 //   = (p0_lo + 2^32 Q_lo) + 2^64 (Q_hi + H)}\par
15323         {\cf20 //}\par
15324         {\cf20 // (Q_hi + H does not overflow a 64-bit int)}\par
15325         {\cf20 //}\par
15326         {\cf20 //   = p_lo + 2^64 p_hi}\par
15327 \par
15328         {\cf17 const} std::uint64_t u_lo = x.f & 0xFFFFFFFFu;\par
15329         {\cf17 const} std::uint64_t u_hi = x.f >> 32u;\par
15330         {\cf17 const} std::uint64_t v_lo = y.f & 0xFFFFFFFFu;\par
15331         {\cf17 const} std::uint64_t v_hi = y.f >> 32u;\par
15332 \par
15333         {\cf17 const} std::uint64_t p0 = u_lo * v_lo;\par
15334         {\cf17 const} std::uint64_t p1 = u_lo * v_hi;\par
15335         {\cf17 const} std::uint64_t p2 = u_hi * v_lo;\par
15336         {\cf17 const} std::uint64_t p3 = u_hi * v_hi;\par
15337 \par
15338         {\cf17 const} std::uint64_t p0_hi = p0 >> 32u;\par
15339         {\cf17 const} std::uint64_t p1_lo = p1 & 0xFFFFFFFFu;\par
15340         {\cf17 const} std::uint64_t p1_hi = p1 >> 32u;\par
15341         {\cf17 const} std::uint64_t p2_lo = p2 & 0xFFFFFFFFu;\par
15342         {\cf17 const} std::uint64_t p2_hi = p2 >> 32u;\par
15343 \par
15344         std::uint64_t Q = p0_hi + p1_lo + p2_lo;\par
15345 \par
15346         {\cf20 // The full product might now be computed as}\par
15347         {\cf20 //}\par
15348         {\cf20 // p_hi = p3 + p2_hi + p1_hi + (Q >> 32)}\par
15349         {\cf20 // p_lo = p0_lo + (Q << 32)}\par
15350         {\cf20 //}\par
15351         {\cf20 // But in this particular case here, the full p_lo is not required.}\par
15352         {\cf20 // Effectively we only need to add the highest bit in p_lo to p_hi (and}\par
15353         {\cf20 // Q_hi + 1 does not overflow).}\par
15354 \par
15355         Q += std::uint64_t\{1\} << (64u - 32u - 1u); {\cf20 // round, ties up}\par
15356 \par
15357         {\cf17 const} std::uint64_t h = p3 + p2_hi + p1_hi + (Q >> 32u);\par
15358 \par
15359         {\cf19 return} \{h, x.e + y.e + 64\};\par
15360     \}\par
15361 \par
15366     {\cf17 static} diyfp normalize(diyfp x) {\cf17 noexcept}\par
15367     \{\par
15368         JSON_ASSERT(x.f != 0);\par
15369 \par
15370         {\cf19 while} ((x.f >> 63u) == 0)\par
15371         \{\par
15372             x.f <<= 1u;\par
15373             x.e--;\par
15374         \}\par
15375 \par
15376         {\cf19 return} x;\par
15377     \}\par
15378 \par
15383     {\cf17 static} diyfp normalize_to({\cf17 const} diyfp& x, {\cf17 const} {\cf18 int} target_exponent) {\cf17 noexcept}\par
15384     \{\par
15385         {\cf17 const} {\cf18 int} delta = x.e - target_exponent;\par
15386 \par
15387         JSON_ASSERT(delta >= 0);\par
15388         JSON_ASSERT(((x.f << delta) >> delta) == x.f);\par
15389 \par
15390         {\cf19 return} \{x.f << delta, target_exponent\};\par
15391     \}\par
15392 \};\par
15393 \par
15394 {\cf17 struct }boundaries\par
15395 \{\par
15396     diyfp w;\par
15397     diyfp minus;\par
15398     diyfp plus;\par
15399 \};\par
15400 \par
15407 {\cf17 template}<{\cf17 typename} FloatType>\par
15408 boundaries compute_boundaries(FloatType value)\par
15409 \{\par
15410     JSON_ASSERT(std::isfinite(value));\par
15411     JSON_ASSERT(value > 0);\par
15412 \par
15413     {\cf20 // Convert the IEEE representation into a diyfp.}\par
15414     {\cf20 //}\par
15415     {\cf20 // If v is denormal:}\par
15416     {\cf20 //      value = 0.F * 2^(1 - bias) = (          F) * 2^(1 - bias - (p-1))}\par
15417     {\cf20 // If v is normalized:}\par
15418     {\cf20 //      value = 1.F * 2^(E - bias) = (2^(p-1) + F) * 2^(E - bias - (p-1))}\par
15419 \par
15420     {\cf17 static_assert}(std::numeric_limits<FloatType>::is_iec559,\par
15421                   {\cf22 "internal error: dtoa_short requires an IEEE-754 floating-point implementation"});\par
15422 \par
15423     {\cf17 constexpr} {\cf18 int}      kPrecision = std::numeric_limits<FloatType>::digits; {\cf20 // = p (includes the hidden bit)}\par
15424     {\cf17 constexpr} {\cf18 int}      kBias      = std::numeric_limits<FloatType>::max_exponent - 1 + (kPrecision - 1);\par
15425     {\cf17 constexpr} {\cf18 int}      kMinExp    = 1 - kBias;\par
15426     {\cf17 constexpr} std::uint64_t kHiddenBit = std::uint64_t\{1\} << (kPrecision - 1); {\cf20 // = 2^(p-1)}\par
15427 \par
15428     {\cf17 using} bits_type = {\cf17 typename} std::conditional<kPrecision == 24, std::uint32_t, std::uint64_t >::type;\par
15429 \par
15430     {\cf17 const} {\cf17 auto} bits = {\cf17 static_cast<}std::uint64_t{\cf17 >}(reinterpret_bits<bits_type>(value));\par
15431     {\cf17 const} std::uint64_t E = bits >> (kPrecision - 1);\par
15432     {\cf17 const} std::uint64_t F = bits & (kHiddenBit - 1);\par
15433 \par
15434     {\cf17 const} {\cf18 bool} is_denormal = E == 0;\par
15435     {\cf17 const} diyfp v = is_denormal\par
15436                     ? diyfp(F, kMinExp)\par
15437                     : diyfp(F + kHiddenBit, {\cf17 static_cast<}{\cf18 int}{\cf17 >}(E) - kBias);\par
15438 \par
15439     {\cf20 // Compute the boundaries m- and m+ of the floating-point value}\par
15440     {\cf20 // v = f * 2^e.}\par
15441     {\cf20 //}\par
15442     {\cf20 // Determine v- and v+, the floating-point predecessor and successor if v,}\par
15443     {\cf20 // respectively.}\par
15444     {\cf20 //}\par
15445     {\cf20 //      v- = v - 2^e        if f != 2^(p-1) or e == e_min                (A)}\par
15446     {\cf20 //         = v - 2^(e-1)    if f == 2^(p-1) and e > e_min                (B)}\par
15447     {\cf20 //}\par
15448     {\cf20 //      v+ = v + 2^e}\par
15449     {\cf20 //}\par
15450     {\cf20 // Let m- = (v- + v) / 2 and m+ = (v + v+) / 2. All real numbers _strictly_}\par
15451     {\cf20 // between m- and m+ round to v, regardless of how the input rounding}\par
15452     {\cf20 // algorithm breaks ties.}\par
15453     {\cf20 //}\par
15454     {\cf20 //      ---+-------------+-------------+-------------+-------------+---  (A)}\par
15455     {\cf20 //         v-            m-            v             m+            v+}\par
15456     {\cf20 //}\par
15457     {\cf20 //      -----------------+------+------+-------------+-------------+---  (B)}\par
15458     {\cf20 //                       v-     m-     v             m+            v+}\par
15459 \par
15460     {\cf17 const} {\cf18 bool} lower_boundary_is_closer = F == 0 && E > 1;\par
15461     {\cf17 const} diyfp m_plus = diyfp(2 * v.f + 1, v.e - 1);\par
15462     {\cf17 const} diyfp m_minus = lower_boundary_is_closer\par
15463                           ? diyfp(4 * v.f - 1, v.e - 2)  {\cf20 // (B)}\par
15464                           : diyfp(2 * v.f - 1, v.e - 1); {\cf20 // (A)}\par
15465 \par
15466     {\cf20 // Determine the normalized w+ = m+.}\par
15467     {\cf17 const} diyfp w_plus = diyfp::normalize(m_plus);\par
15468 \par
15469     {\cf20 // Determine w- = m- such that e_(w-) = e_(w+).}\par
15470     {\cf17 const} diyfp w_minus = diyfp::normalize_to(m_minus, w_plus.e);\par
15471 \par
15472     {\cf19 return} \{diyfp::normalize(v), w_minus, w_plus\};\par
15473 \}\par
15474 \par
15475 {\cf20 // Given normalized diyfp w, Grisu needs to find a (normalized) cached}\par
15476 {\cf20 // power-of-ten c, such that the exponent of the product c * w = f * 2^e lies}\par
15477 {\cf20 // within a certain range [alpha, gamma] (Definition 3.2 from [1])}\par
15478 {\cf20 //}\par
15479 {\cf20 //      alpha <= e = e_c + e_w + q <= gamma}\par
15480 {\cf20 //}\par
15481 {\cf20 // or}\par
15482 {\cf20 //}\par
15483 {\cf20 //      f_c * f_w * 2^alpha <= f_c 2^(e_c) * f_w 2^(e_w) * 2^q}\par
15484 {\cf20 //                          <= f_c * f_w * 2^gamma}\par
15485 {\cf20 //}\par
15486 {\cf20 // Since c and w are normalized, i.e. 2^(q-1) <= f < 2^q, this implies}\par
15487 {\cf20 //}\par
15488 {\cf20 //      2^(q-1) * 2^(q-1) * 2^alpha <= c * w * 2^q < 2^q * 2^q * 2^gamma}\par
15489 {\cf20 //}\par
15490 {\cf20 // or}\par
15491 {\cf20 //}\par
15492 {\cf20 //      2^(q - 2 + alpha) <= c * w < 2^(q + gamma)}\par
15493 {\cf20 //}\par
15494 {\cf20 // The choice of (alpha,gamma) determines the size of the table and the form of}\par
15495 {\cf20 // the digit generation procedure. Using (alpha,gamma)=(-60,-32) works out well}\par
15496 {\cf20 // in practice:}\par
15497 {\cf20 //}\par
15498 {\cf20 // The idea is to cut the number c * w = f * 2^e into two parts, which can be}\par
15499 {\cf20 // processed independently: An integral part p1, and a fractional part p2:}\par
15500 {\cf20 //}\par
15501 {\cf20 //      f * 2^e = ( (f div 2^-e) * 2^-e + (f mod 2^-e) ) * 2^e}\par
15502 {\cf20 //              = (f div 2^-e) + (f mod 2^-e) * 2^e}\par
15503 {\cf20 //              = p1 + p2 * 2^e}\par
15504 {\cf20 //}\par
15505 {\cf20 // The conversion of p1 into decimal form requires a series of divisions and}\par
15506 {\cf20 // modulos by (a power of) 10. These operations are faster for 32-bit than for}\par
15507 {\cf20 // 64-bit integers, so p1 should ideally fit into a 32-bit integer. This can be}\par
15508 {\cf20 // achieved by choosing}\par
15509 {\cf20 //}\par
15510 {\cf20 //      -e >= 32   or   e <= -32 := gamma}\par
15511 {\cf20 //}\par
15512 {\cf20 // In order to convert the fractional part}\par
15513 {\cf20 //}\par
15514 {\cf20 //      p2 * 2^e = p2 / 2^-e = d[-1] / 10^1 + d[-2] / 10^2 + ...}\par
15515 {\cf20 //}\par
15516 {\cf20 // into decimal form, the fraction is repeatedly multiplied by 10 and the digits}\par
15517 {\cf20 // d[-i] are extracted in order:}\par
15518 {\cf20 //}\par
15519 {\cf20 //      (10 * p2) div 2^-e = d[-1]}\par
15520 {\cf20 //      (10 * p2) mod 2^-e = d[-2] / 10^1 + ...}\par
15521 {\cf20 //}\par
15522 {\cf20 // The multiplication by 10 must not overflow. It is sufficient to choose}\par
15523 {\cf20 //}\par
15524 {\cf20 //      10 * p2 < 16 * p2 = 2^4 * p2 <= 2^64.}\par
15525 {\cf20 //}\par
15526 {\cf20 // Since p2 = f mod 2^-e < 2^-e,}\par
15527 {\cf20 //}\par
15528 {\cf20 //      -e <= 60   or   e >= -60 := alpha}\par
15529 \par
15530 {\cf17 constexpr} {\cf18 int} kAlpha = -60;\par
15531 {\cf17 constexpr} {\cf18 int} kGamma = -32;\par
15532 \par
15533 {\cf17 struct }cached_power {\cf20 // c = f * 2^e ~= 10^k}\par
15534 \{\par
15535     std::uint64_t f;\par
15536     {\cf18 int} e;\par
15537     {\cf18 int} k;\par
15538 \};\par
15539 \par
15547 {\cf17 inline} cached_power get_cached_power_for_binary_exponent({\cf18 int} e)\par
15548 \{\par
15549     {\cf20 // Now}\par
15550     {\cf20 //}\par
15551     {\cf20 //      alpha <= e_c + e + q <= gamma                                    (1)}\par
15552     {\cf20 //      ==> f_c * 2^alpha <= c * 2^e * 2^q}\par
15553     {\cf20 //}\par
15554     {\cf20 // and since the c's are normalized, 2^(q-1) <= f_c,}\par
15555     {\cf20 //}\par
15556     {\cf20 //      ==> 2^(q - 1 + alpha) <= c * 2^(e + q)}\par
15557     {\cf20 //      ==> 2^(alpha - e - 1) <= c}\par
15558     {\cf20 //}\par
15559     {\cf20 // If c were an exact power of ten, i.e. c = 10^k, one may determine k as}\par
15560     {\cf20 //}\par
15561     {\cf20 //      k = ceil( log_10( 2^(alpha - e - 1) ) )}\par
15562     {\cf20 //        = ceil( (alpha - e - 1) * log_10(2) )}\par
15563     {\cf20 //}\par
15564     {\cf20 // From the paper:}\par
15565     {\cf20 // "In theory the result of the procedure could be wrong since c is rounded,}\par
15566     {\cf20 //  and the computation itself is approximated [...]. In practice, however,}\par
15567     {\cf20 //  this simple function is sufficient."}\par
15568     {\cf20 //}\par
15569     {\cf20 // For IEEE double precision floating-point numbers converted into}\par
15570     {\cf20 // normalized diyfp's w = f * 2^e, with q = 64,}\par
15571     {\cf20 //}\par
15572     {\cf20 //      e >= -1022      (min IEEE exponent)}\par
15573     {\cf20 //           -52        (p - 1)}\par
15574     {\cf20 //           -52        (p - 1, possibly normalize denormal IEEE numbers)}\par
15575     {\cf20 //           -11        (normalize the diyfp)}\par
15576     {\cf20 //         = -1137}\par
15577     {\cf20 //}\par
15578     {\cf20 // and}\par
15579     {\cf20 //}\par
15580     {\cf20 //      e <= +1023      (max IEEE exponent)}\par
15581     {\cf20 //           -52        (p - 1)}\par
15582     {\cf20 //           -11        (normalize the diyfp)}\par
15583     {\cf20 //         = 960}\par
15584     {\cf20 //}\par
15585     {\cf20 // This binary exponent range [-1137,960] results in a decimal exponent}\par
15586     {\cf20 // range [-307,324]. One does not need to store a cached power for each}\par
15587     {\cf20 // k in this range. For each such k it suffices to find a cached power}\par
15588     {\cf20 // such that the exponent of the product lies in [alpha,gamma].}\par
15589     {\cf20 // This implies that the difference of the decimal exponents of adjacent}\par
15590     {\cf20 // table entries must be less than or equal to}\par
15591     {\cf20 //}\par
15592     {\cf20 //      floor( (gamma - alpha) * log_10(2) ) = 8.}\par
15593     {\cf20 //}\par
15594     {\cf20 // (A smaller distance gamma-alpha would require a larger table.)}\par
15595 \par
15596     {\cf20 // NB:}\par
15597     {\cf20 // Actually this function returns c, such that -60 <= e_c + e + 64 <= -34.}\par
15598 \par
15599     {\cf17 constexpr} {\cf18 int} kCachedPowersMinDecExp = -300;\par
15600     {\cf17 constexpr} {\cf18 int} kCachedPowersDecStep = 8;\par
15601 \par
15602     {\cf17 static} {\cf17 constexpr} std::array<cached_power, 79> kCachedPowers =\par
15603     \{\par
15604         \{\par
15605             \{ 0xAB70FE17C79AC6CA, -1060, -300 \},\par
15606             \{ 0xFF77B1FCBEBCDC4F, -1034, -292 \},\par
15607             \{ 0xBE5691EF416BD60C, -1007, -284 \},\par
15608             \{ 0x8DD01FAD907FFC3C,  -980, -276 \},\par
15609             \{ 0xD3515C2831559A83,  -954, -268 \},\par
15610             \{ 0x9D71AC8FADA6C9B5,  -927, -260 \},\par
15611             \{ 0xEA9C227723EE8BCB,  -901, -252 \},\par
15612             \{ 0xAECC49914078536D,  -874, -244 \},\par
15613             \{ 0x823C12795DB6CE57,  -847, -236 \},\par
15614             \{ 0xC21094364DFB5637,  -821, -228 \},\par
15615             \{ 0x9096EA6F3848984F,  -794, -220 \},\par
15616             \{ 0xD77485CB25823AC7,  -768, -212 \},\par
15617             \{ 0xA086CFCD97BF97F4,  -741, -204 \},\par
15618             \{ 0xEF340A98172AACE5,  -715, -196 \},\par
15619             \{ 0xB23867FB2A35B28E,  -688, -188 \},\par
15620             \{ 0x84C8D4DFD2C63F3B,  -661, -180 \},\par
15621             \{ 0xC5DD44271AD3CDBA,  -635, -172 \},\par
15622             \{ 0x936B9FCEBB25C996,  -608, -164 \},\par
15623             \{ 0xDBAC6C247D62A584,  -582, -156 \},\par
15624             \{ 0xA3AB66580D5FDAF6,  -555, -148 \},\par
15625             \{ 0xF3E2F893DEC3F126,  -529, -140 \},\par
15626             \{ 0xB5B5ADA8AAFF80B8,  -502, -132 \},\par
15627             \{ 0x87625F056C7C4A8B,  -475, -124 \},\par
15628             \{ 0xC9BCFF6034C13053,  -449, -116 \},\par
15629             \{ 0x964E858C91BA2655,  -422, -108 \},\par
15630             \{ 0xDFF9772470297EBD,  -396, -100 \},\par
15631             \{ 0xA6DFBD9FB8E5B88F,  -369,  -92 \},\par
15632             \{ 0xF8A95FCF88747D94,  -343,  -84 \},\par
15633             \{ 0xB94470938FA89BCF,  -316,  -76 \},\par
15634             \{ 0x8A08F0F8BF0F156B,  -289,  -68 \},\par
15635             \{ 0xCDB02555653131B6,  -263,  -60 \},\par
15636             \{ 0x993FE2C6D07B7FAC,  -236,  -52 \},\par
15637             \{ 0xE45C10C42A2B3B06,  -210,  -44 \},\par
15638             \{ 0xAA242499697392D3,  -183,  -36 \},\par
15639             \{ 0xFD87B5F28300CA0E,  -157,  -28 \},\par
15640             \{ 0xBCE5086492111AEB,  -130,  -20 \},\par
15641             \{ 0x8CBCCC096F5088CC,  -103,  -12 \},\par
15642             \{ 0xD1B71758E219652C,   -77,   -4 \},\par
15643             \{ 0x9C40000000000000,   -50,    4 \},\par
15644             \{ 0xE8D4A51000000000,   -24,   12 \},\par
15645             \{ 0xAD78EBC5AC620000,     3,   20 \},\par
15646             \{ 0x813F3978F8940984,    30,   28 \},\par
15647             \{ 0xC097CE7BC90715B3,    56,   36 \},\par
15648             \{ 0x8F7E32CE7BEA5C70,    83,   44 \},\par
15649             \{ 0xD5D238A4ABE98068,   109,   52 \},\par
15650             \{ 0x9F4F2726179A2245,   136,   60 \},\par
15651             \{ 0xED63A231D4C4FB27,   162,   68 \},\par
15652             \{ 0xB0DE65388CC8ADA8,   189,   76 \},\par
15653             \{ 0x83C7088E1AAB65DB,   216,   84 \},\par
15654             \{ 0xC45D1DF942711D9A,   242,   92 \},\par
15655             \{ 0x924D692CA61BE758,   269,  100 \},\par
15656             \{ 0xDA01EE641A708DEA,   295,  108 \},\par
15657             \{ 0xA26DA3999AEF774A,   322,  116 \},\par
15658             \{ 0xF209787BB47D6B85,   348,  124 \},\par
15659             \{ 0xB454E4A179DD1877,   375,  132 \},\par
15660             \{ 0x865B86925B9BC5C2,   402,  140 \},\par
15661             \{ 0xC83553C5C8965D3D,   428,  148 \},\par
15662             \{ 0x952AB45CFA97A0B3,   455,  156 \},\par
15663             \{ 0xDE469FBD99A05FE3,   481,  164 \},\par
15664             \{ 0xA59BC234DB398C25,   508,  172 \},\par
15665             \{ 0xF6C69A72A3989F5C,   534,  180 \},\par
15666             \{ 0xB7DCBF5354E9BECE,   561,  188 \},\par
15667             \{ 0x88FCF317F22241E2,   588,  196 \},\par
15668             \{ 0xCC20CE9BD35C78A5,   614,  204 \},\par
15669             \{ 0x98165AF37B2153DF,   641,  212 \},\par
15670             \{ 0xE2A0B5DC971F303A,   667,  220 \},\par
15671             \{ 0xA8D9D1535CE3B396,   694,  228 \},\par
15672             \{ 0xFB9B7CD9A4A7443C,   720,  236 \},\par
15673             \{ 0xBB764C4CA7A44410,   747,  244 \},\par
15674             \{ 0x8BAB8EEFB6409C1A,   774,  252 \},\par
15675             \{ 0xD01FEF10A657842C,   800,  260 \},\par
15676             \{ 0x9B10A4E5E9913129,   827,  268 \},\par
15677             \{ 0xE7109BFBA19C0C9D,   853,  276 \},\par
15678             \{ 0xAC2820D9623BF429,   880,  284 \},\par
15679             \{ 0x80444B5E7AA7CF85,   907,  292 \},\par
15680             \{ 0xBF21E44003ACDD2D,   933,  300 \},\par
15681             \{ 0x8E679C2F5E44FF8F,   960,  308 \},\par
15682             \{ 0xD433179D9C8CB841,   986,  316 \},\par
15683             \{ 0x9E19DB92B4E31BA9,  1013,  324 \},\par
15684         \}\par
15685     \};\par
15686 \par
15687     {\cf20 // This computation gives exactly the same results for k as}\par
15688     {\cf20 //      k = ceil((kAlpha - e - 1) * 0.30102999566398114)}\par
15689     {\cf20 // for |e| <= 1500, but doesn't require floating-point operations.}\par
15690     {\cf20 // NB: log_10(2) ~= 78913 / 2^18}\par
15691     JSON_ASSERT(e >= -1500);\par
15692     JSON_ASSERT(e <=  1500);\par
15693     {\cf17 const} {\cf18 int} f = kAlpha - e - 1;\par
15694     {\cf17 const} {\cf18 int} k = (f * 78913) / (1 << 18) + {\cf17 static_cast<}{\cf18 int}{\cf17 >}(f > 0);\par
15695 \par
15696     {\cf17 const} {\cf18 int} index = (-kCachedPowersMinDecExp + k + (kCachedPowersDecStep - 1)) / kCachedPowersDecStep;\par
15697     JSON_ASSERT(index >= 0);\par
15698     JSON_ASSERT({\cf17 static_cast<}std::size_t{\cf17 >}(index) < kCachedPowers.size());\par
15699 \par
15700     {\cf17 const} cached_power cached = kCachedPowers[{\cf17 static_cast<}std::size_t{\cf17 >}(index)];\par
15701     JSON_ASSERT(kAlpha <= cached.e + e + 64);\par
15702     JSON_ASSERT(kGamma >= cached.e + e + 64);\par
15703 \par
15704     {\cf19 return} cached;\par
15705 \}\par
15706 \par
15711 {\cf17 inline} {\cf18 int} find_largest_pow10({\cf17 const} std::uint32_t n, std::uint32_t& pow10)\par
15712 \{\par
15713     {\cf20 // LCOV_EXCL_START}\par
15714     {\cf19 if} (n >= 1000000000)\par
15715     \{\par
15716         pow10 = 1000000000;\par
15717         {\cf19 return} 10;\par
15718     \}\par
15719     {\cf20 // LCOV_EXCL_STOP}\par
15720     {\cf19 if} (n >= 100000000)\par
15721     \{\par
15722         pow10 = 100000000;\par
15723         {\cf19 return}  9;\par
15724     \}\par
15725     {\cf19 if} (n >= 10000000)\par
15726     \{\par
15727         pow10 = 10000000;\par
15728         {\cf19 return}  8;\par
15729     \}\par
15730     {\cf19 if} (n >= 1000000)\par
15731     \{\par
15732         pow10 = 1000000;\par
15733         {\cf19 return}  7;\par
15734     \}\par
15735     {\cf19 if} (n >= 100000)\par
15736     \{\par
15737         pow10 = 100000;\par
15738         {\cf19 return}  6;\par
15739     \}\par
15740     {\cf19 if} (n >= 10000)\par
15741     \{\par
15742         pow10 = 10000;\par
15743         {\cf19 return}  5;\par
15744     \}\par
15745     {\cf19 if} (n >= 1000)\par
15746     \{\par
15747         pow10 = 1000;\par
15748         {\cf19 return}  4;\par
15749     \}\par
15750     {\cf19 if} (n >= 100)\par
15751     \{\par
15752         pow10 = 100;\par
15753         {\cf19 return}  3;\par
15754     \}\par
15755     {\cf19 if} (n >= 10)\par
15756     \{\par
15757         pow10 = 10;\par
15758         {\cf19 return}  2;\par
15759     \}\par
15760 \par
15761     pow10 = 1;\par
15762     {\cf19 return} 1;\par
15763 \}\par
15764 \par
15765 {\cf17 inline} {\cf18 void} grisu2_round({\cf18 char}* buf, {\cf18 int} len, std::uint64_t dist, std::uint64_t delta,\par
15766                          std::uint64_t rest, std::uint64_t ten_k)\par
15767 \{\par
15768     JSON_ASSERT(len >= 1);\par
15769     JSON_ASSERT(dist <= delta);\par
15770     JSON_ASSERT(rest <= delta);\par
15771     JSON_ASSERT(ten_k > 0);\par
15772 \par
15773     {\cf20 //               <--------------------------- delta ---->}\par
15774     {\cf20 //                                  <---- dist --------->}\par
15775     {\cf20 // --------------[------------------+-------------------]--------------}\par
15776     {\cf20 //               M-                 w                   M+}\par
15777     {\cf20 //}\par
15778     {\cf20 //                                  ten_k}\par
15779     {\cf20 //                                <------>}\par
15780     {\cf20 //                                       <---- rest ---->}\par
15781     {\cf20 // --------------[------------------+----+--------------]--------------}\par
15782     {\cf20 //                                  w    V}\par
15783     {\cf20 //                                       = buf * 10^k}\par
15784     {\cf20 //}\par
15785     {\cf20 // ten_k represents a unit-in-the-last-place in the decimal representation}\par
15786     {\cf20 // stored in buf.}\par
15787     {\cf20 // Decrement buf by ten_k while this takes buf closer to w.}\par
15788 \par
15789     {\cf20 // The tests are written in this order to avoid overflow in unsigned}\par
15790     {\cf20 // integer arithmetic.}\par
15791 \par
15792     {\cf19 while} (rest < dist\par
15793             && delta - rest >= ten_k\par
15794             && (rest + ten_k < dist || dist - rest > rest + ten_k - dist))\par
15795     \{\par
15796         JSON_ASSERT(buf[len - 1] != {\cf23 '0'});\par
15797         buf[len - 1]--;\par
15798         rest += ten_k;\par
15799     \}\par
15800 \}\par
15801 \par
15806 {\cf17 inline} {\cf18 void} grisu2_digit_gen({\cf18 char}* buffer, {\cf18 int}& length, {\cf18 int}& decimal_exponent,\par
15807                              diyfp M_minus, diyfp w, diyfp M_plus)\par
15808 \{\par
15809     {\cf17 static_assert}(kAlpha >= -60, {\cf22 "internal error"});\par
15810     {\cf17 static_assert}(kGamma <= -32, {\cf22 "internal error"});\par
15811 \par
15812     {\cf20 // Generates the digits (and the exponent) of a decimal floating-point}\par
15813     {\cf20 // number V = buffer * 10^decimal_exponent in the range [M-, M+]. The diyfp's}\par
15814     {\cf20 // w, M- and M+ share the same exponent e, which satisfies alpha <= e <= gamma.}\par
15815     {\cf20 //}\par
15816     {\cf20 //               <--------------------------- delta ---->}\par
15817     {\cf20 //                                  <---- dist --------->}\par
15818     {\cf20 // --------------[------------------+-------------------]--------------}\par
15819     {\cf20 //               M-                 w                   M+}\par
15820     {\cf20 //}\par
15821     {\cf20 // Grisu2 generates the digits of M+ from left to right and stops as soon as}\par
15822     {\cf20 // V is in [M-,M+].}\par
15823 \par
15824     JSON_ASSERT(M_plus.e >= kAlpha);\par
15825     JSON_ASSERT(M_plus.e <= kGamma);\par
15826 \par
15827     std::uint64_t delta = diyfp::sub(M_plus, M_minus).f; {\cf20 // (significand of (M+ - M-), implicit exponent is e)}\par
15828     std::uint64_t dist  = diyfp::sub(M_plus, w      ).f; {\cf20 // (significand of (M+ - w ), implicit exponent is e)}\par
15829 \par
15830     {\cf20 // Split M+ = f * 2^e into two parts p1 and p2 (note: e < 0):}\par
15831     {\cf20 //}\par
15832     {\cf20 //      M+ = f * 2^e}\par
15833     {\cf20 //         = ((f div 2^-e) * 2^-e + (f mod 2^-e)) * 2^e}\par
15834     {\cf20 //         = ((p1        ) * 2^-e + (p2        )) * 2^e}\par
15835     {\cf20 //         = p1 + p2 * 2^e}\par
15836 \par
15837     {\cf17 const} diyfp one(std::uint64_t\{1\} << -M_plus.e, M_plus.e);\par
15838 \par
15839     {\cf17 auto} p1 = {\cf17 static_cast<}std::uint32_t{\cf17 >}(M_plus.f >> -one.e); {\cf20 // p1 = f div 2^-e (Since -e >= 32, p1 fits into a 32-bit int.)}\par
15840     std::uint64_t p2 = M_plus.f & (one.f - 1);                    {\cf20 // p2 = f mod 2^-e}\par
15841 \par
15842     {\cf20 // 1)}\par
15843     {\cf20 //}\par
15844     {\cf20 // Generate the digits of the integral part p1 = d[n-1]...d[1]d[0]}\par
15845 \par
15846     JSON_ASSERT(p1 > 0);\par
15847 \par
15848     std::uint32_t pow10\{\};\par
15849     {\cf17 const} {\cf18 int} k = find_largest_pow10(p1, pow10);\par
15850 \par
15851     {\cf20 //      10^(k-1) <= p1 < 10^k, pow10 = 10^(k-1)}\par
15852     {\cf20 //}\par
15853     {\cf20 //      p1 = (p1 div 10^(k-1)) * 10^(k-1) + (p1 mod 10^(k-1))}\par
15854     {\cf20 //         = (d[k-1]         ) * 10^(k-1) + (p1 mod 10^(k-1))}\par
15855     {\cf20 //}\par
15856     {\cf20 //      M+ = p1                                             + p2 * 2^e}\par
15857     {\cf20 //         = d[k-1] * 10^(k-1) + (p1 mod 10^(k-1))          + p2 * 2^e}\par
15858     {\cf20 //         = d[k-1] * 10^(k-1) + ((p1 mod 10^(k-1)) * 2^-e + p2) * 2^e}\par
15859     {\cf20 //         = d[k-1] * 10^(k-1) + (                         rest) * 2^e}\par
15860     {\cf20 //}\par
15861     {\cf20 // Now generate the digits d[n] of p1 from left to right (n = k-1,...,0)}\par
15862     {\cf20 //}\par
15863     {\cf20 //      p1 = d[k-1]...d[n] * 10^n + d[n-1]...d[0]}\par
15864     {\cf20 //}\par
15865     {\cf20 // but stop as soon as}\par
15866     {\cf20 //}\par
15867     {\cf20 //      rest * 2^e = (d[n-1]...d[0] * 2^-e + p2) * 2^e <= delta * 2^e}\par
15868 \par
15869     {\cf18 int} n = k;\par
15870     {\cf19 while} (n > 0)\par
15871     \{\par
15872         {\cf20 // Invariants:}\par
15873         {\cf20 //      M+ = buffer * 10^n + (p1 + p2 * 2^e)    (buffer = 0 for n = k)}\par
15874         {\cf20 //      pow10 = 10^(n-1) <= p1 < 10^n}\par
15875         {\cf20 //}\par
15876         {\cf17 const} std::uint32_t d = p1 / pow10;  {\cf20 // d = p1 div 10^(n-1)}\par
15877         {\cf17 const} std::uint32_t r = p1 % pow10;  {\cf20 // r = p1 mod 10^(n-1)}\par
15878         {\cf20 //}\par
15879         {\cf20 //      M+ = buffer * 10^n + (d * 10^(n-1) + r) + p2 * 2^e}\par
15880         {\cf20 //         = (buffer * 10 + d) * 10^(n-1) + (r + p2 * 2^e)}\par
15881         {\cf20 //}\par
15882         JSON_ASSERT(d <= 9);\par
15883         buffer[length++] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}({\cf23 '0'} + d); {\cf20 // buffer := buffer * 10 + d}\par
15884         {\cf20 //}\par
15885         {\cf20 //      M+ = buffer * 10^(n-1) + (r + p2 * 2^e)}\par
15886         {\cf20 //}\par
15887         p1 = r;\par
15888         n--;\par
15889         {\cf20 //}\par
15890         {\cf20 //      M+ = buffer * 10^n + (p1 + p2 * 2^e)}\par
15891         {\cf20 //      pow10 = 10^n}\par
15892         {\cf20 //}\par
15893 \par
15894         {\cf20 // Now check if enough digits have been generated.}\par
15895         {\cf20 // Compute}\par
15896         {\cf20 //}\par
15897         {\cf20 //      p1 + p2 * 2^e = (p1 * 2^-e + p2) * 2^e = rest * 2^e}\par
15898         {\cf20 //}\par
15899         {\cf20 // Note:}\par
15900         {\cf20 // Since rest and delta share the same exponent e, it suffices to}\par
15901         {\cf20 // compare the significands.}\par
15902         {\cf17 const} std::uint64_t rest = (std::uint64_t\{p1\} << -one.e) + p2;\par
15903         {\cf19 if} (rest <= delta)\par
15904         \{\par
15905             {\cf20 // V = buffer * 10^n, with M- <= V <= M+.}\par
15906 \par
15907             decimal_exponent += n;\par
15908 \par
15909             {\cf20 // We may now just stop. But instead look if the buffer could be}\par
15910             {\cf20 // decremented to bring V closer to w.}\par
15911             {\cf20 //}\par
15912             {\cf20 // pow10 = 10^n is now 1 ulp in the decimal representation V.}\par
15913             {\cf20 // The rounding procedure works with diyfp's with an implicit}\par
15914             {\cf20 // exponent of e.}\par
15915             {\cf20 //}\par
15916             {\cf20 //      10^n = (10^n * 2^-e) * 2^e = ulp * 2^e}\par
15917             {\cf20 //}\par
15918             {\cf17 const} std::uint64_t ten_n = std::uint64_t\{pow10\} << -one.e;\par
15919             grisu2_round(buffer, length, dist, delta, rest, ten_n);\par
15920 \par
15921             {\cf19 return};\par
15922         \}\par
15923 \par
15924         pow10 /= 10;\par
15925         {\cf20 //}\par
15926         {\cf20 //      pow10 = 10^(n-1) <= p1 < 10^n}\par
15927         {\cf20 // Invariants restored.}\par
15928     \}\par
15929 \par
15930     {\cf20 // 2)}\par
15931     {\cf20 //}\par
15932     {\cf20 // The digits of the integral part have been generated:}\par
15933     {\cf20 //}\par
15934     {\cf20 //      M+ = d[k-1]...d[1]d[0] + p2 * 2^e}\par
15935     {\cf20 //         = buffer            + p2 * 2^e}\par
15936     {\cf20 //}\par
15937     {\cf20 // Now generate the digits of the fractional part p2 * 2^e.}\par
15938     {\cf20 //}\par
15939     {\cf20 // Note:}\par
15940     {\cf20 // No decimal point is generated: the exponent is adjusted instead.}\par
15941     {\cf20 //}\par
15942     {\cf20 // p2 actually represents the fraction}\par
15943     {\cf20 //}\par
15944     {\cf20 //      p2 * 2^e}\par
15945     {\cf20 //          = p2 / 2^-e}\par
15946     {\cf20 //          = d[-1] / 10^1 + d[-2] / 10^2 + ...}\par
15947     {\cf20 //}\par
15948     {\cf20 // Now generate the digits d[-m] of p1 from left to right (m = 1,2,...)}\par
15949     {\cf20 //}\par
15950     {\cf20 //      p2 * 2^e = d[-1]d[-2]...d[-m] * 10^-m}\par
15951     {\cf20 //                      + 10^-m * (d[-m-1] / 10^1 + d[-m-2] / 10^2 + ...)}\par
15952     {\cf20 //}\par
15953     {\cf20 // using}\par
15954     {\cf20 //}\par
15955     {\cf20 //      10^m * p2 = ((10^m * p2) div 2^-e) * 2^-e + ((10^m * p2) mod 2^-e)}\par
15956     {\cf20 //                = (                   d) * 2^-e + (                   r)}\par
15957     {\cf20 //}\par
15958     {\cf20 // or}\par
15959     {\cf20 //      10^m * p2 * 2^e = d + r * 2^e}\par
15960     {\cf20 //}\par
15961     {\cf20 // i.e.}\par
15962     {\cf20 //}\par
15963     {\cf20 //      M+ = buffer + p2 * 2^e}\par
15964     {\cf20 //         = buffer + 10^-m * (d + r * 2^e)}\par
15965     {\cf20 //         = (buffer * 10^m + d) * 10^-m + 10^-m * r * 2^e}\par
15966     {\cf20 //}\par
15967     {\cf20 // and stop as soon as 10^-m * r * 2^e <= delta * 2^e}\par
15968 \par
15969     JSON_ASSERT(p2 > delta);\par
15970 \par
15971     {\cf18 int} m = 0;\par
15972     {\cf19 for} (;;)\par
15973     \{\par
15974         {\cf20 // Invariant:}\par
15975         {\cf20 //      M+ = buffer * 10^-m + 10^-m * (d[-m-1] / 10 + d[-m-2] / 10^2 + ...) * 2^e}\par
15976         {\cf20 //         = buffer * 10^-m + 10^-m * (p2                                 ) * 2^e}\par
15977         {\cf20 //         = buffer * 10^-m + 10^-m * (1/10 * (10 * p2)                   ) * 2^e}\par
15978         {\cf20 //         = buffer * 10^-m + 10^-m * (1/10 * ((10*p2 div 2^-e) * 2^-e + (10*p2 mod 2^-e)) * 2^e}\par
15979         {\cf20 //}\par
15980         JSON_ASSERT(p2 <= (std::numeric_limits<std::uint64_t>::max)() / 10);\par
15981         p2 *= 10;\par
15982         {\cf17 const} std::uint64_t d = p2 >> -one.e;     {\cf20 // d = (10 * p2) div 2^-e}\par
15983         {\cf17 const} std::uint64_t r = p2 & (one.f - 1); {\cf20 // r = (10 * p2) mod 2^-e}\par
15984         {\cf20 //}\par
15985         {\cf20 //      M+ = buffer * 10^-m + 10^-m * (1/10 * (d * 2^-e + r) * 2^e}\par
15986         {\cf20 //         = buffer * 10^-m + 10^-m * (1/10 * (d + r * 2^e))}\par
15987         {\cf20 //         = (buffer * 10 + d) * 10^(-m-1) + 10^(-m-1) * r * 2^e}\par
15988         {\cf20 //}\par
15989         JSON_ASSERT(d <= 9);\par
15990         buffer[length++] = {\cf17 static_cast<}{\cf18 char}{\cf17 >}({\cf23 '0'} + d); {\cf20 // buffer := buffer * 10 + d}\par
15991         {\cf20 //}\par
15992         {\cf20 //      M+ = buffer * 10^(-m-1) + 10^(-m-1) * r * 2^e}\par
15993         {\cf20 //}\par
15994         p2 = r;\par
15995         m++;\par
15996         {\cf20 //}\par
15997         {\cf20 //      M+ = buffer * 10^-m + 10^-m * p2 * 2^e}\par
15998         {\cf20 // Invariant restored.}\par
15999 \par
16000         {\cf20 // Check if enough digits have been generated.}\par
16001         {\cf20 //}\par
16002         {\cf20 //      10^-m * p2 * 2^e <= delta * 2^e}\par
16003         {\cf20 //              p2 * 2^e <= 10^m * delta * 2^e}\par
16004         {\cf20 //                    p2 <= 10^m * delta}\par
16005         delta *= 10;\par
16006         dist  *= 10;\par
16007         {\cf19 if} (p2 <= delta)\par
16008         \{\par
16009             {\cf19 break};\par
16010         \}\par
16011     \}\par
16012 \par
16013     {\cf20 // V = buffer * 10^-m, with M- <= V <= M+.}\par
16014 \par
16015     decimal_exponent -= m;\par
16016 \par
16017     {\cf20 // 1 ulp in the decimal representation is now 10^-m.}\par
16018     {\cf20 // Since delta and dist are now scaled by 10^m, we need to do the}\par
16019     {\cf20 // same with ulp in order to keep the units in sync.}\par
16020     {\cf20 //}\par
16021     {\cf20 //      10^m * 10^-m = 1 = 2^-e * 2^e = ten_m * 2^e}\par
16022     {\cf20 //}\par
16023     {\cf17 const} std::uint64_t ten_m = one.f;\par
16024     grisu2_round(buffer, length, dist, delta, p2, ten_m);\par
16025 \par
16026     {\cf20 // By construction this algorithm generates the shortest possible decimal}\par
16027     {\cf20 // number (Loitsch, Theorem 6.2) which rounds back to w.}\par
16028     {\cf20 // For an input number of precision p, at least}\par
16029     {\cf20 //}\par
16030     {\cf20 //      N = 1 + ceil(p * log_10(2))}\par
16031     {\cf20 //}\par
16032     {\cf20 // decimal digits are sufficient to identify all binary floating-point}\par
16033     {\cf20 // numbers (Matula, "In-and-Out conversions").}\par
16034     {\cf20 // This implies that the algorithm does not produce more than N decimal}\par
16035     {\cf20 // digits.}\par
16036     {\cf20 //}\par
16037     {\cf20 //      N = 17 for p = 53 (IEEE double precision)}\par
16038     {\cf20 //      N = 9  for p = 24 (IEEE single precision)}\par
16039 \}\par
16040 \par
16046 JSON_HEDLEY_NON_NULL(1)\par
16047 inline {\cf18 void} grisu2({\cf18 char}* buf, {\cf18 int}& len, {\cf18 int}& decimal_exponent,\par
16048                    diyfp m_minus, diyfp v, diyfp m_plus)\par
16049 \{\par
16050     JSON_ASSERT(m_plus.e == m_minus.e);\par
16051     JSON_ASSERT(m_plus.e == v.e);\par
16052 \par
16053     {\cf20 //  --------(-----------------------+-----------------------)--------    (A)}\par
16054     {\cf20 //          m-                      v                       m+}\par
16055     {\cf20 //}\par
16056     {\cf20 //  --------------------(-----------+-----------------------)--------    (B)}\par
16057     {\cf20 //                      m-          v                       m+}\par
16058     {\cf20 //}\par
16059     {\cf20 // First scale v (and m- and m+) such that the exponent is in the range}\par
16060     {\cf20 // [alpha, gamma].}\par
16061 \par
16062     {\cf17 const} cached_power cached = get_cached_power_for_binary_exponent(m_plus.e);\par
16063 \par
16064     {\cf17 const} diyfp c_minus_k(cached.f, cached.e); {\cf20 // = c ~= 10^-k}\par
16065 \par
16066     {\cf20 // The exponent of the products is = v.e + c_minus_k.e + q and is in the range [alpha,gamma]}\par
16067     {\cf17 const} diyfp w       = diyfp::mul(v,       c_minus_k);\par
16068     {\cf17 const} diyfp w_minus = diyfp::mul(m_minus, c_minus_k);\par
16069     {\cf17 const} diyfp w_plus  = diyfp::mul(m_plus,  c_minus_k);\par
16070 \par
16071     {\cf20 //  ----(---+---)---------------(---+---)---------------(---+---)----}\par
16072     {\cf20 //          w-                      w                       w+}\par
16073     {\cf20 //          = c*m-                  = c*v                   = c*m+}\par
16074     {\cf20 //}\par
16075     {\cf20 // diyfp::mul rounds its result and c_minus_k is approximated too. w, w- and}\par
16076     {\cf20 // w+ are now off by a small amount.}\par
16077     {\cf20 // In fact:}\par
16078     {\cf20 //}\par
16079     {\cf20 //      w - v * 10^k < 1 ulp}\par
16080     {\cf20 //}\par
16081     {\cf20 // To account for this inaccuracy, add resp. subtract 1 ulp.}\par
16082     {\cf20 //}\par
16083     {\cf20 //  --------+---[---------------(---+---)---------------]---+--------}\par
16084     {\cf20 //          w-  M-                  w                   M+  w+}\par
16085     {\cf20 //}\par
16086     {\cf20 // Now any number in [M-, M+] (bounds included) will round to w when input,}\par
16087     {\cf20 // regardless of how the input rounding algorithm breaks ties.}\par
16088     {\cf20 //}\par
16089     {\cf20 // And digit_gen generates the shortest possible such number in [M-, M+].}\par
16090     {\cf20 // Note that this does not mean that Grisu2 always generates the shortest}\par
16091     {\cf20 // possible number in the interval (m-, m+).}\par
16092     {\cf17 const} diyfp M_minus(w_minus.f + 1, w_minus.e);\par
16093     {\cf17 const} diyfp M_plus (w_plus.f  - 1, w_plus.e );\par
16094 \par
16095     decimal_exponent = -cached.k; {\cf20 // = -(-k) = k}\par
16096 \par
16097     grisu2_digit_gen(buf, len, decimal_exponent, M_minus, w, M_plus);\par
16098 \}\par
16099 \par
16105 {\cf17 template}<{\cf17 typename} FloatType>\par
16106 JSON_HEDLEY_NON_NULL(1)\par
16107 void grisu2({\cf18 char}* buf, {\cf18 int}& len, {\cf18 int}& decimal_exponent, FloatType value)\par
16108 \{\par
16109     {\cf17 static_assert}(diyfp::kPrecision >= std::numeric_limits<FloatType>::digits + 3,\par
16110                   {\cf22 "internal error: not enough precision"});\par
16111 \par
16112     JSON_ASSERT(std::isfinite(value));\par
16113     JSON_ASSERT(value > 0);\par
16114 \par
16115     {\cf20 // If the neighbors (and boundaries) of 'value' are always computed for double-precision}\par
16116     {\cf20 // numbers, all float's can be recovered using strtod (and strtof). However, the resulting}\par
16117     {\cf20 // decimal representations are not exactly "short".}\par
16118     {\cf20 //}\par
16119     {\cf20 // The documentation for 'std::to_chars' (https://en.cppreference.com/w/cpp/utility/to_chars)}\par
16120     {\cf20 // says "value is converted to a string as if by std::sprintf in the default ("C") locale"}\par
16121     {\cf20 // and since sprintf promotes float's to double's, I think this is exactly what 'std::to_chars'}\par
16122     {\cf20 // does.}\par
16123     {\cf20 // On the other hand, the documentation for 'std::to_chars' requires that "parsing the}\par
16124     {\cf20 // representation using the corresponding std::from_chars function recovers value exactly". That}\par
16125     {\cf20 // indicates that single precision floating-point numbers should be recovered using}\par
16126     {\cf20 // 'std::strtof'.}\par
16127     {\cf20 //}\par
16128     {\cf20 // NB: If the neighbors are computed for single-precision numbers, there is a single float}\par
16129     {\cf20 //     (7.0385307e-26f) which can't be recovered using strtod. The resulting double precision}\par
16130     {\cf20 //     value is off by 1 ulp.}\par
16131 {\cf21 #if 0}\par
16132     {\cf17 const} boundaries w = compute_boundaries({\cf17 static_cast<}{\cf18 double}{\cf17 >}(value));\par
16133 {\cf21 #else}\par
16134     {\cf17 const} boundaries w = compute_boundaries(value);\par
16135 {\cf21 #endif}\par
16136 \par
16137     grisu2(buf, len, decimal_exponent, w.minus, w.w, w.plus);\par
16138 \}\par
16139 \par
16145 JSON_HEDLEY_NON_NULL(1)\par
16146 JSON_HEDLEY_RETURNS_NON_NULL\par
16147 inline {\cf18 char}* append_exponent({\cf18 char}* buf, {\cf18 int} e)\par
16148 \{\par
16149     JSON_ASSERT(e > -1000);\par
16150     JSON_ASSERT(e <  1000);\par
16151 \par
16152     {\cf19 if} (e < 0)\par
16153     \{\par
16154         e = -e;\par
16155         *buf++ = {\cf23 '-'};\par
16156     \}\par
16157     {\cf19 else}\par
16158     \{\par
16159         *buf++ = {\cf23 '+'};\par
16160     \}\par
16161 \par
16162     {\cf17 auto} k = {\cf17 static_cast<}std::uint32_t{\cf17 >}(e);\par
16163     {\cf19 if} (k < 10)\par
16164     \{\par
16165         {\cf20 // Always print at least two digits in the exponent.}\par
16166         {\cf20 // This is for compatibility with printf("%g").}\par
16167         *buf++ = {\cf23 '0'};\par
16168         *buf++ = {\cf17 static_cast<}{\cf18 char}{\cf17 >}({\cf23 '0'} + k);\par
16169     \}\par
16170     {\cf19 else} {\cf19 if} (k < 100)\par
16171     \{\par
16172         *buf++ = {\cf17 static_cast<}{\cf18 char}{\cf17 >}({\cf23 '0'} + k / 10);\par
16173         k %= 10;\par
16174         *buf++ = {\cf17 static_cast<}{\cf18 char}{\cf17 >}({\cf23 '0'} + k);\par
16175     \}\par
16176     {\cf19 else}\par
16177     \{\par
16178         *buf++ = {\cf17 static_cast<}{\cf18 char}{\cf17 >}({\cf23 '0'} + k / 100);\par
16179         k %= 100;\par
16180         *buf++ = {\cf17 static_cast<}{\cf18 char}{\cf17 >}({\cf23 '0'} + k / 10);\par
16181         k %= 10;\par
16182         *buf++ = {\cf17 static_cast<}{\cf18 char}{\cf17 >}({\cf23 '0'} + k);\par
16183     \}\par
16184 \par
16185     {\cf19 return} buf;\par
16186 \}\par
16187 \par
16197 JSON_HEDLEY_NON_NULL(1)\par
16198 JSON_HEDLEY_RETURNS_NON_NULL\par
16199 inline {\cf18 char}* format_buffer({\cf18 char}* buf, {\cf18 int} len, {\cf18 int} decimal_exponent,\par
16200                            {\cf18 int} min_exp, {\cf18 int} max_exp)\par
16201 \{\par
16202     JSON_ASSERT(min_exp < 0);\par
16203     JSON_ASSERT(max_exp > 0);\par
16204 \par
16205     {\cf17 const} {\cf18 int} k = len;\par
16206     {\cf17 const} {\cf18 int} n = len + decimal_exponent;\par
16207 \par
16208     {\cf20 // v = buf * 10^(n-k)}\par
16209     {\cf20 // k is the length of the buffer (number of decimal digits)}\par
16210     {\cf20 // n is the position of the decimal point relative to the start of the buffer.}\par
16211 \par
16212     {\cf19 if} (k <= n && n <= max_exp)\par
16213     \{\par
16214         {\cf20 // digits[000]}\par
16215         {\cf20 // len <= max_exp + 2}\par
16216 \par
16217         std::memset(buf + k, {\cf23 '0'}, {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(n) - {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k));\par
16218         {\cf20 // Make it look like a floating-point number (#362, #378)}\par
16219         buf[n + 0] = {\cf23 '.'};\par
16220         buf[n + 1] = {\cf23 '0'};\par
16221         {\cf19 return} buf + ({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(n) + 2);\par
16222     \}\par
16223 \par
16224     {\cf19 if} (0 < n && n <= max_exp)\par
16225     \{\par
16226         {\cf20 // dig.its}\par
16227         {\cf20 // len <= max_digits10 + 1}\par
16228 \par
16229         JSON_ASSERT(k > n);\par
16230 \par
16231         std::memmove(buf + ({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(n) + 1), buf + n, {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k) - {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(n));\par
16232         buf[n] = {\cf23 '.'};\par
16233         {\cf19 return} buf + ({\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k) + 1U);\par
16234     \}\par
16235 \par
16236     {\cf19 if} (min_exp < n && n <= 0)\par
16237     \{\par
16238         {\cf20 // 0.[000]digits}\par
16239         {\cf20 // len <= 2 + (-min_exp - 1) + max_digits10}\par
16240 \par
16241         std::memmove(buf + (2 + {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(-n)), buf, {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k));\par
16242         buf[0] = {\cf23 '0'};\par
16243         buf[1] = {\cf23 '.'};\par
16244         std::memset(buf + 2, {\cf23 '0'}, {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(-n));\par
16245         {\cf19 return} buf + (2U + {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(-n) + {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k));\par
16246     \}\par
16247 \par
16248     {\cf19 if} (k == 1)\par
16249     \{\par
16250         {\cf20 // dE+123}\par
16251         {\cf20 // len <= 1 + 5}\par
16252 \par
16253         buf += 1;\par
16254     \}\par
16255     {\cf19 else}\par
16256     \{\par
16257         {\cf20 // d.igitsE+123}\par
16258         {\cf20 // len <= max_digits10 + 1 + 5}\par
16259 \par
16260         std::memmove(buf + 2, buf + 1, {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k) - 1);\par
16261         buf[1] = {\cf23 '.'};\par
16262         buf += 1 + {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(k);\par
16263     \}\par
16264 \par
16265     *buf++ = {\cf23 'e'};\par
16266     {\cf19 return} append_exponent(buf, n - 1);\par
16267 \}\par
16268 \par
16269 \} {\cf20 // namespace dtoa_impl}\par
16270 \par
16281 {\cf17 template}<{\cf17 typename} FloatType>\par
16282 JSON_HEDLEY_NON_NULL(1, 2)\par
16283 JSON_HEDLEY_RETURNS_NON_NULL\par
16284 {\cf18 char}* to_chars({\cf18 char}* first, const {\cf18 char}* last, FloatType value)\par
16285 \{\par
16286     {\cf17 static_cast<}{\cf18 void}{\cf17 >}(last); {\cf20 // maybe unused - fix warning}\par
16287     JSON_ASSERT(std::isfinite(value));\par
16288 \par
16289     {\cf20 // Use signbit(value) instead of (value < 0) since signbit works for -0.}\par
16290     {\cf19 if} (std::signbit(value))\par
16291     \{\par
16292         value = -value;\par
16293         *first++ = {\cf23 '-'};\par
16294     \}\par
16295 \par
16296 {\cf21 #ifdef __GNUC__}\par
16297 {\cf21 #pragma GCC diagnostic push}\par
16298 {\cf21 #pragma GCC diagnostic ignored "-Wfloat-equal"}\par
16299 {\cf21 #endif}\par
16300     {\cf19 if} (value == 0) {\cf20 // +-0}\par
16301     \{\par
16302         *first++ = {\cf23 '0'};\par
16303         {\cf20 // Make it look like a floating-point number (#362, #378)}\par
16304         *first++ = {\cf23 '.'};\par
16305         *first++ = {\cf23 '0'};\par
16306         {\cf19 return} first;\par
16307     \}\par
16308 {\cf21 #ifdef __GNUC__}\par
16309 {\cf21 #pragma GCC diagnostic pop}\par
16310 {\cf21 #endif}\par
16311 \par
16312     JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10);\par
16313 \par
16314     {\cf20 // Compute v = buffer * 10^decimal_exponent.}\par
16315     {\cf20 // The decimal digits are stored in the buffer, which needs to be interpreted}\par
16316     {\cf20 // as an unsigned decimal integer.}\par
16317     {\cf20 // len is the length of the buffer, i.e. the number of decimal digits.}\par
16318     {\cf18 int} len = 0;\par
16319     {\cf18 int} decimal_exponent = 0;\par
16320     dtoa_impl::grisu2(first, len, decimal_exponent, value);\par
16321 \par
16322     JSON_ASSERT(len <= std::numeric_limits<FloatType>::max_digits10);\par
16323 \par
16324     {\cf20 // Format the buffer like printf("%.*g", prec, value)}\par
16325     {\cf17 constexpr} {\cf18 int} kMinExp = -4;\par
16326     {\cf20 // Use digits10 here to increase compatibility with version 2.}\par
16327     {\cf17 constexpr} {\cf18 int} kMaxExp = std::numeric_limits<FloatType>::digits10;\par
16328 \par
16329     JSON_ASSERT(last - first >= kMaxExp + 2);\par
16330     JSON_ASSERT(last - first >= 2 + (-kMinExp - 1) + std::numeric_limits<FloatType>::max_digits10);\par
16331     JSON_ASSERT(last - first >= std::numeric_limits<FloatType>::max_digits10 + 6);\par
16332 \par
16333     {\cf19 return} dtoa_impl::format_buffer(first, len, decimal_exponent, kMinExp, kMaxExp);\par
16334 \}\par
16335 \par
16336 \} {\cf20 // namespace detail}\par
16337 \} {\cf20 // namespace nlohmann}\par
16338 \par
16339 {\cf20 // #include <nlohmann/detail/exceptions.hpp>}\par
16340 \par
16341 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
16342 \par
16343 {\cf20 // #include <nlohmann/detail/meta/cpp_future.hpp>}\par
16344 \par
16345 {\cf20 // #include <nlohmann/detail/output/binary_writer.hpp>}\par
16346 \par
16347 {\cf20 // #include <nlohmann/detail/output/output_adapters.hpp>}\par
16348 \par
16349 {\cf20 // #include <nlohmann/detail/value_t.hpp>}\par
16350 \par
16351 \par
16352 {\cf17 namespace }nlohmann\par
16353 \{\par
16354 {\cf17 namespace }detail\par
16355 \{\par
16357 {\cf20 // serialization //}\par
16359 {\cf20 }\par
16361 {\cf17 enum class} error_handler_t\par
16362 \{\par
16363     strict,  \par
16364     replace, \par
16365     ignore   \par
16366 \};\par
16367 \par
16368 {\cf17 template}<{\cf17 typename} BasicJsonType>\par
16369 {\cf17 class }serializer\par
16370 \{\par
16371     {\cf17 using} string_t = {\cf17 typename} BasicJsonType::string_t;\par
16372     {\cf17 using} number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
16373     {\cf17 using} number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
16374     {\cf17 using} number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
16375     {\cf17 using} binary_char_t = {\cf17 typename} BasicJsonType::binary_t::value_type;\par
16376     {\cf17 static} {\cf17 constexpr} std::uint8_t UTF8_ACCEPT = 0;\par
16377     {\cf17 static} {\cf17 constexpr} std::uint8_t UTF8_REJECT = 1;\par
16378 \par
16379   {\cf17 public}:\par
16385     serializer(output_adapter_t<char> s, {\cf17 const} {\cf18 char} ichar,\par
16386                error_handler_t error_handler_ = error_handler_t::strict)\par
16387         : o(std::move(s))\par
16388         , loc(std::localeconv())\par
16389         , thousands_sep(loc->thousands_sep == nullptr ? {\cf22 '\\0'} : std::char_traits<char>::to_char_type(* (loc->thousands_sep)))\par
16390         , decimal_point(loc->decimal_point == nullptr ? {\cf22 '\\0'} : std::char_traits<char>::to_char_type(* (loc->decimal_point)))\par
16391         , indent_char(ichar)\par
16392         , indent_string(512, indent_char)\par
16393         , error_handler(error_handler_)\par
16394     \{\}\par
16395 \par
16396     {\cf20 // delete because of pointer members}\par
16397     serializer({\cf17 const} serializer&) = {\cf17 delete};\par
16398     serializer& operator=({\cf17 const} serializer&) = {\cf17 delete};\par
16399     serializer(serializer&&) = {\cf17 delete};\par
16400     serializer& operator=(serializer&&) = {\cf17 delete};\par
16401     ~serializer() = {\cf19 default};\par
16402 \par
16425     {\cf18 void} dump({\cf17 const} BasicJsonType& val,\par
16426               {\cf17 const} {\cf18 bool} pretty_print,\par
16427               {\cf17 const} {\cf18 bool} ensure_ascii,\par
16428               {\cf17 const} {\cf18 unsigned} {\cf18 int} indent_step,\par
16429               {\cf17 const} {\cf18 unsigned} {\cf18 int} current_indent = 0)\par
16430     \{\par
16431         {\cf19 switch} (val.m_type)\par
16432         \{\par
16433             {\cf19 case} value_t::object:\par
16434             \{\par
16435                 {\cf19 if} (val.m_value.object->empty())\par
16436                 \{\par
16437                     o->write_characters({\cf22 "\{\}"}, 2);\par
16438                     {\cf19 return};\par
16439                 \}\par
16440 \par
16441                 {\cf19 if} (pretty_print)\par
16442                 \{\par
16443                     o->write_characters({\cf22 "\{\\n"}, 2);\par
16444 \par
16445                     {\cf20 // variable to hold indentation for recursive calls}\par
16446                     {\cf17 const} {\cf17 auto} new_indent = current_indent + indent_step;\par
16447                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))\par
16448                     \{\par
16449                         indent_string.resize(indent_string.size() * 2, {\cf23 ' '});\par
16450                     \}\par
16451 \par
16452                     {\cf20 // first n-1 elements}\par
16453                     {\cf17 auto} i = val.m_value.object->cbegin();\par
16454                     {\cf19 for} (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)\par
16455                     \{\par
16456                         o->write_characters(indent_string.c_str(), new_indent);\par
16457                         o->write_character({\cf23 '\\"'});\par
16458                         dump_escaped(i->first, ensure_ascii);\par
16459                         o->write_characters({\cf22 "\\": "}, 3);\par
16460                         dump(i->second, {\cf17 true}, ensure_ascii, indent_step, new_indent);\par
16461                         o->write_characters({\cf22 ",\\n"}, 2);\par
16462                     \}\par
16463 \par
16464                     {\cf20 // last element}\par
16465                     JSON_ASSERT(i != val.m_value.object->cend());\par
16466                     JSON_ASSERT(std::next(i) == val.m_value.object->cend());\par
16467                     o->write_characters(indent_string.c_str(), new_indent);\par
16468                     o->write_character({\cf23 '\\"'});\par
16469                     dump_escaped(i->first, ensure_ascii);\par
16470                     o->write_characters({\cf22 "\\": "}, 3);\par
16471                     dump(i->second, {\cf17 true}, ensure_ascii, indent_step, new_indent);\par
16472 \par
16473                     o->write_character({\cf23 '\\n'});\par
16474                     o->write_characters(indent_string.c_str(), current_indent);\par
16475                     o->write_character({\cf23 '\}'});\par
16476                 \}\par
16477                 {\cf19 else}\par
16478                 \{\par
16479                     o->write_character({\cf23 '\{'});\par
16480 \par
16481                     {\cf20 // first n-1 elements}\par
16482                     {\cf17 auto} i = val.m_value.object->cbegin();\par
16483                     {\cf19 for} (std::size_t cnt = 0; cnt < val.m_value.object->size() - 1; ++cnt, ++i)\par
16484                     \{\par
16485                         o->write_character({\cf23 '\\"'});\par
16486                         dump_escaped(i->first, ensure_ascii);\par
16487                         o->write_characters({\cf22 "\\":"}, 2);\par
16488                         dump(i->second, {\cf17 false}, ensure_ascii, indent_step, current_indent);\par
16489                         o->write_character({\cf23 ','});\par
16490                     \}\par
16491 \par
16492                     {\cf20 // last element}\par
16493                     JSON_ASSERT(i != val.m_value.object->cend());\par
16494                     JSON_ASSERT(std::next(i) == val.m_value.object->cend());\par
16495                     o->write_character({\cf23 '\\"'});\par
16496                     dump_escaped(i->first, ensure_ascii);\par
16497                     o->write_characters({\cf22 "\\":"}, 2);\par
16498                     dump(i->second, {\cf17 false}, ensure_ascii, indent_step, current_indent);\par
16499 \par
16500                     o->write_character({\cf23 '\}'});\par
16501                 \}\par
16502 \par
16503                 {\cf19 return};\par
16504             \}\par
16505 \par
16506             {\cf19 case} value_t::array:\par
16507             \{\par
16508                 {\cf19 if} (val.m_value.array->empty())\par
16509                 \{\par
16510                     o->write_characters({\cf22 "[]"}, 2);\par
16511                     {\cf19 return};\par
16512                 \}\par
16513 \par
16514                 {\cf19 if} (pretty_print)\par
16515                 \{\par
16516                     o->write_characters({\cf22 "[\\n"}, 2);\par
16517 \par
16518                     {\cf20 // variable to hold indentation for recursive calls}\par
16519                     {\cf17 const} {\cf17 auto} new_indent = current_indent + indent_step;\par
16520                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))\par
16521                     \{\par
16522                         indent_string.resize(indent_string.size() * 2, {\cf23 ' '});\par
16523                     \}\par
16524 \par
16525                     {\cf20 // first n-1 elements}\par
16526                     {\cf19 for} ({\cf17 auto} i = val.m_value.array->cbegin();\par
16527                             i != val.m_value.array->cend() - 1; ++i)\par
16528                     \{\par
16529                         o->write_characters(indent_string.c_str(), new_indent);\par
16530                         dump(*i, {\cf17 true}, ensure_ascii, indent_step, new_indent);\par
16531                         o->write_characters({\cf22 ",\\n"}, 2);\par
16532                     \}\par
16533 \par
16534                     {\cf20 // last element}\par
16535                     JSON_ASSERT(!val.m_value.array->empty());\par
16536                     o->write_characters(indent_string.c_str(), new_indent);\par
16537                     dump(val.m_value.array->back(), {\cf17 true}, ensure_ascii, indent_step, new_indent);\par
16538 \par
16539                     o->write_character({\cf23 '\\n'});\par
16540                     o->write_characters(indent_string.c_str(), current_indent);\par
16541                     o->write_character({\cf23 ']'});\par
16542                 \}\par
16543                 {\cf19 else}\par
16544                 \{\par
16545                     o->write_character({\cf23 '['});\par
16546 \par
16547                     {\cf20 // first n-1 elements}\par
16548                     {\cf19 for} ({\cf17 auto} i = val.m_value.array->cbegin();\par
16549                             i != val.m_value.array->cend() - 1; ++i)\par
16550                     \{\par
16551                         dump(*i, {\cf17 false}, ensure_ascii, indent_step, current_indent);\par
16552                         o->write_character({\cf23 ','});\par
16553                     \}\par
16554 \par
16555                     {\cf20 // last element}\par
16556                     JSON_ASSERT(!val.m_value.array->empty());\par
16557                     dump(val.m_value.array->back(), {\cf17 false}, ensure_ascii, indent_step, current_indent);\par
16558 \par
16559                     o->write_character({\cf23 ']'});\par
16560                 \}\par
16561 \par
16562                 {\cf19 return};\par
16563             \}\par
16564 \par
16565             {\cf19 case} value_t::string:\par
16566             \{\par
16567                 o->write_character({\cf23 '\\"'});\par
16568                 dump_escaped(*val.m_value.string, ensure_ascii);\par
16569                 o->write_character({\cf23 '\\"'});\par
16570                 {\cf19 return};\par
16571             \}\par
16572 \par
16573             {\cf19 case} value_t::binary:\par
16574             \{\par
16575                 {\cf19 if} (pretty_print)\par
16576                 \{\par
16577                     o->write_characters({\cf22 "\{\\n"}, 2);\par
16578 \par
16579                     {\cf20 // variable to hold indentation for recursive calls}\par
16580                     {\cf17 const} {\cf17 auto} new_indent = current_indent + indent_step;\par
16581                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(indent_string.size() < new_indent))\par
16582                     \{\par
16583                         indent_string.resize(indent_string.size() * 2, {\cf23 ' '});\par
16584                     \}\par
16585 \par
16586                     o->write_characters(indent_string.c_str(), new_indent);\par
16587 \par
16588                     o->write_characters({\cf22 "\\"bytes\\": ["}, 10);\par
16589 \par
16590                     {\cf19 if} (!val.m_value.binary->empty())\par
16591                     \{\par
16592                         {\cf19 for} ({\cf17 auto} i = val.m_value.binary->cbegin();\par
16593                                 i != val.m_value.binary->cend() - 1; ++i)\par
16594                         \{\par
16595                             dump_integer(*i);\par
16596                             o->write_characters({\cf22 ", "}, 2);\par
16597                         \}\par
16598                         dump_integer(val.m_value.binary->back());\par
16599                     \}\par
16600 \par
16601                     o->write_characters({\cf22 "],\\n"}, 3);\par
16602                     o->write_characters(indent_string.c_str(), new_indent);\par
16603 \par
16604                     o->write_characters({\cf22 "\\"subtype\\": "}, 11);\par
16605                     {\cf19 if} (val.m_value.binary->has_subtype())\par
16606                     \{\par
16607                         dump_integer(val.m_value.binary->subtype());\par
16608                     \}\par
16609                     {\cf19 else}\par
16610                     \{\par
16611                         o->write_characters({\cf22 "null"}, 4);\par
16612                     \}\par
16613                     o->write_character({\cf23 '\\n'});\par
16614                     o->write_characters(indent_string.c_str(), current_indent);\par
16615                     o->write_character({\cf23 '\}'});\par
16616                 \}\par
16617                 {\cf19 else}\par
16618                 \{\par
16619                     o->write_characters({\cf22 "\{\\"bytes\\":["}, 10);\par
16620 \par
16621                     {\cf19 if} (!val.m_value.binary->empty())\par
16622                     \{\par
16623                         {\cf19 for} ({\cf17 auto} i = val.m_value.binary->cbegin();\par
16624                                 i != val.m_value.binary->cend() - 1; ++i)\par
16625                         \{\par
16626                             dump_integer(*i);\par
16627                             o->write_character({\cf23 ','});\par
16628                         \}\par
16629                         dump_integer(val.m_value.binary->back());\par
16630                     \}\par
16631 \par
16632                     o->write_characters({\cf22 "],\\"subtype\\":"}, 12);\par
16633                     {\cf19 if} (val.m_value.binary->has_subtype())\par
16634                     \{\par
16635                         dump_integer(val.m_value.binary->subtype());\par
16636                         o->write_character({\cf23 '\}'});\par
16637                     \}\par
16638                     {\cf19 else}\par
16639                     \{\par
16640                         o->write_characters({\cf22 "null\}"}, 5);\par
16641                     \}\par
16642                 \}\par
16643                 {\cf19 return};\par
16644             \}\par
16645 \par
16646             {\cf19 case} value_t::boolean:\par
16647             \{\par
16648                 {\cf19 if} (val.m_value.boolean)\par
16649                 \{\par
16650                     o->write_characters({\cf22 "true"}, 4);\par
16651                 \}\par
16652                 {\cf19 else}\par
16653                 \{\par
16654                     o->write_characters({\cf22 "false"}, 5);\par
16655                 \}\par
16656                 {\cf19 return};\par
16657             \}\par
16658 \par
16659             {\cf19 case} value_t::number_integer:\par
16660             \{\par
16661                 dump_integer(val.m_value.number_integer);\par
16662                 {\cf19 return};\par
16663             \}\par
16664 \par
16665             {\cf19 case} value_t::number_unsigned:\par
16666             \{\par
16667                 dump_integer(val.m_value.number_unsigned);\par
16668                 {\cf19 return};\par
16669             \}\par
16670 \par
16671             {\cf19 case} value_t::number_float:\par
16672             \{\par
16673                 dump_float(val.m_value.number_float);\par
16674                 {\cf19 return};\par
16675             \}\par
16676 \par
16677             {\cf19 case} value_t::discarded:\par
16678             \{\par
16679                 o->write_characters({\cf22 "<discarded>"}, 11);\par
16680                 {\cf19 return};\par
16681             \}\par
16682 \par
16683             {\cf19 case} value_t::null:\par
16684             \{\par
16685                 o->write_characters({\cf22 "null"}, 4);\par
16686                 {\cf19 return};\par
16687             \}\par
16688 \par
16689             {\cf19 default}:            {\cf20 // LCOV_EXCL_LINE}\par
16690                 JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE}\par
16691         \}\par
16692     \}\par
16693 \par
16694   JSON_PRIVATE_UNLESS_TESTED:\par
16709     {\cf18 void} dump_escaped({\cf17 const} string_t& s, {\cf17 const} {\cf18 bool} ensure_ascii)\par
16710     \{\par
16711         std::uint32_t codepoint\{\};\par
16712         std::uint8_t state = UTF8_ACCEPT;\par
16713         std::size_t bytes = 0;  {\cf20 // number of bytes written to string_buffer}\par
16714 \par
16715         {\cf20 // number of bytes written at the point of the last valid byte}\par
16716         std::size_t bytes_after_last_accept = 0;\par
16717         std::size_t undumped_chars = 0;\par
16718 \par
16719         {\cf19 for} (std::size_t i = 0; i < s.size(); ++i)\par
16720         \{\par
16721             {\cf17 const} {\cf17 auto} {\cf18 byte} = {\cf17 static_cast<}std::uint8_t{\cf17 >}(s[i]);\par
16722 \par
16723             {\cf19 switch} (decode(state, codepoint, {\cf18 byte}))\par
16724             \{\par
16725                 {\cf19 case} UTF8_ACCEPT:  {\cf20 // decode found a new code point}\par
16726                 \{\par
16727                     {\cf19 switch} (codepoint)\par
16728                     \{\par
16729                         {\cf19 case} 0x08: {\cf20 // backspace}\par
16730                         \{\par
16731                             string_buffer[bytes++] = {\cf23 '\\\\'};\par
16732                             string_buffer[bytes++] = {\cf23 'b'};\par
16733                             {\cf19 break};\par
16734                         \}\par
16735 \par
16736                         {\cf19 case} 0x09: {\cf20 // horizontal tab}\par
16737                         \{\par
16738                             string_buffer[bytes++] = {\cf23 '\\\\'};\par
16739                             string_buffer[bytes++] = {\cf23 't'};\par
16740                             {\cf19 break};\par
16741                         \}\par
16742 \par
16743                         {\cf19 case} 0x0A: {\cf20 // newline}\par
16744                         \{\par
16745                             string_buffer[bytes++] = {\cf23 '\\\\'};\par
16746                             string_buffer[bytes++] = {\cf23 'n'};\par
16747                             {\cf19 break};\par
16748                         \}\par
16749 \par
16750                         {\cf19 case} 0x0C: {\cf20 // formfeed}\par
16751                         \{\par
16752                             string_buffer[bytes++] = {\cf23 '\\\\'};\par
16753                             string_buffer[bytes++] = {\cf23 'f'};\par
16754                             {\cf19 break};\par
16755                         \}\par
16756 \par
16757                         {\cf19 case} 0x0D: {\cf20 // carriage return}\par
16758                         \{\par
16759                             string_buffer[bytes++] = {\cf23 '\\\\'};\par
16760                             string_buffer[bytes++] = {\cf23 'r'};\par
16761                             {\cf19 break};\par
16762                         \}\par
16763 \par
16764                         {\cf19 case} 0x22: {\cf20 // quotation mark}\par
16765                         \{\par
16766                             string_buffer[bytes++] = {\cf23 '\\\\'};\par
16767                             string_buffer[bytes++] = {\cf23 '\\"'};\par
16768                             {\cf19 break};\par
16769                         \}\par
16770 \par
16771                         {\cf19 case} 0x5C: {\cf20 // reverse solidus}\par
16772                         \{\par
16773                             string_buffer[bytes++] = {\cf23 '\\\\'};\par
16774                             string_buffer[bytes++] = {\cf23 '\\\\'};\par
16775                             {\cf19 break};\par
16776                         \}\par
16777 \par
16778                         {\cf19 default}:\par
16779                         \{\par
16780                             {\cf20 // escape control characters (0x00..0x1F) or, if}\par
16781                             {\cf20 // ensure_ascii parameter is used, non-ASCII characters}\par
16782                             {\cf19 if} ((codepoint <= 0x1F) || (ensure_ascii && (codepoint >= 0x7F)))\par
16783                             \{\par
16784                                 {\cf19 if} (codepoint <= 0xFFFF)\par
16785                                 \{\par
16786                                     {\cf20 // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)}\par
16787                                     (std::snprintf)(string_buffer.data() + bytes, 7, {\cf22 "\\\\u%04x"},\par
16788                                                     {\cf17 static_cast<}std::uint16_t{\cf17 >}(codepoint));\par
16789                                     bytes += 6;\par
16790                                 \}\par
16791                                 {\cf19 else}\par
16792                                 \{\par
16793                                     {\cf20 // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)}\par
16794                                     (std::snprintf)(string_buffer.data() + bytes, 13, {\cf22 "\\\\u%04x\\\\u%04x"},\par
16795                                                     {\cf17 static_cast<}std::uint16_t{\cf17 >}(0xD7C0u + (codepoint >> 10u)),\par
16796                                                     {\cf17 static_cast<}std::uint16_t{\cf17 >}(0xDC00u + (codepoint & 0x3FFu)));\par
16797                                     bytes += 12;\par
16798                                 \}\par
16799                             \}\par
16800                             {\cf19 else}\par
16801                             \{\par
16802                                 {\cf20 // copy byte to buffer (all previous bytes}\par
16803                                 {\cf20 // been copied have in default case above)}\par
16804                                 string_buffer[bytes++] = s[i];\par
16805                             \}\par
16806                             {\cf19 break};\par
16807                         \}\par
16808                     \}\par
16809 \par
16810                     {\cf20 // write buffer and reset index; there must be 13 bytes}\par
16811                     {\cf20 // left, as this is the maximal number of bytes to be}\par
16812                     {\cf20 // written ("\\uxxxx\\uxxxx\\0") for one code point}\par
16813                     {\cf19 if} (string_buffer.size() - bytes < 13)\par
16814                     \{\par
16815                         o->write_characters(string_buffer.data(), bytes);\par
16816                         bytes = 0;\par
16817                     \}\par
16818 \par
16819                     {\cf20 // remember the byte position of this accept}\par
16820                     bytes_after_last_accept = bytes;\par
16821                     undumped_chars = 0;\par
16822                     {\cf19 break};\par
16823                 \}\par
16824 \par
16825                 {\cf19 case} UTF8_REJECT:  {\cf20 // decode found invalid UTF-8 byte}\par
16826                 \{\par
16827                     {\cf19 switch} (error_handler)\par
16828                     \{\par
16829                         {\cf19 case} error_handler_t::strict:\par
16830                         \{\par
16831                             std::string sn(9, {\cf23 '\\0'});\par
16832                             {\cf20 // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)}\par
16833                             (std::snprintf)(&sn[0], sn.size(), {\cf22 "%.2X"}, byte);\par
16834                             JSON_THROW(type_error::create(316, {\cf22 "invalid UTF-8 byte at index "} + std::to_string(i) + {\cf22 ": 0x"} + sn, BasicJsonType()));\par
16835                         \}\par
16836 \par
16837                         {\cf19 case} error_handler_t::ignore:\par
16838                         {\cf19 case} error_handler_t::replace:\par
16839                         \{\par
16840                             {\cf20 // in case we saw this character the first time, we}\par
16841                             {\cf20 // would like to read it again, because the byte}\par
16842                             {\cf20 // may be OK for itself, but just not OK for the}\par
16843                             {\cf20 // previous sequence}\par
16844                             {\cf19 if} (undumped_chars > 0)\par
16845                             \{\par
16846                                 --i;\par
16847                             \}\par
16848 \par
16849                             {\cf20 // reset length buffer to the last accepted index;}\par
16850                             {\cf20 // thus removing/ignoring the invalid characters}\par
16851                             bytes = bytes_after_last_accept;\par
16852 \par
16853                             {\cf19 if} (error_handler == error_handler_t::replace)\par
16854                             \{\par
16855                                 {\cf20 // add a replacement character}\par
16856                                 {\cf19 if} (ensure_ascii)\par
16857                                 \{\par
16858                                     string_buffer[bytes++] = {\cf23 '\\\\'};\par
16859                                     string_buffer[bytes++] = {\cf23 'u'};\par
16860                                     string_buffer[bytes++] = {\cf23 'f'};\par
16861                                     string_buffer[bytes++] = {\cf23 'f'};\par
16862                                     string_buffer[bytes++] = {\cf23 'f'};\par
16863                                     string_buffer[bytes++] = {\cf23 'd'};\par
16864                                 \}\par
16865                                 {\cf19 else}\par
16866                                 \{\par
16867                                     string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type({\cf22 '\\xEF'});\par
16868                                     string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type({\cf22 '\\xBF'});\par
16869                                     string_buffer[bytes++] = detail::binary_writer<BasicJsonType, char>::to_char_type({\cf22 '\\xBD'});\par
16870                                 \}\par
16871 \par
16872                                 {\cf20 // write buffer and reset index; there must be 13 bytes}\par
16873                                 {\cf20 // left, as this is the maximal number of bytes to be}\par
16874                                 {\cf20 // written ("\\uxxxx\\uxxxx\\0") for one code point}\par
16875                                 {\cf19 if} (string_buffer.size() - bytes < 13)\par
16876                                 \{\par
16877                                     o->write_characters(string_buffer.data(), bytes);\par
16878                                     bytes = 0;\par
16879                                 \}\par
16880 \par
16881                                 bytes_after_last_accept = bytes;\par
16882                             \}\par
16883 \par
16884                             undumped_chars = 0;\par
16885 \par
16886                             {\cf20 // continue processing the string}\par
16887                             state = UTF8_ACCEPT;\par
16888                             {\cf19 break};\par
16889                         \}\par
16890 \par
16891                         {\cf19 default}:            {\cf20 // LCOV_EXCL_LINE}\par
16892                             JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE}\par
16893                     \}\par
16894                     {\cf19 break};\par
16895                 \}\par
16896 \par
16897                 {\cf19 default}:  {\cf20 // decode found yet incomplete multi-byte code point}\par
16898                 \{\par
16899                     {\cf19 if} (!ensure_ascii)\par
16900                     \{\par
16901                         {\cf20 // code point will not be escaped - copy byte to buffer}\par
16902                         string_buffer[bytes++] = s[i];\par
16903                     \}\par
16904                     ++undumped_chars;\par
16905                     {\cf19 break};\par
16906                 \}\par
16907             \}\par
16908         \}\par
16909 \par
16910         {\cf20 // we finished processing the string}\par
16911         {\cf19 if} (JSON_HEDLEY_LIKELY(state == UTF8_ACCEPT))\par
16912         \{\par
16913             {\cf20 // write buffer}\par
16914             {\cf19 if} (bytes > 0)\par
16915             \{\par
16916                 o->write_characters(string_buffer.data(), bytes);\par
16917             \}\par
16918         \}\par
16919         {\cf19 else}\par
16920         \{\par
16921             {\cf20 // we finish reading, but do not accept: string was incomplete}\par
16922             {\cf19 switch} (error_handler)\par
16923             \{\par
16924                 {\cf19 case} error_handler_t::strict:\par
16925                 \{\par
16926                     std::string sn(9, {\cf23 '\\0'});\par
16927                     {\cf20 // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)}\par
16928                     (std::snprintf)(&sn[0], sn.size(), {\cf22 "%.2X"}, {\cf17 static_cast<}std::uint8_t{\cf17 >}(s.back()));\par
16929                     JSON_THROW(type_error::create(316, {\cf22 "incomplete UTF-8 string; last byte: 0x"} + sn, BasicJsonType()));\par
16930                 \}\par
16931 \par
16932                 {\cf19 case} error_handler_t::ignore:\par
16933                 \{\par
16934                     {\cf20 // write all accepted bytes}\par
16935                     o->write_characters(string_buffer.data(), bytes_after_last_accept);\par
16936                     {\cf19 break};\par
16937                 \}\par
16938 \par
16939                 {\cf19 case} error_handler_t::replace:\par
16940                 \{\par
16941                     {\cf20 // write all accepted bytes}\par
16942                     o->write_characters(string_buffer.data(), bytes_after_last_accept);\par
16943                     {\cf20 // add a replacement character}\par
16944                     {\cf19 if} (ensure_ascii)\par
16945                     \{\par
16946                         o->write_characters({\cf22 "\\\\ufffd"}, 6);\par
16947                     \}\par
16948                     {\cf19 else}\par
16949                     \{\par
16950                         o->write_characters({\cf22 "\\xEF\\xBF\\xBD"}, 3);\par
16951                     \}\par
16952                     {\cf19 break};\par
16953                 \}\par
16954 \par
16955                 {\cf19 default}:            {\cf20 // LCOV_EXCL_LINE}\par
16956                     JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE}\par
16957             \}\par
16958         \}\par
16959     \}\par
16960 \par
16961   {\cf17 private}:\par
16970     {\cf17 inline} {\cf18 unsigned} {\cf18 int} count_digits(number_unsigned_t x) {\cf17 noexcept}\par
16971     \{\par
16972         {\cf18 unsigned} {\cf18 int} n_digits = 1;\par
16973         {\cf19 for} (;;)\par
16974         \{\par
16975             {\cf19 if} (x < 10)\par
16976             \{\par
16977                 {\cf19 return} n_digits;\par
16978             \}\par
16979             {\cf19 if} (x < 100)\par
16980             \{\par
16981                 {\cf19 return} n_digits + 1;\par
16982             \}\par
16983             {\cf19 if} (x < 1000)\par
16984             \{\par
16985                 {\cf19 return} n_digits + 2;\par
16986             \}\par
16987             {\cf19 if} (x < 10000)\par
16988             \{\par
16989                 {\cf19 return} n_digits + 3;\par
16990             \}\par
16991             x = x / 10000u;\par
16992             n_digits += 4;\par
16993         \}\par
16994     \}\par
16995 \par
17005     {\cf17 template} < {\cf17 typename} NumberType, detail::enable_if_t <\par
17006                    std::is_integral<NumberType>::value ||\par
17007                    std::is_same<NumberType, number_unsigned_t>::value ||\par
17008                    std::is_same<NumberType, number_integer_t>::value ||\par
17009                    std::is_same<NumberType, binary_char_t>::value,\par
17010                    {\cf18 int} > = 0 >\par
17011     {\cf18 void} dump_integer(NumberType x)\par
17012     \{\par
17013         {\cf17 static} {\cf17 constexpr} std::array<std::array<char, 2>, 100> digits_to_99\par
17014         \{\par
17015             \{\par
17016                 \{\{{\cf23 '0'}, {\cf23 '0'}\}\}, \{\{{\cf23 '0'}, {\cf23 '1'}\}\}, \{\{{\cf23 '0'}, {\cf23 '2'}\}\}, \{\{{\cf23 '0'}, {\cf23 '3'}\}\}, \{\{{\cf23 '0'}, {\cf23 '4'}\}\}, \{\{{\cf23 '0'}, {\cf23 '5'}\}\}, \{\{{\cf23 '0'}, {\cf23 '6'}\}\}, \{\{{\cf23 '0'}, {\cf23 '7'}\}\}, \{\{{\cf23 '0'}, {\cf23 '8'}\}\}, \{\{{\cf23 '0'}, {\cf23 '9'}\}\},\par
17017                 \{\{{\cf23 '1'}, {\cf23 '0'}\}\}, \{\{{\cf23 '1'}, {\cf23 '1'}\}\}, \{\{{\cf23 '1'}, {\cf23 '2'}\}\}, \{\{{\cf23 '1'}, {\cf23 '3'}\}\}, \{\{{\cf23 '1'}, {\cf23 '4'}\}\}, \{\{{\cf23 '1'}, {\cf23 '5'}\}\}, \{\{{\cf23 '1'}, {\cf23 '6'}\}\}, \{\{{\cf23 '1'}, {\cf23 '7'}\}\}, \{\{{\cf23 '1'}, {\cf23 '8'}\}\}, \{\{{\cf23 '1'}, {\cf23 '9'}\}\},\par
17018                 \{\{{\cf23 '2'}, {\cf23 '0'}\}\}, \{\{{\cf23 '2'}, {\cf23 '1'}\}\}, \{\{{\cf23 '2'}, {\cf23 '2'}\}\}, \{\{{\cf23 '2'}, {\cf23 '3'}\}\}, \{\{{\cf23 '2'}, {\cf23 '4'}\}\}, \{\{{\cf23 '2'}, {\cf23 '5'}\}\}, \{\{{\cf23 '2'}, {\cf23 '6'}\}\}, \{\{{\cf23 '2'}, {\cf23 '7'}\}\}, \{\{{\cf23 '2'}, {\cf23 '8'}\}\}, \{\{{\cf23 '2'}, {\cf23 '9'}\}\},\par
17019                 \{\{{\cf23 '3'}, {\cf23 '0'}\}\}, \{\{{\cf23 '3'}, {\cf23 '1'}\}\}, \{\{{\cf23 '3'}, {\cf23 '2'}\}\}, \{\{{\cf23 '3'}, {\cf23 '3'}\}\}, \{\{{\cf23 '3'}, {\cf23 '4'}\}\}, \{\{{\cf23 '3'}, {\cf23 '5'}\}\}, \{\{{\cf23 '3'}, {\cf23 '6'}\}\}, \{\{{\cf23 '3'}, {\cf23 '7'}\}\}, \{\{{\cf23 '3'}, {\cf23 '8'}\}\}, \{\{{\cf23 '3'}, {\cf23 '9'}\}\},\par
17020                 \{\{{\cf23 '4'}, {\cf23 '0'}\}\}, \{\{{\cf23 '4'}, {\cf23 '1'}\}\}, \{\{{\cf23 '4'}, {\cf23 '2'}\}\}, \{\{{\cf23 '4'}, {\cf23 '3'}\}\}, \{\{{\cf23 '4'}, {\cf23 '4'}\}\}, \{\{{\cf23 '4'}, {\cf23 '5'}\}\}, \{\{{\cf23 '4'}, {\cf23 '6'}\}\}, \{\{{\cf23 '4'}, {\cf23 '7'}\}\}, \{\{{\cf23 '4'}, {\cf23 '8'}\}\}, \{\{{\cf23 '4'}, {\cf23 '9'}\}\},\par
17021                 \{\{{\cf23 '5'}, {\cf23 '0'}\}\}, \{\{{\cf23 '5'}, {\cf23 '1'}\}\}, \{\{{\cf23 '5'}, {\cf23 '2'}\}\}, \{\{{\cf23 '5'}, {\cf23 '3'}\}\}, \{\{{\cf23 '5'}, {\cf23 '4'}\}\}, \{\{{\cf23 '5'}, {\cf23 '5'}\}\}, \{\{{\cf23 '5'}, {\cf23 '6'}\}\}, \{\{{\cf23 '5'}, {\cf23 '7'}\}\}, \{\{{\cf23 '5'}, {\cf23 '8'}\}\}, \{\{{\cf23 '5'}, {\cf23 '9'}\}\},\par
17022                 \{\{{\cf23 '6'}, {\cf23 '0'}\}\}, \{\{{\cf23 '6'}, {\cf23 '1'}\}\}, \{\{{\cf23 '6'}, {\cf23 '2'}\}\}, \{\{{\cf23 '6'}, {\cf23 '3'}\}\}, \{\{{\cf23 '6'}, {\cf23 '4'}\}\}, \{\{{\cf23 '6'}, {\cf23 '5'}\}\}, \{\{{\cf23 '6'}, {\cf23 '6'}\}\}, \{\{{\cf23 '6'}, {\cf23 '7'}\}\}, \{\{{\cf23 '6'}, {\cf23 '8'}\}\}, \{\{{\cf23 '6'}, {\cf23 '9'}\}\},\par
17023                 \{\{{\cf23 '7'}, {\cf23 '0'}\}\}, \{\{{\cf23 '7'}, {\cf23 '1'}\}\}, \{\{{\cf23 '7'}, {\cf23 '2'}\}\}, \{\{{\cf23 '7'}, {\cf23 '3'}\}\}, \{\{{\cf23 '7'}, {\cf23 '4'}\}\}, \{\{{\cf23 '7'}, {\cf23 '5'}\}\}, \{\{{\cf23 '7'}, {\cf23 '6'}\}\}, \{\{{\cf23 '7'}, {\cf23 '7'}\}\}, \{\{{\cf23 '7'}, {\cf23 '8'}\}\}, \{\{{\cf23 '7'}, {\cf23 '9'}\}\},\par
17024                 \{\{{\cf23 '8'}, {\cf23 '0'}\}\}, \{\{{\cf23 '8'}, {\cf23 '1'}\}\}, \{\{{\cf23 '8'}, {\cf23 '2'}\}\}, \{\{{\cf23 '8'}, {\cf23 '3'}\}\}, \{\{{\cf23 '8'}, {\cf23 '4'}\}\}, \{\{{\cf23 '8'}, {\cf23 '5'}\}\}, \{\{{\cf23 '8'}, {\cf23 '6'}\}\}, \{\{{\cf23 '8'}, {\cf23 '7'}\}\}, \{\{{\cf23 '8'}, {\cf23 '8'}\}\}, \{\{{\cf23 '8'}, {\cf23 '9'}\}\},\par
17025                 \{\{{\cf23 '9'}, {\cf23 '0'}\}\}, \{\{{\cf23 '9'}, {\cf23 '1'}\}\}, \{\{{\cf23 '9'}, {\cf23 '2'}\}\}, \{\{{\cf23 '9'}, {\cf23 '3'}\}\}, \{\{{\cf23 '9'}, {\cf23 '4'}\}\}, \{\{{\cf23 '9'}, {\cf23 '5'}\}\}, \{\{{\cf23 '9'}, {\cf23 '6'}\}\}, \{\{{\cf23 '9'}, {\cf23 '7'}\}\}, \{\{{\cf23 '9'}, {\cf23 '8'}\}\}, \{\{{\cf23 '9'}, {\cf23 '9'}\}\},\par
17026             \}\par
17027         \};\par
17028 \par
17029         {\cf20 // special case for "0"}\par
17030         {\cf19 if} (x == 0)\par
17031         \{\par
17032             o->write_character({\cf23 '0'});\par
17033             {\cf19 return};\par
17034         \}\par
17035 \par
17036         {\cf20 // use a pointer to fill the buffer}\par
17037         {\cf17 auto} buffer_ptr = number_buffer.begin(); {\cf20 // NOLINT(llvm-qualified-auto,readability-qualified-auto,cppcoreguidelines-pro-type-vararg,hicpp-vararg)}\par
17038 \par
17039         {\cf17 const} {\cf18 bool} is_negative = std::is_signed<NumberType>::value && !(x >= 0); {\cf20 // see issue #755}\par
17040         number_unsigned_t abs_value;\par
17041 \par
17042         {\cf18 unsigned} {\cf18 int} n_chars\{\};\par
17043 \par
17044         {\cf19 if} (is_negative)\par
17045         \{\par
17046             *buffer_ptr = {\cf23 '-'};\par
17047             abs_value = remove_sign({\cf17 static_cast<}number_integer_t{\cf17 >}(x));\par
17048 \par
17049             {\cf20 // account one more byte for the minus sign}\par
17050             n_chars = 1 + count_digits(abs_value);\par
17051         \}\par
17052         {\cf19 else}\par
17053         \{\par
17054             abs_value = {\cf17 static_cast<}number_unsigned_t{\cf17 >}(x);\par
17055             n_chars = count_digits(abs_value);\par
17056         \}\par
17057 \par
17058         {\cf20 // spare 1 byte for '\\0'}\par
17059         JSON_ASSERT(n_chars < number_buffer.size() - 1);\par
17060 \par
17061         {\cf20 // jump to the end to generate the string from backward}\par
17062         {\cf20 // so we later avoid reversing the result}\par
17063         buffer_ptr += n_chars;\par
17064 \par
17065         {\cf20 // Fast int2ascii implementation inspired by "Fastware" talk by Andrei Alexandrescu}\par
17066         {\cf20 // See: https://www.youtube.com/watch?v=o4-CwDo2zpg}\par
17067         {\cf19 while} (abs_value >= 100)\par
17068         \{\par
17069             {\cf17 const} {\cf17 auto} digits_index = {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}((abs_value % 100));\par
17070             abs_value /= 100;\par
17071             *(--buffer_ptr) = digits_to_99[digits_index][1];\par
17072             *(--buffer_ptr) = digits_to_99[digits_index][0];\par
17073         \}\par
17074 \par
17075         {\cf19 if} (abs_value >= 10)\par
17076         \{\par
17077             {\cf17 const} {\cf17 auto} digits_index = {\cf17 static_cast<}{\cf18 unsigned}{\cf17 >}(abs_value);\par
17078             *(--buffer_ptr) = digits_to_99[digits_index][1];\par
17079             *(--buffer_ptr) = digits_to_99[digits_index][0];\par
17080         \}\par
17081         {\cf19 else}\par
17082         \{\par
17083             *(--buffer_ptr) = {\cf17 static_cast<}{\cf18 char}{\cf17 >}({\cf23 '0'} + abs_value);\par
17084         \}\par
17085 \par
17086         o->write_characters(number_buffer.data(), n_chars);\par
17087     \}\par
17088 \par
17097     {\cf18 void} dump_float(number_float_t x)\par
17098     \{\par
17099         {\cf20 // NaN / inf}\par
17100         {\cf19 if} (!std::isfinite(x))\par
17101         \{\par
17102             o->write_characters({\cf22 "null"}, 4);\par
17103             {\cf19 return};\par
17104         \}\par
17105 \par
17106         {\cf20 // If number_float_t is an IEEE-754 single or double precision number,}\par
17107         {\cf20 // use the Grisu2 algorithm to produce short numbers which are}\par
17108         {\cf20 // guaranteed to round-trip, using strtof and strtod, resp.}\par
17109         {\cf20 //}\par
17110         {\cf20 // NB: The test below works if <long double> == <double>.}\par
17111         {\cf17 static} {\cf17 constexpr} {\cf18 bool} is_ieee_single_or_double\par
17112             = (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 24 && std::numeric_limits<number_float_t>::max_exponent == 128) ||\par
17113               (std::numeric_limits<number_float_t>::is_iec559 && std::numeric_limits<number_float_t>::digits == 53 && std::numeric_limits<number_float_t>::max_exponent == 1024);\par
17114 \par
17115         dump_float(x, std::integral_constant<bool, is_ieee_single_or_double>());\par
17116     \}\par
17117 \par
17118     {\cf18 void} dump_float(number_float_t x, std::true_type {\cf20 /*is_ieee_single_or_double*/})\par
17119     \{\par
17120         {\cf17 auto}* begin = number_buffer.data();\par
17121         {\cf17 auto}* end = ::nlohmann::detail::to_chars(begin, begin + number_buffer.size(), x);\par
17122 \par
17123         o->write_characters(begin, {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(end - begin));\par
17124     \}\par
17125 \par
17126     {\cf18 void} dump_float(number_float_t x, std::false_type {\cf20 /*is_ieee_single_or_double*/})\par
17127     \{\par
17128         {\cf20 // get number of digits for a float -> text -> float round-trip}\par
17129         {\cf17 static} {\cf17 constexpr} {\cf17 auto} d = std::numeric_limits<number_float_t>::max_digits10;\par
17130 \par
17131         {\cf20 // the actual conversion}\par
17132         {\cf20 // NOLINTNEXTLINE(cppcoreguidelines-pro-type-vararg,hicpp-vararg)}\par
17133         std::ptrdiff_t len = (std::snprintf)(number_buffer.data(), number_buffer.size(), {\cf22 "%.*g"}, d, x);\par
17134 \par
17135         {\cf20 // negative value indicates an error}\par
17136         JSON_ASSERT(len > 0);\par
17137         {\cf20 // check if buffer was large enough}\par
17138         JSON_ASSERT({\cf17 static_cast<}std::size_t{\cf17 >}(len) < number_buffer.size());\par
17139 \par
17140         {\cf20 // erase thousands separator}\par
17141         {\cf19 if} (thousands_sep != {\cf23 '\\0'})\par
17142         \{\par
17143             {\cf17 auto}* {\cf17 const} end = std::remove(number_buffer.begin(),\par
17144                                           number_buffer.begin() + len, thousands_sep);\par
17145             std::fill(end, number_buffer.end(), {\cf23 '\\0'});\par
17146             JSON_ASSERT((end - number_buffer.begin()) <= len);\par
17147             len = (end - number_buffer.begin());\par
17148         \}\par
17149 \par
17150         {\cf20 // convert decimal point to '.'}\par
17151         {\cf19 if} (decimal_point != {\cf23 '\\0'} && decimal_point != {\cf23 '.'})\par
17152         \{\par
17153             {\cf17 auto}* {\cf17 const} dec_pos = std::find(number_buffer.begin(), number_buffer.end(), decimal_point);\par
17154             {\cf19 if} (dec_pos != number_buffer.end())\par
17155             \{\par
17156                 *dec_pos = {\cf23 '.'};\par
17157             \}\par
17158         \}\par
17159 \par
17160         o->write_characters(number_buffer.data(), {\cf17 static_cast<}std::size_t{\cf17 >}(len));\par
17161 \par
17162         {\cf20 // determine if need to append ".0"}\par
17163         {\cf17 const} {\cf18 bool} value_is_int_like =\par
17164             std::none_of(number_buffer.begin(), number_buffer.begin() + len + 1,\par
17165                          []({\cf18 char} c)\par
17166         \{\par
17167             return c == {\cf22 '.'} || c == {\cf22 'e'};\par
17168         \});\par
17169 \par
17170         {\cf19 if} (value_is_int_like)\par
17171         \{\par
17172             o->write_characters({\cf22 ".0"}, 2);\par
17173         \}\par
17174     \}\par
17175 \par
17197     {\cf17 static} std::uint8_t decode(std::uint8_t& state, std::uint32_t& codep, {\cf17 const} std::uint8_t {\cf18 byte}) {\cf17 noexcept}\par
17198     \{\par
17199         {\cf17 static} {\cf17 const} std::array<std::uint8_t, 400> utf8d =\par
17200         \{\par
17201             \{\par
17202                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {\cf20 // 00..1F}\par
17203                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {\cf20 // 20..3F}\par
17204                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {\cf20 // 40..5F}\par
17205                 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {\cf20 // 60..7F}\par
17206                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, {\cf20 // 80..9F}\par
17207                 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, {\cf20 // A0..BF}\par
17208                 8, 8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, {\cf20 // C0..DF}\par
17209                 0xA, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x3, {\cf20 // E0..EF}\par
17210                 0xB, 0x6, 0x6, 0x6, 0x5, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, {\cf20 // F0..FF}\par
17211                 0x0, 0x1, 0x2, 0x3, 0x5, 0x8, 0x7, 0x1, 0x1, 0x1, 0x4, 0x6, 0x1, 0x1, 0x1, 0x1, {\cf20 // s0..s0}\par
17212                 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, {\cf20 // s1..s2}\par
17213                 1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, {\cf20 // s3..s4}\par
17214                 1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, {\cf20 // s5..s6}\par
17215                 1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 {\cf20 // s7..s8}\par
17216             \}\par
17217         \};\par
17218 \par
17219         JSON_ASSERT({\cf18 byte} < utf8d.size());\par
17220         {\cf17 const} std::uint8_t type = utf8d[byte];\par
17221 \par
17222         codep = (state != UTF8_ACCEPT)\par
17223                 ? ({\cf18 byte} & 0x3fu) | (codep << 6u)\par
17224                 : (0xFFu >> type) & (byte);\par
17225 \par
17226         std::size_t index = 256u + {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(state) * 16u + {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(type);\par
17227         JSON_ASSERT(index < 400);\par
17228         state = utf8d[index];\par
17229         {\cf19 return} state;\par
17230     \}\par
17231 \par
17232     {\cf20 /*}\par
17233 {\cf20      * Overload to make the compiler happy while it is instantiating}\par
17234 {\cf20      * dump_integer for number_unsigned_t.}\par
17235 {\cf20      * Must never be called.}\par
17236 {\cf20      */}\par
17237     number_unsigned_t remove_sign(number_unsigned_t x)\par
17238     \{\par
17239         JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE}\par
17240         {\cf19 return} x; {\cf20 // LCOV_EXCL_LINE}\par
17241     \}\par
17242 \par
17243     {\cf20 /*}\par
17244 {\cf20      * Helper function for dump_integer}\par
17245 {\cf20      *}\par
17246 {\cf20      * This function takes a negative signed integer and returns its absolute}\par
17247 {\cf20      * value as unsigned integer. The plus/minus shuffling is necessary as we can}\par
17248 {\cf20      * not directly remove the sign of an arbitrary signed integer as the}\par
17249 {\cf20      * absolute values of INT_MIN and INT_MAX are usually not the same. See}\par
17250 {\cf20      * #1708 for details.}\par
17251 {\cf20      */}\par
17252     {\cf17 inline} number_unsigned_t remove_sign(number_integer_t x) {\cf17 noexcept}\par
17253     \{\par
17254         JSON_ASSERT(x < 0 && x < (std::numeric_limits<number_integer_t>::max)()); {\cf20 // NOLINT(misc-redundant-expression)}\par
17255         {\cf19 return} {\cf17 static_cast<}number_unsigned_t{\cf17 >}(-(x + 1)) + 1;\par
17256     \}\par
17257 \par
17258   {\cf17 private}:\par
17260     output_adapter_t<char> o = {\cf17 nullptr};\par
17261 \par
17263     std::array<char, 64> number_buffer\{\{\}\};\par
17264 \par
17266     {\cf17 const} std::lconv* loc = {\cf17 nullptr};\par
17268     {\cf17 const} {\cf18 char} thousands_sep = {\cf23 '\\0'};\par
17270     {\cf17 const} {\cf18 char} decimal_point = {\cf23 '\\0'};\par
17271 \par
17273     std::array<char, 512> string_buffer\{\{\}\};\par
17274 \par
17276     {\cf17 const} {\cf18 char} indent_char;\par
17278     string_t indent_string;\par
17279 \par
17281     {\cf17 const} error_handler_t error_handler;\par
17282 \};\par
17283 \}  {\cf20 // namespace detail}\par
17284 \}  {\cf20 // namespace nlohmann}\par
17285 \par
17286 {\cf20 // #include <nlohmann/detail/value_t.hpp>}\par
17287 \par
17288 {\cf20 // #include <nlohmann/json_fwd.hpp>}\par
17289 \par
17290 {\cf20 // #include <nlohmann/ordered_map.hpp>}\par
17291 \par
17292 \par
17293 {\cf21 #include <functional>} {\cf20 // less}\par
17294 {\cf21 #include <initializer_list>} {\cf20 // initializer_list}\par
17295 {\cf21 #include <iterator>} {\cf20 // input_iterator_tag, iterator_traits}\par
17296 {\cf21 #include <memory>} {\cf20 // allocator}\par
17297 {\cf21 #include <stdexcept>} {\cf20 // for out_of_range}\par
17298 {\cf21 #include <type_traits>} {\cf20 // enable_if, is_convertible}\par
17299 {\cf21 #include <utility>} {\cf20 // pair}\par
17300 {\cf21 #include <vector>} {\cf20 // vector}\par
17301 \par
17302 {\cf20 // #include <nlohmann/detail/macro_scope.hpp>}\par
17303 \par
17304 \par
17305 {\cf17 namespace }nlohmann\par
17306 \{\par
17307 \par
17310 {\cf17 template} <{\cf17 class} Key, {\cf17 class} T, {\cf17 class} IgnoredLess = std::less<Key>,\par
17311           {\cf17 class} Allocator = std::allocator<std::pair<const Key, T>>>\par
17312                   {\cf17 struct }ordered_map : std::vector<std::pair<const Key, T>, Allocator>\par
17313 \{\par
17314     {\cf17 using} key_type = Key;\par
17315     {\cf17 using} mapped_type = T;\par
17316     {\cf17 using} Container = std::vector<std::pair<const Key, T>, Allocator>;\par
17317     {\cf17 using} {\cf17 typename} Container::iterator;\par
17318     {\cf17 using} {\cf17 typename} Container::const_iterator;\par
17319     {\cf17 using} {\cf17 typename} Container::size_type;\par
17320     {\cf17 using} {\cf17 typename} Container::value_type;\par
17321 \par
17322     {\cf20 // Explicit constructors instead of `using Container::Container`}\par
17323     {\cf20 // otherwise older compilers choke on it (GCC <= 5.5, xcode <= 9.4)}\par
17324     ordered_map({\cf17 const} Allocator& alloc = Allocator()) : Container\{alloc\} \{\}\par
17325     {\cf17 template} <{\cf17 class} It>\par
17326     ordered_map(It first, It last, {\cf17 const} Allocator& alloc = Allocator())\par
17327         : Container\{first, last, alloc\} \{\}\par
17328     ordered_map(std::initializer_list<T> init, {\cf17 const} Allocator& alloc = Allocator() )\par
17329         : Container\{init, alloc\} \{\}\par
17330 \par
17331     std::pair<iterator, bool> emplace({\cf17 const} key_type& key, T&& t)\par
17332     \{\par
17333         {\cf19 for} ({\cf17 auto} it = this->begin(); it != this->end(); ++it)\par
17334         \{\par
17335             {\cf19 if} (it->first == key)\par
17336             \{\par
17337                 {\cf19 return} \{it, {\cf17 false}\};\par
17338             \}\par
17339         \}\par
17340         Container::emplace_back(key, t);\par
17341         {\cf19 return} \{--this->end(), {\cf17 true}\};\par
17342     \}\par
17343 \par
17344     T& operator[]({\cf17 const} Key& key)\par
17345     \{\par
17346         {\cf19 return} emplace(key, T\{\}).first->second;\par
17347     \}\par
17348 \par
17349     {\cf17 const} T& operator[]({\cf17 const} Key& key){\cf17  const}\par
17350 {\cf17     }\{\par
17351         {\cf19 return} at(key);\par
17352     \}\par
17353 \par
17354     T& at({\cf17 const} Key& key)\par
17355     \{\par
17356         {\cf19 for} ({\cf17 auto} it = this->begin(); it != this->end(); ++it)\par
17357         \{\par
17358             {\cf19 if} (it->first == key)\par
17359             \{\par
17360                 {\cf19 return} it->second;\par
17361             \}\par
17362         \}\par
17363 \par
17364         JSON_THROW(std::out_of_range({\cf22 "key not found"}));\par
17365     \}\par
17366 \par
17367     {\cf17 const} T& at({\cf17 const} Key& key){\cf17  const}\par
17368 {\cf17     }\{\par
17369         {\cf19 for} ({\cf17 auto} it = this->begin(); it != this->end(); ++it)\par
17370         \{\par
17371             {\cf19 if} (it->first == key)\par
17372             \{\par
17373                 {\cf19 return} it->second;\par
17374             \}\par
17375         \}\par
17376 \par
17377         JSON_THROW(std::out_of_range({\cf22 "key not found"}));\par
17378     \}\par
17379 \par
17380     size_type erase({\cf17 const} Key& key)\par
17381     \{\par
17382         {\cf19 for} ({\cf17 auto} it = this->begin(); it != this->end(); ++it)\par
17383         \{\par
17384             {\cf19 if} (it->first == key)\par
17385             \{\par
17386                 {\cf20 // Since we cannot move const Keys, re-construct them in place}\par
17387                 {\cf19 for} ({\cf17 auto} next = it; ++next != this->end(); ++it)\par
17388                 \{\par
17389                     it->~value_type(); {\cf20 // Destroy but keep allocation}\par
17390                     {\cf17 new} (&*it) value_type\{std::move(*next)\};\par
17391                 \}\par
17392                 Container::pop_back();\par
17393                 {\cf19 return} 1;\par
17394             \}\par
17395         \}\par
17396         {\cf19 return} 0;\par
17397     \}\par
17398 \par
17399     iterator erase(iterator pos)\par
17400     \{\par
17401         {\cf17 auto} it = pos;\par
17402 \par
17403         {\cf20 // Since we cannot move const Keys, re-construct them in place}\par
17404         {\cf19 for} ({\cf17 auto} next = it; ++next != this->end(); ++it)\par
17405         \{\par
17406             it->~value_type(); {\cf20 // Destroy but keep allocation}\par
17407             {\cf17 new} (&*it) value_type\{std::move(*next)\};\par
17408         \}\par
17409         Container::pop_back();\par
17410         {\cf19 return} pos;\par
17411     \}\par
17412 \par
17413     size_type count({\cf17 const} Key& key){\cf17  const}\par
17414 {\cf17     }\{\par
17415         {\cf19 for} ({\cf17 auto} it = this->begin(); it != this->end(); ++it)\par
17416         \{\par
17417             {\cf19 if} (it->first == key)\par
17418             \{\par
17419                 {\cf19 return} 1;\par
17420             \}\par
17421         \}\par
17422         {\cf19 return} 0;\par
17423     \}\par
17424 \par
17425     iterator find({\cf17 const} Key& key)\par
17426     \{\par
17427         {\cf19 for} ({\cf17 auto} it = this->begin(); it != this->end(); ++it)\par
17428         \{\par
17429             {\cf19 if} (it->first == key)\par
17430             \{\par
17431                 {\cf19 return} it;\par
17432             \}\par
17433         \}\par
17434         {\cf19 return} Container::end();\par
17435     \}\par
17436 \par
17437     const_iterator find({\cf17 const} Key& key){\cf17  const}\par
17438 {\cf17     }\{\par
17439         {\cf19 for} ({\cf17 auto} it = this->begin(); it != this->end(); ++it)\par
17440         \{\par
17441             {\cf19 if} (it->first == key)\par
17442             \{\par
17443                 {\cf19 return} it;\par
17444             \}\par
17445         \}\par
17446         {\cf19 return} Container::end();\par
17447     \}\par
17448 \par
17449     std::pair<iterator, bool> insert( value_type&& value )\par
17450     \{\par
17451         {\cf19 return} emplace(value.first, std::move(value.second));\par
17452     \}\par
17453 \par
17454     std::pair<iterator, bool> insert( {\cf17 const} value_type& value )\par
17455     \{\par
17456         {\cf19 for} ({\cf17 auto} it = this->begin(); it != this->end(); ++it)\par
17457         \{\par
17458             {\cf19 if} (it->first == value.first)\par
17459             \{\par
17460                 {\cf19 return} \{it, {\cf17 false}\};\par
17461             \}\par
17462         \}\par
17463         Container::push_back(value);\par
17464         {\cf19 return} \{--this->end(), {\cf17 true}\};\par
17465     \}\par
17466 \par
17467     {\cf17 template}<{\cf17 typename} InputIt>\par
17468     {\cf17 using} require_input_iter = {\cf17 typename} std::enable_if<std::is_convertible<typename std::iterator_traits<InputIt>::iterator_category,\par
17469             std::input_iterator_tag>::value>::type;\par
17470 \par
17471     {\cf17 template}<{\cf17 typename} InputIt, {\cf17 typename} = require_input_iter<InputIt>>\par
17472     {\cf18 void} insert(InputIt first, InputIt last)\par
17473     \{\par
17474         {\cf19 for} ({\cf17 auto} it = first; it != last; ++it)\par
17475         \{\par
17476             insert(*it);\par
17477         \}\par
17478     \}\par
17479 \};\par
17480 \par
17481 \}  {\cf20 // namespace nlohmann}\par
17482 \par
17483 \par
17484 {\cf21 #if defined(JSON_HAS_CPP_17)}\par
17485 {\cf21     #include <string_view>}\par
17486 {\cf21 #endif}\par
17487 \par
17493 {\cf17 namespace }nlohmann\par
17494 \{\par
17495 \par
17580 NLOHMANN_BASIC_JSON_TPL_DECLARATION\par
17581 {\cf17 class }basic_json {\cf20 // NOLINT(cppcoreguidelines-special-member-functions,hicpp-special-member-functions)}\par
17582 \{\par
17583   {\cf17 private}:\par
17584     {\cf17 template}<detail::value_t> {\cf17 friend} {\cf17 struct }detail::external_constructor;\par
17585     friend ::nlohmann::json_pointer<basic_json>;\par
17586 \par
17587     {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} InputType>\par
17588     {\cf17 friend} class ::nlohmann::detail::parser;\par
17589     friend ::nlohmann::detail::serializer<basic_json>;\par
17590     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
17591     {\cf17 friend} class ::nlohmann::detail::iter_impl;\par
17592     {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} CharType>\par
17593     {\cf17 friend} class ::nlohmann::detail::binary_writer;\par
17594     {\cf17 template}<{\cf17 typename} BasicJsonType, {\cf17 typename} InputType, {\cf17 typename} SAX>\par
17595     {\cf17 friend} class ::nlohmann::detail::binary_reader;\par
17596     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
17597     {\cf17 friend} class ::nlohmann::detail::json_sax_dom_parser;\par
17598     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
17599     {\cf17 friend} class ::nlohmann::detail::json_sax_dom_callback_parser;\par
17600     {\cf17 friend} class ::nlohmann::detail::exception;\par
17601 \par
17603     {\cf17 using} basic_json_t = NLOHMANN_BASIC_JSON_TPL;\par
17604 \par
17605   JSON_PRIVATE_UNLESS_TESTED:\par
17606     {\cf20 // convenience aliases for types residing in namespace detail;}\par
17607     {\cf17 using} lexer = ::nlohmann::detail::lexer_base<basic_json>;\par
17608 \par
17609     {\cf17 template}<{\cf17 typename} InputAdapterType>\par
17610     static ::nlohmann::detail::parser<basic_json, InputAdapterType> parser(\par
17611         InputAdapterType adapter,\par
17612         detail::parser_callback_t<basic_json>cb = {\cf17 nullptr},\par
17613         {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true},\par
17614         {\cf17 const} {\cf18 bool} ignore_comments = {\cf17 false}\par
17615                                  )\par
17616     \{\par
17617         return ::nlohmann::detail::parser<basic_json, InputAdapterType>(std::move(adapter),\par
17618                 std::move(cb), allow_exceptions, ignore_comments);\par
17619     \}\par
17620 \par
17621   {\cf17 private}:\par
17622     {\cf17 using} primitive_iterator_t = ::nlohmann::detail::primitive_iterator_t;\par
17623     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
17624     {\cf17 using} internal_iterator = ::nlohmann::detail::internal_iterator<BasicJsonType>;\par
17625     {\cf17 template}<{\cf17 typename} BasicJsonType>\par
17626     {\cf17 using} iter_impl = ::nlohmann::detail::iter_impl<BasicJsonType>;\par
17627     {\cf17 template}<{\cf17 typename} Iterator>\par
17628     {\cf17 using} iteration_proxy = ::nlohmann::detail::iteration_proxy<Iterator>;\par
17629     {\cf17 template}<{\cf17 typename} Base> {\cf17 using} json_reverse_iterator = ::nlohmann::detail::json_reverse_iterator<Base>;\par
17630 \par
17631     {\cf17 template}<{\cf17 typename} CharType>\par
17632     {\cf17 using} output_adapter_t = ::nlohmann::detail::output_adapter_t<CharType>;\par
17633 \par
17634     {\cf17 template}<{\cf17 typename} InputType>\par
17635     {\cf17 using} binary_reader = ::nlohmann::detail::binary_reader<basic_json, InputType>;\par
17636     {\cf17 template}<{\cf17 typename} CharType> {\cf17 using} binary_writer = ::nlohmann::detail::binary_writer<basic_json, CharType>;\par
17637 \par
17638   JSON_PRIVATE_UNLESS_TESTED:\par
17639     {\cf17 using} serializer = ::nlohmann::detail::serializer<basic_json>;\par
17640 \par
17641   {\cf17 public}:\par
17642     {\cf17 using} value_t = detail::value_t;\par
17644     {\cf17 using} json_pointer = ::nlohmann::json_pointer<basic_json>;\par
17645     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} SFINAE>\par
17646     {\cf17 using} json_serializer = JSONSerializer<T, SFINAE>;\par
17648     {\cf17 using} error_handler_t = detail::error_handler_t;\par
17650     {\cf17 using} cbor_tag_handler_t = detail::cbor_tag_handler_t;\par
17652     {\cf17 using} initializer_list_t = std::initializer_list<detail::json_ref<basic_json>>;\par
17653 \par
17654     {\cf17 using} input_format_t = detail::input_format_t;\par
17656     {\cf17 using} json_sax_t = json_sax<basic_json>;\par
17657 \par
17659     {\cf20 // exceptions //}\par
17661 {\cf20 }\par
17665 \par
17667     {\cf17 using} exception = detail::exception;\par
17669     {\cf17 using} parse_error = detail::parse_error;\par
17671     {\cf17 using} invalid_iterator = detail::invalid_iterator;\par
17673     {\cf17 using} type_error = detail::type_error;\par
17675     {\cf17 using} out_of_range = detail::out_of_range;\par
17677     {\cf17 using} other_error = detail::other_error;\par
17678 \par
17680 \par
17681 \par
17683     {\cf20 // container types //}\par
17685 {\cf20 }\par
17690 \par
17692     {\cf17 using} value_type = basic_json;\par
17693 \par
17695     {\cf17 using} reference = value_type&;\par
17697     {\cf17 using} const_reference = {\cf17 const} value_type&;\par
17698 \par
17700     {\cf17 using} difference_type = std::ptrdiff_t;\par
17702     {\cf17 using} size_type = std::size_t;\par
17703 \par
17705     {\cf17 using} allocator_type = AllocatorType<basic_json>;\par
17706 \par
17708     {\cf17 using} pointer = {\cf17 typename} std::allocator_traits<allocator_type>::pointer;\par
17710     {\cf17 using} const_pointer = {\cf17 typename} std::allocator_traits<allocator_type>::const_pointer;\par
17711 \par
17713     {\cf17 using} iterator = iter_impl<basic_json>;\par
17715     {\cf17 using} const_iterator = iter_impl<const basic_json>;\par
17717     {\cf17 using} reverse_iterator = json_reverse_iterator<typename basic_json::iterator>;\par
17719     {\cf17 using} const_reverse_iterator = json_reverse_iterator<typename basic_json::const_iterator>;\par
17720 \par
17722 \par
17723 \par
17727     {\cf17 static} allocator_type get_allocator()\par
17728     \{\par
17729         {\cf19 return} allocator_type();\par
17730     \}\par
17731 \par
17758     JSON_HEDLEY_WARN_UNUSED_RESULT\par
17759     {\cf17 static} basic_json meta()\par
17760     \{\par
17761         basic_json result;\par
17762 \par
17763         result[{\cf22 "copyright"}] = {\cf22 "(C) 2013-2021 Niels Lohmann"};\par
17764         result[{\cf22 "name"}] = {\cf22 "JSON for Modern C++"};\par
17765         result[{\cf22 "url"}] = {\cf22 "https://github.com/nlohmann/json"};\par
17766         result[{\cf22 "version"}][{\cf22 "string"}] =\par
17767             std::to_string(NLOHMANN_JSON_VERSION_MAJOR) + {\cf22 "."} +\par
17768             std::to_string(NLOHMANN_JSON_VERSION_MINOR) + {\cf22 "."} +\par
17769             std::to_string(NLOHMANN_JSON_VERSION_PATCH);\par
17770         result[{\cf22 "version"}][{\cf22 "major"}] = NLOHMANN_JSON_VERSION_MAJOR;\par
17771         result[{\cf22 "version"}][{\cf22 "minor"}] = NLOHMANN_JSON_VERSION_MINOR;\par
17772         result[{\cf22 "version"}][{\cf22 "patch"}] = NLOHMANN_JSON_VERSION_PATCH;\par
17773 \par
17774 {\cf21 #ifdef _WIN32}\par
17775         result[{\cf22 "platform"}] = {\cf22 "win32"};\par
17776 {\cf21 #elif defined __linux__}\par
17777         result[{\cf22 "platform"}] = {\cf22 "linux"};\par
17778 {\cf21 #elif defined __APPLE__}\par
17779         result[{\cf22 "platform"}] = {\cf22 "apple"};\par
17780 {\cf21 #elif defined __unix__}\par
17781         result[{\cf22 "platform"}] = {\cf22 "unix"};\par
17782 {\cf21 #else}\par
17783         result[{\cf22 "platform"}] = {\cf22 "unknown"};\par
17784 {\cf21 #endif}\par
17785 \par
17786 {\cf21 #if defined(__ICC) || defined(__INTEL_COMPILER)}\par
17787         result[{\cf22 "compiler"}] = \{\{{\cf22 "family"}, {\cf22 "icc"}\}, \{{\cf22 "version"}, __INTEL_COMPILER\}\};\par
17788 {\cf21 #elif defined(__clang__)}\par
17789         result[{\cf22 "compiler"}] = \{\{{\cf22 "family"}, {\cf22 "clang"}\}, \{{\cf22 "version"}, __clang_version__\}\};\par
17790 {\cf21 #elif defined(__GNUC__) || defined(__GNUG__)}\par
17791         result[{\cf22 "compiler"}] = \{\{{\cf22 "family"}, {\cf22 "gcc"}\}, \{{\cf22 "version"}, std::to_string(__GNUC__) + {\cf22 "."} + std::to_string(__GNUC_MINOR__) + {\cf22 "."} + std::to_string(__GNUC_PATCHLEVEL__)\}\};\par
17792 {\cf21 #elif defined(__HP_cc) || defined(__HP_aCC)}\par
17793         result[{\cf22 "compiler"}] = {\cf22 "hp"}\par
17794 {\cf21 #elif defined(__IBMCPP__)}\par
17795         result[{\cf22 "compiler"}] = \{\{{\cf22 "family"}, {\cf22 "ilecpp"}\}, \{{\cf22 "version"}, __IBMCPP__\}\};\par
17796 {\cf21 #elif defined(_MSC_VER)}\par
17797         result[{\cf22 "compiler"}] = \{\{{\cf22 "family"}, {\cf22 "msvc"}\}, \{{\cf22 "version"}, _MSC_VER\}\};\par
17798 {\cf21 #elif defined(__PGI)}\par
17799         result[{\cf22 "compiler"}] = \{\{{\cf22 "family"}, {\cf22 "pgcpp"}\}, \{{\cf22 "version"}, __PGI\}\};\par
17800 {\cf21 #elif defined(__SUNPRO_CC)}\par
17801         result[{\cf22 "compiler"}] = \{\{{\cf22 "family"}, {\cf22 "sunpro"}\}, \{{\cf22 "version"}, __SUNPRO_CC\}\};\par
17802 {\cf21 #else}\par
17803         result[{\cf22 "compiler"}] = \{\{{\cf22 "family"}, {\cf22 "unknown"}\}, \{{\cf22 "version"}, {\cf22 "unknown"}\}\};\par
17804 {\cf21 #endif}\par
17805 \par
17806 {\cf21 #ifdef __cplusplus}\par
17807         result[{\cf22 "compiler"}][{\cf22 "c++"}] = std::to_string(__cplusplus);\par
17808 {\cf21 #else}\par
17809         result[{\cf22 "compiler"}][{\cf22 "c++"}] = {\cf22 "unknown"};\par
17810 {\cf21 #endif}\par
17811         {\cf19 return} result;\par
17812     \}\par
17813 \par
17814 \par
17816     {\cf20 // JSON value data types //}\par
17818 {\cf20 }\par
17823 \par
17824 {\cf21 #if defined(JSON_HAS_CPP_14)}\par
17825     {\cf20 // Use transparent comparator if possible, combined with perfect forwarding}\par
17826     {\cf20 // on find() and count() calls prevents unnecessary string construction.}\par
17827     {\cf17 using} object_comparator_t = std::less<>;\par
17828 {\cf21 #else}\par
17829     {\cf17 using} object_comparator_t = std::less<StringType>;\par
17830 {\cf21 #endif}\par
17831 \par
17915     {\cf17 using} object_t = ObjectType<StringType,\par
17916           basic_json,\par
17917           object_comparator_t,\par
17918           AllocatorType<std::pair<{\cf17 const} StringType,\par
17919           basic_json>>>;\par
17920 \par
17965     {\cf17 using} array_t = ArrayType<basic_json, AllocatorType<basic_json>>;\par
17966 \par
18018     {\cf17 using} string_t = StringType;\par
18019 \par
18044     {\cf17 using} boolean_t = BooleanType;\par
18045 \par
18116     {\cf17 using} number_integer_t = NumberIntegerType;\par
18117 \par
18187     {\cf17 using} number_unsigned_t = NumberUnsignedType;\par
18188 \par
18255     {\cf17 using} number_float_t = NumberFloatType;\par
18256 \par
18326     {\cf17 using} binary_t = nlohmann::byte_container_with_subtype<BinaryType>;\par
18328 \par
18329   {\cf17 private}:\par
18330 \par
18332     {\cf17 template}<{\cf17 typename} T, {\cf17 typename}... Args>\par
18333     JSON_HEDLEY_RETURNS_NON_NULL\par
18334     {\cf17 static} T* create(Args&& ... args)\par
18335     \{\par
18336         AllocatorType<T> alloc;\par
18337         {\cf17 using} AllocatorTraits = std::allocator_traits<AllocatorType<T>>;\par
18338 \par
18339         {\cf17 auto} deleter = [&](T * obj)\par
18340         \{\par
18341             AllocatorTraits::deallocate(alloc, obj, 1);\par
18342         \};\par
18343         std::unique_ptr<T, {\cf17 decltype}(deleter)> obj(AllocatorTraits::allocate(alloc, 1), deleter);\par
18344         AllocatorTraits::construct(alloc, obj.get(), std::forward<Args>(args)...);\par
18345         JSON_ASSERT(obj != {\cf17 nullptr});\par
18346         {\cf19 return} obj.release();\par
18347     \}\par
18348 \par
18350     {\cf20 // JSON value storage //}\par
18352 {\cf20 }\par
18353   JSON_PRIVATE_UNLESS_TESTED:\par
18379     {\cf17 union }json_value\par
18380     \{\par
18382         object_t* object;\par
18384         array_t* array;\par
18386         string_t* string;\par
18388         binary_t* binary;\par
18390         boolean_t boolean;\par
18392         number_integer_t number_integer;\par
18394         number_unsigned_t number_unsigned;\par
18396         number_float_t number_float;\par
18397 \par
18399         json_value() = {\cf19 default};\par
18401         json_value(boolean_t v) noexcept : boolean(v) \{\}\par
18403         json_value(number_integer_t v) noexcept : number_integer(v) \{\}\par
18405         json_value(number_unsigned_t v) noexcept : number_unsigned(v) \{\}\par
18407         json_value(number_float_t v) noexcept : number_float(v) \{\}\par
18409         json_value(value_t t)\par
18410         \{\par
18411             {\cf19 switch} (t)\par
18412             \{\par
18413                 {\cf19 case} value_t::object:\par
18414                 \{\par
18415                     {\cf18 object} = create<object_t>();\par
18416                     {\cf19 break};\par
18417                 \}\par
18418 \par
18419                 {\cf19 case} value_t::array:\par
18420                 \{\par
18421                     array = create<array_t>();\par
18422                     {\cf19 break};\par
18423                 \}\par
18424 \par
18425                 {\cf19 case} value_t::string:\par
18426                 \{\par
18427                     {\cf18 string} = create<string_t>({\cf22 ""});\par
18428                     {\cf19 break};\par
18429                 \}\par
18430 \par
18431                 {\cf19 case} value_t::binary:\par
18432                 \{\par
18433                     binary = create<binary_t>();\par
18434                     {\cf19 break};\par
18435                 \}\par
18436 \par
18437                 {\cf19 case} value_t::boolean:\par
18438                 \{\par
18439                     {\cf18 boolean} = boolean_t({\cf17 false});\par
18440                     {\cf19 break};\par
18441                 \}\par
18442 \par
18443                 {\cf19 case} value_t::number_integer:\par
18444                 \{\par
18445                     number_integer = number_integer_t(0);\par
18446                     {\cf19 break};\par
18447                 \}\par
18448 \par
18449                 {\cf19 case} value_t::number_unsigned:\par
18450                 \{\par
18451                     number_unsigned = number_unsigned_t(0);\par
18452                     {\cf19 break};\par
18453                 \}\par
18454 \par
18455                 {\cf19 case} value_t::number_float:\par
18456                 \{\par
18457                     number_float = number_float_t(0.0);\par
18458                     {\cf19 break};\par
18459                 \}\par
18460 \par
18461                 {\cf19 case} value_t::null:\par
18462                 \{\par
18463                     {\cf18 object} = {\cf17 nullptr};  {\cf20 // silence warning, see #821}\par
18464                     {\cf19 break};\par
18465                 \}\par
18466 \par
18467                 {\cf19 case} value_t::discarded:\par
18468                 {\cf19 default}:\par
18469                 \{\par
18470                     {\cf18 object} = {\cf17 nullptr};  {\cf20 // silence warning, see #821}\par
18471                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(t == value_t::null))\par
18472                     \{\par
18473                         JSON_THROW(other_error::create(500, {\cf22 "961c151d2e87f2686a955a9be24d316f1362bf21 3.10.2"}, basic_json())); {\cf20 // LCOV_EXCL_LINE}\par
18474                     \}\par
18475                     {\cf19 break};\par
18476                 \}\par
18477             \}\par
18478         \}\par
18479 \par
18481         json_value({\cf17 const} string_t& value)\par
18482         \{\par
18483             {\cf18 string} = create<string_t>(value);\par
18484         \}\par
18485 \par
18487         json_value(string_t&& value)\par
18488         \{\par
18489             {\cf18 string} = create<string_t>(std::move(value));\par
18490         \}\par
18491 \par
18493         json_value({\cf17 const} object_t& value)\par
18494         \{\par
18495             {\cf18 object} = create<object_t>(value);\par
18496         \}\par
18497 \par
18499         json_value(object_t&& value)\par
18500         \{\par
18501             {\cf18 object} = create<object_t>(std::move(value));\par
18502         \}\par
18503 \par
18505         json_value({\cf17 const} array_t& value)\par
18506         \{\par
18507             array = create<array_t>(value);\par
18508         \}\par
18509 \par
18511         json_value(array_t&& value)\par
18512         \{\par
18513             array = create<array_t>(std::move(value));\par
18514         \}\par
18515 \par
18517         json_value({\cf17 const} {\cf17 typename} binary_t::container_type& value)\par
18518         \{\par
18519             binary = create<binary_t>(value);\par
18520         \}\par
18521 \par
18523         json_value({\cf17 typename} binary_t::container_type&& value)\par
18524         \{\par
18525             binary = create<binary_t>(std::move(value));\par
18526         \}\par
18527 \par
18529         json_value({\cf17 const} binary_t& value)\par
18530         \{\par
18531             binary = create<binary_t>(value);\par
18532         \}\par
18533 \par
18535         json_value(binary_t&& value)\par
18536         \{\par
18537             binary = create<binary_t>(std::move(value));\par
18538         \}\par
18539 \par
18540         {\cf18 void} destroy(value_t t)\par
18541         \{\par
18542             {\cf19 if} (t == value_t::array || t == value_t::object)\par
18543             \{\par
18544                 {\cf20 // flatten the current json_value to a heap-allocated stack}\par
18545                 std::vector<basic_json> stack;\par
18546 \par
18547                 {\cf20 // move the top-level items to stack}\par
18548                 {\cf19 if} (t == value_t::array)\par
18549                 \{\par
18550                     stack.reserve(array->size());\par
18551                     std::move(array->begin(), array->end(), std::back_inserter(stack));\par
18552                 \}\par
18553                 {\cf19 else}\par
18554                 \{\par
18555                     stack.reserve(object->size());\par
18556                     {\cf19 for} ({\cf17 auto}&& it : *{\cf18 object})\par
18557                     \{\par
18558                         stack.push_back(std::move(it.second));\par
18559                     \}\par
18560                 \}\par
18561 \par
18562                 {\cf19 while} (!stack.empty())\par
18563                 \{\par
18564                     {\cf20 // move the last item to local variable to be processed}\par
18565                     basic_json current_item(std::move(stack.back()));\par
18566                     stack.pop_back();\par
18567 \par
18568                     {\cf20 // if current_item is array/object, move}\par
18569                     {\cf20 // its children to the stack to be processed later}\par
18570                     {\cf19 if} (current_item.is_array())\par
18571                     \{\par
18572                         std::move(current_item.m_value.array->begin(), current_item.m_value.array->end(), std::back_inserter(stack));\par
18573 \par
18574                         current_item.m_value.array->clear();\par
18575                     \}\par
18576                     {\cf19 else} {\cf19 if} (current_item.is_object())\par
18577                     \{\par
18578                         {\cf19 for} ({\cf17 auto}&& it : *current_item.m_value.object)\par
18579                         \{\par
18580                             stack.push_back(std::move(it.second));\par
18581                         \}\par
18582 \par
18583                         current_item.m_value.object->clear();\par
18584                     \}\par
18585 \par
18586                     {\cf20 // it's now safe that current_item get destructed}\par
18587                     {\cf20 // since it doesn't have any children}\par
18588                 \}\par
18589             \}\par
18590 \par
18591             {\cf19 switch} (t)\par
18592             \{\par
18593                 {\cf19 case} value_t::object:\par
18594                 \{\par
18595                     AllocatorType<object_t> alloc;\par
18596                     std::allocator_traits<{\cf17 decltype}(alloc)>::destroy(alloc, {\cf18 object});\par
18597                     std::allocator_traits<{\cf17 decltype}(alloc)>::deallocate(alloc, {\cf18 object}, 1);\par
18598                     {\cf19 break};\par
18599                 \}\par
18600 \par
18601                 {\cf19 case} value_t::array:\par
18602                 \{\par
18603                     AllocatorType<array_t> alloc;\par
18604                     std::allocator_traits<{\cf17 decltype}(alloc)>::destroy(alloc, array);\par
18605                     std::allocator_traits<{\cf17 decltype}(alloc)>::deallocate(alloc, array, 1);\par
18606                     {\cf19 break};\par
18607                 \}\par
18608 \par
18609                 {\cf19 case} value_t::string:\par
18610                 \{\par
18611                     AllocatorType<string_t> alloc;\par
18612                     std::allocator_traits<{\cf17 decltype}(alloc)>::destroy(alloc, {\cf18 string});\par
18613                     std::allocator_traits<{\cf17 decltype}(alloc)>::deallocate(alloc, {\cf18 string}, 1);\par
18614                     {\cf19 break};\par
18615                 \}\par
18616 \par
18617                 {\cf19 case} value_t::binary:\par
18618                 \{\par
18619                     AllocatorType<binary_t> alloc;\par
18620                     std::allocator_traits<{\cf17 decltype}(alloc)>::destroy(alloc, binary);\par
18621                     std::allocator_traits<{\cf17 decltype}(alloc)>::deallocate(alloc, binary, 1);\par
18622                     {\cf19 break};\par
18623                 \}\par
18624 \par
18625                 {\cf19 case} value_t::null:\par
18626                 {\cf19 case} value_t::boolean:\par
18627                 {\cf19 case} value_t::number_integer:\par
18628                 {\cf19 case} value_t::number_unsigned:\par
18629                 {\cf19 case} value_t::number_float:\par
18630                 {\cf19 case} value_t::discarded:\par
18631                 {\cf19 default}:\par
18632                 \{\par
18633                     {\cf19 break};\par
18634                 \}\par
18635             \}\par
18636         \}\par
18637     \};\par
18638 \par
18639   {\cf17 private}:\par
18658     {\cf18 void} assert_invariant({\cf18 bool} check_parents = {\cf17 true}) const noexcept\par
18659     \{\par
18660         JSON_ASSERT(m_type != value_t::object || m_value.object != {\cf17 nullptr});\par
18661         JSON_ASSERT(m_type != value_t::array || m_value.array != {\cf17 nullptr});\par
18662         JSON_ASSERT(m_type != value_t::string || m_value.string != {\cf17 nullptr});\par
18663         JSON_ASSERT(m_type != value_t::binary || m_value.binary != {\cf17 nullptr});\par
18664 \par
18665 {\cf21 #if JSON_DIAGNOSTICS}\par
18666         JSON_TRY\par
18667         \{\par
18668             {\cf20 // cppcheck-suppress assertWithSideEffect}\par
18669             JSON_ASSERT(!check_parents || !is_structured() || std::all_of(begin(), end(), [{\cf17 this}]({\cf17 const} basic_json & j)\par
18670             \{\par
18671                 {\cf19 return} j.m_parent == {\cf17 this};\par
18672             \}));\par
18673         \}\par
18674         JSON_CATCH(...) \{\} {\cf20 // LCOV_EXCL_LINE}\par
18675 {\cf21 #endif}\par
18676         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(check_parents);\par
18677     \}\par
18678 \par
18679     {\cf18 void} set_parents()\par
18680     \{\par
18681 {\cf21 #if JSON_DIAGNOSTICS}\par
18682         {\cf19 switch} (m_type)\par
18683         \{\par
18684             {\cf19 case} value_t::array:\par
18685             \{\par
18686                 {\cf19 for} ({\cf17 auto}& element : *m_value.array)\par
18687                 \{\par
18688                     element.m_parent = {\cf17 this};\par
18689                 \}\par
18690                 {\cf19 break};\par
18691             \}\par
18692 \par
18693             {\cf19 case} value_t::object:\par
18694             \{\par
18695                 {\cf19 for} ({\cf17 auto}& element : *m_value.object)\par
18696                 \{\par
18697                     element.second.m_parent = {\cf17 this};\par
18698                 \}\par
18699                 {\cf19 break};\par
18700             \}\par
18701 \par
18702             {\cf19 case} value_t::null:\par
18703             {\cf19 case} value_t::string:\par
18704             {\cf19 case} value_t::boolean:\par
18705             {\cf19 case} value_t::number_integer:\par
18706             {\cf19 case} value_t::number_unsigned:\par
18707             {\cf19 case} value_t::number_float:\par
18708             {\cf19 case} value_t::binary:\par
18709             {\cf19 case} value_t::discarded:\par
18710             {\cf19 default}:\par
18711                 {\cf19 break};\par
18712         \}\par
18713 {\cf21 #endif}\par
18714     \}\par
18715 \par
18716     iterator set_parents(iterator it, {\cf17 typename} iterator::difference_type count)\par
18717     \{\par
18718 {\cf21 #if JSON_DIAGNOSTICS}\par
18719         {\cf19 for} ({\cf17 typename} iterator::difference_type i = 0; i < count; ++i)\par
18720         \{\par
18721             (it + i)->m_parent = {\cf17 this};\par
18722         \}\par
18723 {\cf21 #else}\par
18724         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(count);\par
18725 {\cf21 #endif}\par
18726         {\cf19 return} it;\par
18727     \}\par
18728 \par
18729     reference set_parent(reference j, std::size_t old_capacity = std::size_t(-1))\par
18730     \{\par
18731 {\cf21 #if JSON_DIAGNOSTICS}\par
18732         {\cf19 if} (old_capacity != std::size_t(-1))\par
18733         \{\par
18734             {\cf20 // see https://github.com/nlohmann/json/issues/2838}\par
18735             JSON_ASSERT(type() == value_t::array);\par
18736             {\cf19 if} (JSON_HEDLEY_UNLIKELY(m_value.array->capacity() != old_capacity))\par
18737             \{\par
18738                 {\cf20 // capacity has changed: update all parents}\par
18739                 set_parents();\par
18740                 {\cf19 return} j;\par
18741             \}\par
18742         \}\par
18743 \par
18744         {\cf20 // ordered_json uses a vector internally, so pointers could have}\par
18745         {\cf20 // been invalidated; see https://github.com/nlohmann/json/issues/2962}\par
18746 {\cf21 #ifdef JSON_HEDLEY_MSVC_VERSION}\par
18747 {\cf21 #pragma warning(push )}\par
18748 {\cf21 #pragma warning(disable : 4127) }{\cf20 // ignore warning to replace if with if constexpr}\par
18749 {\cf21 #endif}\par
18750         {\cf19 if} (detail::is_ordered_map<object_t>::value)\par
18751         \{\par
18752             set_parents();\par
18753             {\cf19 return} j;\par
18754         \}\par
18755 {\cf21 #ifdef JSON_HEDLEY_MSVC_VERSION}\par
18756 {\cf21 #pragma warning( pop )}\par
18757 {\cf21 #endif}\par
18758 \par
18759         j.m_parent = {\cf17 this};\par
18760 {\cf21 #else}\par
18761         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(j);\par
18762         {\cf17 static_cast<}{\cf18 void}{\cf17 >}(old_capacity);\par
18763 {\cf21 #endif}\par
18764         {\cf19 return} j;\par
18765     \}\par
18766 \par
18767   {\cf17 public}:\par
18769     {\cf20 // JSON parser callback //}\par
18771 {\cf20 }\par
18787     {\cf17 using} parse_event_t = detail::parse_event_t;\par
18788 \par
18838     {\cf17 using} parser_callback_t = detail::parser_callback_t<basic_json>;\par
18839 \par
18841     {\cf20 // constructors //}\par
18843 {\cf20 }\par
18848 \par
18879     basic_json({\cf17 const} value_t v)\par
18880         : m_type(v), m_value(v)\par
18881     \{\par
18882         assert_invariant();\par
18883     \}\par
18884 \par
18903     basic_json(std::nullptr_t = {\cf17 nullptr}) noexcept\par
18904         : basic_json(value_t::null)\par
18905     \{\par
18906         assert_invariant();\par
18907     \}\par
18908 \par
18971     {\cf17 template} < {\cf17 typename} CompatibleType,\par
18972                {\cf17 typename} U = detail::uncvref_t<CompatibleType>,\par
18973                detail::enable_if_t <\par
18974                    !detail::is_basic_json<U>::value && detail::is_compatible_type<basic_json_t, U>::value, {\cf18 int} > = 0 >\par
18975     basic_json(CompatibleType && val) {\cf17 noexcept}({\cf17 noexcept}( {\cf20 // NOLINT(bugprone-forwarding-reference-overload,bugprone-exception-escape)}\par
18976                 JSONSerializer<U>::to_json(std::declval<basic_json_t&>(),\par
18977                                            std::forward<CompatibleType>(val))))\par
18978     \{\par
18979         JSONSerializer<U>::to_json(*{\cf17 this}, std::forward<CompatibleType>(val));\par
18980         set_parents();\par
18981         assert_invariant();\par
18982     \}\par
18983 \par
19010     {\cf17 template} < {\cf17 typename} BasicJsonType,\par
19011                detail::enable_if_t <\par
19012                    detail::is_basic_json<BasicJsonType>::value&& !std::is_same<basic_json, BasicJsonType>::value, {\cf18 int} > = 0 >\par
19013     basic_json({\cf17 const} BasicJsonType& val)\par
19014     \{\par
19015         {\cf17 using} other_boolean_t = {\cf17 typename} BasicJsonType::boolean_t;\par
19016         {\cf17 using} other_number_float_t = {\cf17 typename} BasicJsonType::number_float_t;\par
19017         {\cf17 using} other_number_integer_t = {\cf17 typename} BasicJsonType::number_integer_t;\par
19018         {\cf17 using} other_number_unsigned_t = {\cf17 typename} BasicJsonType::number_unsigned_t;\par
19019         {\cf17 using} other_string_t = {\cf17 typename} BasicJsonType::string_t;\par
19020         {\cf17 using} other_object_t = {\cf17 typename} BasicJsonType::object_t;\par
19021         {\cf17 using} other_array_t = {\cf17 typename} BasicJsonType::array_t;\par
19022         {\cf17 using} other_binary_t = {\cf17 typename} BasicJsonType::binary_t;\par
19023 \par
19024         {\cf19 switch} (val.type())\par
19025         \{\par
19026             {\cf19 case} value_t::boolean:\par
19027                 JSONSerializer<other_boolean_t>::to_json(*{\cf17 this}, val.template get<other_boolean_t>());\par
19028                 {\cf19 break};\par
19029             {\cf19 case} value_t::number_float:\par
19030                 JSONSerializer<other_number_float_t>::to_json(*{\cf17 this}, val.template get<other_number_float_t>());\par
19031                 {\cf19 break};\par
19032             {\cf19 case} value_t::number_integer:\par
19033                 JSONSerializer<other_number_integer_t>::to_json(*{\cf17 this}, val.template get<other_number_integer_t>());\par
19034                 {\cf19 break};\par
19035             {\cf19 case} value_t::number_unsigned:\par
19036                 JSONSerializer<other_number_unsigned_t>::to_json(*{\cf17 this}, val.template get<other_number_unsigned_t>());\par
19037                 {\cf19 break};\par
19038             {\cf19 case} value_t::string:\par
19039                 JSONSerializer<other_string_t>::to_json(*{\cf17 this}, val.template get_ref<const other_string_t&>());\par
19040                 {\cf19 break};\par
19041             {\cf19 case} value_t::object:\par
19042                 JSONSerializer<other_object_t>::to_json(*{\cf17 this}, val.template get_ref<const other_object_t&>());\par
19043                 {\cf19 break};\par
19044             {\cf19 case} value_t::array:\par
19045                 JSONSerializer<other_array_t>::to_json(*{\cf17 this}, val.template get_ref<const other_array_t&>());\par
19046                 {\cf19 break};\par
19047             {\cf19 case} value_t::binary:\par
19048                 JSONSerializer<other_binary_t>::to_json(*{\cf17 this}, val.template get_ref<const other_binary_t&>());\par
19049                 {\cf19 break};\par
19050             {\cf19 case} value_t::null:\par
19051                 *{\cf17 this} = {\cf17 nullptr};\par
19052                 {\cf19 break};\par
19053             {\cf19 case} value_t::discarded:\par
19054                 m_type = value_t::discarded;\par
19055                 {\cf19 break};\par
19056             {\cf19 default}:            {\cf20 // LCOV_EXCL_LINE}\par
19057                 JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE}\par
19058         \}\par
19059         set_parents();\par
19060         assert_invariant();\par
19061     \}\par
19062 \par
19137     basic_json(initializer_list_t init,\par
19138                {\cf18 bool} type_deduction = {\cf17 true},\par
19139                value_t manual_type = value_t::array)\par
19140     \{\par
19141         {\cf20 // check if each element is an array with two elements whose first}\par
19142         {\cf20 // element is a string}\par
19143         {\cf18 bool} is_an_object = std::all_of(init.begin(), init.end(),\par
19144                                         []({\cf17 const} detail::json_ref<basic_json>& element_ref)\par
19145         \{\par
19146             return element_ref->is_array() && element_ref->size() == 2 && (*element_ref)[0].is_string();\par
19147         \});\par
19148 \par
19149         {\cf20 // adjust type if type deduction is not wanted}\par
19150         {\cf19 if} (!type_deduction)\par
19151         \{\par
19152             {\cf20 // if array is wanted, do not create an object though possible}\par
19153             {\cf19 if} (manual_type == value_t::array)\par
19154             \{\par
19155                 is_an_object = {\cf17 false};\par
19156             \}\par
19157 \par
19158             {\cf20 // if object is wanted but impossible, throw an exception}\par
19159             {\cf19 if} (JSON_HEDLEY_UNLIKELY(manual_type == value_t::object && !is_an_object))\par
19160             \{\par
19161                 JSON_THROW(type_error::create(301, {\cf22 "cannot create object from initializer list"}, basic_json()));\par
19162             \}\par
19163         \}\par
19164 \par
19165         {\cf19 if} (is_an_object)\par
19166         \{\par
19167             {\cf20 // the initializer list is a list of pairs -> create object}\par
19168             m_type = value_t::object;\par
19169             m_value = value_t::object;\par
19170 \par
19171             {\cf19 for} ({\cf17 auto}& element_ref : init)\par
19172             \{\par
19173                 {\cf17 auto} element = element_ref.moved_or_copied();\par
19174                 m_value.object->emplace(\par
19175                     std::move(*((*element.m_value.array)[0].m_value.string)),\par
19176                     std::move((*element.m_value.array)[1]));\par
19177             \}\par
19178         \}\par
19179         {\cf19 else}\par
19180         \{\par
19181             {\cf20 // the initializer list describes an array -> create array}\par
19182             m_type = value_t::array;\par
19183             m_value.array = create<array_t>(init.begin(), init.end());\par
19184         \}\par
19185 \par
19186         set_parents();\par
19187         assert_invariant();\par
19188     \}\par
19189 \par
19217     JSON_HEDLEY_WARN_UNUSED_RESULT\par
19218     {\cf17 static} basic_json binary({\cf17 const} {\cf17 typename} binary_t::container_type& init)\par
19219     \{\par
19220         {\cf17 auto} res = basic_json();\par
19221         res.m_type = value_t::binary;\par
19222         res.m_value = init;\par
19223         {\cf19 return} res;\par
19224     \}\par
19225 \par
19254     JSON_HEDLEY_WARN_UNUSED_RESULT\par
19255     {\cf17 static} basic_json binary({\cf17 const} {\cf17 typename} binary_t::container_type& init, {\cf17 typename} binary_t::subtype_type subtype)\par
19256     \{\par
19257         {\cf17 auto} res = basic_json();\par
19258         res.m_type = value_t::binary;\par
19259         res.m_value = binary_t(init, subtype);\par
19260         {\cf19 return} res;\par
19261     \}\par
19262 \par
19264     JSON_HEDLEY_WARN_UNUSED_RESULT\par
19265     {\cf17 static} basic_json binary({\cf17 typename} binary_t::container_type&& init)\par
19266     \{\par
19267         {\cf17 auto} res = basic_json();\par
19268         res.m_type = value_t::binary;\par
19269         res.m_value = std::move(init);\par
19270         {\cf19 return} res;\par
19271     \}\par
19272 \par
19274     JSON_HEDLEY_WARN_UNUSED_RESULT\par
19275     {\cf17 static} basic_json binary({\cf17 typename} binary_t::container_type&& init, {\cf17 typename} binary_t::subtype_type subtype)\par
19276     \{\par
19277         {\cf17 auto} res = basic_json();\par
19278         res.m_type = value_t::binary;\par
19279         res.m_value = binary_t(std::move(init), subtype);\par
19280         {\cf19 return} res;\par
19281     \}\par
19282 \par
19320     JSON_HEDLEY_WARN_UNUSED_RESULT\par
19321     {\cf17 static} basic_json array(initializer_list_t init = \{\})\par
19322     \{\par
19323         {\cf19 return} basic_json(init, {\cf17 false}, value_t::array);\par
19324     \}\par
19325 \par
19364     JSON_HEDLEY_WARN_UNUSED_RESULT\par
19365     {\cf17 static} basic_json object(initializer_list_t init = \{\})\par
19366     \{\par
19367         {\cf19 return} basic_json(init, {\cf17 false}, value_t::object);\par
19368     \}\par
19369 \par
19392     basic_json(size_type cnt, {\cf17 const} basic_json& val)\par
19393         : m_type(value_t::array)\par
19394     \{\par
19395         m_value.array = create<array_t>(cnt, val);\par
19396         set_parents();\par
19397         assert_invariant();\par
19398     \}\par
19399 \par
19455     {\cf17 template} < {\cf17 class }InputIT, {\cf17 typename} std::enable_if <\par
19456                    std::is_same<InputIT, typename basic_json_t::iterator>::value ||\par
19457                    std::is_same<InputIT, typename basic_json_t::const_iterator>::value, {\cf18 int} >::type = 0 >\par
19458     basic_json(InputIT first, InputIT last)\par
19459     \{\par
19460         JSON_ASSERT(first.m_object != {\cf17 nullptr});\par
19461         JSON_ASSERT(last.m_object != {\cf17 nullptr});\par
19462 \par
19463         {\cf20 // make sure iterator fits the current value}\par
19464         {\cf19 if} (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))\par
19465         \{\par
19466             JSON_THROW(invalid_iterator::create(201, {\cf22 "iterators are not compatible"}, basic_json()));\par
19467         \}\par
19468 \par
19469         {\cf20 // copy type from first iterator}\par
19470         m_type = first.m_object->m_type;\par
19471 \par
19472         {\cf20 // check if iterator range is complete for primitive values}\par
19473         {\cf19 switch} (m_type)\par
19474         \{\par
19475             {\cf19 case} value_t::boolean:\par
19476             {\cf19 case} value_t::number_float:\par
19477             {\cf19 case} value_t::number_integer:\par
19478             {\cf19 case} value_t::number_unsigned:\par
19479             {\cf19 case} value_t::string:\par
19480             \{\par
19481                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!first.m_it.primitive_iterator.is_begin()\par
19482                                          || !last.m_it.primitive_iterator.is_end()))\par
19483                 \{\par
19484                     JSON_THROW(invalid_iterator::create(204, {\cf22 "iterators out of range"}, *first.m_object));\par
19485                 \}\par
19486                 {\cf19 break};\par
19487             \}\par
19488 \par
19489             {\cf19 case} value_t::null:\par
19490             {\cf19 case} value_t::object:\par
19491             {\cf19 case} value_t::array:\par
19492             {\cf19 case} value_t::binary:\par
19493             {\cf19 case} value_t::discarded:\par
19494             {\cf19 default}:\par
19495                 {\cf19 break};\par
19496         \}\par
19497 \par
19498         {\cf19 switch} (m_type)\par
19499         \{\par
19500             {\cf19 case} value_t::number_integer:\par
19501             \{\par
19502                 m_value.number_integer = first.m_object->m_value.number_integer;\par
19503                 {\cf19 break};\par
19504             \}\par
19505 \par
19506             {\cf19 case} value_t::number_unsigned:\par
19507             \{\par
19508                 m_value.number_unsigned = first.m_object->m_value.number_unsigned;\par
19509                 {\cf19 break};\par
19510             \}\par
19511 \par
19512             {\cf19 case} value_t::number_float:\par
19513             \{\par
19514                 m_value.number_float = first.m_object->m_value.number_float;\par
19515                 {\cf19 break};\par
19516             \}\par
19517 \par
19518             {\cf19 case} value_t::boolean:\par
19519             \{\par
19520                 m_value.boolean = first.m_object->m_value.boolean;\par
19521                 {\cf19 break};\par
19522             \}\par
19523 \par
19524             {\cf19 case} value_t::string:\par
19525             \{\par
19526                 m_value = *first.m_object->m_value.string;\par
19527                 {\cf19 break};\par
19528             \}\par
19529 \par
19530             {\cf19 case} value_t::object:\par
19531             \{\par
19532                 m_value.object = create<object_t>(first.m_it.object_iterator,\par
19533                                                   last.m_it.object_iterator);\par
19534                 {\cf19 break};\par
19535             \}\par
19536 \par
19537             {\cf19 case} value_t::array:\par
19538             \{\par
19539                 m_value.array = create<array_t>(first.m_it.array_iterator,\par
19540                                                 last.m_it.array_iterator);\par
19541                 {\cf19 break};\par
19542             \}\par
19543 \par
19544             {\cf19 case} value_t::binary:\par
19545             \{\par
19546                 m_value = *first.m_object->m_value.binary;\par
19547                 {\cf19 break};\par
19548             \}\par
19549 \par
19550             {\cf19 case} value_t::null:\par
19551             {\cf19 case} value_t::discarded:\par
19552             {\cf19 default}:\par
19553                 JSON_THROW(invalid_iterator::create(206, {\cf22 "cannot construct with iterators from "} + std::string(first.m_object->type_name()), *first.m_object));\par
19554         \}\par
19555 \par
19556         set_parents();\par
19557         assert_invariant();\par
19558     \}\par
19559 \par
19560 \par
19562     {\cf20 // other constructors and destructor //}\par
19564 {\cf20 }\par
19565     {\cf17 template}<{\cf17 typename} JsonRef,\par
19566              detail::enable_if_t<detail::conjunction<detail::is_json_ref<JsonRef>,\par
19567                                  std::is_same<typename JsonRef::value_type, basic_json>>::value, {\cf18 int}> = 0 >\par
19568     basic_json({\cf17 const} JsonRef& ref) : basic_json(ref.moved_or_copied()) \{\}\par
19569 \par
19595     basic_json({\cf17 const} basic_json& other)\par
19596         : m_type(other.m_type)\par
19597     \{\par
19598         {\cf20 // check of passed value is valid}\par
19599         other.assert_invariant();\par
19600 \par
19601         {\cf19 switch} (m_type)\par
19602         \{\par
19603             {\cf19 case} value_t::object:\par
19604             \{\par
19605                 m_value = *other.m_value.object;\par
19606                 {\cf19 break};\par
19607             \}\par
19608 \par
19609             {\cf19 case} value_t::array:\par
19610             \{\par
19611                 m_value = *other.m_value.array;\par
19612                 {\cf19 break};\par
19613             \}\par
19614 \par
19615             {\cf19 case} value_t::string:\par
19616             \{\par
19617                 m_value = *other.m_value.string;\par
19618                 {\cf19 break};\par
19619             \}\par
19620 \par
19621             {\cf19 case} value_t::boolean:\par
19622             \{\par
19623                 m_value = other.m_value.boolean;\par
19624                 {\cf19 break};\par
19625             \}\par
19626 \par
19627             {\cf19 case} value_t::number_integer:\par
19628             \{\par
19629                 m_value = other.m_value.number_integer;\par
19630                 {\cf19 break};\par
19631             \}\par
19632 \par
19633             {\cf19 case} value_t::number_unsigned:\par
19634             \{\par
19635                 m_value = other.m_value.number_unsigned;\par
19636                 {\cf19 break};\par
19637             \}\par
19638 \par
19639             {\cf19 case} value_t::number_float:\par
19640             \{\par
19641                 m_value = other.m_value.number_float;\par
19642                 {\cf19 break};\par
19643             \}\par
19644 \par
19645             {\cf19 case} value_t::binary:\par
19646             \{\par
19647                 m_value = *other.m_value.binary;\par
19648                 {\cf19 break};\par
19649             \}\par
19650 \par
19651             {\cf19 case} value_t::null:\par
19652             {\cf19 case} value_t::discarded:\par
19653             {\cf19 default}:\par
19654                 {\cf19 break};\par
19655         \}\par
19656 \par
19657         set_parents();\par
19658         assert_invariant();\par
19659     \}\par
19660 \par
19687     basic_json(basic_json&& other) noexcept\par
19688         : m_type(std::move(other.m_type)),\par
19689           m_value(std::move(other.m_value))\par
19690     \{\par
19691         {\cf20 // check that passed value is valid}\par
19692         other.assert_invariant({\cf17 false});\par
19693 \par
19694         {\cf20 // invalidate payload}\par
19695         other.m_type = value_t::null;\par
19696         other.m_value = \{\};\par
19697 \par
19698         set_parents();\par
19699         assert_invariant();\par
19700     \}\par
19701 \par
19725     basic_json& operator=(basic_json other) {\cf17 noexcept} (\par
19726         std::is_nothrow_move_constructible<value_t>::value&&\par
19727         std::is_nothrow_move_assignable<value_t>::value&&\par
19728         std::is_nothrow_move_constructible<json_value>::value&&\par
19729         std::is_nothrow_move_assignable<json_value>::value\par
19730     )\par
19731     \{\par
19732         {\cf20 // check that passed value is valid}\par
19733         other.assert_invariant();\par
19734 \par
19735         {\cf17 using} std::swap;\par
19736         swap(m_type, other.m_type);\par
19737         swap(m_value, other.m_value);\par
19738 \par
19739         set_parents();\par
19740         assert_invariant();\par
19741         {\cf19 return} *{\cf17 this};\par
19742     \}\par
19743 \par
19759     ~basic_json() noexcept\par
19760     \{\par
19761         assert_invariant({\cf17 false});\par
19762         m_value.destroy(m_type);\par
19763     \}\par
19764 \par
19766 \par
19767   {\cf17 public}:\par
19769     {\cf20 // object inspection //}\par
19771 {\cf20 }\par
19775 \par
19823     string_t dump({\cf17 const} {\cf18 int} indent = -1,\par
19824                   {\cf17 const} {\cf18 char} indent_char = {\cf23 ' '},\par
19825                   {\cf17 const} {\cf18 bool} ensure_ascii = {\cf17 false},\par
19826                   {\cf17 const} error_handler_t error_handler = error_handler_t::strict){\cf17  const}\par
19827 {\cf17     }\{\par
19828         string_t result;\par
19829         serializer s(detail::output_adapter<char, string_t>(result), indent_char, error_handler);\par
19830 \par
19831         {\cf19 if} (indent >= 0)\par
19832         \{\par
19833             s.dump(*{\cf17 this}, {\cf17 true}, ensure_ascii, {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(indent));\par
19834         \}\par
19835         {\cf19 else}\par
19836         \{\par
19837             s.dump(*{\cf17 this}, {\cf17 false}, ensure_ascii, 0);\par
19838         \}\par
19839 \par
19840         {\cf19 return} result;\par
19841     \}\par
19842 \par
19876     {\cf17 constexpr} value_t type() const noexcept\par
19877     \{\par
19878         {\cf19 return} m_type;\par
19879     \}\par
19880 \par
19907     {\cf17 constexpr} {\cf18 bool} is_primitive() const noexcept\par
19908     \{\par
19909         {\cf19 return} is_null() || is_string() || is_boolean() || is_number() || is_binary();\par
19910     \}\par
19911 \par
19934     {\cf17 constexpr} {\cf18 bool} is_structured() const noexcept\par
19935     \{\par
19936         {\cf19 return} is_array() || is_object();\par
19937     \}\par
19938 \par
19956     {\cf17 constexpr} {\cf18 bool} is_null() const noexcept\par
19957     \{\par
19958         {\cf19 return} m_type == value_t::null;\par
19959     \}\par
19960 \par
19978     {\cf17 constexpr} {\cf18 bool} is_boolean() const noexcept\par
19979     \{\par
19980         {\cf19 return} m_type == value_t::boolean;\par
19981     \}\par
19982 \par
20008     {\cf17 constexpr} {\cf18 bool} is_number() const noexcept\par
20009     \{\par
20010         {\cf19 return} is_number_integer() || is_number_float();\par
20011     \}\par
20012 \par
20037     {\cf17 constexpr} {\cf18 bool} is_number_integer() const noexcept\par
20038     \{\par
20039         {\cf19 return} m_type == value_t::number_integer || m_type == value_t::number_unsigned;\par
20040     \}\par
20041 \par
20065     {\cf17 constexpr} {\cf18 bool} is_number_unsigned() const noexcept\par
20066     \{\par
20067         {\cf19 return} m_type == value_t::number_unsigned;\par
20068     \}\par
20069 \par
20093     {\cf17 constexpr} {\cf18 bool} is_number_float() const noexcept\par
20094     \{\par
20095         {\cf19 return} m_type == value_t::number_float;\par
20096     \}\par
20097 \par
20115     {\cf17 constexpr} {\cf18 bool} is_object() const noexcept\par
20116     \{\par
20117         {\cf19 return} m_type == value_t::object;\par
20118     \}\par
20119 \par
20137     {\cf17 constexpr} {\cf18 bool} is_array() const noexcept\par
20138     \{\par
20139         {\cf19 return} m_type == value_t::array;\par
20140     \}\par
20141 \par
20159     {\cf17 constexpr} {\cf18 bool} is_string() const noexcept\par
20160     \{\par
20161         {\cf19 return} m_type == value_t::string;\par
20162     \}\par
20163 \par
20181     {\cf17 constexpr} {\cf18 bool} is_binary() const noexcept\par
20182     \{\par
20183         {\cf19 return} m_type == value_t::binary;\par
20184     \}\par
20185 \par
20208     {\cf17 constexpr} {\cf18 bool} is_discarded() const noexcept\par
20209     \{\par
20210         {\cf19 return} m_type == value_t::discarded;\par
20211     \}\par
20212 \par
20234     {\cf17 constexpr} {\cf17 operator} value_t() const noexcept\par
20235     \{\par
20236         {\cf19 return} m_type;\par
20237     \}\par
20238 \par
20240 \par
20241   {\cf17 private}:\par
20243     {\cf20 // value access //}\par
20245 {\cf20 }\par
20247     boolean_t get_impl(boolean_t* {\cf20 /*unused*/}){\cf17  const}\par
20248 {\cf17     }\{\par
20249         {\cf19 if} (JSON_HEDLEY_LIKELY(is_boolean()))\par
20250         \{\par
20251             {\cf19 return} m_value.boolean;\par
20252         \}\par
20253 \par
20254         JSON_THROW(type_error::create(302, {\cf22 "type must be boolean, but is "} + std::string(type_name()), *{\cf17 this}));\par
20255     \}\par
20256 \par
20258     object_t* get_impl_ptr(object_t* {\cf20 /*unused*/}) {\cf17 noexcept}\par
20259     \{\par
20260         {\cf19 return} is_object() ? m_value.object : {\cf17 nullptr};\par
20261     \}\par
20262 \par
20264     {\cf17 constexpr} {\cf17 const} object_t* get_impl_ptr({\cf17 const} object_t* {\cf20 /*unused*/}) {\cf17 const} {\cf17 noexcept}\par
20265     \{\par
20266         {\cf19 return} is_object() ? m_value.object : {\cf17 nullptr};\par
20267     \}\par
20268 \par
20270     array_t* get_impl_ptr(array_t* {\cf20 /*unused*/}) {\cf17 noexcept}\par
20271     \{\par
20272         {\cf19 return} is_array() ? m_value.array : {\cf17 nullptr};\par
20273     \}\par
20274 \par
20276     {\cf17 constexpr} {\cf17 const} array_t* get_impl_ptr({\cf17 const} array_t* {\cf20 /*unused*/}) {\cf17 const} {\cf17 noexcept}\par
20277     \{\par
20278         {\cf19 return} is_array() ? m_value.array : {\cf17 nullptr};\par
20279     \}\par
20280 \par
20282     string_t* get_impl_ptr(string_t* {\cf20 /*unused*/}) {\cf17 noexcept}\par
20283     \{\par
20284         {\cf19 return} is_string() ? m_value.string : {\cf17 nullptr};\par
20285     \}\par
20286 \par
20288     {\cf17 constexpr} {\cf17 const} string_t* get_impl_ptr({\cf17 const} string_t* {\cf20 /*unused*/}) {\cf17 const} {\cf17 noexcept}\par
20289     \{\par
20290         {\cf19 return} is_string() ? m_value.string : {\cf17 nullptr};\par
20291     \}\par
20292 \par
20294     boolean_t* get_impl_ptr(boolean_t* {\cf20 /*unused*/}) {\cf17 noexcept}\par
20295     \{\par
20296         {\cf19 return} is_boolean() ? &m_value.boolean : {\cf17 nullptr};\par
20297     \}\par
20298 \par
20300     {\cf17 constexpr} {\cf17 const} boolean_t* get_impl_ptr({\cf17 const} boolean_t* {\cf20 /*unused*/}) {\cf17 const} {\cf17 noexcept}\par
20301     \{\par
20302         {\cf19 return} is_boolean() ? &m_value.boolean : {\cf17 nullptr};\par
20303     \}\par
20304 \par
20306     number_integer_t* get_impl_ptr(number_integer_t* {\cf20 /*unused*/}) {\cf17 noexcept}\par
20307     \{\par
20308         {\cf19 return} is_number_integer() ? &m_value.number_integer : {\cf17 nullptr};\par
20309     \}\par
20310 \par
20312     {\cf17 constexpr} {\cf17 const} number_integer_t* get_impl_ptr({\cf17 const} number_integer_t* {\cf20 /*unused*/}) {\cf17 const} {\cf17 noexcept}\par
20313     \{\par
20314         {\cf19 return} is_number_integer() ? &m_value.number_integer : {\cf17 nullptr};\par
20315     \}\par
20316 \par
20318     number_unsigned_t* get_impl_ptr(number_unsigned_t* {\cf20 /*unused*/}) {\cf17 noexcept}\par
20319     \{\par
20320         {\cf19 return} is_number_unsigned() ? &m_value.number_unsigned : {\cf17 nullptr};\par
20321     \}\par
20322 \par
20324     {\cf17 constexpr} {\cf17 const} number_unsigned_t* get_impl_ptr({\cf17 const} number_unsigned_t* {\cf20 /*unused*/}) {\cf17 const} {\cf17 noexcept}\par
20325     \{\par
20326         {\cf19 return} is_number_unsigned() ? &m_value.number_unsigned : {\cf17 nullptr};\par
20327     \}\par
20328 \par
20330     number_float_t* get_impl_ptr(number_float_t* {\cf20 /*unused*/}) {\cf17 noexcept}\par
20331     \{\par
20332         {\cf19 return} is_number_float() ? &m_value.number_float : {\cf17 nullptr};\par
20333     \}\par
20334 \par
20336     {\cf17 constexpr} {\cf17 const} number_float_t* get_impl_ptr({\cf17 const} number_float_t* {\cf20 /*unused*/}) {\cf17 const} {\cf17 noexcept}\par
20337     \{\par
20338         {\cf19 return} is_number_float() ? &m_value.number_float : {\cf17 nullptr};\par
20339     \}\par
20340 \par
20342     binary_t* get_impl_ptr(binary_t* {\cf20 /*unused*/}) {\cf17 noexcept}\par
20343     \{\par
20344         {\cf19 return} is_binary() ? m_value.binary : {\cf17 nullptr};\par
20345     \}\par
20346 \par
20348     {\cf17 constexpr} {\cf17 const} binary_t* get_impl_ptr({\cf17 const} binary_t* {\cf20 /*unused*/}) {\cf17 const} {\cf17 noexcept}\par
20349     \{\par
20350         {\cf19 return} is_binary() ? m_value.binary : {\cf17 nullptr};\par
20351     \}\par
20352 \par
20364     {\cf17 template}<{\cf17 typename} ReferenceType, {\cf17 typename} ThisType>\par
20365     {\cf17 static} ReferenceType get_ref_impl(ThisType& obj)\par
20366     \{\par
20367         {\cf20 // delegate the call to get_ptr<>()}\par
20368         {\cf17 auto}* ptr = obj.template get_ptr<typename std::add_pointer<ReferenceType>::type>();\par
20369 \par
20370         {\cf19 if} (JSON_HEDLEY_LIKELY(ptr != {\cf17 nullptr}))\par
20371         \{\par
20372             {\cf19 return} *ptr;\par
20373         \}\par
20374 \par
20375         JSON_THROW(type_error::create(303, {\cf22 "incompatible ReferenceType for get_ref, actual type is "} + std::string(obj.type_name()), obj));\par
20376     \}\par
20377 \par
20378   {\cf17 public}:\par
20382 \par
20409     {\cf17 template}<{\cf17 typename} PointerType, {\cf17 typename} std::enable_if<\par
20410                  std::is_pointer<PointerType>::value, {\cf18 int}>::type = 0>\par
20411     {\cf17 auto} get_ptr() noexcept -> decltype(std::declval<basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))\par
20412     \{\par
20413         {\cf20 // delegate the call to get_impl_ptr<>()}\par
20414         {\cf19 return} get_impl_ptr({\cf17 static_cast<}PointerType{\cf17 >}({\cf17 nullptr}));\par
20415     \}\par
20416 \par
20421     {\cf17 template} < {\cf17 typename} PointerType, {\cf17 typename} std::enable_if <\par
20422                    std::is_pointer<PointerType>::value&&\par
20423                    std::is_const<typename std::remove_pointer<PointerType>::type>::value, {\cf18 int} >::type = 0 >\par
20424     {\cf17 constexpr} {\cf17 auto} get_ptr() const noexcept -> decltype(std::declval<const basic_json_t&>().get_impl_ptr(std::declval<PointerType>()))\par
20425     \{\par
20426         {\cf20 // delegate the call to get_impl_ptr<>() const}\par
20427         {\cf19 return} get_impl_ptr({\cf17 static_cast<}PointerType{\cf17 >}({\cf17 nullptr}));\par
20428     \}\par
20429 \par
20430   {\cf17 private}:\par
20469     {\cf17 template} < {\cf17 typename} ValueType,\par
20470                detail::enable_if_t <\par
20471                    detail::is_default_constructible<ValueType>::value&&\par
20472                    detail::has_from_json<basic_json_t, ValueType>::value,\par
20473                    {\cf18 int} > = 0 >\par
20474     ValueType get_impl(detail::priority_tag<0> {\cf20 /*unused*/}) {\cf17 const} {\cf17 noexcept}({\cf17 noexcept}(\par
20475                 JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), std::declval<ValueType&>())))\par
20476     \{\par
20477         ValueType ret\{\};\par
20478         JSONSerializer<ValueType>::from_json(*{\cf17 this}, ret);\par
20479         {\cf19 return} ret;\par
20480     \}\par
20481 \par
20512     {\cf17 template} < {\cf17 typename} ValueType,\par
20513                detail::enable_if_t <\par
20514                    detail::has_non_default_from_json<basic_json_t, ValueType>::value,\par
20515                    {\cf18 int} > = 0 >\par
20516     ValueType get_impl(detail::priority_tag<1> {\cf20 /*unused*/}) {\cf17 const} {\cf17 noexcept}({\cf17 noexcept}(\par
20517                 JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>())))\par
20518     \{\par
20519         {\cf19 return} JSONSerializer<ValueType>::from_json(*{\cf17 this});\par
20520     \}\par
20521 \par
20537     {\cf17 template} < {\cf17 typename} BasicJsonType,\par
20538                detail::enable_if_t <\par
20539                    detail::is_basic_json<BasicJsonType>::value,\par
20540                    {\cf18 int} > = 0 >\par
20541     BasicJsonType get_impl(detail::priority_tag<2> {\cf20 /*unused*/}){\cf17  const}\par
20542 {\cf17     }\{\par
20543         {\cf19 return} *{\cf17 this};\par
20544     \}\par
20545 \par
20560     {\cf17 template}<{\cf17 typename} BasicJsonType,\par
20561              detail::enable_if_t<\par
20562                  std::is_same<BasicJsonType, basic_json_t>::value,\par
20563                  {\cf18 int}> = 0>\par
20564     basic_json get_impl(detail::priority_tag<3> {\cf20 /*unused*/}){\cf17  const}\par
20565 {\cf17     }\{\par
20566         {\cf19 return} *{\cf17 this};\par
20567     \}\par
20568 \par
20573     {\cf17 template}<{\cf17 typename} PointerType,\par
20574              detail::enable_if_t<\par
20575                  std::is_pointer<PointerType>::value,\par
20576                  {\cf18 int}> = 0>\par
20577     {\cf17 constexpr} {\cf17 auto} get_impl(detail::priority_tag<4> {\cf20 /*unused*/}) {\cf17 const} {\cf17 noexcept}\par
20578     -> {\cf17 decltype}(std::declval<const basic_json_t&>().template get_ptr<PointerType>())\par
20579     \{\par
20580         {\cf20 // delegate the call to get_ptr}\par
20581         {\cf19 return} get_ptr<PointerType>();\par
20582     \}\par
20583 \par
20584   {\cf17 public}:\par
20608     {\cf17 template} < {\cf17 typename} ValueTypeCV, {\cf17 typename} ValueType = detail::uncvref_t<ValueTypeCV>>\par
20609 {\cf21 #if defined(JSON_HAS_CPP_14)}\par
20610     {\cf17 constexpr}\par
20611 {\cf21 #endif}\par
20612     {\cf17 auto} get() const noexcept(\par
20613     noexcept(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> \{\})))\par
20614     -> {\cf17 decltype}(std::declval<const basic_json_t&>().template get_impl<ValueType>(detail::priority_tag<4> \{\}))\par
20615     \{\par
20616         {\cf20 // we cannot static_assert on ValueTypeCV being non-const, because}\par
20617         {\cf20 // there is support for get<const basic_json_t>(), which is why we}\par
20618         {\cf20 // still need the uncvref}\par
20619         {\cf17 static_assert}(!std::is_reference<ValueTypeCV>::value,\par
20620                       {\cf22 "get() cannot be used with reference types, you might want to use get_ref()"});\par
20621         {\cf19 return} get_impl<ValueType>(detail::priority_tag<4> \{\});\par
20622     \}\par
20623 \par
20651     {\cf17 template}<{\cf17 typename} PointerType, {\cf17 typename} std::enable_if<\par
20652                  std::is_pointer<PointerType>::value, {\cf18 int}>::type = 0>\par
20653     {\cf17 auto} get() noexcept -> decltype(std::declval<basic_json_t&>().template get_ptr<PointerType>())\par
20654     \{\par
20655         {\cf20 // delegate the call to get_ptr}\par
20656         {\cf19 return} get_ptr<PointerType>();\par
20657     \}\par
20658 \par
20692     {\cf17 template} < {\cf17 typename} ValueType,\par
20693                detail::enable_if_t <\par
20694                    !detail::is_basic_json<ValueType>::value&&\par
20695                    detail::has_from_json<basic_json_t, ValueType>::value,\par
20696                    {\cf18 int} > = 0 >\par
20697     ValueType & get_to(ValueType& v) {\cf17 const} {\cf17 noexcept}({\cf17 noexcept}(\par
20698                 JSONSerializer<ValueType>::from_json(std::declval<const basic_json_t&>(), v)))\par
20699     \{\par
20700         JSONSerializer<ValueType>::from_json(*{\cf17 this}, v);\par
20701         {\cf19 return} v;\par
20702     \}\par
20703 \par
20704     {\cf20 // specialization to allow to call get_to with a basic_json value}\par
20705     {\cf20 // see https://github.com/nlohmann/json/issues/2175}\par
20706     {\cf17 template}<{\cf17 typename} ValueType,\par
20707              detail::enable_if_t <\par
20708                  detail::is_basic_json<ValueType>::value,\par
20709                  {\cf18 int}> = 0>\par
20710     ValueType & get_to(ValueType& v){\cf17  const}\par
20711 {\cf17     }\{\par
20712         v = *{\cf17 this};\par
20713         {\cf19 return} v;\par
20714     \}\par
20715 \par
20716     {\cf17 template} <\par
20717         {\cf17 typename} T, std::size_t N,\par
20718         {\cf17 typename} Array = T (&)[N], {\cf20 // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)}\par
20719         detail::enable_if_t <\par
20720             detail::has_from_json<basic_json_t, Array>::value, {\cf18 int} > = 0 >\par
20721     Array get_to(T (&v)[N]) {\cf17 const} {\cf20 // NOLINT(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)}\par
20722     {\cf17 noexcept}({\cf17 noexcept}(JSONSerializer<Array>::from_json(\par
20723                           std::declval<const basic_json_t&>(), v)))\par
20724     \{\par
20725         JSONSerializer<Array>::from_json(*{\cf17 this}, v);\par
20726         {\cf19 return} v;\par
20727     \}\par
20728 \par
20755     {\cf17 template}<{\cf17 typename} ReferenceType, {\cf17 typename} std::enable_if<\par
20756                  std::is_reference<ReferenceType>::value, {\cf18 int}>::type = 0>\par
20757     ReferenceType get_ref()\par
20758     \{\par
20759         {\cf20 // delegate call to get_ref_impl}\par
20760         {\cf19 return} get_ref_impl<ReferenceType>(*{\cf17 this});\par
20761     \}\par
20762 \par
20767     {\cf17 template} < {\cf17 typename} ReferenceType, {\cf17 typename} std::enable_if <\par
20768                    std::is_reference<ReferenceType>::value&&\par
20769                    std::is_const<typename std::remove_reference<ReferenceType>::type>::value, {\cf18 int} >::type = 0 >\par
20770     ReferenceType get_ref(){\cf17  const}\par
20771 {\cf17     }\{\par
20772         {\cf20 // delegate call to get_ref_impl}\par
20773         {\cf19 return} get_ref_impl<ReferenceType>(*{\cf17 this});\par
20774     \}\par
20775 \par
20805     {\cf17 template} < {\cf17 typename} ValueType, {\cf17 typename} std::enable_if <\par
20806                    detail::conjunction <\par
20807                        detail::negation<std::is_pointer<ValueType>>,\par
20808                        detail::negation<std::is_same<ValueType, detail::json_ref<basic_json>>>,\par
20809                                         detail::negation<std::is_same<ValueType, typename string_t::value_type>>,\par
20810                                         detail::negation<detail::is_basic_json<ValueType>>,\par
20811                                         detail::negation<std::is_same<ValueType, std::initializer_list<typename string_t::value_type>>>,\par
20812 \par
20813 {\cf21 #if defined(JSON_HAS_CPP_17) && (defined(__GNUC__) || (defined(_MSC_VER) && _MSC_VER >= 1910 && _MSC_VER <= 1914))}\par
20814                                                 detail::negation<std::is_same<ValueType, std::string_view>>,\par
20815 {\cf21 #endif}\par
20816                                                 detail::is_detected_lazy<detail::get_template_function, const basic_json_t&, ValueType>\par
20817                                                 >::value, {\cf18 int} >::type = 0 >\par
20818                                         JSON_EXPLICIT {\cf17 operator} ValueType(){\cf17  const}\par
20819 {\cf17     }\{\par
20820         {\cf20 // delegate the call to get<>() const}\par
20821         {\cf19 return} get<ValueType>();\par
20822     \}\par
20823 \par
20833     binary_t& get_binary()\par
20834     \{\par
20835         {\cf19 if} (!is_binary())\par
20836         \{\par
20837             JSON_THROW(type_error::create(302, {\cf22 "type must be binary, but is "} + std::string(type_name()), *{\cf17 this}));\par
20838         \}\par
20839 \par
20840         {\cf19 return} *get_ptr<binary_t*>();\par
20841     \}\par
20842 \par
20844     {\cf17 const} binary_t& get_binary(){\cf17  const}\par
20845 {\cf17     }\{\par
20846         {\cf19 if} (!is_binary())\par
20847         \{\par
20848             JSON_THROW(type_error::create(302, {\cf22 "type must be binary, but is "} + std::string(type_name()), *{\cf17 this}));\par
20849         \}\par
20850 \par
20851         {\cf19 return} *get_ptr<const binary_t*>();\par
20852     \}\par
20853 \par
20855 \par
20856 \par
20858     {\cf20 // element access //}\par
20860 {\cf20 }\par
20864 \par
20891     reference at(size_type idx)\par
20892     \{\par
20893         {\cf20 // at only works for arrays}\par
20894         {\cf19 if} (JSON_HEDLEY_LIKELY(is_array()))\par
20895         \{\par
20896             JSON_TRY\par
20897             \{\par
20898                 {\cf19 return} set_parent(m_value.array->at(idx));\par
20899             \}\par
20900             JSON_CATCH (std::out_of_range&)\par
20901             \{\par
20902                 {\cf20 // create better exception explanation}\par
20903                 JSON_THROW(out_of_range::create(401, {\cf22 "array index "} + std::to_string(idx) + {\cf22 " is out of range"}, *{\cf17 this}));\par
20904             \}\par
20905         \}\par
20906         {\cf19 else}\par
20907         \{\par
20908             JSON_THROW(type_error::create(304, {\cf22 "cannot use at() with "} + std::string(type_name()), *{\cf17 this}));\par
20909         \}\par
20910     \}\par
20911 \par
20938     const_reference at(size_type idx){\cf17  const}\par
20939 {\cf17     }\{\par
20940         {\cf20 // at only works for arrays}\par
20941         {\cf19 if} (JSON_HEDLEY_LIKELY(is_array()))\par
20942         \{\par
20943             JSON_TRY\par
20944             \{\par
20945                 {\cf19 return} m_value.array->at(idx);\par
20946             \}\par
20947             JSON_CATCH (std::out_of_range&)\par
20948             \{\par
20949                 {\cf20 // create better exception explanation}\par
20950                 JSON_THROW(out_of_range::create(401, {\cf22 "array index "} + std::to_string(idx) + {\cf22 " is out of range"}, *{\cf17 this}));\par
20951             \}\par
20952         \}\par
20953         {\cf19 else}\par
20954         \{\par
20955             JSON_THROW(type_error::create(304, {\cf22 "cannot use at() with "} + std::string(type_name()), *{\cf17 this}));\par
20956         \}\par
20957     \}\par
20958 \par
20989     reference at({\cf17 const} {\cf17 typename} object_t::key_type& key)\par
20990     \{\par
20991         {\cf20 // at only works for objects}\par
20992         {\cf19 if} (JSON_HEDLEY_LIKELY(is_object()))\par
20993         \{\par
20994             JSON_TRY\par
20995             \{\par
20996                 {\cf19 return} set_parent(m_value.object->at(key));\par
20997             \}\par
20998             JSON_CATCH (std::out_of_range&)\par
20999             \{\par
21000                 {\cf20 // create better exception explanation}\par
21001                 JSON_THROW(out_of_range::create(403, {\cf22 "key '"} + key + {\cf22 "' not found"}, *{\cf17 this}));\par
21002             \}\par
21003         \}\par
21004         {\cf19 else}\par
21005         \{\par
21006             JSON_THROW(type_error::create(304, {\cf22 "cannot use at() with "} + std::string(type_name()), *{\cf17 this}));\par
21007         \}\par
21008     \}\par
21009 \par
21040     const_reference at({\cf17 const} {\cf17 typename} object_t::key_type& key){\cf17  const}\par
21041 {\cf17     }\{\par
21042         {\cf20 // at only works for objects}\par
21043         {\cf19 if} (JSON_HEDLEY_LIKELY(is_object()))\par
21044         \{\par
21045             JSON_TRY\par
21046             \{\par
21047                 {\cf19 return} m_value.object->at(key);\par
21048             \}\par
21049             JSON_CATCH (std::out_of_range&)\par
21050             \{\par
21051                 {\cf20 // create better exception explanation}\par
21052                 JSON_THROW(out_of_range::create(403, {\cf22 "key '"} + key + {\cf22 "' not found"}, *{\cf17 this}));\par
21053             \}\par
21054         \}\par
21055         {\cf19 else}\par
21056         \{\par
21057             JSON_THROW(type_error::create(304, {\cf22 "cannot use at() with "} + std::string(type_name()), *{\cf17 this}));\par
21058         \}\par
21059     \}\par
21060 \par
21086     reference operator[](size_type idx)\par
21087     \{\par
21088         {\cf20 // implicitly convert null value to an empty array}\par
21089         {\cf19 if} (is_null())\par
21090         \{\par
21091             m_type = value_t::array;\par
21092             m_value.array = create<array_t>();\par
21093             assert_invariant();\par
21094         \}\par
21095 \par
21096         {\cf20 // operator[] only works for arrays}\par
21097         {\cf19 if} (JSON_HEDLEY_LIKELY(is_array()))\par
21098         \{\par
21099             {\cf20 // fill up array with null values if given idx is outside range}\par
21100             {\cf19 if} (idx >= m_value.array->size())\par
21101             \{\par
21102 {\cf21 #if JSON_DIAGNOSTICS}\par
21103                 {\cf20 // remember array size before resizing}\par
21104                 {\cf17 const} {\cf17 auto} previous_size = m_value.array->size();\par
21105 {\cf21 #endif}\par
21106                 m_value.array->resize(idx + 1);\par
21107 \par
21108 {\cf21 #if JSON_DIAGNOSTICS}\par
21109                 {\cf20 // set parent for values added above}\par
21110                 set_parents(begin() + {\cf17 static_cast<}typename iterator::difference_type{\cf17 >}(previous_size), {\cf17 static_cast<}typename iterator::difference_type{\cf17 >}(idx + 1 - previous_size));\par
21111 {\cf21 #endif}\par
21112             \}\par
21113 \par
21114             {\cf19 return} m_value.array->operator[](idx);\par
21115         \}\par
21116 \par
21117         JSON_THROW(type_error::create(305, {\cf22 "cannot use operator[] with a numeric argument with "} + std::string(type_name()), *{\cf17 this}));\par
21118     \}\par
21119 \par
21139     const_reference operator[](size_type idx){\cf17  const}\par
21140 {\cf17     }\{\par
21141         {\cf20 // const operator[] only works for arrays}\par
21142         {\cf19 if} (JSON_HEDLEY_LIKELY(is_array()))\par
21143         \{\par
21144             {\cf19 return} m_value.array->operator[](idx);\par
21145         \}\par
21146 \par
21147         JSON_THROW(type_error::create(305, {\cf22 "cannot use operator[] with a numeric argument with "} + std::string(type_name()), *{\cf17 this}));\par
21148     \}\par
21149 \par
21177     reference operator[]({\cf17 const} {\cf17 typename} object_t::key_type& key)\par
21178     \{\par
21179         {\cf20 // implicitly convert null value to an empty object}\par
21180         {\cf19 if} (is_null())\par
21181         \{\par
21182             m_type = value_t::object;\par
21183             m_value.object = create<object_t>();\par
21184             assert_invariant();\par
21185         \}\par
21186 \par
21187         {\cf20 // operator[] only works for objects}\par
21188         {\cf19 if} (JSON_HEDLEY_LIKELY(is_object()))\par
21189         \{\par
21190             {\cf19 return} set_parent(m_value.object->operator[](key));\par
21191         \}\par
21192 \par
21193         JSON_THROW(type_error::create(305, {\cf22 "cannot use operator[] with a string argument with "} + std::string(type_name()), *{\cf17 this}));\par
21194     \}\par
21195 \par
21226     const_reference operator[]({\cf17 const} {\cf17 typename} object_t::key_type& key){\cf17  const}\par
21227 {\cf17     }\{\par
21228         {\cf20 // const operator[] only works for objects}\par
21229         {\cf19 if} (JSON_HEDLEY_LIKELY(is_object()))\par
21230         \{\par
21231             JSON_ASSERT(m_value.object->find(key) != m_value.object->end());\par
21232             {\cf19 return} m_value.object->find(key)->second;\par
21233         \}\par
21234 \par
21235         JSON_THROW(type_error::create(305, {\cf22 "cannot use operator[] with a string argument with "} + std::string(type_name()), *{\cf17 this}));\par
21236     \}\par
21237 \par
21265     {\cf17 template}<{\cf17 typename} T>\par
21266     JSON_HEDLEY_NON_NULL(2)\par
21267     reference operator[](T* key)\par
21268     \{\par
21269         {\cf20 // implicitly convert null to object}\par
21270         {\cf19 if} (is_null())\par
21271         \{\par
21272             m_type = value_t::object;\par
21273             m_value = value_t::object;\par
21274             assert_invariant();\par
21275         \}\par
21276 \par
21277         {\cf20 // at only works for objects}\par
21278         {\cf19 if} (JSON_HEDLEY_LIKELY(is_object()))\par
21279         \{\par
21280             {\cf19 return} set_parent(m_value.object->operator[](key));\par
21281         \}\par
21282 \par
21283         JSON_THROW(type_error::create(305, {\cf22 "cannot use operator[] with a string argument with "} + std::string(type_name()), *{\cf17 this}));\par
21284     \}\par
21285 \par
21316     {\cf17 template}<{\cf17 typename} T>\par
21317     JSON_HEDLEY_NON_NULL(2)\par
21318     const_reference operator[](T* key){\cf17  const}\par
21319 {\cf17     }\{\par
21320         {\cf20 // at only works for objects}\par
21321         {\cf19 if} (JSON_HEDLEY_LIKELY(is_object()))\par
21322         \{\par
21323             JSON_ASSERT(m_value.object->find(key) != m_value.object->end());\par
21324             {\cf19 return} m_value.object->find(key)->second;\par
21325         \}\par
21326 \par
21327         JSON_THROW(type_error::create(305, {\cf22 "cannot use operator[] with a string argument with "} + std::string(type_name()), *{\cf17 this}));\par
21328     \}\par
21329 \par
21380     {\cf20 // using std::is_convertible in a std::enable_if will fail when using explicit conversions}\par
21381     {\cf17 template} < {\cf17 class }ValueType, {\cf17 typename} std::enable_if <\par
21382                    detail::is_getable<basic_json_t, ValueType>::value\par
21383                    && !std::is_same<value_t, ValueType>::value, {\cf18 int} >::type = 0 >\par
21384     ValueType value({\cf17 const} {\cf17 typename} object_t::key_type& key, {\cf17 const} ValueType& default_value){\cf17  const}\par
21385 {\cf17     }\{\par
21386         {\cf20 // at only works for objects}\par
21387         {\cf19 if} (JSON_HEDLEY_LIKELY(is_object()))\par
21388         \{\par
21389             {\cf20 // if key is found, return value and given default value otherwise}\par
21390             {\cf17 const} {\cf17 auto} it = find(key);\par
21391             {\cf19 if} (it != end())\par
21392             \{\par
21393                 {\cf19 return} it->template get<ValueType>();\par
21394             \}\par
21395 \par
21396             {\cf19 return} default_value;\par
21397         \}\par
21398 \par
21399         JSON_THROW(type_error::create(306, {\cf22 "cannot use value() with "} + std::string(type_name()), *{\cf17 this}));\par
21400     \}\par
21401 \par
21406     string_t value({\cf17 const} {\cf17 typename} object_t::key_type& key, {\cf17 const} {\cf18 char}* default_value){\cf17  const}\par
21407 {\cf17     }\{\par
21408         {\cf19 return} value(key, string_t(default_value));\par
21409     \}\par
21410 \par
21454     {\cf17 template}<{\cf17 class }ValueType, {\cf17 typename} std::enable_if<\par
21455                  detail::is_getable<basic_json_t, ValueType>::value, {\cf18 int}>::type = 0>\par
21456     ValueType value({\cf17 const} json_pointer& ptr, {\cf17 const} ValueType& default_value){\cf17  const}\par
21457 {\cf17     }\{\par
21458         {\cf20 // at only works for objects}\par
21459         {\cf19 if} (JSON_HEDLEY_LIKELY(is_object()))\par
21460         \{\par
21461             {\cf20 // if pointer resolves a value, return it or use default value}\par
21462             JSON_TRY\par
21463             \{\par
21464                 {\cf19 return} ptr.get_checked({\cf17 this}).template get<ValueType>();\par
21465             \}\par
21466             JSON_INTERNAL_CATCH (out_of_range&)\par
21467             \{\par
21468                 {\cf19 return} default_value;\par
21469             \}\par
21470         \}\par
21471 \par
21472         JSON_THROW(type_error::create(306, {\cf22 "cannot use value() with "} + std::string(type_name()), *{\cf17 this}));\par
21473     \}\par
21474 \par
21479     JSON_HEDLEY_NON_NULL(3)\par
21480     string_t value(const json_pointer& ptr, const {\cf18 char}* default_value){\cf17  const}\par
21481 {\cf17     }\{\par
21482         {\cf19 return} value(ptr, string_t(default_value));\par
21483     \}\par
21484 \par
21510     reference front()\par
21511     \{\par
21512         {\cf19 return} *begin();\par
21513     \}\par
21514 \par
21518     const_reference front(){\cf17  const}\par
21519 {\cf17     }\{\par
21520         {\cf19 return} *cbegin();\par
21521     \}\par
21522 \par
21554     reference back()\par
21555     \{\par
21556         {\cf17 auto} tmp = end();\par
21557         --tmp;\par
21558         {\cf19 return} *tmp;\par
21559     \}\par
21560 \par
21564     const_reference back(){\cf17  const}\par
21565 {\cf17     }\{\par
21566         {\cf17 auto} tmp = cend();\par
21567         --tmp;\par
21568         {\cf19 return} *tmp;\par
21569     \}\par
21570 \par
21617     {\cf17 template} < {\cf17 class }IteratorType, {\cf17 typename} std::enable_if <\par
21618                    std::is_same<IteratorType, typename basic_json_t::iterator>::value ||\par
21619                    std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, {\cf18 int} >::type\par
21620                = 0 >\par
21621     IteratorType erase(IteratorType pos)\par
21622     \{\par
21623         {\cf20 // make sure iterator fits the current value}\par
21624         {\cf19 if} (JSON_HEDLEY_UNLIKELY({\cf17 this} != pos.m_object))\par
21625         \{\par
21626             JSON_THROW(invalid_iterator::create(202, {\cf22 "iterator does not fit current value"}, *{\cf17 this}));\par
21627         \}\par
21628 \par
21629         IteratorType result = end();\par
21630 \par
21631         {\cf19 switch} (m_type)\par
21632         \{\par
21633             {\cf19 case} value_t::boolean:\par
21634             {\cf19 case} value_t::number_float:\par
21635             {\cf19 case} value_t::number_integer:\par
21636             {\cf19 case} value_t::number_unsigned:\par
21637             {\cf19 case} value_t::string:\par
21638             {\cf19 case} value_t::binary:\par
21639             \{\par
21640                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(!pos.m_it.primitive_iterator.is_begin()))\par
21641                 \{\par
21642                     JSON_THROW(invalid_iterator::create(205, {\cf22 "iterator out of range"}, *{\cf17 this}));\par
21643                 \}\par
21644 \par
21645                 {\cf19 if} (is_string())\par
21646                 \{\par
21647                     AllocatorType<string_t> alloc;\par
21648                     std::allocator_traits<{\cf17 decltype}(alloc)>::destroy(alloc, m_value.string);\par
21649                     std::allocator_traits<{\cf17 decltype}(alloc)>::deallocate(alloc, m_value.string, 1);\par
21650                     m_value.string = {\cf17 nullptr};\par
21651                 \}\par
21652                 {\cf19 else} {\cf19 if} (is_binary())\par
21653                 \{\par
21654                     AllocatorType<binary_t> alloc;\par
21655                     std::allocator_traits<{\cf17 decltype}(alloc)>::destroy(alloc, m_value.binary);\par
21656                     std::allocator_traits<{\cf17 decltype}(alloc)>::deallocate(alloc, m_value.binary, 1);\par
21657                     m_value.binary = {\cf17 nullptr};\par
21658                 \}\par
21659 \par
21660                 m_type = value_t::null;\par
21661                 assert_invariant();\par
21662                 {\cf19 break};\par
21663             \}\par
21664 \par
21665             {\cf19 case} value_t::object:\par
21666             \{\par
21667                 result.m_it.object_iterator = m_value.object->erase(pos.m_it.object_iterator);\par
21668                 {\cf19 break};\par
21669             \}\par
21670 \par
21671             {\cf19 case} value_t::array:\par
21672             \{\par
21673                 result.m_it.array_iterator = m_value.array->erase(pos.m_it.array_iterator);\par
21674                 {\cf19 break};\par
21675             \}\par
21676 \par
21677             {\cf19 case} value_t::null:\par
21678             {\cf19 case} value_t::discarded:\par
21679             {\cf19 default}:\par
21680                 JSON_THROW(type_error::create(307, {\cf22 "cannot use erase() with "} + std::string(type_name()), *{\cf17 this}));\par
21681         \}\par
21682 \par
21683         {\cf19 return} result;\par
21684     \}\par
21685 \par
21732     {\cf17 template} < {\cf17 class }IteratorType, {\cf17 typename} std::enable_if <\par
21733                    std::is_same<IteratorType, typename basic_json_t::iterator>::value ||\par
21734                    std::is_same<IteratorType, typename basic_json_t::const_iterator>::value, {\cf18 int} >::type\par
21735                = 0 >\par
21736     IteratorType erase(IteratorType first, IteratorType last)\par
21737     \{\par
21738         {\cf20 // make sure iterator fits the current value}\par
21739         {\cf19 if} (JSON_HEDLEY_UNLIKELY({\cf17 this} != first.m_object || {\cf17 this} != last.m_object))\par
21740         \{\par
21741             JSON_THROW(invalid_iterator::create(203, {\cf22 "iterators do not fit current value"}, *{\cf17 this}));\par
21742         \}\par
21743 \par
21744         IteratorType result = end();\par
21745 \par
21746         {\cf19 switch} (m_type)\par
21747         \{\par
21748             {\cf19 case} value_t::boolean:\par
21749             {\cf19 case} value_t::number_float:\par
21750             {\cf19 case} value_t::number_integer:\par
21751             {\cf19 case} value_t::number_unsigned:\par
21752             {\cf19 case} value_t::string:\par
21753             {\cf19 case} value_t::binary:\par
21754             \{\par
21755                 {\cf19 if} (JSON_HEDLEY_LIKELY(!first.m_it.primitive_iterator.is_begin()\par
21756                                        || !last.m_it.primitive_iterator.is_end()))\par
21757                 \{\par
21758                     JSON_THROW(invalid_iterator::create(204, {\cf22 "iterators out of range"}, *{\cf17 this}));\par
21759                 \}\par
21760 \par
21761                 {\cf19 if} (is_string())\par
21762                 \{\par
21763                     AllocatorType<string_t> alloc;\par
21764                     std::allocator_traits<{\cf17 decltype}(alloc)>::destroy(alloc, m_value.string);\par
21765                     std::allocator_traits<{\cf17 decltype}(alloc)>::deallocate(alloc, m_value.string, 1);\par
21766                     m_value.string = {\cf17 nullptr};\par
21767                 \}\par
21768                 {\cf19 else} {\cf19 if} (is_binary())\par
21769                 \{\par
21770                     AllocatorType<binary_t> alloc;\par
21771                     std::allocator_traits<{\cf17 decltype}(alloc)>::destroy(alloc, m_value.binary);\par
21772                     std::allocator_traits<{\cf17 decltype}(alloc)>::deallocate(alloc, m_value.binary, 1);\par
21773                     m_value.binary = {\cf17 nullptr};\par
21774                 \}\par
21775 \par
21776                 m_type = value_t::null;\par
21777                 assert_invariant();\par
21778                 {\cf19 break};\par
21779             \}\par
21780 \par
21781             {\cf19 case} value_t::object:\par
21782             \{\par
21783                 result.m_it.object_iterator = m_value.object->erase(first.m_it.object_iterator,\par
21784                                               last.m_it.object_iterator);\par
21785                 {\cf19 break};\par
21786             \}\par
21787 \par
21788             {\cf19 case} value_t::array:\par
21789             \{\par
21790                 result.m_it.array_iterator = m_value.array->erase(first.m_it.array_iterator,\par
21791                                              last.m_it.array_iterator);\par
21792                 {\cf19 break};\par
21793             \}\par
21794 \par
21795             {\cf19 case} value_t::null:\par
21796             {\cf19 case} value_t::discarded:\par
21797             {\cf19 default}:\par
21798                 JSON_THROW(type_error::create(307, {\cf22 "cannot use erase() with "} + std::string(type_name()), *{\cf17 this}));\par
21799         \}\par
21800 \par
21801         {\cf19 return} result;\par
21802     \}\par
21803 \par
21833     size_type erase({\cf17 const} {\cf17 typename} object_t::key_type& key)\par
21834     \{\par
21835         {\cf20 // this erase only works for objects}\par
21836         {\cf19 if} (JSON_HEDLEY_LIKELY(is_object()))\par
21837         \{\par
21838             {\cf19 return} m_value.object->erase(key);\par
21839         \}\par
21840 \par
21841         JSON_THROW(type_error::create(307, {\cf22 "cannot use erase() with "} + std::string(type_name()), *{\cf17 this}));\par
21842     \}\par
21843 \par
21868     {\cf18 void} erase({\cf17 const} size_type idx)\par
21869     \{\par
21870         {\cf20 // this erase only works for arrays}\par
21871         {\cf19 if} (JSON_HEDLEY_LIKELY(is_array()))\par
21872         \{\par
21873             {\cf19 if} (JSON_HEDLEY_UNLIKELY(idx >= size()))\par
21874             \{\par
21875                 JSON_THROW(out_of_range::create(401, {\cf22 "array index "} + std::to_string(idx) + {\cf22 " is out of range"}, *{\cf17 this}));\par
21876             \}\par
21877 \par
21878             m_value.array->erase(m_value.array->begin() + {\cf17 static_cast<}difference_type{\cf17 >}(idx));\par
21879         \}\par
21880         {\cf19 else}\par
21881         \{\par
21882             JSON_THROW(type_error::create(307, {\cf22 "cannot use erase() with "} + std::string(type_name()), *{\cf17 this}));\par
21883         \}\par
21884     \}\par
21885 \par
21887 \par
21888 \par
21890     {\cf20 // lookup //}\par
21892 {\cf20 }\par
21895 \par
21920     {\cf17 template}<{\cf17 typename} KeyT>\par
21921     iterator find(KeyT&& key)\par
21922     \{\par
21923         {\cf17 auto} result = end();\par
21924 \par
21925         {\cf19 if} (is_object())\par
21926         \{\par
21927             result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));\par
21928         \}\par
21929 \par
21930         {\cf19 return} result;\par
21931     \}\par
21932 \par
21937     {\cf17 template}<{\cf17 typename} KeyT>\par
21938     const_iterator find(KeyT&& key){\cf17  const}\par
21939 {\cf17     }\{\par
21940         {\cf17 auto} result = cend();\par
21941 \par
21942         {\cf19 if} (is_object())\par
21943         \{\par
21944             result.m_it.object_iterator = m_value.object->find(std::forward<KeyT>(key));\par
21945         \}\par
21946 \par
21947         {\cf19 return} result;\par
21948     \}\par
21949 \par
21971     {\cf17 template}<{\cf17 typename} KeyT>\par
21972     size_type count(KeyT&& key){\cf17  const}\par
21973 {\cf17     }\{\par
21974         {\cf20 // return 0 for all nonobject types}\par
21975         {\cf19 return} is_object() ? m_value.object->count(std::forward<KeyT>(key)) : 0;\par
21976     \}\par
21977 \par
22003     {\cf17 template} < {\cf17 typename} KeyT, {\cf17 typename} std::enable_if <\par
22004                    !std::is_same<typename std::decay<KeyT>::type, json_pointer>::value, {\cf18 int} >::type = 0 >\par
22005     {\cf18 bool} contains(KeyT && key){\cf17  const}\par
22006 {\cf17     }\{\par
22007         {\cf19 return} is_object() && m_value.object->find(std::forward<KeyT>(key)) != m_value.object->end();\par
22008     \}\par
22009 \par
22036     {\cf18 bool} contains({\cf17 const} json_pointer& ptr){\cf17  const}\par
22037 {\cf17     }\{\par
22038         {\cf19 return} ptr.contains({\cf17 this});\par
22039     \}\par
22040 \par
22042 \par
22043 \par
22045     {\cf20 // iterators //}\par
22047 {\cf20 }\par
22050 \par
22075     iterator begin() noexcept\par
22076     \{\par
22077         iterator result({\cf17 this});\par
22078         result.set_begin();\par
22079         {\cf19 return} result;\par
22080     \}\par
22081 \par
22085     const_iterator begin() const noexcept\par
22086     \{\par
22087         {\cf19 return} cbegin();\par
22088     \}\par
22089 \par
22115     const_iterator cbegin() const noexcept\par
22116     \{\par
22117         const_iterator result({\cf17 this});\par
22118         result.set_begin();\par
22119         {\cf19 return} result;\par
22120     \}\par
22121 \par
22146     iterator end() noexcept\par
22147     \{\par
22148         iterator result({\cf17 this});\par
22149         result.set_end();\par
22150         {\cf19 return} result;\par
22151     \}\par
22152 \par
22156     const_iterator end() const noexcept\par
22157     \{\par
22158         {\cf19 return} cend();\par
22159     \}\par
22160 \par
22186     const_iterator cend() const noexcept\par
22187     \{\par
22188         const_iterator result({\cf17 this});\par
22189         result.set_end();\par
22190         {\cf19 return} result;\par
22191     \}\par
22192 \par
22216     reverse_iterator rbegin() noexcept\par
22217     \{\par
22218         {\cf19 return} reverse_iterator(end());\par
22219     \}\par
22220 \par
22224     const_reverse_iterator rbegin() const noexcept\par
22225     \{\par
22226         {\cf19 return} crbegin();\par
22227     \}\par
22228 \par
22253     reverse_iterator rend() noexcept\par
22254     \{\par
22255         {\cf19 return} reverse_iterator(begin());\par
22256     \}\par
22257 \par
22261     const_reverse_iterator rend() const noexcept\par
22262     \{\par
22263         {\cf19 return} crend();\par
22264     \}\par
22265 \par
22290     const_reverse_iterator crbegin() const noexcept\par
22291     \{\par
22292         {\cf19 return} const_reverse_iterator(cend());\par
22293     \}\par
22294 \par
22319     const_reverse_iterator crend() const noexcept\par
22320     \{\par
22321         {\cf19 return} const_reverse_iterator(cbegin());\par
22322     \}\par
22323 \par
22324   {\cf17 public}:\par
22382     JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())\par
22383     static iteration_proxy<iterator> iterator_wrapper(reference ref) noexcept\par
22384     \{\par
22385         {\cf19 return} ref.items();\par
22386     \}\par
22387 \par
22391     JSON_HEDLEY_DEPRECATED_FOR(3.1.0, items())\par
22392     static iteration_proxy<const_iterator> iterator_wrapper(const_reference ref) noexcept\par
22393     \{\par
22394         {\cf19 return} ref.items();\par
22395     \}\par
22396 \par
22465     iteration_proxy<iterator> items() noexcept\par
22466     \{\par
22467         {\cf19 return} iteration_proxy<iterator>(*{\cf17 this});\par
22468     \}\par
22469 \par
22473     iteration_proxy<const_iterator> items() const noexcept\par
22474     \{\par
22475         {\cf19 return} iteration_proxy<const_iterator>(*{\cf17 this});\par
22476     \}\par
22477 \par
22479 \par
22480 \par
22482     {\cf20 // capacity //}\par
22484 {\cf20 }\par
22487 \par
22530     {\cf18 bool} empty() const noexcept\par
22531     \{\par
22532         {\cf19 switch} (m_type)\par
22533         \{\par
22534             {\cf19 case} value_t::null:\par
22535             \{\par
22536                 {\cf20 // null values are empty}\par
22537                 {\cf19 return} {\cf17 true};\par
22538             \}\par
22539 \par
22540             {\cf19 case} value_t::array:\par
22541             \{\par
22542                 {\cf20 // delegate call to array_t::empty()}\par
22543                 {\cf19 return} m_value.array->empty();\par
22544             \}\par
22545 \par
22546             {\cf19 case} value_t::object:\par
22547             \{\par
22548                 {\cf20 // delegate call to object_t::empty()}\par
22549                 {\cf19 return} m_value.object->empty();\par
22550             \}\par
22551 \par
22552             {\cf19 case} value_t::string:\par
22553             {\cf19 case} value_t::boolean:\par
22554             {\cf19 case} value_t::number_integer:\par
22555             {\cf19 case} value_t::number_unsigned:\par
22556             {\cf19 case} value_t::number_float:\par
22557             {\cf19 case} value_t::binary:\par
22558             {\cf19 case} value_t::discarded:\par
22559             {\cf19 default}:\par
22560             \{\par
22561                 {\cf20 // all other types are nonempty}\par
22562                 {\cf19 return} {\cf17 false};\par
22563             \}\par
22564         \}\par
22565     \}\par
22566 \par
22610     size_type size() const noexcept\par
22611     \{\par
22612         {\cf19 switch} (m_type)\par
22613         \{\par
22614             {\cf19 case} value_t::null:\par
22615             \{\par
22616                 {\cf20 // null values are empty}\par
22617                 {\cf19 return} 0;\par
22618             \}\par
22619 \par
22620             {\cf19 case} value_t::array:\par
22621             \{\par
22622                 {\cf20 // delegate call to array_t::size()}\par
22623                 {\cf19 return} m_value.array->size();\par
22624             \}\par
22625 \par
22626             {\cf19 case} value_t::object:\par
22627             \{\par
22628                 {\cf20 // delegate call to object_t::size()}\par
22629                 {\cf19 return} m_value.object->size();\par
22630             \}\par
22631 \par
22632             {\cf19 case} value_t::string:\par
22633             {\cf19 case} value_t::boolean:\par
22634             {\cf19 case} value_t::number_integer:\par
22635             {\cf19 case} value_t::number_unsigned:\par
22636             {\cf19 case} value_t::number_float:\par
22637             {\cf19 case} value_t::binary:\par
22638             {\cf19 case} value_t::discarded:\par
22639             {\cf19 default}:\par
22640             \{\par
22641                 {\cf20 // all other types have size 1}\par
22642                 {\cf19 return} 1;\par
22643             \}\par
22644         \}\par
22645     \}\par
22646 \par
22688     size_type max_size() const noexcept\par
22689     \{\par
22690         {\cf19 switch} (m_type)\par
22691         \{\par
22692             {\cf19 case} value_t::array:\par
22693             \{\par
22694                 {\cf20 // delegate call to array_t::max_size()}\par
22695                 {\cf19 return} m_value.array->max_size();\par
22696             \}\par
22697 \par
22698             {\cf19 case} value_t::object:\par
22699             \{\par
22700                 {\cf20 // delegate call to object_t::max_size()}\par
22701                 {\cf19 return} m_value.object->max_size();\par
22702             \}\par
22703 \par
22704             {\cf19 case} value_t::null:\par
22705             {\cf19 case} value_t::string:\par
22706             {\cf19 case} value_t::boolean:\par
22707             {\cf19 case} value_t::number_integer:\par
22708             {\cf19 case} value_t::number_unsigned:\par
22709             {\cf19 case} value_t::number_float:\par
22710             {\cf19 case} value_t::binary:\par
22711             {\cf19 case} value_t::discarded:\par
22712             {\cf19 default}:\par
22713             \{\par
22714                 {\cf20 // all other types have max_size() == size()}\par
22715                 {\cf19 return} size();\par
22716             \}\par
22717         \}\par
22718     \}\par
22719 \par
22721 \par
22722 \par
22724     {\cf20 // modifiers //}\par
22726 {\cf20 }\par
22729 \par
22767     {\cf18 void} clear() noexcept\par
22768     \{\par
22769         {\cf19 switch} (m_type)\par
22770         \{\par
22771             {\cf19 case} value_t::number_integer:\par
22772             \{\par
22773                 m_value.number_integer = 0;\par
22774                 {\cf19 break};\par
22775             \}\par
22776 \par
22777             {\cf19 case} value_t::number_unsigned:\par
22778             \{\par
22779                 m_value.number_unsigned = 0;\par
22780                 {\cf19 break};\par
22781             \}\par
22782 \par
22783             {\cf19 case} value_t::number_float:\par
22784             \{\par
22785                 m_value.number_float = 0.0;\par
22786                 {\cf19 break};\par
22787             \}\par
22788 \par
22789             {\cf19 case} value_t::boolean:\par
22790             \{\par
22791                 m_value.boolean = {\cf17 false};\par
22792                 {\cf19 break};\par
22793             \}\par
22794 \par
22795             {\cf19 case} value_t::string:\par
22796             \{\par
22797                 m_value.string->clear();\par
22798                 {\cf19 break};\par
22799             \}\par
22800 \par
22801             {\cf19 case} value_t::binary:\par
22802             \{\par
22803                 m_value.binary->clear();\par
22804                 {\cf19 break};\par
22805             \}\par
22806 \par
22807             {\cf19 case} value_t::array:\par
22808             \{\par
22809                 m_value.array->clear();\par
22810                 {\cf19 break};\par
22811             \}\par
22812 \par
22813             {\cf19 case} value_t::object:\par
22814             \{\par
22815                 m_value.object->clear();\par
22816                 {\cf19 break};\par
22817             \}\par
22818 \par
22819             {\cf19 case} value_t::null:\par
22820             {\cf19 case} value_t::discarded:\par
22821             {\cf19 default}:\par
22822                 {\cf19 break};\par
22823         \}\par
22824     \}\par
22825 \par
22846     {\cf18 void} push_back(basic_json&& val)\par
22847     \{\par
22848         {\cf20 // push_back only works for null objects or arrays}\par
22849         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))\par
22850         \{\par
22851             JSON_THROW(type_error::create(308, {\cf22 "cannot use push_back() with "} + std::string(type_name()), *{\cf17 this}));\par
22852         \}\par
22853 \par
22854         {\cf20 // transform null object into an array}\par
22855         {\cf19 if} (is_null())\par
22856         \{\par
22857             m_type = value_t::array;\par
22858             m_value = value_t::array;\par
22859             assert_invariant();\par
22860         \}\par
22861 \par
22862         {\cf20 // add element to array (move semantics)}\par
22863         {\cf17 const} {\cf17 auto} old_capacity = m_value.array->capacity();\par
22864         m_value.array->push_back(std::move(val));\par
22865         set_parent(m_value.array->back(), old_capacity);\par
22866         {\cf20 // if val is moved from, basic_json move constructor marks it null so we do not call the destructor}\par
22867     \}\par
22868 \par
22873     reference operator+=(basic_json&& val)\par
22874     \{\par
22875         push_back(std::move(val));\par
22876         {\cf19 return} *{\cf17 this};\par
22877     \}\par
22878 \par
22883     {\cf18 void} push_back({\cf17 const} basic_json& val)\par
22884     \{\par
22885         {\cf20 // push_back only works for null objects or arrays}\par
22886         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))\par
22887         \{\par
22888             JSON_THROW(type_error::create(308, {\cf22 "cannot use push_back() with "} + std::string(type_name()), *{\cf17 this}));\par
22889         \}\par
22890 \par
22891         {\cf20 // transform null object into an array}\par
22892         {\cf19 if} (is_null())\par
22893         \{\par
22894             m_type = value_t::array;\par
22895             m_value = value_t::array;\par
22896             assert_invariant();\par
22897         \}\par
22898 \par
22899         {\cf20 // add element to array}\par
22900         {\cf17 const} {\cf17 auto} old_capacity = m_value.array->capacity();\par
22901         m_value.array->push_back(val);\par
22902         set_parent(m_value.array->back(), old_capacity);\par
22903     \}\par
22904 \par
22909     reference operator+=({\cf17 const} basic_json& val)\par
22910     \{\par
22911         push_back(val);\par
22912         {\cf19 return} *{\cf17 this};\par
22913     \}\par
22914 \par
22935     {\cf18 void} push_back({\cf17 const} {\cf17 typename} object_t::value_type& val)\par
22936     \{\par
22937         {\cf20 // push_back only works for null objects or objects}\par
22938         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))\par
22939         \{\par
22940             JSON_THROW(type_error::create(308, {\cf22 "cannot use push_back() with "} + std::string(type_name()), *{\cf17 this}));\par
22941         \}\par
22942 \par
22943         {\cf20 // transform null object into an object}\par
22944         {\cf19 if} (is_null())\par
22945         \{\par
22946             m_type = value_t::object;\par
22947             m_value = value_t::object;\par
22948             assert_invariant();\par
22949         \}\par
22950 \par
22951         {\cf20 // add element to object}\par
22952         {\cf17 auto} res = m_value.object->insert(val);\par
22953         set_parent(res.first->second);\par
22954     \}\par
22955 \par
22960     reference operator+=({\cf17 const} {\cf17 typename} object_t::value_type& val)\par
22961     \{\par
22962         push_back(val);\par
22963         {\cf19 return} *{\cf17 this};\par
22964     \}\par
22965 \par
22991     {\cf18 void} push_back(initializer_list_t init)\par
22992     \{\par
22993         {\cf19 if} (is_object() && init.size() == 2 && (*init.begin())->is_string())\par
22994         \{\par
22995             basic_json&& key = init.begin()->moved_or_copied();\par
22996             push_back({\cf17 typename} object_t::value_type(\par
22997                           std::move(key.get_ref<string_t&>()), (init.begin() + 1)->moved_or_copied()));\par
22998         \}\par
22999         {\cf19 else}\par
23000         \{\par
23001             push_back(basic_json(init));\par
23002         \}\par
23003     \}\par
23004 \par
23009     reference operator+=(initializer_list_t init)\par
23010     \{\par
23011         push_back(init);\par
23012         {\cf19 return} *{\cf17 this};\par
23013     \}\par
23014 \par
23038     {\cf17 template}<{\cf17 class}... Args>\par
23039     reference emplace_back(Args&& ... args)\par
23040     \{\par
23041         {\cf20 // emplace_back only works for null objects or arrays}\par
23042         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!(is_null() || is_array())))\par
23043         \{\par
23044             JSON_THROW(type_error::create(311, {\cf22 "cannot use emplace_back() with "} + std::string(type_name()), *{\cf17 this}));\par
23045         \}\par
23046 \par
23047         {\cf20 // transform null object into an array}\par
23048         {\cf19 if} (is_null())\par
23049         \{\par
23050             m_type = value_t::array;\par
23051             m_value = value_t::array;\par
23052             assert_invariant();\par
23053         \}\par
23054 \par
23055         {\cf20 // add element to array (perfect forwarding)}\par
23056         {\cf17 const} {\cf17 auto} old_capacity = m_value.array->capacity();\par
23057         m_value.array->emplace_back(std::forward<Args>(args)...);\par
23058         {\cf19 return} set_parent(m_value.array->back(), old_capacity);\par
23059     \}\par
23060 \par
23088     {\cf17 template}<{\cf17 class}... Args>\par
23089     std::pair<iterator, bool> emplace(Args&& ... args)\par
23090     \{\par
23091         {\cf20 // emplace only works for null objects or arrays}\par
23092         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!(is_null() || is_object())))\par
23093         \{\par
23094             JSON_THROW(type_error::create(311, {\cf22 "cannot use emplace() with "} + std::string(type_name()), *{\cf17 this}));\par
23095         \}\par
23096 \par
23097         {\cf20 // transform null object into an object}\par
23098         {\cf19 if} (is_null())\par
23099         \{\par
23100             m_type = value_t::object;\par
23101             m_value = value_t::object;\par
23102             assert_invariant();\par
23103         \}\par
23104 \par
23105         {\cf20 // add element to array (perfect forwarding)}\par
23106         {\cf17 auto} res = m_value.object->emplace(std::forward<Args>(args)...);\par
23107         set_parent(res.first->second);\par
23108 \par
23109         {\cf20 // create result iterator and set iterator to the result of emplace}\par
23110         {\cf17 auto} it = begin();\par
23111         it.m_it.object_iterator = res.first;\par
23112 \par
23113         {\cf20 // return pair of iterator and boolean}\par
23114         {\cf19 return} \{it, res.second\};\par
23115     \}\par
23116 \par
23120     {\cf17 template}<{\cf17 typename}... Args>\par
23121     iterator insert_iterator(const_iterator pos, Args&& ... args)\par
23122     \{\par
23123         iterator result({\cf17 this});\par
23124         JSON_ASSERT(m_value.array != {\cf17 nullptr});\par
23125 \par
23126         {\cf17 auto} insert_pos = std::distance(m_value.array->begin(), pos.m_it.array_iterator);\par
23127         m_value.array->insert(pos.m_it.array_iterator, std::forward<Args>(args)...);\par
23128         result.m_it.array_iterator = m_value.array->begin() + insert_pos;\par
23129 \par
23130         {\cf20 // This could have been written as:}\par
23131         {\cf20 // result.m_it.array_iterator = m_value.array->insert(pos.m_it.array_iterator, cnt, val);}\par
23132         {\cf20 // but the return value of insert is missing in GCC 4.8, so it is written this way instead.}\par
23133 \par
23134         set_parents();\par
23135         {\cf19 return} result;\par
23136     \}\par
23137 \par
23160     iterator insert(const_iterator pos, {\cf17 const} basic_json& val)\par
23161     \{\par
23162         {\cf20 // insert only works for arrays}\par
23163         {\cf19 if} (JSON_HEDLEY_LIKELY(is_array()))\par
23164         \{\par
23165             {\cf20 // check if iterator pos fits to this JSON value}\par
23166             {\cf19 if} (JSON_HEDLEY_UNLIKELY(pos.m_object != {\cf17 this}))\par
23167             \{\par
23168                 JSON_THROW(invalid_iterator::create(202, {\cf22 "iterator does not fit current value"}, *{\cf17 this}));\par
23169             \}\par
23170 \par
23171             {\cf20 // insert to array and return iterator}\par
23172             {\cf19 return} insert_iterator(pos, val);\par
23173         \}\par
23174 \par
23175         JSON_THROW(type_error::create(309, {\cf22 "cannot use insert() with "} + std::string(type_name()), *{\cf17 this}));\par
23176     \}\par
23177 \par
23182     iterator insert(const_iterator pos, basic_json&& val)\par
23183     \{\par
23184         {\cf19 return} insert(pos, val);\par
23185     \}\par
23186 \par
23211     iterator insert(const_iterator pos, size_type cnt, {\cf17 const} basic_json& val)\par
23212     \{\par
23213         {\cf20 // insert only works for arrays}\par
23214         {\cf19 if} (JSON_HEDLEY_LIKELY(is_array()))\par
23215         \{\par
23216             {\cf20 // check if iterator pos fits to this JSON value}\par
23217             {\cf19 if} (JSON_HEDLEY_UNLIKELY(pos.m_object != {\cf17 this}))\par
23218             \{\par
23219                 JSON_THROW(invalid_iterator::create(202, {\cf22 "iterator does not fit current value"}, *{\cf17 this}));\par
23220             \}\par
23221 \par
23222             {\cf20 // insert to array and return iterator}\par
23223             {\cf19 return} insert_iterator(pos, cnt, val);\par
23224         \}\par
23225 \par
23226         JSON_THROW(type_error::create(309, {\cf22 "cannot use insert() with "} + std::string(type_name()), *{\cf17 this}));\par
23227     \}\par
23228 \par
23259     iterator insert(const_iterator pos, const_iterator first, const_iterator last)\par
23260     \{\par
23261         {\cf20 // insert only works for arrays}\par
23262         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!is_array()))\par
23263         \{\par
23264             JSON_THROW(type_error::create(309, {\cf22 "cannot use insert() with "} + std::string(type_name()), *{\cf17 this}));\par
23265         \}\par
23266 \par
23267         {\cf20 // check if iterator pos fits to this JSON value}\par
23268         {\cf19 if} (JSON_HEDLEY_UNLIKELY(pos.m_object != {\cf17 this}))\par
23269         \{\par
23270             JSON_THROW(invalid_iterator::create(202, {\cf22 "iterator does not fit current value"}, *{\cf17 this}));\par
23271         \}\par
23272 \par
23273         {\cf20 // check if range iterators belong to the same JSON object}\par
23274         {\cf19 if} (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))\par
23275         \{\par
23276             JSON_THROW(invalid_iterator::create(210, {\cf22 "iterators do not fit"}, *{\cf17 this}));\par
23277         \}\par
23278 \par
23279         {\cf19 if} (JSON_HEDLEY_UNLIKELY(first.m_object == {\cf17 this}))\par
23280         \{\par
23281             JSON_THROW(invalid_iterator::create(211, {\cf22 "passed iterators may not belong to container"}, *{\cf17 this}));\par
23282         \}\par
23283 \par
23284         {\cf20 // insert to array and return iterator}\par
23285         {\cf19 return} insert_iterator(pos, first.m_it.array_iterator, last.m_it.array_iterator);\par
23286     \}\par
23287 \par
23312     iterator insert(const_iterator pos, initializer_list_t ilist)\par
23313     \{\par
23314         {\cf20 // insert only works for arrays}\par
23315         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!is_array()))\par
23316         \{\par
23317             JSON_THROW(type_error::create(309, {\cf22 "cannot use insert() with "} + std::string(type_name()), *{\cf17 this}));\par
23318         \}\par
23319 \par
23320         {\cf20 // check if iterator pos fits to this JSON value}\par
23321         {\cf19 if} (JSON_HEDLEY_UNLIKELY(pos.m_object != {\cf17 this}))\par
23322         \{\par
23323             JSON_THROW(invalid_iterator::create(202, {\cf22 "iterator does not fit current value"}, *{\cf17 this}));\par
23324         \}\par
23325 \par
23326         {\cf20 // insert to array and return iterator}\par
23327         {\cf19 return} insert_iterator(pos, ilist.begin(), ilist.end());\par
23328     \}\par
23329 \par
23353     {\cf18 void} insert(const_iterator first, const_iterator last)\par
23354     \{\par
23355         {\cf20 // insert only works for objects}\par
23356         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!is_object()))\par
23357         \{\par
23358             JSON_THROW(type_error::create(309, {\cf22 "cannot use insert() with "} + std::string(type_name()), *{\cf17 this}));\par
23359         \}\par
23360 \par
23361         {\cf20 // check if range iterators belong to the same JSON object}\par
23362         {\cf19 if} (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))\par
23363         \{\par
23364             JSON_THROW(invalid_iterator::create(210, {\cf22 "iterators do not fit"}, *{\cf17 this}));\par
23365         \}\par
23366 \par
23367         {\cf20 // passed iterators must belong to objects}\par
23368         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()))\par
23369         \{\par
23370             JSON_THROW(invalid_iterator::create(202, {\cf22 "iterators first and last must point to objects"}, *{\cf17 this}));\par
23371         \}\par
23372 \par
23373         m_value.object->insert(first.m_it.object_iterator, last.m_it.object_iterator);\par
23374     \}\par
23375 \par
23395     {\cf18 void} update(const_reference j)\par
23396     \{\par
23397         {\cf20 // implicitly convert null value to an empty object}\par
23398         {\cf19 if} (is_null())\par
23399         \{\par
23400             m_type = value_t::object;\par
23401             m_value.object = create<object_t>();\par
23402             assert_invariant();\par
23403         \}\par
23404 \par
23405         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!is_object()))\par
23406         \{\par
23407             JSON_THROW(type_error::create(312, {\cf22 "cannot use update() with "} + std::string(type_name()), *{\cf17 this}));\par
23408         \}\par
23409         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!j.is_object()))\par
23410         \{\par
23411             JSON_THROW(type_error::create(312, {\cf22 "cannot use update() with "} + std::string(j.type_name()), *{\cf17 this}));\par
23412         \}\par
23413 \par
23414         {\cf19 for} ({\cf17 auto} it = j.cbegin(); it != j.cend(); ++it)\par
23415         \{\par
23416             m_value.object->operator[](it.key()) = it.value();\par
23417         \}\par
23418     \}\par
23419 \par
23446     {\cf18 void} update(const_iterator first, const_iterator last)\par
23447     \{\par
23448         {\cf20 // implicitly convert null value to an empty object}\par
23449         {\cf19 if} (is_null())\par
23450         \{\par
23451             m_type = value_t::object;\par
23452             m_value.object = create<object_t>();\par
23453             assert_invariant();\par
23454         \}\par
23455 \par
23456         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!is_object()))\par
23457         \{\par
23458             JSON_THROW(type_error::create(312, {\cf22 "cannot use update() with "} + std::string(type_name()), *{\cf17 this}));\par
23459         \}\par
23460 \par
23461         {\cf20 // check if range iterators belong to the same JSON object}\par
23462         {\cf19 if} (JSON_HEDLEY_UNLIKELY(first.m_object != last.m_object))\par
23463         \{\par
23464             JSON_THROW(invalid_iterator::create(210, {\cf22 "iterators do not fit"}, *{\cf17 this}));\par
23465         \}\par
23466 \par
23467         {\cf20 // passed iterators must belong to objects}\par
23468         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!first.m_object->is_object()\par
23469                                  || !last.m_object->is_object()))\par
23470         \{\par
23471             JSON_THROW(invalid_iterator::create(202, {\cf22 "iterators first and last must point to objects"}, *{\cf17 this}));\par
23472         \}\par
23473 \par
23474         {\cf19 for} ({\cf17 auto} it = first; it != last; ++it)\par
23475         \{\par
23476             m_value.object->operator[](it.key()) = it.value();\par
23477         \}\par
23478     \}\par
23479 \par
23497     {\cf18 void} swap(reference other) {\cf17 noexcept} (\par
23498         std::is_nothrow_move_constructible<value_t>::value&&\par
23499         std::is_nothrow_move_assignable<value_t>::value&&\par
23500         std::is_nothrow_move_constructible<json_value>::value&&\par
23501         std::is_nothrow_move_assignable<json_value>::value\par
23502     )\par
23503     \{\par
23504         std::swap(m_type, other.m_type);\par
23505         std::swap(m_value, other.m_value);\par
23506 \par
23507         set_parents();\par
23508         other.set_parents();\par
23509         assert_invariant();\par
23510     \}\par
23511 \par
23530     {\cf17 friend} {\cf18 void} swap(reference left, reference right) {\cf17 noexcept} (\par
23531         std::is_nothrow_move_constructible<value_t>::value&&\par
23532         std::is_nothrow_move_assignable<value_t>::value&&\par
23533         std::is_nothrow_move_constructible<json_value>::value&&\par
23534         std::is_nothrow_move_assignable<json_value>::value\par
23535     )\par
23536     \{\par
23537         left.swap(right);\par
23538     \}\par
23539 \par
23560     {\cf18 void} swap(array_t& other) {\cf20 // NOLINT(bugprone-exception-escape)}\par
23561     \{\par
23562         {\cf20 // swap only works for arrays}\par
23563         {\cf19 if} (JSON_HEDLEY_LIKELY(is_array()))\par
23564         \{\par
23565             std::swap(*(m_value.array), other);\par
23566         \}\par
23567         {\cf19 else}\par
23568         \{\par
23569             JSON_THROW(type_error::create(310, {\cf22 "cannot use swap() with "} + std::string(type_name()), *{\cf17 this}));\par
23570         \}\par
23571     \}\par
23572 \par
23593     {\cf18 void} swap(object_t& other) {\cf20 // NOLINT(bugprone-exception-escape)}\par
23594     \{\par
23595         {\cf20 // swap only works for objects}\par
23596         {\cf19 if} (JSON_HEDLEY_LIKELY(is_object()))\par
23597         \{\par
23598             std::swap(*(m_value.object), other);\par
23599         \}\par
23600         {\cf19 else}\par
23601         \{\par
23602             JSON_THROW(type_error::create(310, {\cf22 "cannot use swap() with "} + std::string(type_name()), *{\cf17 this}));\par
23603         \}\par
23604     \}\par
23605 \par
23626     {\cf18 void} swap(string_t& other) {\cf20 // NOLINT(bugprone-exception-escape)}\par
23627     \{\par
23628         {\cf20 // swap only works for strings}\par
23629         {\cf19 if} (JSON_HEDLEY_LIKELY(is_string()))\par
23630         \{\par
23631             std::swap(*(m_value.string), other);\par
23632         \}\par
23633         {\cf19 else}\par
23634         \{\par
23635             JSON_THROW(type_error::create(310, {\cf22 "cannot use swap() with "} + std::string(type_name()), *{\cf17 this}));\par
23636         \}\par
23637     \}\par
23638 \par
23659     {\cf18 void} swap(binary_t& other) {\cf20 // NOLINT(bugprone-exception-escape)}\par
23660     \{\par
23661         {\cf20 // swap only works for strings}\par
23662         {\cf19 if} (JSON_HEDLEY_LIKELY(is_binary()))\par
23663         \{\par
23664             std::swap(*(m_value.binary), other);\par
23665         \}\par
23666         {\cf19 else}\par
23667         \{\par
23668             JSON_THROW(type_error::create(310, {\cf22 "cannot use swap() with "} + std::string(type_name()), *{\cf17 this}));\par
23669         \}\par
23670     \}\par
23671 \par
23673     {\cf18 void} swap({\cf17 typename} binary_t::container_type& other) {\cf20 // NOLINT(bugprone-exception-escape)}\par
23674     \{\par
23675         {\cf20 // swap only works for strings}\par
23676         {\cf19 if} (JSON_HEDLEY_LIKELY(is_binary()))\par
23677         \{\par
23678             std::swap(*(m_value.binary), other);\par
23679         \}\par
23680         {\cf19 else}\par
23681         \{\par
23682             JSON_THROW(type_error::create(310, {\cf22 "cannot use swap() with "} + std::string(type_name()), *{\cf17 this}));\par
23683         \}\par
23684     \}\par
23685 \par
23687 \par
23688   {\cf17 public}:\par
23690     {\cf20 // lexicographical comparison operators //}\par
23692 {\cf20 }\par
23695 \par
23751     {\cf17 friend} {\cf18 bool} operator==(const_reference lhs, const_reference rhs) {\cf17 noexcept}\par
23752     \{\par
23753 {\cf21 #ifdef __GNUC__}\par
23754 {\cf21 #pragma GCC diagnostic push}\par
23755 {\cf21 #pragma GCC diagnostic ignored "-Wfloat-equal"}\par
23756 {\cf21 #endif}\par
23757         {\cf17 const} {\cf17 auto} lhs_type = lhs.type();\par
23758         {\cf17 const} {\cf17 auto} rhs_type = rhs.type();\par
23759 \par
23760         {\cf19 if} (lhs_type == rhs_type)\par
23761         \{\par
23762             {\cf19 switch} (lhs_type)\par
23763             \{\par
23764                 {\cf19 case} value_t::array:\par
23765                     {\cf19 return} *lhs.m_value.array == *rhs.m_value.array;\par
23766 \par
23767                 {\cf19 case} value_t::object:\par
23768                     {\cf19 return} *lhs.m_value.object == *rhs.m_value.object;\par
23769 \par
23770                 {\cf19 case} value_t::null:\par
23771                     {\cf19 return} {\cf17 true};\par
23772 \par
23773                 {\cf19 case} value_t::string:\par
23774                     {\cf19 return} *lhs.m_value.string == *rhs.m_value.string;\par
23775 \par
23776                 {\cf19 case} value_t::boolean:\par
23777                     {\cf19 return} lhs.m_value.boolean == rhs.m_value.boolean;\par
23778 \par
23779                 {\cf19 case} value_t::number_integer:\par
23780                     {\cf19 return} lhs.m_value.number_integer == rhs.m_value.number_integer;\par
23781 \par
23782                 {\cf19 case} value_t::number_unsigned:\par
23783                     {\cf19 return} lhs.m_value.number_unsigned == rhs.m_value.number_unsigned;\par
23784 \par
23785                 {\cf19 case} value_t::number_float:\par
23786                     {\cf19 return} lhs.m_value.number_float == rhs.m_value.number_float;\par
23787 \par
23788                 {\cf19 case} value_t::binary:\par
23789                     {\cf19 return} *lhs.m_value.binary == *rhs.m_value.binary;\par
23790 \par
23791                 {\cf19 case} value_t::discarded:\par
23792                 {\cf19 default}:\par
23793                     {\cf19 return} {\cf17 false};\par
23794             \}\par
23795         \}\par
23796         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)\par
23797         \{\par
23798             {\cf19 return} {\cf17 static_cast<}number_float_t{\cf17 >}(lhs.m_value.number_integer) == rhs.m_value.number_float;\par
23799         \}\par
23800         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)\par
23801         \{\par
23802             {\cf19 return} lhs.m_value.number_float == {\cf17 static_cast<}number_float_t{\cf17 >}(rhs.m_value.number_integer);\par
23803         \}\par
23804         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)\par
23805         \{\par
23806             {\cf19 return} {\cf17 static_cast<}number_float_t{\cf17 >}(lhs.m_value.number_unsigned) == rhs.m_value.number_float;\par
23807         \}\par
23808         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)\par
23809         \{\par
23810             {\cf19 return} lhs.m_value.number_float == {\cf17 static_cast<}number_float_t{\cf17 >}(rhs.m_value.number_unsigned);\par
23811         \}\par
23812         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)\par
23813         \{\par
23814             {\cf19 return} {\cf17 static_cast<}number_integer_t{\cf17 >}(lhs.m_value.number_unsigned) == rhs.m_value.number_integer;\par
23815         \}\par
23816         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)\par
23817         \{\par
23818             {\cf19 return} lhs.m_value.number_integer == {\cf17 static_cast<}number_integer_t{\cf17 >}(rhs.m_value.number_unsigned);\par
23819         \}\par
23820 \par
23821         {\cf19 return} {\cf17 false};\par
23822 {\cf21 #ifdef __GNUC__}\par
23823 {\cf21 #pragma GCC diagnostic pop}\par
23824 {\cf21 #endif}\par
23825     \}\par
23826 \par
23831     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
23832                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
23833     {\cf17 friend} {\cf18 bool} operator==(const_reference lhs, ScalarType rhs) {\cf17 noexcept}\par
23834     \{\par
23835         {\cf19 return} lhs == basic_json(rhs);\par
23836     \}\par
23837 \par
23842     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
23843                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
23844     {\cf17 friend} {\cf18 bool} operator==(ScalarType lhs, const_reference rhs) {\cf17 noexcept}\par
23845     \{\par
23846         {\cf19 return} basic_json(lhs) == rhs;\par
23847     \}\par
23848 \par
23867     {\cf17 friend} {\cf18 bool} operator!=(const_reference lhs, const_reference rhs) {\cf17 noexcept}\par
23868     \{\par
23869         {\cf19 return} !(lhs == rhs);\par
23870     \}\par
23871 \par
23876     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
23877                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
23878     {\cf17 friend} {\cf18 bool} operator!=(const_reference lhs, ScalarType rhs) {\cf17 noexcept}\par
23879     \{\par
23880         {\cf19 return} lhs != basic_json(rhs);\par
23881     \}\par
23882 \par
23887     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
23888                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
23889     {\cf17 friend} {\cf18 bool} operator!=(ScalarType lhs, const_reference rhs) {\cf17 noexcept}\par
23890     \{\par
23891         {\cf19 return} basic_json(lhs) != rhs;\par
23892     \}\par
23893 \par
23920     {\cf17 friend} {\cf18 bool} operator<(const_reference lhs, const_reference rhs) {\cf17 noexcept}\par
23921     \{\par
23922         {\cf17 const} {\cf17 auto} lhs_type = lhs.type();\par
23923         {\cf17 const} {\cf17 auto} rhs_type = rhs.type();\par
23924 \par
23925         {\cf19 if} (lhs_type == rhs_type)\par
23926         \{\par
23927             {\cf19 switch} (lhs_type)\par
23928             \{\par
23929                 {\cf19 case} value_t::array:\par
23930                     {\cf20 // note parentheses are necessary, see}\par
23931                     {\cf20 // https://github.com/nlohmann/json/issues/1530}\par
23932                     {\cf19 return} (*lhs.m_value.array) < (*rhs.m_value.array);\par
23933 \par
23934                 {\cf19 case} value_t::object:\par
23935                     {\cf19 return} (*lhs.m_value.object) < (*rhs.m_value.object);\par
23936 \par
23937                 {\cf19 case} value_t::null:\par
23938                     {\cf19 return} {\cf17 false};\par
23939 \par
23940                 {\cf19 case} value_t::string:\par
23941                     {\cf19 return} (*lhs.m_value.string) < (*rhs.m_value.string);\par
23942 \par
23943                 {\cf19 case} value_t::boolean:\par
23944                     {\cf19 return} (lhs.m_value.boolean) < (rhs.m_value.boolean);\par
23945 \par
23946                 {\cf19 case} value_t::number_integer:\par
23947                     {\cf19 return} (lhs.m_value.number_integer) < (rhs.m_value.number_integer);\par
23948 \par
23949                 {\cf19 case} value_t::number_unsigned:\par
23950                     {\cf19 return} (lhs.m_value.number_unsigned) < (rhs.m_value.number_unsigned);\par
23951 \par
23952                 {\cf19 case} value_t::number_float:\par
23953                     {\cf19 return} (lhs.m_value.number_float) < (rhs.m_value.number_float);\par
23954 \par
23955                 {\cf19 case} value_t::binary:\par
23956                     {\cf19 return} (*lhs.m_value.binary) < (*rhs.m_value.binary);\par
23957 \par
23958                 {\cf19 case} value_t::discarded:\par
23959                 {\cf19 default}:\par
23960                     {\cf19 return} {\cf17 false};\par
23961             \}\par
23962         \}\par
23963         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_integer && rhs_type == value_t::number_float)\par
23964         \{\par
23965             {\cf19 return} {\cf17 static_cast<}number_float_t{\cf17 >}(lhs.m_value.number_integer) < rhs.m_value.number_float;\par
23966         \}\par
23967         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_float && rhs_type == value_t::number_integer)\par
23968         \{\par
23969             {\cf19 return} lhs.m_value.number_float < {\cf17 static_cast<}number_float_t{\cf17 >}(rhs.m_value.number_integer);\par
23970         \}\par
23971         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_float)\par
23972         \{\par
23973             {\cf19 return} {\cf17 static_cast<}number_float_t{\cf17 >}(lhs.m_value.number_unsigned) < rhs.m_value.number_float;\par
23974         \}\par
23975         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_float && rhs_type == value_t::number_unsigned)\par
23976         \{\par
23977             {\cf19 return} lhs.m_value.number_float < {\cf17 static_cast<}number_float_t{\cf17 >}(rhs.m_value.number_unsigned);\par
23978         \}\par
23979         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_integer && rhs_type == value_t::number_unsigned)\par
23980         \{\par
23981             {\cf19 return} lhs.m_value.number_integer < {\cf17 static_cast<}number_integer_t{\cf17 >}(rhs.m_value.number_unsigned);\par
23982         \}\par
23983         {\cf19 else} {\cf19 if} (lhs_type == value_t::number_unsigned && rhs_type == value_t::number_integer)\par
23984         \{\par
23985             {\cf19 return} {\cf17 static_cast<}number_integer_t{\cf17 >}(lhs.m_value.number_unsigned) < rhs.m_value.number_integer;\par
23986         \}\par
23987 \par
23988         {\cf20 // We only reach this line if we cannot compare values. In that case,}\par
23989         {\cf20 // we compare types. Note we have to call the operator explicitly,}\par
23990         {\cf20 // because MSVC has problems otherwise.}\par
23991         {\cf19 return} operator<(lhs_type, rhs_type);\par
23992     \}\par
23993 \par
23998     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
23999                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
24000     {\cf17 friend} {\cf18 bool} operator<(const_reference lhs, ScalarType rhs) {\cf17 noexcept}\par
24001     \{\par
24002         {\cf19 return} lhs < basic_json(rhs);\par
24003     \}\par
24004 \par
24009     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
24010                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
24011     {\cf17 friend} {\cf18 bool} operator<(ScalarType lhs, const_reference rhs) {\cf17 noexcept}\par
24012     \{\par
24013         {\cf19 return} basic_json(lhs) < rhs;\par
24014     \}\par
24015 \par
24035     {\cf17 friend} {\cf18 bool} operator<=(const_reference lhs, const_reference rhs) {\cf17 noexcept}\par
24036     \{\par
24037         {\cf19 return} !(rhs < lhs);\par
24038     \}\par
24039 \par
24044     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
24045                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
24046     {\cf17 friend} {\cf18 bool} operator<=(const_reference lhs, ScalarType rhs) {\cf17 noexcept}\par
24047     \{\par
24048         {\cf19 return} lhs <= basic_json(rhs);\par
24049     \}\par
24050 \par
24055     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
24056                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
24057     {\cf17 friend} {\cf18 bool} operator<=(ScalarType lhs, const_reference rhs) {\cf17 noexcept}\par
24058     \{\par
24059         {\cf19 return} basic_json(lhs) <= rhs;\par
24060     \}\par
24061 \par
24081     {\cf17 friend} {\cf18 bool} operator>(const_reference lhs, const_reference rhs) {\cf17 noexcept}\par
24082     \{\par
24083         {\cf19 return} !(lhs <= rhs);\par
24084     \}\par
24085 \par
24090     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
24091                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
24092     {\cf17 friend} {\cf18 bool} operator>(const_reference lhs, ScalarType rhs) {\cf17 noexcept}\par
24093     \{\par
24094         {\cf19 return} lhs > basic_json(rhs);\par
24095     \}\par
24096 \par
24101     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
24102                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
24103     {\cf17 friend} {\cf18 bool} operator>(ScalarType lhs, const_reference rhs) {\cf17 noexcept}\par
24104     \{\par
24105         {\cf19 return} basic_json(lhs) > rhs;\par
24106     \}\par
24107 \par
24127     {\cf17 friend} {\cf18 bool} operator>=(const_reference lhs, const_reference rhs) {\cf17 noexcept}\par
24128     \{\par
24129         {\cf19 return} !(lhs < rhs);\par
24130     \}\par
24131 \par
24136     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
24137                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
24138     {\cf17 friend} {\cf18 bool} operator>=(const_reference lhs, ScalarType rhs) {\cf17 noexcept}\par
24139     \{\par
24140         {\cf19 return} lhs >= basic_json(rhs);\par
24141     \}\par
24142 \par
24147     {\cf17 template}<{\cf17 typename} ScalarType, {\cf17 typename} std::enable_if<\par
24148                  std::is_scalar<ScalarType>::value, {\cf18 int}>::type = 0>\par
24149     {\cf17 friend} {\cf18 bool} operator>=(ScalarType lhs, const_reference rhs) {\cf17 noexcept}\par
24150     \{\par
24151         {\cf19 return} basic_json(lhs) >= rhs;\par
24152     \}\par
24153 \par
24155 \par
24157     {\cf20 // serialization //}\par
24159 {\cf20 }\par
24162 {\cf21 #ifndef JSON_NO_IO}\par
24194     {\cf17 friend} std::ostream& operator<<(std::ostream& o, {\cf17 const} basic_json& j)\par
24195     \{\par
24196         {\cf20 // read width member and use it as indentation parameter if nonzero}\par
24197         {\cf17 const} {\cf18 bool} pretty_print = o.width() > 0;\par
24198         {\cf17 const} {\cf17 auto} indentation = pretty_print ? o.width() : 0;\par
24199 \par
24200         {\cf20 // reset width to 0 for subsequent calls to this stream}\par
24201         o.width(0);\par
24202 \par
24203         {\cf20 // do the actual serialization}\par
24204         serializer s(detail::output_adapter<char>(o), o.fill());\par
24205         s.dump(j, pretty_print, {\cf17 false}, {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >}(indentation));\par
24206         {\cf19 return} o;\par
24207     \}\par
24208 \par
24217     JSON_HEDLEY_DEPRECATED_FOR(3.0.0, {\cf17 operator}<<(std::ostream&, {\cf17 const} basic_json&))\par
24218     friend std::ostream& operator>>(const basic_json& j, std::ostream& o)\par
24219     \{\par
24220         {\cf19 return} o << j;\par
24221     \}\par
24222 {\cf21 #endif  }{\cf20 // JSON_NO_IO}\par
24224 {\cf20 }\par
24225 \par
24227     {\cf20 // deserialization //}\par
24229 {\cf20 }\par
24232 \par
24284     {\cf17 template}<{\cf17 typename} InputType>\par
24285     JSON_HEDLEY_WARN_UNUSED_RESULT\par
24286     {\cf17 static} basic_json parse(InputType&& i,\par
24287                             {\cf17 const} parser_callback_t cb = {\cf17 nullptr},\par
24288                             {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true},\par
24289                             {\cf17 const} {\cf18 bool} ignore_comments = {\cf17 false})\par
24290     \{\par
24291         basic_json result;\par
24292         parser(detail::input_adapter(std::forward<InputType>(i)), cb, allow_exceptions, ignore_comments).parse({\cf17 true}, result);\par
24293         {\cf19 return} result;\par
24294     \}\par
24295 \par
24322     {\cf17 template}<{\cf17 typename} IteratorType>\par
24323     JSON_HEDLEY_WARN_UNUSED_RESULT\par
24324     {\cf17 static} basic_json parse(IteratorType first,\par
24325                             IteratorType last,\par
24326                             {\cf17 const} parser_callback_t cb = {\cf17 nullptr},\par
24327                             {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true},\par
24328                             {\cf17 const} {\cf18 bool} ignore_comments = {\cf17 false})\par
24329     \{\par
24330         basic_json result;\par
24331         parser(detail::input_adapter(std::move(first), std::move(last)), cb, allow_exceptions, ignore_comments).parse({\cf17 true}, result);\par
24332         {\cf19 return} result;\par
24333     \}\par
24334 \par
24335     JSON_HEDLEY_WARN_UNUSED_RESULT\par
24336     JSON_HEDLEY_DEPRECATED_FOR(3.8.0, parse(ptr, ptr + len))\par
24337     static basic_json parse(detail::span_input_adapter&& i,\par
24338                             const parser_callback_t cb = {\cf18 nullptr},\par
24339                             const {\cf18 bool} allow_exceptions = true,\par
24340                             const {\cf18 bool} ignore_comments = false)\par
24341     \{\par
24342         basic_json result;\par
24343         parser(i.get(), cb, allow_exceptions, ignore_comments).parse({\cf17 true}, result);\par
24344         {\cf19 return} result;\par
24345     \}\par
24346 \par
24377     {\cf17 template}<{\cf17 typename} InputType>\par
24378     {\cf17 static} {\cf18 bool} accept(InputType&& i,\par
24379                        {\cf17 const} {\cf18 bool} ignore_comments = {\cf17 false})\par
24380     \{\par
24381         {\cf19 return} parser(detail::input_adapter(std::forward<InputType>(i)), {\cf17 nullptr}, {\cf17 false}, ignore_comments).accept({\cf17 true});\par
24382     \}\par
24383 \par
24384     {\cf17 template}<{\cf17 typename} IteratorType>\par
24385     {\cf17 static} {\cf18 bool} accept(IteratorType first, IteratorType last,\par
24386                        {\cf17 const} {\cf18 bool} ignore_comments = {\cf17 false})\par
24387     \{\par
24388         {\cf19 return} parser(detail::input_adapter(std::move(first), std::move(last)), {\cf17 nullptr}, {\cf17 false}, ignore_comments).accept({\cf17 true});\par
24389     \}\par
24390 \par
24391     JSON_HEDLEY_WARN_UNUSED_RESULT\par
24392     JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))\par
24393     static {\cf18 bool} accept(detail::span_input_adapter&& i,\par
24394                        const {\cf18 bool} ignore_comments = false)\par
24395     \{\par
24396         {\cf19 return} parser(i.get(), {\cf17 nullptr}, {\cf17 false}, ignore_comments).accept({\cf17 true});\par
24397     \}\par
24398 \par
24439     {\cf17 template} <{\cf17 typename} InputType, {\cf17 typename} SAX>\par
24440     JSON_HEDLEY_NON_NULL(2)\par
24441     static {\cf18 bool} sax_parse(InputType&& i, SAX* sax,\par
24442                           input_format_t format = input_format_t::json,\par
24443                           const {\cf18 bool} strict = true,\par
24444                           const {\cf18 bool} ignore_comments = false)\par
24445     \{\par
24446         {\cf17 auto} ia = detail::input_adapter(std::forward<InputType>(i));\par
24447         {\cf19 return} format == input_format_t::json\par
24448                ? parser(std::move(ia), {\cf17 nullptr}, {\cf17 true}, ignore_comments).sax_parse(sax, strict)\par
24449                : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);\par
24450     \}\par
24451 \par
24452     {\cf17 template}<{\cf17 class} IteratorType, {\cf17 class} SAX>\par
24453     JSON_HEDLEY_NON_NULL(3)\par
24454     static {\cf18 bool} sax_parse(IteratorType first, IteratorType last, SAX* sax,\par
24455                           input_format_t format = input_format_t::json,\par
24456                           const {\cf18 bool} strict = true,\par
24457                           const {\cf18 bool} ignore_comments = false)\par
24458     \{\par
24459         {\cf17 auto} ia = detail::input_adapter(std::move(first), std::move(last));\par
24460         {\cf19 return} format == input_format_t::json\par
24461                ? parser(std::move(ia), {\cf17 nullptr}, {\cf17 true}, ignore_comments).sax_parse(sax, strict)\par
24462                : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);\par
24463     \}\par
24464 \par
24465     {\cf17 template} <{\cf17 typename} SAX>\par
24466     JSON_HEDLEY_DEPRECATED_FOR(3.8.0, sax_parse(ptr, ptr + len, ...))\par
24467     JSON_HEDLEY_NON_NULL(2)\par
24468     static {\cf18 bool} sax_parse(detail::span_input_adapter&& i, SAX* sax,\par
24469                           input_format_t format = input_format_t::json,\par
24470                           const {\cf18 bool} strict = true,\par
24471                           const {\cf18 bool} ignore_comments = false)\par
24472     \{\par
24473         {\cf17 auto} ia = i.get();\par
24474         {\cf19 return} format == input_format_t::json\par
24475                {\cf20 // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)}\par
24476                ? parser(std::move(ia), {\cf17 nullptr}, {\cf17 true}, ignore_comments).sax_parse(sax, strict)\par
24477                {\cf20 // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)}\par
24478                : detail::binary_reader<basic_json, decltype(ia), SAX>(std::move(ia)).sax_parse(format, sax, strict);\par
24479     \}\par
24480 {\cf21 #ifndef JSON_NO_IO}\par
24489     JSON_HEDLEY_DEPRECATED_FOR(3.0.0, {\cf17 operator}>>(std::istream&, basic_json&))\par
24490     friend std::istream& operator<<(basic_json& j, std::istream& i)\par
24491     \{\par
24492         {\cf19 return} operator>>(i, j);\par
24493     \}\par
24494 \par
24520     {\cf17 friend} std::istream& operator>>(std::istream& i, basic_json& j)\par
24521     \{\par
24522         parser(detail::input_adapter(i)).parse({\cf17 false}, j);\par
24523         {\cf19 return} i;\par
24524     \}\par
24525 {\cf21 #endif  }{\cf20 // JSON_NO_IO}\par
24527 {\cf20 }\par
24529     {\cf20 // convenience functions //}\par
24531 {\cf20 }\par
24563     JSON_HEDLEY_RETURNS_NON_NULL\par
24564     {\cf17 const} {\cf18 char}* type_name() const noexcept\par
24565     \{\par
24566         \{\par
24567             {\cf19 switch} (m_type)\par
24568             \{\par
24569                 {\cf19 case} value_t::null:\par
24570                     {\cf19 return} {\cf22 "null"};\par
24571                 {\cf19 case} value_t::object:\par
24572                     {\cf19 return} {\cf22 "object"};\par
24573                 {\cf19 case} value_t::array:\par
24574                     {\cf19 return} {\cf22 "array"};\par
24575                 {\cf19 case} value_t::string:\par
24576                     {\cf19 return} {\cf22 "string"};\par
24577                 {\cf19 case} value_t::boolean:\par
24578                     {\cf19 return} {\cf22 "boolean"};\par
24579                 {\cf19 case} value_t::binary:\par
24580                     {\cf19 return} {\cf22 "binary"};\par
24581                 {\cf19 case} value_t::discarded:\par
24582                     {\cf19 return} {\cf22 "discarded"};\par
24583                 {\cf19 case} value_t::number_integer:\par
24584                 {\cf19 case} value_t::number_unsigned:\par
24585                 {\cf19 case} value_t::number_float:\par
24586                 {\cf19 default}:\par
24587                     {\cf19 return} {\cf22 "number"};\par
24588             \}\par
24589         \}\par
24590     \}\par
24591 \par
24592 \par
24593   JSON_PRIVATE_UNLESS_TESTED:\par
24595     {\cf20 // member variables //}\par
24597 {\cf20 }\par
24599     value_t m_type = value_t::null;\par
24600 \par
24602     json_value m_value = \{\};\par
24603 \par
24604 {\cf21 #if JSON_DIAGNOSTICS}\par
24606     basic_json* m_parent = {\cf17 nullptr};\par
24607 {\cf21 #endif}\par
24608 \par
24610     {\cf20 // binary serialization/deserialization //}\par
24612 {\cf20 }\par
24615 \par
24616   {\cf17 public}:\par
24715     {\cf17 static} std::vector<std::uint8_t> to_cbor({\cf17 const} basic_json& j)\par
24716     \{\par
24717         std::vector<std::uint8_t> result;\par
24718         to_cbor(j, result);\par
24719         {\cf19 return} result;\par
24720     \}\par
24721 \par
24722     {\cf17 static} {\cf18 void} to_cbor({\cf17 const} basic_json& j, detail::output_adapter<std::uint8_t> o)\par
24723     \{\par
24724         binary_writer<std::uint8_t>(o).write_cbor(j);\par
24725     \}\par
24726 \par
24727     {\cf17 static} {\cf18 void} to_cbor({\cf17 const} basic_json& j, detail::output_adapter<char> o)\par
24728     \{\par
24729         binary_writer<char>(o).write_cbor(j);\par
24730     \}\par
24731 \par
24810     {\cf17 static} std::vector<std::uint8_t> to_msgpack({\cf17 const} basic_json& j)\par
24811     \{\par
24812         std::vector<std::uint8_t> result;\par
24813         to_msgpack(j, result);\par
24814         {\cf19 return} result;\par
24815     \}\par
24816 \par
24817     {\cf17 static} {\cf18 void} to_msgpack({\cf17 const} basic_json& j, detail::output_adapter<std::uint8_t> o)\par
24818     \{\par
24819         binary_writer<std::uint8_t>(o).write_msgpack(j);\par
24820     \}\par
24821 \par
24822     {\cf17 static} {\cf18 void} to_msgpack({\cf17 const} basic_json& j, detail::output_adapter<char> o)\par
24823     \{\par
24824         binary_writer<char>(o).write_msgpack(j);\par
24825     \}\par
24826 \par
24913     {\cf17 static} std::vector<std::uint8_t> to_ubjson({\cf17 const} basic_json& j,\par
24914             {\cf17 const} {\cf18 bool} use_size = {\cf17 false},\par
24915             {\cf17 const} {\cf18 bool} use_type = {\cf17 false})\par
24916     \{\par
24917         std::vector<std::uint8_t> result;\par
24918         to_ubjson(j, result, use_size, use_type);\par
24919         {\cf19 return} result;\par
24920     \}\par
24921 \par
24922     {\cf17 static} {\cf18 void} to_ubjson({\cf17 const} basic_json& j, detail::output_adapter<std::uint8_t> o,\par
24923                           {\cf17 const} {\cf18 bool} use_size = {\cf17 false}, {\cf17 const} {\cf18 bool} use_type = {\cf17 false})\par
24924     \{\par
24925         binary_writer<std::uint8_t>(o).write_ubjson(j, use_size, use_type);\par
24926     \}\par
24927 \par
24928     {\cf17 static} {\cf18 void} to_ubjson({\cf17 const} basic_json& j, detail::output_adapter<char> o,\par
24929                           {\cf17 const} {\cf18 bool} use_size = {\cf17 false}, {\cf17 const} {\cf18 bool} use_type = {\cf17 false})\par
24930     \{\par
24931         binary_writer<char>(o).write_ubjson(j, use_size, use_type);\par
24932     \}\par
24933 \par
24934 \par
24991     {\cf17 static} std::vector<std::uint8_t> to_bson({\cf17 const} basic_json& j)\par
24992     \{\par
24993         std::vector<std::uint8_t> result;\par
24994         to_bson(j, result);\par
24995         {\cf19 return} result;\par
24996     \}\par
24997 \par
25006     {\cf17 static} {\cf18 void} to_bson({\cf17 const} basic_json& j, detail::output_adapter<std::uint8_t> o)\par
25007     \{\par
25008         binary_writer<std::uint8_t>(o).write_bson(j);\par
25009     \}\par
25010 \par
25014     {\cf17 static} {\cf18 void} to_bson({\cf17 const} basic_json& j, detail::output_adapter<char> o)\par
25015     \{\par
25016         binary_writer<char>(o).write_bson(j);\par
25017     \}\par
25018 \par
25019 \par
25122     {\cf17 template}<{\cf17 typename} InputType>\par
25123     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25124     {\cf17 static} basic_json from_cbor(InputType&& i,\par
25125                                 {\cf17 const} {\cf18 bool} strict = {\cf17 true},\par
25126                                 {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true},\par
25127                                 {\cf17 const} cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)\par
25128     \{\par
25129         basic_json result;\par
25130         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25131         {\cf17 auto} ia = detail::input_adapter(std::forward<InputType>(i));\par
25132         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);\par
25133         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25134     \}\par
25135 \par
25139     {\cf17 template}<{\cf17 typename} IteratorType>\par
25140     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25141     {\cf17 static} basic_json from_cbor(IteratorType first, IteratorType last,\par
25142                                 {\cf17 const} {\cf18 bool} strict = {\cf17 true},\par
25143                                 {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true},\par
25144                                 {\cf17 const} cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)\par
25145     \{\par
25146         basic_json result;\par
25147         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25148         {\cf17 auto} ia = detail::input_adapter(std::move(first), std::move(last));\par
25149         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);\par
25150         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25151     \}\par
25152 \par
25153     {\cf17 template}<{\cf17 typename} T>\par
25154     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25155     JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))\par
25156     static basic_json from_cbor(const T* ptr, std::{\cf18 size_t} len,\par
25157                                 const {\cf18 bool} strict = true,\par
25158                                 const {\cf18 bool} allow_exceptions = true,\par
25159                                 const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)\par
25160     \{\par
25161         {\cf19 return} from_cbor(ptr, ptr + len, strict, allow_exceptions, tag_handler);\par
25162     \}\par
25163 \par
25164 \par
25165     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25166     JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_cbor(ptr, ptr + len))\par
25167     static basic_json from_cbor(detail::span_input_adapter&& i,\par
25168                                 const {\cf18 bool} strict = true,\par
25169                                 const {\cf18 bool} allow_exceptions = true,\par
25170                                 const cbor_tag_handler_t tag_handler = cbor_tag_handler_t::error)\par
25171     \{\par
25172         basic_json result;\par
25173         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25174         {\cf17 auto} ia = i.get();\par
25175         {\cf20 // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)}\par
25176         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::cbor, &sdp, strict, tag_handler);\par
25177         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25178     \}\par
25179 \par
25266     {\cf17 template}<{\cf17 typename} InputType>\par
25267     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25268     {\cf17 static} basic_json from_msgpack(InputType&& i,\par
25269                                    {\cf17 const} {\cf18 bool} strict = {\cf17 true},\par
25270                                    {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true})\par
25271     \{\par
25272         basic_json result;\par
25273         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25274         {\cf17 auto} ia = detail::input_adapter(std::forward<InputType>(i));\par
25275         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);\par
25276         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25277     \}\par
25278 \par
25282     {\cf17 template}<{\cf17 typename} IteratorType>\par
25283     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25284     {\cf17 static} basic_json from_msgpack(IteratorType first, IteratorType last,\par
25285                                    {\cf17 const} {\cf18 bool} strict = {\cf17 true},\par
25286                                    {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true})\par
25287     \{\par
25288         basic_json result;\par
25289         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25290         {\cf17 auto} ia = detail::input_adapter(std::move(first), std::move(last));\par
25291         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);\par
25292         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25293     \}\par
25294 \par
25295 \par
25296     {\cf17 template}<{\cf17 typename} T>\par
25297     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25298     JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))\par
25299     static basic_json from_msgpack(const T* ptr, std::{\cf18 size_t} len,\par
25300                                    const {\cf18 bool} strict = true,\par
25301                                    const {\cf18 bool} allow_exceptions = true)\par
25302     \{\par
25303         {\cf19 return} from_msgpack(ptr, ptr + len, strict, allow_exceptions);\par
25304     \}\par
25305 \par
25306     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25307     JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_msgpack(ptr, ptr + len))\par
25308     static basic_json from_msgpack(detail::span_input_adapter&& i,\par
25309                                    const {\cf18 bool} strict = true,\par
25310                                    const {\cf18 bool} allow_exceptions = true)\par
25311     \{\par
25312         basic_json result;\par
25313         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25314         {\cf17 auto} ia = i.get();\par
25315         {\cf20 // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)}\par
25316         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::msgpack, &sdp, strict);\par
25317         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25318     \}\par
25319 \par
25320 \par
25383     {\cf17 template}<{\cf17 typename} InputType>\par
25384     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25385     {\cf17 static} basic_json from_ubjson(InputType&& i,\par
25386                                   {\cf17 const} {\cf18 bool} strict = {\cf17 true},\par
25387                                   {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true})\par
25388     \{\par
25389         basic_json result;\par
25390         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25391         {\cf17 auto} ia = detail::input_adapter(std::forward<InputType>(i));\par
25392         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);\par
25393         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25394     \}\par
25395 \par
25399     {\cf17 template}<{\cf17 typename} IteratorType>\par
25400     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25401     {\cf17 static} basic_json from_ubjson(IteratorType first, IteratorType last,\par
25402                                   {\cf17 const} {\cf18 bool} strict = {\cf17 true},\par
25403                                   {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true})\par
25404     \{\par
25405         basic_json result;\par
25406         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25407         {\cf17 auto} ia = detail::input_adapter(std::move(first), std::move(last));\par
25408         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);\par
25409         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25410     \}\par
25411 \par
25412     {\cf17 template}<{\cf17 typename} T>\par
25413     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25414     JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))\par
25415     static basic_json from_ubjson(const T* ptr, std::{\cf18 size_t} len,\par
25416                                   const {\cf18 bool} strict = true,\par
25417                                   const {\cf18 bool} allow_exceptions = true)\par
25418     \{\par
25419         {\cf19 return} from_ubjson(ptr, ptr + len, strict, allow_exceptions);\par
25420     \}\par
25421 \par
25422     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25423     JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_ubjson(ptr, ptr + len))\par
25424     static basic_json from_ubjson(detail::span_input_adapter&& i,\par
25425                                   const {\cf18 bool} strict = true,\par
25426                                   const {\cf18 bool} allow_exceptions = true)\par
25427     \{\par
25428         basic_json result;\par
25429         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25430         {\cf17 auto} ia = i.get();\par
25431         {\cf20 // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)}\par
25432         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::ubjson, &sdp, strict);\par
25433         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25434     \}\par
25435 \par
25436 \par
25497     {\cf17 template}<{\cf17 typename} InputType>\par
25498     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25499     {\cf17 static} basic_json from_bson(InputType&& i,\par
25500                                 {\cf17 const} {\cf18 bool} strict = {\cf17 true},\par
25501                                 {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true})\par
25502     \{\par
25503         basic_json result;\par
25504         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25505         {\cf17 auto} ia = detail::input_adapter(std::forward<InputType>(i));\par
25506         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);\par
25507         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25508     \}\par
25509 \par
25513     {\cf17 template}<{\cf17 typename} IteratorType>\par
25514     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25515     {\cf17 static} basic_json from_bson(IteratorType first, IteratorType last,\par
25516                                 {\cf17 const} {\cf18 bool} strict = {\cf17 true},\par
25517                                 {\cf17 const} {\cf18 bool} allow_exceptions = {\cf17 true})\par
25518     \{\par
25519         basic_json result;\par
25520         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25521         {\cf17 auto} ia = detail::input_adapter(std::move(first), std::move(last));\par
25522         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);\par
25523         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25524     \}\par
25525 \par
25526     {\cf17 template}<{\cf17 typename} T>\par
25527     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25528     JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))\par
25529     static basic_json from_bson(const T* ptr, std::{\cf18 size_t} len,\par
25530                                 const {\cf18 bool} strict = true,\par
25531                                 const {\cf18 bool} allow_exceptions = true)\par
25532     \{\par
25533         {\cf19 return} from_bson(ptr, ptr + len, strict, allow_exceptions);\par
25534     \}\par
25535 \par
25536     JSON_HEDLEY_WARN_UNUSED_RESULT\par
25537     JSON_HEDLEY_DEPRECATED_FOR(3.8.0, from_bson(ptr, ptr + len))\par
25538     static basic_json from_bson(detail::span_input_adapter&& i,\par
25539                                 const {\cf18 bool} strict = true,\par
25540                                 const {\cf18 bool} allow_exceptions = true)\par
25541     \{\par
25542         basic_json result;\par
25543         detail::json_sax_dom_parser<basic_json> sdp(result, allow_exceptions);\par
25544         {\cf17 auto} ia = i.get();\par
25545         {\cf20 // NOLINTNEXTLINE(hicpp-move-const-arg,performance-move-const-arg)}\par
25546         {\cf17 const} {\cf18 bool} res = binary_reader<decltype(ia)>(std::move(ia)).sax_parse(input_format_t::bson, &sdp, strict);\par
25547         {\cf19 return} res ? result : basic_json(value_t::discarded);\par
25548     \}\par
25550 \par
25552     {\cf20 // JSON Pointer support //}\par
25554 {\cf20 }\par
25557 \par
25591     reference operator[]({\cf17 const} json_pointer& ptr)\par
25592     \{\par
25593         {\cf19 return} ptr.get_unchecked({\cf17 this});\par
25594     \}\par
25595 \par
25619     const_reference operator[]({\cf17 const} json_pointer& ptr){\cf17  const}\par
25620 {\cf17     }\{\par
25621         {\cf19 return} ptr.get_unchecked({\cf17 this});\par
25622     \}\par
25623 \par
25662     reference at({\cf17 const} json_pointer& ptr)\par
25663     \{\par
25664         {\cf19 return} ptr.get_checked({\cf17 this});\par
25665     \}\par
25666 \par
25705     const_reference at({\cf17 const} json_pointer& ptr){\cf17  const}\par
25706 {\cf17     }\{\par
25707         {\cf19 return} ptr.get_checked({\cf17 this});\par
25708     \}\par
25709 \par
25732     basic_json flatten(){\cf17  const}\par
25733 {\cf17     }\{\par
25734         basic_json result(value_t::object);\par
25735         json_pointer::flatten({\cf22 ""}, *{\cf17 this}, result);\par
25736         {\cf19 return} result;\par
25737     \}\par
25738 \par
25769     basic_json unflatten(){\cf17  const}\par
25770 {\cf17     }\{\par
25771         {\cf19 return} json_pointer::unflatten(*{\cf17 this});\par
25772     \}\par
25773 \par
25775 \par
25777     {\cf20 // JSON Patch functions //}\par
25779 {\cf20 }\par
25782 \par
25830     basic_json patch({\cf17 const} basic_json& json_patch){\cf17  const}\par
25831 {\cf17     }\{\par
25832         {\cf20 // make a working copy to apply the patch to}\par
25833         basic_json result = *{\cf17 this};\par
25834 \par
25835         {\cf20 // the valid JSON Patch operations}\par
25836         {\cf17 enum class} patch_operations \{add, remove, replace, move, copy, test, invalid\};\par
25837 \par
25838         {\cf17 const} {\cf17 auto} get_op = []({\cf17 const} std::string & op)\par
25839         \{\par
25840             {\cf19 if} (op == {\cf22 "add"})\par
25841             \{\par
25842                 {\cf19 return} patch_operations::add;\par
25843             \}\par
25844             {\cf19 if} (op == {\cf22 "remove"})\par
25845             \{\par
25846                 {\cf19 return} patch_operations::remove;\par
25847             \}\par
25848             {\cf19 if} (op == {\cf22 "replace"})\par
25849             \{\par
25850                 {\cf19 return} patch_operations::replace;\par
25851             \}\par
25852             {\cf19 if} (op == {\cf22 "move"})\par
25853             \{\par
25854                 {\cf19 return} patch_operations::move;\par
25855             \}\par
25856             {\cf19 if} (op == {\cf22 "copy"})\par
25857             \{\par
25858                 {\cf19 return} patch_operations::copy;\par
25859             \}\par
25860             {\cf19 if} (op == {\cf22 "test"})\par
25861             \{\par
25862                 {\cf19 return} patch_operations::test;\par
25863             \}\par
25864 \par
25865             {\cf19 return} patch_operations::invalid;\par
25866         \};\par
25867 \par
25868         {\cf20 // wrapper for "add" operation; add value at ptr}\par
25869         {\cf17 const} {\cf17 auto} operation_add = [&result](json_pointer & ptr, basic_json val)\par
25870         \{\par
25871             {\cf20 // adding to the root of the target document means replacing it}\par
25872             {\cf19 if} (ptr.empty())\par
25873             \{\par
25874                 result = val;\par
25875                 {\cf19 return};\par
25876             \}\par
25877 \par
25878             {\cf20 // make sure the top element of the pointer exists}\par
25879             json_pointer top_pointer = ptr.top();\par
25880             {\cf19 if} (top_pointer != ptr)\par
25881             \{\par
25882                 result.at(top_pointer);\par
25883             \}\par
25884 \par
25885             {\cf20 // get reference to parent of JSON pointer ptr}\par
25886             {\cf17 const} {\cf17 auto} last_path = ptr.back();\par
25887             ptr.pop_back();\par
25888             basic_json& parent = result[ptr];\par
25889 \par
25890             {\cf19 switch} (parent.m_type)\par
25891             \{\par
25892                 {\cf19 case} value_t::null:\par
25893                 {\cf19 case} value_t::object:\par
25894                 \{\par
25895                     {\cf20 // use operator[] to add value}\par
25896                     parent[last_path] = val;\par
25897                     {\cf19 break};\par
25898                 \}\par
25899 \par
25900                 {\cf19 case} value_t::array:\par
25901                 \{\par
25902                     {\cf19 if} (last_path == {\cf22 "-"})\par
25903                     \{\par
25904                         {\cf20 // special case: append to back}\par
25905                         parent.push_back(val);\par
25906                     \}\par
25907                     {\cf19 else}\par
25908                     \{\par
25909                         {\cf17 const} {\cf17 auto} idx = json_pointer::array_index(last_path);\par
25910                         {\cf19 if} (JSON_HEDLEY_UNLIKELY(idx > parent.size()))\par
25911                         \{\par
25912                             {\cf20 // avoid undefined behavior}\par
25913                             JSON_THROW(out_of_range::create(401, {\cf22 "array index "} + std::to_string(idx) + {\cf22 " is out of range"}, parent));\par
25914                         \}\par
25915 \par
25916                         {\cf20 // default case: insert add offset}\par
25917                         parent.insert(parent.begin() + {\cf17 static_cast<}difference_type{\cf17 >}(idx), val);\par
25918                     \}\par
25919                     {\cf19 break};\par
25920                 \}\par
25921 \par
25922                 {\cf20 // if there exists a parent it cannot be primitive}\par
25923                 {\cf19 case} value_t::string: {\cf20 // LCOV_EXCL_LINE}\par
25924                 {\cf19 case} value_t::boolean: {\cf20 // LCOV_EXCL_LINE}\par
25925                 {\cf19 case} value_t::number_integer: {\cf20 // LCOV_EXCL_LINE}\par
25926                 {\cf19 case} value_t::number_unsigned: {\cf20 // LCOV_EXCL_LINE}\par
25927                 {\cf19 case} value_t::number_float: {\cf20 // LCOV_EXCL_LINE}\par
25928                 {\cf19 case} value_t::binary: {\cf20 // LCOV_EXCL_LINE}\par
25929                 {\cf19 case} value_t::discarded: {\cf20 // LCOV_EXCL_LINE}\par
25930                 {\cf19 default}:            {\cf20 // LCOV_EXCL_LINE}\par
25931                     JSON_ASSERT({\cf17 false}); {\cf20 // NOLINT(cert-dcl03-c,hicpp-static-assert,misc-static-assert) LCOV_EXCL_LINE}\par
25932             \}\par
25933         \};\par
25934 \par
25935         {\cf20 // wrapper for "remove" operation; remove value at ptr}\par
25936         {\cf17 const} {\cf17 auto} operation_remove = [{\cf17 this}, &result](json_pointer & ptr)\par
25937         \{\par
25938             {\cf20 // get reference to parent of JSON pointer ptr}\par
25939             {\cf17 const} {\cf17 auto} last_path = ptr.back();\par
25940             ptr.pop_back();\par
25941             basic_json& parent = result.at(ptr);\par
25942 \par
25943             {\cf20 // remove child}\par
25944             {\cf19 if} (parent.is_object())\par
25945             \{\par
25946                 {\cf20 // perform range check}\par
25947                 {\cf17 auto} it = parent.find(last_path);\par
25948                 {\cf19 if} (JSON_HEDLEY_LIKELY(it != parent.end()))\par
25949                 \{\par
25950                     parent.erase(it);\par
25951                 \}\par
25952                 {\cf19 else}\par
25953                 \{\par
25954                     JSON_THROW(out_of_range::create(403, {\cf22 "key '"} + last_path + {\cf22 "' not found"}, *{\cf17 this}));\par
25955                 \}\par
25956             \}\par
25957             {\cf19 else} {\cf19 if} (parent.is_array())\par
25958             \{\par
25959                 {\cf20 // note erase performs range check}\par
25960                 parent.erase(json_pointer::array_index(last_path));\par
25961             \}\par
25962         \};\par
25963 \par
25964         {\cf20 // type check: top level value must be an array}\par
25965         {\cf19 if} (JSON_HEDLEY_UNLIKELY(!json_patch.is_array()))\par
25966         \{\par
25967             JSON_THROW(parse_error::create(104, 0, {\cf22 "JSON patch must be an array of objects"}, json_patch));\par
25968         \}\par
25969 \par
25970         {\cf20 // iterate and apply the operations}\par
25971         {\cf19 for} ({\cf17 const} {\cf17 auto}& val : json_patch)\par
25972         \{\par
25973             {\cf20 // wrapper to get a value for an operation}\par
25974             {\cf17 const} {\cf17 auto} get_value = [&val]({\cf17 const} std::string & op,\par
25975                                           {\cf17 const} std::string & member,\par
25976                                           {\cf18 bool} string_type) -> basic_json &\par
25977             \{\par
25978                 {\cf20 // find value}\par
25979                 {\cf17 auto} it = val.m_value.object->find(member);\par
25980 \par
25981                 {\cf20 // context-sensitive error message}\par
25982                 {\cf17 const} {\cf17 auto} error_msg = (op == {\cf22 "op"}) ? {\cf22 "operation"} : {\cf22 "operation '"} + op + {\cf22 "'"};\par
25983 \par
25984                 {\cf20 // check if desired value is present}\par
25985                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(it == val.m_value.object->end()))\par
25986                 \{\par
25987                     {\cf20 // NOLINTNEXTLINE(performance-inefficient-string-concatenation)}\par
25988                     JSON_THROW(parse_error::create(105, 0, error_msg + {\cf22 " must have member '"} + member + {\cf22 "'"}, val));\par
25989                 \}\par
25990 \par
25991                 {\cf20 // check if result is of type string}\par
25992                 {\cf19 if} (JSON_HEDLEY_UNLIKELY(string_type && !it->second.is_string()))\par
25993                 \{\par
25994                     {\cf20 // NOLINTNEXTLINE(performance-inefficient-string-concatenation)}\par
25995                     JSON_THROW(parse_error::create(105, 0, error_msg + {\cf22 " must have string member '"} + member + {\cf22 "'"}, val));\par
25996                 \}\par
25997 \par
25998                 {\cf20 // no error: return value}\par
25999                 {\cf19 return} it->second;\par
26000             \};\par
26001 \par
26002             {\cf20 // type check: every element of the array must be an object}\par
26003             {\cf19 if} (JSON_HEDLEY_UNLIKELY(!val.is_object()))\par
26004             \{\par
26005                 JSON_THROW(parse_error::create(104, 0, {\cf22 "JSON patch must be an array of objects"}, val));\par
26006             \}\par
26007 \par
26008             {\cf20 // collect mandatory members}\par
26009             {\cf17 const} {\cf17 auto} op = get_value({\cf22 "op"}, {\cf22 "op"}, {\cf17 true}).template get<std::string>();\par
26010             {\cf17 const} {\cf17 auto} path = get_value(op, {\cf22 "path"}, {\cf17 true}).template get<std::string>();\par
26011             json_pointer ptr(path);\par
26012 \par
26013             {\cf19 switch} (get_op(op))\par
26014             \{\par
26015                 {\cf19 case} patch_operations::add:\par
26016                 \{\par
26017                     operation_add(ptr, get_value({\cf22 "add"}, {\cf22 "value"}, {\cf17 false}));\par
26018                     {\cf19 break};\par
26019                 \}\par
26020 \par
26021                 {\cf19 case} patch_operations::remove:\par
26022                 \{\par
26023                     operation_remove(ptr);\par
26024                     {\cf19 break};\par
26025                 \}\par
26026 \par
26027                 {\cf19 case} patch_operations::replace:\par
26028                 \{\par
26029                     {\cf20 // the "path" location must exist - use at()}\par
26030                     result.at(ptr) = get_value({\cf22 "replace"}, {\cf22 "value"}, {\cf17 false});\par
26031                     {\cf19 break};\par
26032                 \}\par
26033 \par
26034                 {\cf19 case} patch_operations::move:\par
26035                 \{\par
26036                     {\cf17 const} {\cf17 auto} from_path = get_value({\cf22 "move"}, {\cf22 "from"}, {\cf17 true}).template get<std::string>();\par
26037                     json_pointer from_ptr(from_path);\par
26038 \par
26039                     {\cf20 // the "from" location must exist - use at()}\par
26040                     basic_json v = result.at(from_ptr);\par
26041 \par
26042                     {\cf20 // The move operation is functionally identical to a}\par
26043                     {\cf20 // "remove" operation on the "from" location, followed}\par
26044                     {\cf20 // immediately by an "add" operation at the target}\par
26045                     {\cf20 // location with the value that was just removed.}\par
26046                     operation_remove(from_ptr);\par
26047                     operation_add(ptr, v);\par
26048                     {\cf19 break};\par
26049                 \}\par
26050 \par
26051                 {\cf19 case} patch_operations::copy:\par
26052                 \{\par
26053                     {\cf17 const} {\cf17 auto} from_path = get_value({\cf22 "copy"}, {\cf22 "from"}, {\cf17 true}).template get<std::string>();\par
26054                     {\cf17 const} json_pointer from_ptr(from_path);\par
26055 \par
26056                     {\cf20 // the "from" location must exist - use at()}\par
26057                     basic_json v = result.at(from_ptr);\par
26058 \par
26059                     {\cf20 // The copy is functionally identical to an "add"}\par
26060                     {\cf20 // operation at the target location using the value}\par
26061                     {\cf20 // specified in the "from" member.}\par
26062                     operation_add(ptr, v);\par
26063                     {\cf19 break};\par
26064                 \}\par
26065 \par
26066                 {\cf19 case} patch_operations::test:\par
26067                 \{\par
26068                     {\cf18 bool} success = {\cf17 false};\par
26069                     JSON_TRY\par
26070                     \{\par
26071                         {\cf20 // check if "value" matches the one at "path"}\par
26072                         {\cf20 // the "path" location must exist - use at()}\par
26073                         success = (result.at(ptr) == get_value({\cf22 "test"}, {\cf22 "value"}, {\cf17 false}));\par
26074                     \}\par
26075                     JSON_INTERNAL_CATCH (out_of_range&)\par
26076                     \{\par
26077                         {\cf20 // ignore out of range errors: success remains false}\par
26078                     \}\par
26079 \par
26080                     {\cf20 // throw an exception if test fails}\par
26081                     {\cf19 if} (JSON_HEDLEY_UNLIKELY(!success))\par
26082                     \{\par
26083                         JSON_THROW(other_error::create(501, {\cf22 "unsuccessful: "} + val.dump(), val));\par
26084                     \}\par
26085 \par
26086                     {\cf19 break};\par
26087                 \}\par
26088 \par
26089                 {\cf19 case} patch_operations::invalid:\par
26090                 {\cf19 default}:\par
26091                 \{\par
26092                     {\cf20 // op must be "add", "remove", "replace", "move", "copy", or}\par
26093                     {\cf20 // "test"}\par
26094                     JSON_THROW(parse_error::create(105, 0, {\cf22 "operation value '"} + op + {\cf22 "' is invalid"}, val));\par
26095                 \}\par
26096             \}\par
26097         \}\par
26098 \par
26099         {\cf19 return} result;\par
26100     \}\par
26101 \par
26135     JSON_HEDLEY_WARN_UNUSED_RESULT\par
26136     {\cf17 static} basic_json diff({\cf17 const} basic_json& source, {\cf17 const} basic_json& target,\par
26137                            {\cf17 const} std::string& path = {\cf22 ""})\par
26138     \{\par
26139         {\cf20 // the patch}\par
26140         basic_json result(value_t::array);\par
26141 \par
26142         {\cf20 // if the values are the same, return empty patch}\par
26143         {\cf19 if} (source == target)\par
26144         \{\par
26145             {\cf19 return} result;\par
26146         \}\par
26147 \par
26148         {\cf19 if} (source.type() != target.type())\par
26149         \{\par
26150             {\cf20 // different types: replace value}\par
26151             result.push_back(\par
26152             \{\par
26153                 \{{\cf22 "op"}, {\cf22 "replace"}\}, \{{\cf22 "path"}, path\}, \{{\cf22 "value"}, target\}\par
26154             \});\par
26155             {\cf19 return} result;\par
26156         \}\par
26157 \par
26158         {\cf19 switch} (source.type())\par
26159         \{\par
26160             {\cf19 case} value_t::array:\par
26161             \{\par
26162                 {\cf20 // first pass: traverse common elements}\par
26163                 std::size_t i = 0;\par
26164                 {\cf19 while} (i < source.size() && i < target.size())\par
26165                 \{\par
26166                     {\cf20 // recursive call to compare array values at index i}\par
26167                     {\cf17 auto} temp_diff = diff(source[i], target[i], path + {\cf22 "/"} + std::to_string(i));\par
26168                     result.insert(result.end(), temp_diff.begin(), temp_diff.end());\par
26169                     ++i;\par
26170                 \}\par
26171 \par
26172                 {\cf20 // i now reached the end of at least one array}\par
26173                 {\cf20 // in a second pass, traverse the remaining elements}\par
26174 \par
26175                 {\cf20 // remove my remaining elements}\par
26176                 {\cf17 const} {\cf17 auto} end_index = {\cf17 static_cast<}difference_type{\cf17 >}(result.size());\par
26177                 {\cf19 while} (i < source.size())\par
26178                 \{\par
26179                     {\cf20 // add operations in reverse order to avoid invalid}\par
26180                     {\cf20 // indices}\par
26181                     result.insert(result.begin() + end_index, object(\par
26182                     \{\par
26183                         \{{\cf22 "op"}, {\cf22 "remove"}\},\par
26184                         \{{\cf22 "path"}, path + {\cf22 "/"} + std::to_string(i)\}\par
26185                     \}));\par
26186                     ++i;\par
26187                 \}\par
26188 \par
26189                 {\cf20 // add other remaining elements}\par
26190                 {\cf19 while} (i < target.size())\par
26191                 \{\par
26192                     result.push_back(\par
26193                     \{\par
26194                         \{{\cf22 "op"}, {\cf22 "add"}\},\par
26195                         \{{\cf22 "path"}, path + {\cf22 "/-"}\},\par
26196                         \{{\cf22 "value"}, target[i]\}\par
26197                     \});\par
26198                     ++i;\par
26199                 \}\par
26200 \par
26201                 {\cf19 break};\par
26202             \}\par
26203 \par
26204             {\cf19 case} value_t::object:\par
26205             \{\par
26206                 {\cf20 // first pass: traverse this object's elements}\par
26207                 {\cf19 for} ({\cf17 auto} it = source.cbegin(); it != source.cend(); ++it)\par
26208                 \{\par
26209                     {\cf20 // escape the key name to be used in a JSON patch}\par
26210                     {\cf17 const} {\cf17 auto} path_key = path + {\cf22 "/"} + detail::escape(it.key());\par
26211 \par
26212                     {\cf19 if} (target.find(it.key()) != target.end())\par
26213                     \{\par
26214                         {\cf20 // recursive call to compare object values at key it}\par
26215                         {\cf17 auto} temp_diff = diff(it.value(), target[it.key()], path_key);\par
26216                         result.insert(result.end(), temp_diff.begin(), temp_diff.end());\par
26217                     \}\par
26218                     {\cf19 else}\par
26219                     \{\par
26220                         {\cf20 // found a key that is not in o -> remove it}\par
26221                         result.push_back({\cf18 object}(\par
26222                         \{\par
26223                             \{{\cf22 "op"}, {\cf22 "remove"}\}, \{{\cf22 "path"}, path_key\}\par
26224                         \}));\par
26225                     \}\par
26226                 \}\par
26227 \par
26228                 {\cf20 // second pass: traverse other object's elements}\par
26229                 {\cf19 for} ({\cf17 auto} it = target.cbegin(); it != target.cend(); ++it)\par
26230                 \{\par
26231                     {\cf19 if} (source.find(it.key()) == source.end())\par
26232                     \{\par
26233                         {\cf20 // found a key that is not in this -> add it}\par
26234                         {\cf17 const} {\cf17 auto} path_key = path + {\cf22 "/"} + detail::escape(it.key());\par
26235                         result.push_back(\par
26236                         \{\par
26237                             \{{\cf22 "op"}, {\cf22 "add"}\}, \{{\cf22 "path"}, path_key\},\par
26238                             \{{\cf22 "value"}, it.value()\}\par
26239                         \});\par
26240                     \}\par
26241                 \}\par
26242 \par
26243                 {\cf19 break};\par
26244             \}\par
26245 \par
26246             {\cf19 case} value_t::null:\par
26247             {\cf19 case} value_t::string:\par
26248             {\cf19 case} value_t::boolean:\par
26249             {\cf19 case} value_t::number_integer:\par
26250             {\cf19 case} value_t::number_unsigned:\par
26251             {\cf19 case} value_t::number_float:\par
26252             {\cf19 case} value_t::binary:\par
26253             {\cf19 case} value_t::discarded:\par
26254             {\cf19 default}:\par
26255             \{\par
26256                 {\cf20 // both primitive type: replace value}\par
26257                 result.push_back(\par
26258                 \{\par
26259                     \{{\cf22 "op"}, {\cf22 "replace"}\}, \{{\cf22 "path"}, path\}, \{{\cf22 "value"}, target\}\par
26260                 \});\par
26261                 {\cf19 break};\par
26262             \}\par
26263         \}\par
26264 \par
26265         {\cf19 return} result;\par
26266     \}\par
26267 \par
26269 \par
26271     {\cf20 // JSON Merge Patch functions //}\par
26273 {\cf20 }\par
26276 \par
26319     {\cf18 void} merge_patch({\cf17 const} basic_json& apply_patch)\par
26320     \{\par
26321         {\cf19 if} (apply_patch.is_object())\par
26322         \{\par
26323             {\cf19 if} (!is_object())\par
26324             \{\par
26325                 *{\cf17 this} = object();\par
26326             \}\par
26327             {\cf19 for} ({\cf17 auto} it = apply_patch.begin(); it != apply_patch.end(); ++it)\par
26328             \{\par
26329                 {\cf19 if} (it.value().is_null())\par
26330                 \{\par
26331                     erase(it.key());\par
26332                 \}\par
26333                 {\cf19 else}\par
26334                 \{\par
26335                     operator[](it.key()).merge_patch(it.value());\par
26336                 \}\par
26337             \}\par
26338         \}\par
26339         {\cf19 else}\par
26340         \{\par
26341             *{\cf17 this} = apply_patch;\par
26342         \}\par
26343     \}\par
26344 \par
26346 \};\par
26347 \par
26357 NLOHMANN_BASIC_JSON_TPL_DECLARATION\par
26358 std::string to_string({\cf17 const} NLOHMANN_BASIC_JSON_TPL& j)\par
26359 \{\par
26360     {\cf19 return} j.dump();\par
26361 \}\par
26362 \} {\cf20 // namespace nlohmann}\par
26363 \par
26365 {\cf20 // nonmember support //}\par
26367 {\cf20 }\par
26368 {\cf20 // specialization of std::swap, and std::hash}\par
26369 {\cf17 namespace }std\par
26370 \{\par
26371 \par
26373 {\cf17 template}<>\par
26374 {\cf17 struct }hash<nlohmann::json>\par
26375 \{\par
26381     std::size_t operator()({\cf17 const} nlohmann::json& j){\cf17  const}\par
26382 {\cf17     }\{\par
26383         {\cf19 return} nlohmann::detail::hash(j);\par
26384     \}\par
26385 \};\par
26386 \par
26390 {\cf17 template}<>\par
26391 {\cf17 struct }less<::nlohmann::detail::value_t>\par
26392 \{\par
26397     {\cf18 bool} operator()(nlohmann::detail::value_t lhs,\par
26398                     nlohmann::detail::value_t rhs) {\cf17 const} {\cf17 noexcept}\par
26399     \{\par
26400         {\cf19 return} nlohmann::detail::operator<(lhs, rhs);\par
26401     \}\par
26402 \};\par
26403 \par
26404 {\cf20 // C++20 prohibit function specialization in the std namespace.}\par
26405 {\cf21 #ifndef JSON_HAS_CPP_20}\par
26406 \par
26412 {\cf17 template}<>\par
26413 {\cf17 inline} {\cf18 void} swap<nlohmann::json>(nlohmann::json& j1, nlohmann::json& j2) {\cf17 noexcept}( {\cf20 // NOLINT(readability-inconsistent-declaration-parameter-name)}\par
26414     is_nothrow_move_constructible<nlohmann::json>::value&&  {\cf20 // NOLINT(misc-redundant-expression)}\par
26415     is_nothrow_move_assignable<nlohmann::json>::value\par
26416                               )\par
26417 \{\par
26418     j1.swap(j2);\par
26419 \}\par
26420 \par
26421 {\cf21 #endif}\par
26422 \par
26423 \} {\cf20 // namespace std}\par
26424 \par
26438 JSON_HEDLEY_NON_NULL(1)\par
26439 inline nlohmann::json operator "" _json(const {\cf18 char}* s, std::{\cf18 size_t} n)\par
26440 \{\par
26441     {\cf19 return} nlohmann::json::parse(s, s + n);\par
26442 \}\par
26443 \par
26457 JSON_HEDLEY_NON_NULL(1)\par
26458 inline nlohmann::json::json_pointer operator "" _json_pointer(const {\cf18 char}* s, std::{\cf18 size_t} n)\par
26459 \{\par
26460     {\cf19 return} nlohmann::json::json_pointer(std::string(s, n));\par
26461 \}\par
26462 \par
26463 {\cf20 // #include <nlohmann/detail/macro_unscope.hpp>}\par
26464 \par
26465 \par
26466 {\cf20 // restore clang diagnostic settings}\par
26467 {\cf21 #if defined(__clang__)}\par
26468 {\cf21     #pragma clang diagnostic pop}\par
26469 {\cf21 #endif}\par
26470 \par
26471 {\cf20 // clean up}\par
26472 {\cf21 #undef JSON_ASSERT}\par
26473 {\cf21 #undef JSON_INTERNAL_CATCH}\par
26474 {\cf21 #undef JSON_CATCH}\par
26475 {\cf21 #undef JSON_THROW}\par
26476 {\cf21 #undef JSON_TRY}\par
26477 {\cf21 #undef JSON_PRIVATE_UNLESS_TESTED}\par
26478 {\cf21 #undef JSON_HAS_CPP_11}\par
26479 {\cf21 #undef JSON_HAS_CPP_14}\par
26480 {\cf21 #undef JSON_HAS_CPP_17}\par
26481 {\cf21 #undef JSON_HAS_CPP_20}\par
26482 {\cf21 #undef NLOHMANN_BASIC_JSON_TPL_DECLARATION}\par
26483 {\cf21 #undef NLOHMANN_BASIC_JSON_TPL}\par
26484 {\cf21 #undef JSON_EXPLICIT}\par
26485 \par
26486 {\cf20 // #include <nlohmann/thirdparty/hedley/hedley_undef.hpp>}\par
26487 \par
26488 \par
26489 {\cf21 #undef JSON_HEDLEY_ALWAYS_INLINE}\par
26490 {\cf21 #undef JSON_HEDLEY_ARM_VERSION}\par
26491 {\cf21 #undef JSON_HEDLEY_ARM_VERSION_CHECK}\par
26492 {\cf21 #undef JSON_HEDLEY_ARRAY_PARAM}\par
26493 {\cf21 #undef JSON_HEDLEY_ASSUME}\par
26494 {\cf21 #undef JSON_HEDLEY_BEGIN_C_DECLS}\par
26495 {\cf21 #undef JSON_HEDLEY_CLANG_HAS_ATTRIBUTE}\par
26496 {\cf21 #undef JSON_HEDLEY_CLANG_HAS_BUILTIN}\par
26497 {\cf21 #undef JSON_HEDLEY_CLANG_HAS_CPP_ATTRIBUTE}\par
26498 {\cf21 #undef JSON_HEDLEY_CLANG_HAS_DECLSPEC_DECLSPEC_ATTRIBUTE}\par
26499 {\cf21 #undef JSON_HEDLEY_CLANG_HAS_EXTENSION}\par
26500 {\cf21 #undef JSON_HEDLEY_CLANG_HAS_FEATURE}\par
26501 {\cf21 #undef JSON_HEDLEY_CLANG_HAS_WARNING}\par
26502 {\cf21 #undef JSON_HEDLEY_COMPCERT_VERSION}\par
26503 {\cf21 #undef JSON_HEDLEY_COMPCERT_VERSION_CHECK}\par
26504 {\cf21 #undef JSON_HEDLEY_CONCAT}\par
26505 {\cf21 #undef JSON_HEDLEY_CONCAT3}\par
26506 {\cf21 #undef JSON_HEDLEY_CONCAT3_EX}\par
26507 {\cf21 #undef JSON_HEDLEY_CONCAT_EX}\par
26508 {\cf21 #undef JSON_HEDLEY_CONST}\par
26509 {\cf21 #undef JSON_HEDLEY_CONSTEXPR}\par
26510 {\cf21 #undef JSON_HEDLEY_CONST_CAST}\par
26511 {\cf21 #undef JSON_HEDLEY_CPP_CAST}\par
26512 {\cf21 #undef JSON_HEDLEY_CRAY_VERSION}\par
26513 {\cf21 #undef JSON_HEDLEY_CRAY_VERSION_CHECK}\par
26514 {\cf21 #undef JSON_HEDLEY_C_DECL}\par
26515 {\cf21 #undef JSON_HEDLEY_DEPRECATED}\par
26516 {\cf21 #undef JSON_HEDLEY_DEPRECATED_FOR}\par
26517 {\cf21 #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CAST_QUAL}\par
26518 {\cf21 #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_CPP98_COMPAT_WRAP_}\par
26519 {\cf21 #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_DEPRECATED}\par
26520 {\cf21 #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_CPP_ATTRIBUTES}\par
26521 {\cf21 #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNKNOWN_PRAGMAS}\par
26522 {\cf21 #undef JSON_HEDLEY_DIAGNOSTIC_DISABLE_UNUSED_FUNCTION}\par
26523 {\cf21 #undef JSON_HEDLEY_DIAGNOSTIC_POP}\par
26524 {\cf21 #undef JSON_HEDLEY_DIAGNOSTIC_PUSH}\par
26525 {\cf21 #undef JSON_HEDLEY_DMC_VERSION}\par
26526 {\cf21 #undef JSON_HEDLEY_DMC_VERSION_CHECK}\par
26527 {\cf21 #undef JSON_HEDLEY_EMPTY_BASES}\par
26528 {\cf21 #undef JSON_HEDLEY_EMSCRIPTEN_VERSION}\par
26529 {\cf21 #undef JSON_HEDLEY_EMSCRIPTEN_VERSION_CHECK}\par
26530 {\cf21 #undef JSON_HEDLEY_END_C_DECLS}\par
26531 {\cf21 #undef JSON_HEDLEY_FLAGS}\par
26532 {\cf21 #undef JSON_HEDLEY_FLAGS_CAST}\par
26533 {\cf21 #undef JSON_HEDLEY_GCC_HAS_ATTRIBUTE}\par
26534 {\cf21 #undef JSON_HEDLEY_GCC_HAS_BUILTIN}\par
26535 {\cf21 #undef JSON_HEDLEY_GCC_HAS_CPP_ATTRIBUTE}\par
26536 {\cf21 #undef JSON_HEDLEY_GCC_HAS_DECLSPEC_ATTRIBUTE}\par
26537 {\cf21 #undef JSON_HEDLEY_GCC_HAS_EXTENSION}\par
26538 {\cf21 #undef JSON_HEDLEY_GCC_HAS_FEATURE}\par
26539 {\cf21 #undef JSON_HEDLEY_GCC_HAS_WARNING}\par
26540 {\cf21 #undef JSON_HEDLEY_GCC_NOT_CLANG_VERSION_CHECK}\par
26541 {\cf21 #undef JSON_HEDLEY_GCC_VERSION}\par
26542 {\cf21 #undef JSON_HEDLEY_GCC_VERSION_CHECK}\par
26543 {\cf21 #undef JSON_HEDLEY_GNUC_HAS_ATTRIBUTE}\par
26544 {\cf21 #undef JSON_HEDLEY_GNUC_HAS_BUILTIN}\par
26545 {\cf21 #undef JSON_HEDLEY_GNUC_HAS_CPP_ATTRIBUTE}\par
26546 {\cf21 #undef JSON_HEDLEY_GNUC_HAS_DECLSPEC_ATTRIBUTE}\par
26547 {\cf21 #undef JSON_HEDLEY_GNUC_HAS_EXTENSION}\par
26548 {\cf21 #undef JSON_HEDLEY_GNUC_HAS_FEATURE}\par
26549 {\cf21 #undef JSON_HEDLEY_GNUC_HAS_WARNING}\par
26550 {\cf21 #undef JSON_HEDLEY_GNUC_VERSION}\par
26551 {\cf21 #undef JSON_HEDLEY_GNUC_VERSION_CHECK}\par
26552 {\cf21 #undef JSON_HEDLEY_HAS_ATTRIBUTE}\par
26553 {\cf21 #undef JSON_HEDLEY_HAS_BUILTIN}\par
26554 {\cf21 #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE}\par
26555 {\cf21 #undef JSON_HEDLEY_HAS_CPP_ATTRIBUTE_NS}\par
26556 {\cf21 #undef JSON_HEDLEY_HAS_DECLSPEC_ATTRIBUTE}\par
26557 {\cf21 #undef JSON_HEDLEY_HAS_EXTENSION}\par
26558 {\cf21 #undef JSON_HEDLEY_HAS_FEATURE}\par
26559 {\cf21 #undef JSON_HEDLEY_HAS_WARNING}\par
26560 {\cf21 #undef JSON_HEDLEY_IAR_VERSION}\par
26561 {\cf21 #undef JSON_HEDLEY_IAR_VERSION_CHECK}\par
26562 {\cf21 #undef JSON_HEDLEY_IBM_VERSION}\par
26563 {\cf21 #undef JSON_HEDLEY_IBM_VERSION_CHECK}\par
26564 {\cf21 #undef JSON_HEDLEY_IMPORT}\par
26565 {\cf21 #undef JSON_HEDLEY_INLINE}\par
26566 {\cf21 #undef JSON_HEDLEY_INTEL_CL_VERSION}\par
26567 {\cf21 #undef JSON_HEDLEY_INTEL_CL_VERSION_CHECK}\par
26568 {\cf21 #undef JSON_HEDLEY_INTEL_VERSION}\par
26569 {\cf21 #undef JSON_HEDLEY_INTEL_VERSION_CHECK}\par
26570 {\cf21 #undef JSON_HEDLEY_IS_CONSTANT}\par
26571 {\cf21 #undef JSON_HEDLEY_IS_CONSTEXPR_}\par
26572 {\cf21 #undef JSON_HEDLEY_LIKELY}\par
26573 {\cf21 #undef JSON_HEDLEY_MALLOC}\par
26574 {\cf21 #undef JSON_HEDLEY_MCST_LCC_VERSION}\par
26575 {\cf21 #undef JSON_HEDLEY_MCST_LCC_VERSION_CHECK}\par
26576 {\cf21 #undef JSON_HEDLEY_MESSAGE}\par
26577 {\cf21 #undef JSON_HEDLEY_MSVC_VERSION}\par
26578 {\cf21 #undef JSON_HEDLEY_MSVC_VERSION_CHECK}\par
26579 {\cf21 #undef JSON_HEDLEY_NEVER_INLINE}\par
26580 {\cf21 #undef JSON_HEDLEY_NON_NULL}\par
26581 {\cf21 #undef JSON_HEDLEY_NO_ESCAPE}\par
26582 {\cf21 #undef JSON_HEDLEY_NO_RETURN}\par
26583 {\cf21 #undef JSON_HEDLEY_NO_THROW}\par
26584 {\cf21 #undef JSON_HEDLEY_NULL}\par
26585 {\cf21 #undef JSON_HEDLEY_PELLES_VERSION}\par
26586 {\cf21 #undef JSON_HEDLEY_PELLES_VERSION_CHECK}\par
26587 {\cf21 #undef JSON_HEDLEY_PGI_VERSION}\par
26588 {\cf21 #undef JSON_HEDLEY_PGI_VERSION_CHECK}\par
26589 {\cf21 #undef JSON_HEDLEY_PREDICT}\par
26590 {\cf21 #undef JSON_HEDLEY_PRINTF_FORMAT}\par
26591 {\cf21 #undef JSON_HEDLEY_PRIVATE}\par
26592 {\cf21 #undef JSON_HEDLEY_PUBLIC}\par
26593 {\cf21 #undef JSON_HEDLEY_PURE}\par
26594 {\cf21 #undef JSON_HEDLEY_REINTERPRET_CAST}\par
26595 {\cf21 #undef JSON_HEDLEY_REQUIRE}\par
26596 {\cf21 #undef JSON_HEDLEY_REQUIRE_CONSTEXPR}\par
26597 {\cf21 #undef JSON_HEDLEY_REQUIRE_MSG}\par
26598 {\cf21 #undef JSON_HEDLEY_RESTRICT}\par
26599 {\cf21 #undef JSON_HEDLEY_RETURNS_NON_NULL}\par
26600 {\cf21 #undef JSON_HEDLEY_SENTINEL}\par
26601 {\cf21 #undef JSON_HEDLEY_STATIC_ASSERT}\par
26602 {\cf21 #undef JSON_HEDLEY_STATIC_CAST}\par
26603 {\cf21 #undef JSON_HEDLEY_STRINGIFY}\par
26604 {\cf21 #undef JSON_HEDLEY_STRINGIFY_EX}\par
26605 {\cf21 #undef JSON_HEDLEY_SUNPRO_VERSION}\par
26606 {\cf21 #undef JSON_HEDLEY_SUNPRO_VERSION_CHECK}\par
26607 {\cf21 #undef JSON_HEDLEY_TINYC_VERSION}\par
26608 {\cf21 #undef JSON_HEDLEY_TINYC_VERSION_CHECK}\par
26609 {\cf21 #undef JSON_HEDLEY_TI_ARMCL_VERSION}\par
26610 {\cf21 #undef JSON_HEDLEY_TI_ARMCL_VERSION_CHECK}\par
26611 {\cf21 #undef JSON_HEDLEY_TI_CL2000_VERSION}\par
26612 {\cf21 #undef JSON_HEDLEY_TI_CL2000_VERSION_CHECK}\par
26613 {\cf21 #undef JSON_HEDLEY_TI_CL430_VERSION}\par
26614 {\cf21 #undef JSON_HEDLEY_TI_CL430_VERSION_CHECK}\par
26615 {\cf21 #undef JSON_HEDLEY_TI_CL6X_VERSION}\par
26616 {\cf21 #undef JSON_HEDLEY_TI_CL6X_VERSION_CHECK}\par
26617 {\cf21 #undef JSON_HEDLEY_TI_CL7X_VERSION}\par
26618 {\cf21 #undef JSON_HEDLEY_TI_CL7X_VERSION_CHECK}\par
26619 {\cf21 #undef JSON_HEDLEY_TI_CLPRU_VERSION}\par
26620 {\cf21 #undef JSON_HEDLEY_TI_CLPRU_VERSION_CHECK}\par
26621 {\cf21 #undef JSON_HEDLEY_TI_VERSION}\par
26622 {\cf21 #undef JSON_HEDLEY_TI_VERSION_CHECK}\par
26623 {\cf21 #undef JSON_HEDLEY_UNAVAILABLE}\par
26624 {\cf21 #undef JSON_HEDLEY_UNLIKELY}\par
26625 {\cf21 #undef JSON_HEDLEY_UNPREDICTABLE}\par
26626 {\cf21 #undef JSON_HEDLEY_UNREACHABLE}\par
26627 {\cf21 #undef JSON_HEDLEY_UNREACHABLE_RETURN}\par
26628 {\cf21 #undef JSON_HEDLEY_VERSION}\par
26629 {\cf21 #undef JSON_HEDLEY_VERSION_DECODE_MAJOR}\par
26630 {\cf21 #undef JSON_HEDLEY_VERSION_DECODE_MINOR}\par
26631 {\cf21 #undef JSON_HEDLEY_VERSION_DECODE_REVISION}\par
26632 {\cf21 #undef JSON_HEDLEY_VERSION_ENCODE}\par
26633 {\cf21 #undef JSON_HEDLEY_WARNING}\par
26634 {\cf21 #undef JSON_HEDLEY_WARN_UNUSED_RESULT}\par
26635 {\cf21 #undef JSON_HEDLEY_WARN_UNUSED_RESULT_MSG}\par
26636 {\cf21 #undef JSON_HEDLEY_FALL_THROUGH}\par
26637 \par
26638 \par
26639 \par
26640 {\cf21 #endif  }{\cf20 // INCLUDE_NLOHMANN_JSON_HPP_}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/main.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/main.cpp}
{\xe \v Client/main.cpp}
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "mainwindow.h"}\par
{\f2 #include <QApplication>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
main method helps create and initialize the game }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
main method helps create and initialize the game }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argc} \cell }{\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i argv} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definition at line {\b 9} of file {\b main.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main.cpp\par \pard\plain 
{\tc\tcl2 \v Client/main.cpp}
{\xe \v Client/main.cpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "mainwindow.h"}\par
00002 {\cf21 #include <QApplication>}\par
00009 {\cf18 int} main({\cf18 int} argc, {\cf18 char} *argv[])\par
00010 \{\par
00011     QApplication a(argc, argv);\par
00012     MainWindow w;\par
00013     w.show(); {\cf20 // se muestra ventana de inicio}\par
00014 \par
00015     {\cf19 return} a.exec();\par
00016 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/mainwindow.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/mainwindow.cpp}
{\xe \v Client/mainwindow.cpp}
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "mainwindow.h"}\par
{\f2 #include "ui_mainwindow.h"}\par
{\f2 #include "Client.h"}\par
{\f2 #include "QMessageBox"}\par
{\f2 #include "Game.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Game} * {\b game}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v game\:mainwindow.cpp}
{\xe \v mainwindow.cpp\:game}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Game}* game}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b mainwindow.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mainwindow.cpp\par \pard\plain 
{\tc\tcl2 \v Client/mainwindow.cpp}
{\xe \v Client/mainwindow.cpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "mainwindow.h"}\par
00002 {\cf21 #include "ui_mainwindow.h"}\par
00003 {\cf21 #include "Client.h"}\par
00004 {\cf21 #include "QMessageBox"}\par
00005 {\cf21 #include "Game.h"}\par
00006 \par
00007 Game* game;\par
00012 MainWindow::MainWindow(QWidget *parent)\par
00013     : QMainWindow(parent)\par
00014     , ui(new Ui::MainWindow)\par
00015 \{\par
00016     ui->setupUi({\cf17 this});\par
00017 \}\par
00021 MainWindow::~MainWindow()\par
00022 \{\par
00023     {\cf17 delete} ui;\par
00024 \}\par
00025 \par
00029 {\cf18 void} MainWindow::on_playBtn_clicked()\par
00030 \{\par
00031     QMessageBox* msg;\par
00032     game = {\cf17 new} Game();\par
00033 \par
00034     nick = ui->nicknameLineEdit->text(); {\cf20 // gets the text in the portLineEdit QString format}\par
00035     {\cf18 string} textNick = nick.toUtf8().constData(); {\cf20 // convert nick to string}\par
00036 \par
00037 \par
00038     {\cf20 // creating a QMessageBox for warning}\par
00039     msg = {\cf17 new} QMessageBox();\par
00040     msg->setWindowTitle({\cf22 "WARNING"});\par
00041     msg->setIcon(QMessageBox::Warning);\par
00042     msg->setStyleSheet({\cf22 "background-color: rgb(0, 0, 0); color: red"});\par
00043 \par
00044     {\cf19 if}(textNick=={\cf22 ""})\{ {\cf20 // if ip is not valid}\par
00045         msg->setText({\cf22 "Nickname Required!"});\par
00046         msg->show();\par
00047     \}\par
00048     {\cf19 else}\{\par
00049         game->show();\par
00050         game->setNickName(nick);\par
00051         close(); {\cf20 // close main window}\par
00052     \}\par
00053 \par
00054 \}\par
00055 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/mainwindow.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/mainwindow.h}
{\xe \v Client/mainwindow.h}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QMainWindow>}\par
{\f2 #include <iostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MainWindow}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b MainWindow} class shows the first window of the game. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Ui}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
mainwindow.h\par \pard\plain 
{\tc\tcl2 \v Client/mainwindow.h}
{\xe \v Client/mainwindow.h}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef MAINWINDOW_H}\par
00002 {\cf21 #define MAINWINDOW_H}\par
00003 \par
00004 {\cf21 #include <QMainWindow>}\par
00005 {\cf21 #include <iostream>}\par
00006 \par
00007 QT_BEGIN_NAMESPACE\par
00008 {\cf17 namespace }Ui \{ {\cf17 class }MainWindow; \}\par
00009 QT_END_NAMESPACE\par
00013 {\cf17 class }MainWindow : {\cf17 public} QMainWindow\par
00014 \{\par
00015     Q_OBJECT\par
00016 \par
00017 {\cf17 public}:\par
00018     {\cf20 // Attributes}\par
00019     QString IP;\par
00020     QString Port;\par
00021     QString nick;\par
00022 \par
00023     {\cf20 // Public Methods}\par
00024     MainWindow(QWidget *parent = {\cf17 nullptr});\par
00025     ~MainWindow();\par
00026     {\cf18 void} connecting();\par
00027 \par
00028 {\cf17 public} slots:\par
00029     {\cf18 void} on_playBtn_clicked();\par
00030 \par
00031 {\cf17 private}:\par
00032     Ui::MainWindow *ui;\par
00033 \};\par
00034 {\cf21 #endif }{\cf20 // MAINWINDOW_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Paddle.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Paddle.cpp}
{\xe \v Client/Paddle.cpp}
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Paddle.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Paddle.cpp\par \pard\plain 
{\tc\tcl2 \v Client/Paddle.cpp}
{\xe \v Client/Paddle.cpp}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Paddle.h"}\par
00006 Paddle::Paddle(QGraphicsItem *parent)\{\par
00010     setRect(0,0,60,10);\par
00011     brush.setStyle(Qt::SolidPattern);\par
00012     brush.setColor(Qt::gray);\par
00013     setBrush(brush);\par
00014 \}\par
00015 \par
00016 {\cf18 double} Paddle::getCenterX()\{\par
00017     {\cf19 return} x()+rect().width()/2;\par
00018 \}\par
00022 {\cf18 void} Paddle::reduceSize()\par
00023 \{\par
00024     {\cf18 int} padWidth = rect().width();\par
00025     rect().setWidth(padWidth-reduction);\par
00026 \}\par
00030 {\cf18 void} Paddle::increaseSize()\par
00031 \{\par
00032     padWidth = rect().width();\par
00033     rect().setWidth(padWidth+reduction);\par
00034 \}\par
00039 {\cf18 void} Paddle::mouseMoveEvent(QGraphicsSceneMouseEvent *event)\{\par
00040     {\cf20 // follow mouse's x pos}\par
00041     {\cf18 double} mouseX = mapToScene(event->pos()).x();\par
00042     setPos(mouseX-30,y());\par
00043 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Paddle.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Paddle.h}
{\xe \v Client/Paddle.h}
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGraphicsRectItem>}\par
{\f2 #include <QGraphicsSceneMouseEvent>}\par
{\f2 #include <QBrush>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Paddle}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Paddle} class creates objects of type {\b Paddle}. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Paddle.h\par \pard\plain 
{\tc\tcl2 \v Client/Paddle.h}
{\xe \v Client/Paddle.h}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef PADDLE_H}\par
00002 {\cf21 #define PADDLE_H}\par
00003 \par
00004 {\cf21 #include <QGraphicsRectItem>}\par
00005 {\cf21 #include <QGraphicsSceneMouseEvent>}\par
00006 {\cf21 #include <QBrush>}\par
00010 {\cf17 class }Paddle: {\cf17 public} QGraphicsRectItem\{\par
00011 {\cf17 public}:\par
00012     {\cf20 // Attributes}\par
00013     QBrush brush;\par
00014     {\cf18 int} reduction = 10;\par
00015     {\cf18 int} padWidth = 60;\par
00016 \par
00017     {\cf20 // constructors}\par
00018     Paddle(QGraphicsItem* parent=NULL);\par
00019 \par
00020     {\cf20 // public methods}\par
00021     {\cf18 double} getCenterX();\par
00022     {\cf18 void} reduceSize();\par
00023     {\cf18 void} increaseSize();\par
00024 \par
00025     {\cf20 // events}\par
00026     {\cf18 void} mouseMoveEvent(QGraphicsSceneMouseEvent* event);\par
00027 \};\par
00028 \par
00029 {\cf21 #endif }{\cf20 // PADDLE_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v Client/README.md}
{\xe \v Client/README.md}
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/surprise.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/surprise.cpp}
{\xe \v Client/surprise.cpp}
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "surprise.h"}\par
{\f2 #include <QBrush>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
surprise.cpp\par \pard\plain 
{\tc\tcl2 \v Client/surprise.cpp}
{\xe \v Client/surprise.cpp}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "surprise.h"}\par
00002 {\cf21 #include <QBrush>}\par
00007 surprise::surprise(QGraphicsItem *parent): QGraphicsRectItem(parent)\par
00008 \{\par
00012     setRect(0,0,50,52);\par
00013     QBrush brush;\par
00014     brush.setTextureImage(QImage ({\cf22 "/home/user/Escritorio/Repos GitHub/CrazyBreakout/images/surprise.png"}));\par
00015     setBrush(brush);\par
00016 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/surprise.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/surprise.h}
{\xe \v Client/surprise.h}
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGraphicsRectItem>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b surprise}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The surprise class creates surprises. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
surprise.h\par \pard\plain 
{\tc\tcl2 \v Client/surprise.h}
{\xe \v Client/surprise.h}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef SURPRISE_H}\par
00002 {\cf21 #define SURPRISE_H}\par
00003 \par
00004 {\cf21 #include <QGraphicsRectItem>}\par
00005 \par
00009 {\cf17 class }surprise: {\cf17 public} QGraphicsRectItem\par
00010 \{\par
00011 {\cf17 public}:\par
00012     surprise(QGraphicsItem* parent=NULL);\par
00013 \};\par
00014 \par
00015 {\cf21 #endif }{\cf20 // SURPRISE_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Tripleblk.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Tripleblk.cpp}
{\xe \v Client/Tripleblk.cpp}
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Tripleblk.h"}\par
{\f2 #include <QBrush>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Tripleblk.cpp\par \pard\plain 
{\tc\tcl2 \v Client/Tripleblk.cpp}
{\xe \v Client/Tripleblk.cpp}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Tripleblk.h"}\par
00002 {\cf21 #include <QBrush>}\par
00007 TripleBlk::TripleBlk(QGraphicsItem *parent): QGraphicsRectItem(parent)\{\par
00011     setRect(0,0,60,10);\par
00012     QBrush brush;\par
00013     brush.setTextureImage(QImage ({\cf22 "/home/user/Escritorio/Repos GitHub/CrazyBreakout/images/triple.png"}));\par
00014     setBrush(brush);\par
00015 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Client/Tripleblk.h File Reference\par \pard\plain 
{\tc\tcl2 \v Client/Tripleblk.h}
{\xe \v Client/Tripleblk.h}
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGraphicsRectItem>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TripleBlk}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b TripleBlk} class creates objects of type {\b TripleBlk}. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Tripleblk.h\par \pard\plain 
{\tc\tcl2 \v Client/Tripleblk.h}
{\xe \v Client/Tripleblk.h}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef TRIPLEBLK_H}\par
00002 {\cf21 #define TRIPLEBLK_H}\par
00003 \par
00004 {\cf21 #include <QGraphicsRectItem>}\par
00008 {\cf17 class }TripleBlk: {\cf17 public} QGraphicsRectItem\{\par
00009 {\cf17 public}:\par
00010     {\cf20 // Attributes}\par
00011     {\cf18 int} posx = 0;\par
00012     {\cf18 int} posy = 0;\par
00013 \par
00014     {\cf20 // constructors}\par
00015     TripleBlk(QGraphicsItem* parent=NULL);\par
00016     {\cf18 void} setPosition({\cf18 int} x, {\cf18 int} y);\par
00017 \par
00018 \};\par
00019 \par
00020 {\cf21 #endif }{\cf20 // TRIPLEBLK_H}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
